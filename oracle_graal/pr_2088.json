{"pr_number": 2088, "pr_title": "Debug info prototype", "pr_author": "adinn", "pr_createdAt": "2020-01-22T10:51:13Z", "pr_url": "https://github.com/oracle/graal/pull/2088", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMTEwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r370021108", "body": "Can you please convert all these C++ style comments to proper javadoc.", "bodyText": "Can you please convert all these C++ style comments to proper javadoc.", "bodyHTML": "<p dir=\"auto\">Can you please convert all these C++ style comments to proper javadoc.</p>", "author": "dougxc", "createdAt": "2020-01-23T09:52:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.util.List;\n+\n+// class defining interfaces used to allow a native image", "originalCommit": "7138edc94f05596cf2d70d158f317cad5abb5178", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA3MzEyNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r370073127", "bodyText": "Yes, of course -- I should have been on the ball from the start.\nI have converted almost all of these existing comments to javadoc, updated the content to be more informative and added a lot more missing javadoc comments.\nI have (deliberately) not javadoc commented all the final values that clearly identify DWARF constants -- there is the DWARF spec for that.\nI have also not (yet) javadoc commented some of the internal details of DwarfSectionImpl and its subclasses, most notably the various putXXX and writeXXX methods that insert simple data records to the ELF sections in a variety of different formats. The higher level methods which invoke them provide comments detailing the data layouts so this omission should not be not critical when it comes to understanding the code.", "author": "adinn", "createdAt": "2020-01-23T11:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMTEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex cf6daf5ec24..185de9e86e8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -26,58 +26,138 @@\n \n package com.oracle.objectfile.debuginfo;\n \n+import java.nio.file.Path;\n import java.util.List;\n+import java.util.stream.Stream;\n \n-// class defining interfaces used to allow a native image\n-// to communicate details of types, code and data to\n-// the underlying object file so that the object file\n-// can insert appropriate debug info\n+/**\n+ * Interfaces used to allow a native image to communicate details of types, code and data to the\n+ * underlying object file so that the latter can insert appropriate debug info.\n+ */\n public interface DebugInfoProvider {\n-    // access details of a specific type\n+    /**\n+     * access details of a specific type.\n+     */\n     interface DebugTypeInfo {\n     }\n \n-    // access details of a specific compiled method\n+    /**\n+     * access details of a specific compiled method.\n+     */\n     interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled method excluding any path\n+         */\n         String fileName();\n \n+        /**\n+         * @return a relative path to the file containing a compiled method derived from its package\n+         *         name or null if the method is in the empty package\n+         */\n+        Path filePath();\n+\n+        /**\n+         * @return the fully qualified name of the class owning the compiled method\n+         */\n         String className();\n \n+        /**\n+         * @return the name of the compiled method including signature\n+         */\n         String methodName();\n \n+        /**\n+         * @return the lowest address containing code generated for the method represented as an\n+         *         offset into the code segment\n+         */\n         int addressLo();\n \n+        /**\n+         * @return the first address above the code generated for the method represented as an\n+         *         offset into the code segment\n+         */\n         int addressHi();\n \n+        /**\n+         * @return the starting line number for the method\n+         */\n         int line();\n \n-        DebugLineInfoProvider lineInfoProvider();\n+        /**\n+         * @return a stream of records detailing line numbers and addresses within the compiled\n+         *         method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n \n+        /**\n+         * @return a string identifying the method parameters\n+         */\n         String paramNames();\n \n+        /**\n+         * @return a string identifying the method return type\n+         */\n         String returnTypeName();\n \n+        /**\n+         * @return the size of the method frame between prologue and epilogue\n+         */\n         int getFrameSize();\n \n+        /**\n+         * @return a list of positions at which the stack is extended to a full frame or torn down\n+         *         to an empty frame\n+         */\n         List<DebugFrameSizeChange> getFrameSizeChanges();\n     }\n \n-    // access details of a specific heap object\n+    /**\n+     * access details of a specific heap object.\n+     */\n     interface DebugDataInfo {\n     }\n \n-    // access details of a specific outer or inlined method at a given line number\n+    /**\n+     * access details of code generated for a specific outer or inlined method at a given line\n+     * number.\n+     */\n     interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer or inlined method excluding any path\n+         */\n         String fileName();\n \n+        /**\n+         * @return a relative path to the file containing the outer or inlined method derived from\n+         *         its package name or null if the method is in the empty package\n+         */\n+        Path filePath();\n+\n+        /**\n+         * @return the fully qualified name of the class owning the outer or inlined method\n+         */\n         String className();\n \n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n         String methodName();\n \n+        /**\n+         * @return the lowest address containing code generated for an outer or inlined code segment\n+         *         reported at this line represented as an offset into the code segment\n+         */\n         int addressLo();\n \n+        /**\n+         * @return the first address above the code generated for an outer or inlined code segment\n+         *         reported at this line represented as an offset into the code segment\n+         */\n         int addressHi();\n \n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n         int line();\n     }\n \n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 185de9e86e8..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -112,51 +117,51 @@ public interface DebugInfoProvider {\n     }\n \n     /**\n-     * access details of a specific heap object.\n+     * Access details of a specific heap object.\n      */\n     interface DebugDataInfo {\n     }\n \n     /**\n-     * access details of code generated for a specific outer or inlined method at a given line\n+     * Access details of code generated for a specific outer or inlined method at a given line\n      * number.\n      */\n     interface DebugLineInfo {\n         /**\n-         * @return the name of the file containing the outer or inlined method excluding any path\n+         * @return the name of the file containing the outer or inlined method excluding any path.\n          */\n         String fileName();\n \n         /**\n          * @return a relative path to the file containing the outer or inlined method derived from\n-         *         its package name or null if the method is in the empty package\n+         *         its package name or null if the method is in the empty package.\n          */\n         Path filePath();\n \n         /**\n-         * @return the fully qualified name of the class owning the outer or inlined method\n+         * @return the fully qualified name of the class owning the outer or inlined method.\n          */\n         String className();\n \n         /**\n-         * @return the name of the outer or inlined method including signature\n+         * @return the name of the outer or inlined method including signature.\n          */\n         String methodName();\n \n         /**\n          * @return the lowest address containing code generated for an outer or inlined code segment\n-         *         reported at this line represented as an offset into the code segment\n+         *         reported at this line represented as an offset into the code segment.\n          */\n         int addressLo();\n \n         /**\n          * @return the first address above the code generated for an outer or inlined code segment\n-         *         reported at this line represented as an offset into the code segment\n+         *         reported at this line represented as an offset into the code segment.\n          */\n         int addressHi();\n \n         /**\n-         * @return the line number for the outer or inlined segment\n+         * @return the line number for the outer or inlined segment.\n          */\n         int line();\n     }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 63523cb2234..13e8cb73dab 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -26,143 +26,68 @@\n \n package com.oracle.objectfile.debuginfo;\n \n-import java.nio.file.Path;\n import java.util.List;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n \n /**\n- * Interfaces used to allow a native image to communicate details of types, code and data to the\n- * underlying object file so that the latter can insert appropriate debug info.\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n  */\n public interface DebugInfoProvider {\n     /**\n-     * Access details of a specific type.\n+     * access details of a specific type.\n      */\n     interface DebugTypeInfo {\n     }\n \n     /**\n-     * Access details of a specific compiled method.\n+     * access details of a specific compiled method.\n      */\n     interface DebugCodeInfo {\n-        void debugContext(Consumer<DebugContext> action);\n-\n-        /**\n-         * @return the name of the file containing a compiled method excluding any path.\n-         */\n         String fileName();\n \n-        /**\n-         * @return a relative path to the file containing a compiled method derived from its package\n-         *         name or null if the method is in the empty package.\n-         */\n-        Path filePath();\n-\n-        /**\n-         * @return the fully qualified name of the class owning the compiled method.\n-         */\n         String className();\n \n-        /**\n-         * @return the name of the compiled method including signature.\n-         */\n         String methodName();\n \n-        /**\n-         * @return the lowest address containing code generated for the method represented as an\n-         *         offset into the code segment.\n-         */\n         int addressLo();\n \n-        /**\n-         * @return the first address above the code generated for the method represented as an\n-         *         offset into the code segment.\n-         */\n         int addressHi();\n \n-        /**\n-         * @return the starting line number for the method.\n-         */\n         int line();\n \n-        /**\n-         * @return a stream of records detailing line numbers and addresses within the compiled\n-         *         method.\n-         */\n-        Stream<DebugLineInfo> lineInfoProvider();\n+        DebugLineInfoProvider lineInfoProvider();\n \n-        /**\n-         * @return a string identifying the method parameters.\n-         */\n         String paramNames();\n \n-        /**\n-         * @return a string identifying the method return type.\n-         */\n         String returnTypeName();\n \n-        /**\n-         * @return the size of the method frame between prologue and epilogue.\n-         */\n         int getFrameSize();\n \n-        /**\n-         * @return a list of positions at which the stack is extended to a full frame or torn down\n-         *         to an empty frame\n-         */\n         List<DebugFrameSizeChange> getFrameSizeChanges();\n     }\n \n     /**\n-     * Access details of a specific heap object.\n+     * access details of a specific heap object.\n      */\n     interface DebugDataInfo {\n     }\n \n     /**\n-     * Access details of code generated for a specific outer or inlined method at a given line\n-     * number.\n+     *  access details of a specific outer or inlined method at a given line number.\n      */\n     interface DebugLineInfo {\n-        /**\n-         * @return the name of the file containing the outer or inlined method excluding any path.\n-         */\n         String fileName();\n \n-        /**\n-         * @return a relative path to the file containing the outer or inlined method derived from\n-         *         its package name or null if the method is in the empty package.\n-         */\n-        Path filePath();\n-\n-        /**\n-         * @return the fully qualified name of the class owning the outer or inlined method.\n-         */\n         String className();\n \n-        /**\n-         * @return the name of the outer or inlined method including signature.\n-         */\n         String methodName();\n \n-        /**\n-         * @return the lowest address containing code generated for an outer or inlined code segment\n-         *         reported at this line represented as an offset into the code segment.\n-         */\n         int addressLo();\n \n-        /**\n-         * @return the first address above the code generated for an outer or inlined code segment\n-         *         reported at this line represented as an offset into the code segment.\n-         */\n         int addressHi();\n \n-        /**\n-         * @return the line number for the outer or inlined segment.\n-         */\n         int line();\n     }\n \n", "next_change": {"commit": "25c7101fcc02d41865ef60545b6177ee7842dbef", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 13e8cb73dab..5aff1370bb3 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -75,19 +113,45 @@ public interface DebugInfoProvider {\n     }\n \n     /**\n-     *  access details of a specific outer or inlined method at a given line number.\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n      */\n     interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n         String fileName();\n-\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n         String className();\n-\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n         String methodName();\n-\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n         int addressLo();\n-\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n         int addressHi();\n-\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n         int line();\n     }\n \n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 5aff1370bb3..185de9e86e8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -113,42 +118,43 @@ public interface DebugInfoProvider {\n     }\n \n     /**\n-     *  access details of code generated for a specific outer\n-     *  or inlined method at  a given line number.\n+     * access details of code generated for a specific outer or inlined method at a given line\n+     * number.\n      */\n     interface DebugLineInfo {\n         /**\n-         * @return the name of the file containing the outer\n-         * or inlined method excluding any path\n+         * @return the name of the file containing the outer or inlined method excluding any path\n          */\n         String fileName();\n+\n         /**\n-         * @return a relative path to the file containing the outer\n-         * or inlined method derived from its package name or null\n-         * if the method is in the empty package\n+         * @return a relative path to the file containing the outer or inlined method derived from\n+         *         its package name or null if the method is in the empty package\n          */\n         Path filePath();\n+\n         /**\n-         * @return the fully qualified name of the class owning the\n-         * outer or inlined method\n+         * @return the fully qualified name of the class owning the outer or inlined method\n          */\n         String className();\n+\n         /**\n          * @return the name of the outer or inlined method including signature\n          */\n         String methodName();\n+\n         /**\n-         * @return the lowest address containing code generated for\n-         * an outer or inlined code segment reported at this line\n-         * represented as an offset into the code segment\n+         * @return the lowest address containing code generated for an outer or inlined code segment\n+         *         reported at this line represented as an offset into the code segment\n          */\n         int addressLo();\n+\n         /**\n-         * @return the first address above the code generated for\n-         * an outer or inlined code segment reported at this line\n-         * represented as an offset into the code segment\n+         * @return the first address above the code generated for an outer or inlined code segment\n+         *         reported at this line represented as an offset into the code segment\n          */\n         int addressHi();\n+\n         /**\n          * @return the line number for the outer or inlined segment\n          */\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 185de9e86e8..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -112,51 +117,51 @@ public interface DebugInfoProvider {\n     }\n \n     /**\n-     * access details of a specific heap object.\n+     * Access details of a specific heap object.\n      */\n     interface DebugDataInfo {\n     }\n \n     /**\n-     * access details of code generated for a specific outer or inlined method at a given line\n+     * Access details of code generated for a specific outer or inlined method at a given line\n      * number.\n      */\n     interface DebugLineInfo {\n         /**\n-         * @return the name of the file containing the outer or inlined method excluding any path\n+         * @return the name of the file containing the outer or inlined method excluding any path.\n          */\n         String fileName();\n \n         /**\n          * @return a relative path to the file containing the outer or inlined method derived from\n-         *         its package name or null if the method is in the empty package\n+         *         its package name or null if the method is in the empty package.\n          */\n         Path filePath();\n \n         /**\n-         * @return the fully qualified name of the class owning the outer or inlined method\n+         * @return the fully qualified name of the class owning the outer or inlined method.\n          */\n         String className();\n \n         /**\n-         * @return the name of the outer or inlined method including signature\n+         * @return the name of the outer or inlined method including signature.\n          */\n         String methodName();\n \n         /**\n          * @return the lowest address containing code generated for an outer or inlined code segment\n-         *         reported at this line represented as an offset into the code segment\n+         *         reported at this line represented as an offset into the code segment.\n          */\n         int addressLo();\n \n         /**\n          * @return the first address above the code generated for an outer or inlined code segment\n-         *         reported at this line represented as an offset into the code segment\n+         *         reported at this line represented as an offset into the code segment.\n          */\n         int addressHi();\n \n         /**\n-         * @return the line number for the outer or inlined segment\n+         * @return the line number for the outer or inlined segment.\n          */\n         int line();\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1MzY1Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372353653", "body": "No point in assigning to an unused local. Just use `newUserDefinedSection( ....`. I know the names of these methods are stupid.", "bodyText": "No point in assigning to an unused local. Just use newUserDefinedSection( ..... I know the names of these methods are stupid.", "bodyHTML": "<p dir=\"auto\">No point in assigning to an unused local. Just use <code>newUserDefinedSection( ....</code>. I know the names of these methods are stupid.</p>", "author": "olpaw", "createdAt": "2020-01-29T12:27:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java", "diffHunk": "@@ -1155,4 +1157,46 @@ public SymbolTable getSymbolTable() {\n     protected int getMinimumFileSize() {\n         return 0;\n     }\n+\n+    @Override\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        DwarfSections dwarfSections = new DwarfSections(getMachine());\n+        // we need an implementation for each section\n+        DwarfSections.DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n+        DwarfSections.DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n+        DwarfSections.DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n+        DwarfSections.DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n+        DwarfSections.DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n+        DwarfSections.DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n+        // now we can create the section elements with empty content\n+        @SuppressWarnings(\"unused\")\n+        ELFSection strSection = (ELFSection) newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTM0NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375789344", "bodyText": "Yes, indeed. Removed.", "author": "adinn", "createdAt": "2020-02-06T11:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1MzY1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\nindex 936938f5e19..ac9472d06b7 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n", "chunk": "@@ -1160,27 +1166,21 @@ public class ELFObjectFile extends ObjectFile {\n \n     @Override\n     public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        DwarfSections dwarfSections = new DwarfSections(getMachine());\n+        DwarfSections dwarfSections = new DwarfSections(getMachine(), getByteOrder());\n         // we need an implementation for each section\n-        DwarfSections.DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n-        DwarfSections.DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n-        DwarfSections.DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n-        DwarfSections.DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n-        DwarfSections.DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n-        DwarfSections.DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n+        DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n+        DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n+        DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n+        DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n+        DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n+        DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n         // now we can create the section elements with empty content\n-        @SuppressWarnings(\"unused\")\n-        ELFSection strSection = (ELFSection) newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);\n-        @SuppressWarnings(\"unused\")\n-        ELFSection abbrevSection = (ELFSection) newUserDefinedSection(elfAbbrevSectionImpl.getSectionName(), elfAbbrevSectionImpl);\n-        @SuppressWarnings(\"unused\")\n-        ELFSection locSection = (ELFSection) newUserDefinedSection(frameSectionImpl.getSectionName(), frameSectionImpl);\n-        @SuppressWarnings(\"unused\")\n-        ELFSection infoSection = (ELFSection) newUserDefinedSection(elfInfoSectionImpl.getSectionName(), elfInfoSectionImpl);\n-        @SuppressWarnings(\"unused\")\n-        ELFSection aRangesSection = (ELFSection) newUserDefinedSection(elfARangesSectionImpl.getSectionName(), elfARangesSectionImpl);\n-        @SuppressWarnings(\"unused\")\n-        ELFSection debugSection = (ELFSection) newUserDefinedSection(elfLineSectionImpl.getSectionName(), elfLineSectionImpl);\n+        newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);\n+        newUserDefinedSection(elfAbbrevSectionImpl.getSectionName(), elfAbbrevSectionImpl);\n+        newUserDefinedSection(frameSectionImpl.getSectionName(), frameSectionImpl);\n+        newUserDefinedSection(elfInfoSectionImpl.getSectionName(), elfInfoSectionImpl);\n+        newUserDefinedSection(elfARangesSectionImpl.getSectionName(), elfARangesSectionImpl);\n+        newUserDefinedSection(elfLineSectionImpl.getSectionName(), elfLineSectionImpl);\n         // the byte[] for each implementation's content are created and\n         // written under getOrDecideContent. doing that ensures that all\n         // dependent sections are filled in and then sized according to the\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\nindex ac9472d06b7..740779f0840 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n", "chunk": "@@ -1166,37 +1167,39 @@ public class ELFObjectFile extends ObjectFile {\n \n     @Override\n     public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        DwarfSections dwarfSections = new DwarfSections(getMachine(), getByteOrder());\n-        // we need an implementation for each section\n+        DwarfDebugInfo dwarfSections = new DwarfDebugInfo(getMachine(), getByteOrder());\n+        /* We need an implementation for each generated DWARF section. */\n         DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n         DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n         DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n         DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n         DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n         DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n-        // now we can create the section elements with empty content\n+        /* Now we can create the section elements with empty content. */\n         newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);\n         newUserDefinedSection(elfAbbrevSectionImpl.getSectionName(), elfAbbrevSectionImpl);\n         newUserDefinedSection(frameSectionImpl.getSectionName(), frameSectionImpl);\n         newUserDefinedSection(elfInfoSectionImpl.getSectionName(), elfInfoSectionImpl);\n         newUserDefinedSection(elfARangesSectionImpl.getSectionName(), elfARangesSectionImpl);\n         newUserDefinedSection(elfLineSectionImpl.getSectionName(), elfLineSectionImpl);\n-        // the byte[] for each implementation's content are created and\n-        // written under getOrDecideContent. doing that ensures that all\n-        // dependent sections are filled in and then sized according to the\n-        // declared dependencies. however, if we leave it at that then\n-        // associated reloc sections only get created when the first reloc\n-        // is inserted during content write that's too late for them to have\n-        // layout constraints included in the layout decision set and causes\n-        // an NPE during reloc section write. so we need to create the relevant\n-        // reloc sections here in advance\n+        /*\n+         * The byte[] for each implementation's content are created and\n+         * written under getOrDecideContent. Doing that ensures that all\n+         * dependent sections are filled in and then sized according to the\n+         * declared dependencies. However, if we leave it at that then\n+         * associated reloc sections only get created when the first reloc\n+         * is inserted during content write that's too late for them to have\n+         * layout constraints included in the layout decision set and causes\n+         * an NPE during reloc section write. So we need to create the relevant\n+         * reloc sections here in advance.\n+         */\n         elfStrSectionImpl.getOrCreateRelocationElement(false);\n         elfAbbrevSectionImpl.getOrCreateRelocationElement(false);\n         frameSectionImpl.getOrCreateRelocationElement(false);\n         elfInfoSectionImpl.getOrCreateRelocationElement(false);\n         elfARangesSectionImpl.getOrCreateRelocationElement(false);\n         elfLineSectionImpl.getOrCreateRelocationElement(false);\n-        // ok now we can populate the implementations\n+        /* Ok now we can populate the debug info model. */\n         dwarfSections.installDebugInfo(debugInfoProvider);\n     }\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\nindex 740779f0840..be10b81edd8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n", "chunk": "@@ -1167,39 +1161,37 @@ public class ELFObjectFile extends ObjectFile {\n \n     @Override\n     public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        DwarfDebugInfo dwarfSections = new DwarfDebugInfo(getMachine(), getByteOrder());\n-        /* We need an implementation for each generated DWARF section. */\n-        DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n-        DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n-        DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n-        DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n-        DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n-        DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n-        /* Now we can create the section elements with empty content. */\n+        DwarfSections dwarfSections = new DwarfSections(getMachine());\n+        // we need an implementation for each section\n+        DwarfSections.DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n+        DwarfSections.DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n+        DwarfSections.DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n+        DwarfSections.DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n+        DwarfSections.DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n+        DwarfSections.DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n+        // now we can create the section elements with empty content\n         newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);\n         newUserDefinedSection(elfAbbrevSectionImpl.getSectionName(), elfAbbrevSectionImpl);\n         newUserDefinedSection(frameSectionImpl.getSectionName(), frameSectionImpl);\n         newUserDefinedSection(elfInfoSectionImpl.getSectionName(), elfInfoSectionImpl);\n         newUserDefinedSection(elfARangesSectionImpl.getSectionName(), elfARangesSectionImpl);\n         newUserDefinedSection(elfLineSectionImpl.getSectionName(), elfLineSectionImpl);\n-        /*\n-         * The byte[] for each implementation's content are created and\n-         * written under getOrDecideContent. Doing that ensures that all\n-         * dependent sections are filled in and then sized according to the\n-         * declared dependencies. However, if we leave it at that then\n-         * associated reloc sections only get created when the first reloc\n-         * is inserted during content write that's too late for them to have\n-         * layout constraints included in the layout decision set and causes\n-         * an NPE during reloc section write. So we need to create the relevant\n-         * reloc sections here in advance.\n-         */\n+        // the byte[] for each implementation's content are created and\n+        // written under getOrDecideContent. doing that ensures that all\n+        // dependent sections are filled in and then sized according to the\n+        // declared dependencies. however, if we leave it at that then\n+        // associated reloc sections only get created when the first reloc\n+        // is inserted during content write that's too late for them to have\n+        // layout constraints included in the layout decision set and causes\n+        // an NPE during reloc section write. so we need to create the relevant\n+        // reloc sections here in advance\n         elfStrSectionImpl.getOrCreateRelocationElement(false);\n         elfAbbrevSectionImpl.getOrCreateRelocationElement(false);\n         frameSectionImpl.getOrCreateRelocationElement(false);\n         elfInfoSectionImpl.getOrCreateRelocationElement(false);\n         elfARangesSectionImpl.getOrCreateRelocationElement(false);\n         elfLineSectionImpl.getOrCreateRelocationElement(false);\n-        /* Ok now we can populate the debug info model. */\n+        // ok now we can populate the implementations\n         dwarfSections.installDebugInfo(debugInfoProvider);\n     }\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\nindex be10b81edd8..ef1312dbcb5 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java\n", "chunk": "@@ -1161,37 +1167,39 @@ public class ELFObjectFile extends ObjectFile {\n \n     @Override\n     public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        DwarfSections dwarfSections = new DwarfSections(getMachine());\n-        // we need an implementation for each section\n-        DwarfSections.DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n-        DwarfSections.DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n-        DwarfSections.DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n-        DwarfSections.DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n-        DwarfSections.DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n-        DwarfSections.DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n-        // now we can create the section elements with empty content\n+        DwarfSections dwarfSections = new DwarfSections(getMachine(), getByteOrder());\n+        /* We need an implementation for each generated DWARF section. */\n+        DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n+        DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n+        DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n+        DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n+        DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n+        DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n+        /* Now we can create the section elements with empty content. */\n         newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);\n         newUserDefinedSection(elfAbbrevSectionImpl.getSectionName(), elfAbbrevSectionImpl);\n         newUserDefinedSection(frameSectionImpl.getSectionName(), frameSectionImpl);\n         newUserDefinedSection(elfInfoSectionImpl.getSectionName(), elfInfoSectionImpl);\n         newUserDefinedSection(elfARangesSectionImpl.getSectionName(), elfARangesSectionImpl);\n         newUserDefinedSection(elfLineSectionImpl.getSectionName(), elfLineSectionImpl);\n-        // the byte[] for each implementation's content are created and\n-        // written under getOrDecideContent. doing that ensures that all\n-        // dependent sections are filled in and then sized according to the\n-        // declared dependencies. however, if we leave it at that then\n-        // associated reloc sections only get created when the first reloc\n-        // is inserted during content write that's too late for them to have\n-        // layout constraints included in the layout decision set and causes\n-        // an NPE during reloc section write. so we need to create the relevant\n-        // reloc sections here in advance\n+        /*\n+         * The byte[] for each implementation's content are created and\n+         * written under getOrDecideContent. Doing that ensures that all\n+         * dependent sections are filled in and then sized according to the\n+         * declared dependencies. However, if we leave it at that then\n+         * associated reloc sections only get created when the first reloc\n+         * is inserted during content write that's too late for them to have\n+         * layout constraints included in the layout decision set and causes\n+         * an NPE during reloc section write. So we need to create the relevant\n+         * reloc sections here in advance.\n+         */\n         elfStrSectionImpl.getOrCreateRelocationElement(false);\n         elfAbbrevSectionImpl.getOrCreateRelocationElement(false);\n         frameSectionImpl.getOrCreateRelocationElement(false);\n         elfInfoSectionImpl.getOrCreateRelocationElement(false);\n         elfARangesSectionImpl.getOrCreateRelocationElement(false);\n         elfLineSectionImpl.getOrCreateRelocationElement(false);\n-        // ok now we can populate the implementations\n+        /* Ok now we can populate the debug info model. */\n         dwarfSections.installDebugInfo(debugInfoProvider);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358061", "body": "I did not see the code where your elf.darf entities get transformed into their binary representations. Do I miss something or is this simply not ready yet?", "bodyText": "I did not see the code where your elf.darf entities get transformed into their binary representations. Do I miss something or is this simply not ready yet?", "bodyHTML": "<p dir=\"auto\">I did not see the code where your elf.darf entities get transformed into their binary representations. Do I miss something or is this simply not ready yet?</p>", "author": "olpaw", "createdAt": "2020-01-29T12:38:06Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * details of a specific address range in a compiled method\n+ * either a primary range identifying a whole method\n+ * or a sub-range identifying a sequence of\n+ * instructions that belong to an inlined method\n+ */\n+\n+public class Range {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NzE0NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372387145", "bodyText": "Sorry for the noise. Found it in DwarfSections.java (github did not show me that file first because it too large ... and it really is ;-) )", "author": "olpaw", "createdAt": "2020-01-29T13:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTY4Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375789682", "bodyText": "Yes, I will split out the embedded classes so the code can be in separate files.", "author": "adinn", "createdAt": "2020-02-06T11:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nsimilarity index 68%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 758825272a7..191ec29b053 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -24,17 +24,20 @@\n  * questions.\n  */\n \n-package com.oracle.objectfile.elf.dwarf;\n+package com.oracle.objectfile.debugentry;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n \n /**\n- * details of a specific address range in a compiled method\n- * either a primary range identifying a whole method\n- * or a sub-range identifying a sequence of\n- * instructions that belong to an inlined method\n+ * Details of a specific address range in a compiled method either a primary range identifying a\n+ * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n+ * method.\n  */\n \n public class Range {\n     private String fileName;\n+    private Path filePath;\n     private String className;\n     private String methodName;\n     private String paramNames;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODg5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358896", "body": "We would want to have a hosted option. e.g `GenerateDebugInfo` that would ensure TrackNodeSourcePosition is enabled whenever `GenerateDebugInfo > 0`", "bodyText": "We would want to have a hosted option. e.g GenerateDebugInfo that would ensure TrackNodeSourcePosition is enabled whenever GenerateDebugInfo > 0", "bodyHTML": "<p dir=\"auto\">We would want to have a hosted option. e.g <code>GenerateDebugInfo</code> that would ensure TrackNodeSourcePosition is enabled whenever <code>GenerateDebugInfo &gt; 0</code></p>", "author": "olpaw", "createdAt": "2020-01-29T12:40:12Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -458,6 +473,12 @@ public void build(DebugContext debug, ImageHeapLayouter layouter) {\n             cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\n             defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\n \n+            // if we have constructed any debug info then\n+            // give the object file a chance to install it\n+            if (GraalOptions.TrackNodeSourcePosition.getValue(HostedOptionValues.singleton())) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMDI5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376330296", "bodyText": "Answered in another comment", "author": "adinn", "createdAt": "2020-02-07T10:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 562dd1c040e..5787b086d2a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -475,7 +476,8 @@ public abstract class NativeBootImage extends AbstractBootImage {\n \n             // if we have constructed any debug info then\n             // give the object file a chance to install it\n-            if (GraalOptions.TrackNodeSourcePosition.getValue(HostedOptionValues.singleton())) {\n+            if (SubstrateOptions.GenerateDebugInfo.getValue(HostedOptionValues.singleton()) > 0) {\n+                ImageSingletons.add(SourceManager.class, new SourceManager());\n                 DebugInfoProvider provider = new NativeImageDebugInfoProvider(codeCache, heap);\n                 objectFile.installDebugInfo(provider);\n             }\n", "next_change": {"commit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 5787b086d2a..f910ed54dee 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -478,7 +467,7 @@ public abstract class NativeBootImage extends AbstractBootImage {\n             // give the object file a chance to install it\n             if (SubstrateOptions.GenerateDebugInfo.getValue(HostedOptionValues.singleton()) > 0) {\n                 ImageSingletons.add(SourceManager.class, new SourceManager());\n-                DebugInfoProvider provider = new NativeImageDebugInfoProvider(codeCache, heap);\n+                DebugInfoProvider provider = new NativeImageDebugInfoProvider(debug, codeCache, heap);\n                 objectFile.installDebugInfo(provider);\n             }\n             // - Write the heap, either to its own section, or to the ro and rw data sections.\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex f910ed54dee..50078e9ea84 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -463,8 +461,9 @@ public abstract class NativeBootImage extends AbstractBootImage {\n             cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\n             defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\n \n-            // if we have constructed any debug info then\n-            // give the object file a chance to install it\n+            /*\n+             * If we constructed debug info give the object file a chance to install it\n+             */\n             if (SubstrateOptions.GenerateDebugInfo.getValue(HostedOptionValues.singleton()) > 0) {\n                 ImageSingletons.add(SourceManager.class, new SourceManager());\n                 DebugInfoProvider provider = new NativeImageDebugInfoProvider(debug, codeCache, heap);\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 50078e9ea84..30b121818e6 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -461,12 +471,10 @@ public abstract class NativeBootImage extends AbstractBootImage {\n             cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\n             defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\n \n-            /*\n-             * If we constructed debug info give the object file a chance to install it\n-             */\n-            if (SubstrateOptions.GenerateDebugInfo.getValue(HostedOptionValues.singleton()) > 0) {\n-                ImageSingletons.add(SourceManager.class, new SourceManager());\n-                DebugInfoProvider provider = new NativeImageDebugInfoProvider(debug, codeCache, heap);\n+            // if we have constructed any debug info then\n+            // give the object file a chance to install it\n+            if (GraalOptions.TrackNodeSourcePosition.getValue(HostedOptionValues.singleton())) {\n+                DebugInfoProvider provider = new NativeImageDebugInfoProvider(codeCache, heap);\n                 objectFile.installDebugInfo(provider);\n             }\n             // - Write the heap, either to its own section, or to the ro and rw data sections.\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 30b121818e6..0d03818a228 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -473,7 +473,7 @@ public abstract class NativeBootImage extends AbstractBootImage {\n \n             // if we have constructed any debug info then\n             // give the object file a chance to install it\n-            if (GraalOptions.TrackNodeSourcePosition.getValue(HostedOptionValues.singleton())) {\n+            if (SubstrateOptions.GenerateDebugInfo.getValue(HostedOptionValues.singleton()) > 0) {\n                 DebugInfoProvider provider = new NativeImageDebugInfoProvider(codeCache, heap);\n                 objectFile.installDebugInfo(provider);\n             }\n", "next_change": {"commit": "53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 0d03818a228..17c611e6c77 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -474,6 +474,7 @@ public abstract class NativeBootImage extends AbstractBootImage {\n             // if we have constructed any debug info then\n             // give the object file a chance to install it\n             if (SubstrateOptions.GenerateDebugInfo.getValue(HostedOptionValues.singleton()) > 0) {\n+                ImageSingletons.add(SourceManager.class, new SourceManager());\n                 DebugInfoProvider provider = new NativeImageDebugInfoProvider(codeCache, heap);\n                 objectFile.installDebugInfo(provider);\n             }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 17c611e6c77..50078e9ea84 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -471,11 +461,12 @@ public abstract class NativeBootImage extends AbstractBootImage {\n             cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\n             defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\n \n-            // if we have constructed any debug info then\n-            // give the object file a chance to install it\n+            /*\n+             * If we constructed debug info give the object file a chance to install it\n+             */\n             if (SubstrateOptions.GenerateDebugInfo.getValue(HostedOptionValues.singleton()) > 0) {\n                 ImageSingletons.add(SourceManager.class, new SourceManager());\n-                DebugInfoProvider provider = new NativeImageDebugInfoProvider(codeCache, heap);\n+                DebugInfoProvider provider = new NativeImageDebugInfoProvider(debug, codeCache, heap);\n                 objectFile.installDebugInfo(provider);\n             }\n             // - Write the heap, either to its own section, or to the ro and rw data sections.\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NjM3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372366372", "body": "We have org.graalvm.compiler.debug.DebugContext for logging. See e.g. `com.oracle.svm.hosted.ResourcesFeature#scanDirectory`", "bodyText": "We have org.graalvm.compiler.debug.DebugContext for logging. See e.g. com.oracle.svm.hosted.ResourcesFeature#scanDirectory", "bodyHTML": "<p dir=\"auto\">We have org.graalvm.compiler.debug.DebugContext for logging. See e.g. <code>com.oracle.svm.hosted.ResourcesFeature#scanDirectory</code></p>", "author": "olpaw", "createdAt": "2020-01-29T12:57:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -406,1939 +440,37 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n+        /*\n+         * the primary range should already have been seen and associated with a primary class entry\n+         */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n \n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n \n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n \n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTYyNQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372369625", "body": "afaics you only ever add to this list without every using it afterwards", "bodyText": "afaics you only ever add to this list without every using it afterwards", "bodyHTML": "<p dir=\"auto\">afaics you only ever add to this list without every using it afterwards</p>", "author": "olpaw", "createdAt": "2020-01-29T13:04:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NTM5MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375795391", "bodyText": "Yes, I was hedging on the idea that it might be necessary at some point to iterate over (outer) compiled methods in address order. At present all iteration is by methods within each owning class (using the list of ClassEntry) which is effectively the same. I have removed this list and updated the comments regarding iteration options.", "author": "adinn", "createdAt": "2020-02-06T12:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTYyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -192,86 +234,65 @@ public class DwarfSections {\n         return dwarfLineSection;\n     }\n \n-    public ELFMachine getElfMachine() {\n-        return elfMachine;\n-    }\n-\n     /**\n-     * a scratch buffer used during computation of a section's size.\n-     */\n-    protected static final byte[] scratch = new byte[10];\n-\n-    /**\n-     * a table listing all known strings, some of\n-     * which may be marked for insertion into the\n+     * a table listing all known strings, some of which may be marked for insertion into the\n      * debug_str section.\n      */\n     private StringTable stringTable = new StringTable();\n \n     /**\n-     * list detailing all dirs in which files are found to reside\n-     * either as part of substrate/compiler or user code.\n+     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n+     * user code.\n      */\n-    private LinkedList<DirEntry> dirs = new LinkedList<>();\n-    /**\n-     * index of already seen dirs.\n+    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n+\n+    /*\n+     * The obvious traversal structure for debug records is:\n+     *\n+     * 1) by top level compiled method (primary Range) ordered by ascending address\n+     *\n+     * 2) by inlined method (sub range) within top level method ordered by ascending address\n+     *\n+     * these can be used to ensure that all debug records are generated in increasing address order\n+     *\n+     * An alternative traversal option is\n+     *\n+     * 1) by top level class (String id)\n+     *\n+     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+     *\n+     * 3) by inlined method (sub range) within top level method ordered by ascending address\n+     *\n+     * this relies on the (current) fact that methods of a given class always appear in a single\n+     * continuous address range with no intervening code from other methods or data values. this\n+     * means we can treat each class as a compilation unit, allowing data common to all methods of\n+     * the class to be shared.\n+     *\n+     * A third option appears to be to traverse via files, then top level class within file etc.\n+     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n+     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n+     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n+     * a shame because generating debug info records one file at a time would allow more sharing\n+     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n      */\n-    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n-\n-    // The obvious traversal structure for debug records is:\n-    //\n-    // 1) by top level compiled method (primary Range) ordered by ascending address\n-    // 2) by inlined method (sub range) within top level method ordered by ascending address\n-    //\n-    // this ensures that all debug records are generated in increasing address order\n-\n-    /**\n-     * a list recording details of all primary ranges included in\n-     * this file sorted by ascending address range.\n-     */\n-    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n-\n-    // An alternative traversal option is\n-    // 1) by top level class (String id)\n-    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-    // 3) by inlined method (sub range) within top level method ordered by ascending address\n-    //\n-    // this relies on the (current) fact that methods of a given class always appear\n-    // in a single continuous address range with no intervening code from other methods\n-    // or data values. this means we can treat each class as a compilation unit, allowing\n-    // data common to all methods of the class to be shared.\n-    //\n-    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n-    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n-    // class C' in file F' will not be compiled into the address space interleaved between\n-    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n-    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n-    // of the file and dir tables.\n \n     /**\n      * list of class entries detailing class info for primary ranges.\n      */\n     private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n     /**\n-     *  index of already seen classes.\n+     * index of already seen classes.\n      */\n     private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n \n     /**\n-     * list of files which contain primary ranges.\n-     */\n-    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n-    /**\n-     * List of files which contain primary or secondary ranges.\n-     */\n-    private LinkedList<FileEntry> files = new LinkedList<>();\n-    /**\n-     * index of already seen files.\n+     * index of files which contain primary or secondary ranges.\n      */\n-    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n \n     /**\n      * indirects this call to the string table.\n+     * \n      * @param string the string to be inserted\n      * @return a unique equivalent String\n      */\n", "next_change": {"commit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 5d26129bf74..7dd562a042d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -292,8 +294,9 @@ public class DwarfSections {\n \n     /**\n      * indirects this call to the string table.\n-     * \n+     *\n      * @param string the string to be inserted\n+     *\n      * @return a unique equivalent String\n      */\n     public String uniqueString(String string) {\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 7dd562a042d..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,487 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-    // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     *\n-     * @param string the string to be inserted\n-     *\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     *\n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     *\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     *\n-     * @param string the string whose index is required\n-     *\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     *\n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    @SuppressWarnings(\"try\")\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> debugCodeInfo.debugContext((debugContext) -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            debugContext.log(DebugContext.INFO_LEVEL, \"PrimaryRange %s.%s %s %s:%d [0x%x, 0x%x]\", className, methodName, filePath, fileName, primaryLine, lo, hi);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-                try (DebugContext.Scope s = debugContext.scope(\"Subranges\")) {\n-                    debugContext.log(DebugContext.VERBOSE_LEVEL, \"SubRange %s.%s %s %s:%d 0x%x, 0x%x]\", classNameAtLine, methodNameAtLine, filePathAtLine, fileNameAtLine, line, loAtLine, hiAtLine);\n-                }\n-            });\n-        }));\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if(!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MDg5Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372370897", "body": "Maybe Charset.forName(\"US-ASCII\").newEncoder().canEncode ?", "bodyText": "Maybe Charset.forName(\"US-ASCII\").newEncoder().canEncode ?", "bodyHTML": "<p dir=\"auto\">Maybe Charset.forName(\"US-ASCII\").newEncoder().canEncode ?</p>", "author": "olpaw", "createdAt": "2020-01-29T13:07:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -406,1939 +440,37 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n+        /*\n+         * the primary range should already have been seen and associated with a primary class entry\n+         */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n \n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n \n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n \n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MjI3OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372372279", "body": "CUDOs for documenting the binary representations. Please use\r\n```\r\n/*\r\n * This style for code comments wherever possible.\r\n *\r\n */", "bodyText": "CUDOs for documenting the binary representations. Please use\n/*\n * This style for code comments wherever possible.\n *\n */", "bodyHTML": "<p dir=\"auto\">CUDOs for documenting the binary representations. Please use</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"/*\n * This style for code comments wherever possible.\n *\n */\n\"><pre><code>/*\n * This style for code comments wherever possible.\n *\n */\n</code></pre></div>", "author": "olpaw", "createdAt": "2020-01-29T13:10:31Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -406,1939 +440,37 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n+        /*\n+         * the primary range should already have been seen and associated with a primary class entry\n+         */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n \n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n \n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n \n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MzI1NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372373255", "body": "This file would profit from getting partitioned into multiple source files.", "bodyText": "This file would profit from getting partitioned into multiple source files.", "bodyHTML": "<p dir=\"auto\">This file would profit from getting partitioned into multiple source files.</p>", "author": "olpaw", "createdAt": "2020-01-29T13:12:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg2NzcyNA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375867724", "bodyText": "All the section implementation classes are now in separat efiles and they are no longer inner classes of class SwarfSections", "author": "adinn", "createdAt": "2020-02-06T14:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MzI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 286871c7227..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,2344 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.BasicProgbitsSectionImpl;\n-import com.oracle.objectfile.BuildDependency;\n-import com.oracle.objectfile.LayoutDecision;\n-import com.oracle.objectfile.LayoutDecisionMap;\n-import com.oracle.objectfile.ObjectFile;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n-// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n-// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n-import com.oracle.objectfile.ObjectFile.Element;\n-import com.oracle.objectfile.elf.ELFMachine;\n-import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n-\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * an outer class that models the debug info in an\n- * organization that facilitates generation of the\n- * required DWARF sections. It groups common data and\n- * behaviours for use by the various subclasses of\n- * inner class DwarfSectionImpl that take responsibility\n- * for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-    // names of the different ELF sections we create or reference\n-    // in reverse dependency order\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    private static final short DW_VERSION_2 = 2;\n-\n-    // define all the abbrev section codes we need for our DIEs\n-    // private static final int DW_ABBREV_CODE_null = 0;\n-    private static final int DW_ABBREV_CODE_compile_unit = 1;\n-    private static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    // define all the Dwarf tags we need for our DIEs\n-    private static final int DW_TAG_compile_unit = 0x11;\n-    private static final int DW_TAG_subprogram = 0x2e;\n-    // define all the Dwarf attributes we need for our DIEs\n-    private static final int DW_AT_null = 0x0;\n-    private static final int DW_AT_name = 0x3;\n-    // private static final int DW_AT_comp_dir = 0x1b;\n-    private static final int DW_AT_stmt_list = 0x10;\n-    private static final int DW_AT_low_pc = 0x11;\n-    private static final int DW_AT_hi_pc = 0x12;\n-    private static final int DW_AT_language = 0x13;\n-    private static final int DW_AT_external = 0x3f;\n-    // private static final int DW_AT_return_addr = 0x2a;\n-    // private static final int DW_AT_frame_base = 0x40;\n-    // define all the Dwarf attribute forms we need for our DIEs\n-    private static final int DW_FORM_null = 0x0;\n-    // private static final int DW_FORM_string = 0x8;\n-    private static final int DW_FORM_strp = 0xe; // not currently used\n-    private static final int DW_FORM_addr = 0x1;\n-    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n-    private static final int DW_FORM_data4 = 0x6;\n-    // private static final int DW_FORM_data8 = 0x7;\n-    // private static final int DW_FORM_block1 = 0x0a;\n-    private static final int DW_FORM_flag = 0xc;\n-\n-    // define specific attribute values for given attribute or form types\n-    // DIE header has_children attribute values\n-    private static final byte DW_CHILDREN_no = 0;\n-    private static final byte DW_CHILDREN_yes = 1;\n-    // DW_FORM_flag attribute values\n-    // private static final byte DW_FLAG_false = 0;\n-    private static final byte DW_FLAG_true = 1;\n-    // value for DW_AT_language attribute with form DATA1\n-    private static final byte DW_LANG_Java = 0xb;\n-    // access not needed until we make functions members\n-    // DW_AT_Accessibility attribute values\n-    // private static final byte DW_ACCESS_public = 1;\n-    // private static final byte DW_ACCESS_protected = 2;\n-    // private static final byte DW_ACCESS_private = 3;\n-\n-    // not yet needed\n-    // private static final int DW_AT_type = 0; // only present for non-void functions\n-    // private static final int DW_AT_accessibility = 0;\n-\n-    // CIE and FDE entries\n-\n-    private static final int DW_CFA_CIE_id = -1;\n-    // private static final int DW_CFA_FDE_id = 0;\n-\n-    private static final byte DW_CFA_CIE_version = 1;\n-\n-    // values for high 2 bits\n-    private static final byte DW_CFA_advance_loc = 0x1;\n-    private static final byte DW_CFA_offset = 0x2;\n-    // private static final byte DW_CFA_restore = 0x3;\n-\n-    // values for low 6 bits\n-    private static final byte DW_CFA_nop = 0x0;\n-    // private static final byte DW_CFA_set_loc1 = 0x1;\n-    private static final byte DW_CFA_advance_loc1 = 0x2;\n-    private static final byte DW_CFA_advance_loc2 = 0x3;\n-    private static final byte DW_CFA_advance_loc4 = 0x4;\n-    // private static final byte DW_CFA_offset_extended = 0x5;\n-    // private static final byte DW_CFA_restore_extended = 0x6;\n-    // private static final byte DW_CFA_undefined = 0x7;\n-    // private static final byte DW_CFA_same_value = 0x8;\n-    private static final byte DW_CFA_register = 0x9;\n-    private static final byte DW_CFA_def_cfa = 0xc;\n-    // private static final byte DW_CFA_def_cfa_register = 0xd;\n-    private static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ELFMachine elfMachine;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine) {\n-        this.elfMachine = elfMachine;\n-        dwarfStrSection = new DwarfStrSectionImpl();\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n-        dwarfInfoSection = new DwarfInfoSectionImpl();\n-        dwarfARangesSection = new DwarfARangesSectionImpl();\n-        dwarfLineSection = new DwarfLineSectionImpl();\n-        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n-                        ? new DwarfFrameSectionImplAArch64()\n-                        : new DwarfFrameSectionImplX86_64());\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    public ELFMachine getElfMachine() {\n-        return elfMachine;\n-    }\n-\n-    /**\n-     * a scratch buffer used during computation of a section's size.\n-     */\n-    protected static final byte[] scratch = new byte[10];\n-\n-    /**\n-     * a table listing all known strings, some of\n-     * which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * list detailing all dirs in which files are found to reside\n-     * either as part of substrate/compiler or user code.\n-     */\n-    private LinkedList<DirEntry> dirs = new LinkedList<>();\n-    /**\n-     * index of already seen dirs.\n-     */\n-    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n-\n-    // The obvious traversal structure for debug records is:\n-    //\n-    // 1) by top level compiled method (primary Range) ordered by ascending address\n-    // 2) by inlined method (sub range) within top level method ordered by ascending address\n-    //\n-    // this ensures that all debug records are generated in increasing address order\n-\n-    /**\n-     * a list recording details of all primary ranges included in\n-     * this file sorted by ascending address range.\n-     */\n-    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n-\n-    // An alternative traversal option is\n-    // 1) by top level class (String id)\n-    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-    // 3) by inlined method (sub range) within top level method ordered by ascending address\n-    //\n-    // this relies on the (current) fact that methods of a given class always appear\n-    // in a single continuous address range with no intervening code from other methods\n-    // or data values. this means we can treat each class as a compilation unit, allowing\n-    // data common to all methods of the class to be shared.\n-    //\n-    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n-    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n-    // class C' in file F' will not be compiled into the address space interleaved between\n-    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n-    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n-    // of the file and dir tables.\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     *  index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * list of files which contain primary ranges.\n-     */\n-    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n-    /**\n-     * List of files which contain primary or secondary ranges.\n-     */\n-    private LinkedList<FileEntry> files = new LinkedList<>();\n-    /**\n-     * index of already seen files.\n-     */\n-    private Map<String, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring\n-     * the table entry is marked for inclusion in the\n-     * debug_str section.\n-     * @param string the string to be inserted and\n-     * marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str\n-     * section\n-     */\n-    private int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information\n-     * about types, code and heap data.\n-     * @param debugInfoProvider provider instance passed by\n-     * ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n-        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n-        // install types\n-        // }\n-\n-        // ensure we have a null string in the string section\n-        uniqueDebugString(\"\");\n-\n-        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n-        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n-            // primary file name and full method name need to be written to the debug_str section\n-            String fileName = debugCodeInfo.fileName();\n-            String className = debugCodeInfo.className();\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-            // returnTypeName, className, methodName, paramNames, fileName);\n-            // create an infoSection entry for the method\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                String classNameAtLine = debugLineInfo.className();\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                // record all subranges even if they have no line or file so we at least get a\n-                // symbol for them\n-                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            }\n-        }\n-        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n-        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n-        // install details of heap elements\n-        // String name = debugDataInfo.toString();\n-        // }\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        // see if we already have an entry\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            // create and index the entry associating it with the right file\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        // ensure we have an entry\n-        FileEntry fileEntry = filesIndex.get(fileName);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(fileName);\n-            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n-            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n-                            stringTable.uniqueString(baseName),\n-                            dirEntry);\n-            files.add(fileEntry);\n-            filesIndex.put(fileName, fileEntry);\n-            // if this is a primary entry then add it to the primary list\n-            if (range.isPrimary()) {\n-                primaryFiles.add(fileEntry);\n-            } else {\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n-                assert primaryEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-        if (entry != null) {\n-            // track the entry for this range in address order\n-            primaryEntries.add(entry);\n-        }\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n-    }\n-\n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n-            return null;\n-        }\n-        String filePath = file.substring(0, pathLength);\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n-            dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDQ3Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372380476", "body": "Why not use Path for path-like entities?", "bodyText": "Why not use Path for path-like entities?", "bodyHTML": "<p dir=\"auto\">Why not use Path for path-like entities?</p>", "author": "olpaw", "createdAt": "2020-01-29T13:28:02Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DirEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track the directory associated with one or\n+ * more source files.\n+ */\n+public class DirEntry {\n+    private String path;", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MjcwNg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383972706", "bodyText": "Done", "author": "adinn", "createdAt": "2020-02-25T15:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DirEntry.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCacheType.java\nsimilarity index 78%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DirEntry.java\nrename to substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCacheType.java\nindex 5caac5a2099..5e37d388314 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DirEntry.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCacheType.java\n", "chunk": "@@ -24,20 +24,24 @@\n  * questions.\n  */\n \n-package com.oracle.objectfile.elf.dwarf;\n+package com.oracle.svm.hosted.image.sources;\n \n-/**\n- * track the directory associated with one or\n- * more source files.\n- */\n-public class DirEntry {\n-    private String path;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public enum SourceCacheType {\n+    JDK(\"jdk\"),\n+    GRAALVM(\"graal\"),\n+    APPLICATION(\"src\");\n \n-    public DirEntry(String path) {\n-        this.path = path;\n+    final Path subdir;\n+\n+    SourceCacheType(String subdir) {\n+        this.subdir = Paths.get(subdir);\n     }\n \n-    public String getPath() {\n-        return path;\n+    public Path getSubdir() {\n+        return subdir;\n     }\n+\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372381712", "body": "Use Path here an you get Platform portability for free.", "bodyText": "Use Path here an you get Platform portability for free.", "bodyHTML": "<p dir=\"auto\">Use Path here an you get Platform portability for free.</p>", "author": "olpaw", "createdAt": "2020-01-29T13:30:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzAzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377773031", "bodyText": "I have pushed some changes which address this problem. I modified the interface between the native image writer and the object file to pass a String for file name and Path for directory. The object file writer also employs Path internally to store both dir names and full (dir-qualfiied) file names. This avoids issues any need to handle path separators.\nI'm not sure yet that this is all done though. In particular, the info in the hosted class and source node positions does not contain any information about original source file locations. So, the native image writer is still populating Path instances with the component elements of the hosted class's package name or the inlined class's qualified name, respectively.", "author": "adinn", "createdAt": "2020-02-11T17:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTMxMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383975310", "bodyText": "Thsi has been reworked. See other comments.", "author": "adinn", "createdAt": "2020-02-25T16:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -406,1939 +440,37 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n+        /*\n+         * the primary range should already have been seen and associated with a primary class entry\n+         */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n \n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n \n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n \n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MjkxMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372382910", "body": "Should be a static class. Others likely as well. Event better split out into several source files", "bodyText": "Should be a static class. Others likely as well. Event better split out into several source files", "bodyHTML": "<p dir=\"auto\">Should be a static class. Others likely as well. Event better split out into several source files</p>", "author": "olpaw", "createdAt": "2020-01-29T13:32:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMTM5Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376331392", "bodyText": "Fixed as part of the move to separate files.", "author": "adinn", "createdAt": "2020-02-07T10:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MjkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -406,1939 +440,37 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n+        /*\n+         * the primary range should already have been seen and associated with a primary class entry\n+         */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n \n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n \n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n \n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NDk2MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372384961", "body": "That is the right place to switch from Path to String objects.", "bodyText": "That is the right place to switch from Path to String objects.", "bodyHTML": "<p dir=\"auto\">That is the right place to switch from Path to String objects.</p>", "author": "olpaw", "createdAt": "2020-01-29T13:36:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+             ", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NjQwNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377776407", "bodyText": "Yes, uses of file names and paths are now converted at the point of use.", "author": "adinn", "createdAt": "2020-02-11T17:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NDk2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -406,1939 +440,37 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n+        /*\n+         * the primary range should already have been seen and associated with a primary class entry\n+         */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n \n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n \n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n \n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372385631", "body": "Strings ...", "bodyText": "Strings ...", "bodyHTML": "<p dir=\"auto\">Strings ...</p>", "author": "olpaw", "createdAt": "2020-01-29T13:38:12Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/FileEntry.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track debug info associated with a Java source file.\n+ */\n+public class FileEntry {\n+    // the name of the associated file including path\n+    private String fileName;\n+    // the name of the associated file excluding path\n+    private String baseName;\n+    // the directory entry associated with this file entry\n+    DirEntry dirEntry;\n+\n+    public FileEntry(String fileName, String baseName, DirEntry dirEntry) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NjU4NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377776585", "bodyText": "See the last commit.", "author": "adinn", "createdAt": "2020-02-11T17:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTY1Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383975656", "bodyText": "Yes, now using Path. See other comments", "author": "adinn", "createdAt": "2020-02-25T16:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/FileEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nsimilarity index 71%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/FileEntry.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\nindex cd530c68de0..1aedf4dc879 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/FileEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java\n", "chunk": "@@ -24,34 +24,39 @@\n  * questions.\n  */\n \n-package com.oracle.objectfile.elf.dwarf;\n+package com.oracle.objectfile.debugentry;\n \n /**\n- * track debug info associated with a Java source file.\n+ * Tracks debug info associated with a Java source file.\n  */\n public class FileEntry {\n-    // the name of the associated file including path\n     private String fileName;\n-    // the name of the associated file excluding path\n-    private String baseName;\n-    // the directory entry associated with this file entry\n-    DirEntry dirEntry;\n+    private DirEntry dirEntry;\n \n-    public FileEntry(String fileName, String baseName, DirEntry dirEntry) {\n+    public FileEntry(String fileName, DirEntry dirEntry) {\n         this.fileName = fileName;\n-        this.baseName = baseName;\n         this.dirEntry = dirEntry;\n     }\n \n+    /**\n+     * The name of the associated file excluding path elements.\n+     */\n     public String getFileName() {\n         return fileName;\n     }\n \n-    public String getBaseName() {\n-        return baseName;\n+    public String getPathName() {\n+        return getDirEntry().getPathString();\n     }\n \n-    String getDirName() {\n-        return (dirEntry != null ? dirEntry.getPath() : \"\");\n+    public String getFullName() {\n+        return getDirEntry().getPath().resolve(getFileName()).toString();\n+    }\n+\n+    /**\n+     * The directory entry associated with this file entry.\n+     */\n+    public DirEntry getDirEntry() {\n+        return dirEntry;\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjIzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372386231", "body": "Always start JavaDoc with capital letter.", "bodyText": "Always start JavaDoc with capital letter.", "bodyHTML": "<p dir=\"auto\">Always start JavaDoc with capital letter.</p>", "author": "olpaw", "createdAt": "2020-01-29T13:39:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/PrimaryEntry.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * track debug info associated with a primary method.", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzM1MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377777350", "bodyText": "I have done a global update to all Javadoc and will endeavour to stick to this from now on. I will do a final pass once the other comments have been addressed.", "author": "adinn", "createdAt": "2020-02-11T17:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/PrimaryEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/PrimaryEntry.java\nsimilarity index 54%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/PrimaryEntry.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/PrimaryEntry.java\nindex 6720703cf92..b0199d3c3f6 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/PrimaryEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/PrimaryEntry.java\n", "chunk": "@@ -33,50 +33,33 @@ import java.util.LinkedList;\n import java.util.List;\n \n /**\n- * track debug info associated with a primary method.\n- * i.e. a top level compiled method\n+ * Tracks debug info associated with a primary method. i.e. a top level compiled method\n  */\n public class PrimaryEntry {\n     /**\n-     * the primary range detailed by this object.\n+     * The primary range detailed by this object.\n      */\n     Range primary;\n     /**\n-     * details of the class owning this range.\n+     * Details of the class owning this range.\n      */\n     ClassEntry classEntry;\n     /**\n-     * a list of subranges associated with the primary range.\n+     * A list of subranges associated with the primary range.\n      */\n     List<Range> subranges;\n     /**\n-     * a mapping from subranges to their associated file entry.\n+     * A mapping from subranges to their associated file entry.\n      */\n     HashMap<Range, FileEntry> subrangeIndex;\n     /**\n-     * details of of compiled method frame size changes.\n+     * Details of of compiled method frame size changes.\n      */\n     private List<DebugFrameSizeChange> frameSizeInfos;\n     /**\n-     * size of compiled method frame.\n+     * Size of compiled method frame.\n      */\n     private int frameSize;\n-    /**\n-     * index of debug_info section compilation unit for this file.\n-     */\n-    private int cuIndex;\n-    /**\n-     * index into debug_line section for associated compilation unit.\n-     */\n-    private int lineIndex;\n-    /**\n-     * size of line number info prologue region for associated compilation unit.\n-     */\n-    private int linePrologueSize;\n-    /**\n-     * total size of line number info region for associated compilation unit.\n-     */\n-    private int totalSize;\n \n     public PrimaryEntry(Range primary, List<DebugFrameSizeChange> frameSizeInfos, int frameSize, ClassEntry classEntry) {\n         this.primary = primary;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4ODQwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372388408", "body": "afaics this is the only thing used atm, right?", "bodyText": "afaics this is the only thing used atm, right?", "bodyHTML": "<p dir=\"auto\">afaics this is the only thing used atm, right?</p>", "author": "olpaw", "createdAt": "2020-01-29T13:43:27Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NzY1OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375797658", "bodyText": "Yes, at present. However, the plan is to also allow the debug writer to iterate over types and details of heap contents courtesy of a DebugTypeInfoProvider and DebugDataInfoProvider. The details of those interfaces still need to be fully worked out.", "author": "adinn", "createdAt": "2020-02-06T12:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4ODQwOA=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 562dd1c040e..5787b086d2a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -975,119 +977,74 @@ public abstract class NativeBootImage extends AbstractBootImage {\n     }\n \n     /**\n-     * implementation of the DebugInfoProvider API interface\n-     * that allows type, code and heap data info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n+     * implementation of the DebugInfoProvider API interface that allows type, code and heap data\n+     * info to be passed to an ObjectFile when generation of debug info is enabled.\n      */\n     private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n         private final NativeImageCodeCache codeCache;\n+        @SuppressWarnings(\"unused\")\n         private final NativeImageHeap heap;\n-        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n-        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n \n         NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n             super();\n             this.codeCache = codeCache;\n             this.heap = heap;\n-            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n-            this.heapIterator = heap.objects.entrySet().iterator();\n         }\n \n         @Override\n-        public DebugTypeInfoProvider typeInfoProvider() {\n-            return () -> new Iterator<DebugTypeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugTypeInfo next() {\n-                    return null;\n-                }\n-            };\n+        public Stream<DebugTypeInfo> typeInfoProvider() {\n+            return Stream.empty();\n         }\n \n         @Override\n-        public DebugCodeInfoProvider codeInfoProvider() {\n-            return () -> new Iterator<DebugCodeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return codeCacheIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugCodeInfo next() {\n-                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n-                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n-                }\n-            };\n+        public Stream<DebugCodeInfo> codeInfoProvider() {\n+            return codeCache.compilations.entrySet().stream().map(entry -> new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue()));\n         }\n \n         @Override\n-        public DebugDataInfoProvider dataInfoProvider() {\n-            return () -> new Iterator<DebugDataInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugDataInfo next() {\n-                    return null;\n-                }\n-            };\n+        public Stream<DebugDataInfo> dataInfoProvider() {\n+            return Stream.empty();\n         }\n     }\n \n     /**\n-     * implementation of the DebugCodeInfo API interface\n-     * that allows code info to be passed to an ObjectFile\n-     * when generation of debug info is enabled.\n+     * implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n      */\n     private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n         private final HostedMethod method;\n+        private final ResolvedJavaType javaType;\n         private final CompilationResult compilation;\n+        private Path fullFilePath;\n \n         NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n             this.method = method;\n+            HostedType declaringClass = method.getDeclaringClass();\n+            Class<?> clazz = declaringClass.getJavaClass();\n+            this.javaType = declaringClass.getWrapped();\n             this.compilation = compilation;\n+            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(javaType, clazz);\n         }\n \n         @Override\n         public String fileName() {\n-            HostedType declaringClass = method.getDeclaringClass();\n-            String name = declaringClass.getSourceFileName();\n-            if (name != null) {\n-                // the file name will not include any path\n-                // use the package to create a path prefix\n-                Package pkg = declaringClass.getJavaClass().getPackage();\n-                if (pkg != null) {\n-                    String prefix = pkg.getName();\n-                    prefix = prefix.replace('.', '/');\n-                    name = prefix + \"/\" + name;\n-                }\n-            } else {\n-                // build file name from the class name which includes the package\n-                name = className();\n-                // try to map inner classes back to their parent class's file\n-                int idx = name.indexOf('$');\n-                if (idx == 0) {\n-                    // name is $XXX so cannot associate with a file\n-                    return \"\";\n-                }\n-                if (idx > 0) {\n-                    // name is XXX$YYY so use outer class to derive file name\n-                    name = name.substring(0, idx);\n-                }\n-                name = name.replace('.', '/') + \".java\";\n+            if (fullFilePath != null) {\n+                return fullFilePath.getFileName().toString();\n             }\n-            return name;\n+            return null;\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            if (fullFilePath != null) {\n+                return fullFilePath.getParent();\n+            }\n+            return null;\n         }\n \n         @Override\n         public String className() {\n-            return method.format(\"%H\");\n+            return javaType.toClassName();\n         }\n \n         @Override\n", "next_change": {"commit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 5787b086d2a..f910ed54dee 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -975,255 +964,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface that allows type, code and heap data\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        @SuppressWarnings(\"unused\")\n-        private final NativeImageHeap heap;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-        }\n-\n-        @Override\n-        public Stream<DebugTypeInfo> typeInfoProvider() {\n-            return Stream.empty();\n-        }\n-\n-        @Override\n-        public Stream<DebugCodeInfo> codeInfoProvider() {\n-            return codeCache.compilations.entrySet().stream().map(entry -> new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue()));\n-        }\n-\n-        @Override\n-        public Stream<DebugDataInfo> dataInfoProvider() {\n-            return Stream.empty();\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            HostedType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = declaringClass.getJavaClass();\n-            this.javaType = declaringClass.getWrapped();\n-            this.compilation = compilation;\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(javaType, clazz);\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return javaType.toClassName();\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public Stream<DebugLineInfo> lineInfoProvider() {\n-            if (fileName().toString().length() == 0) {\n-                return Stream.empty();\n-            }\n-            return compilation.getSourceMappings().stream().map(sourceMapping -> new NativeImageDebugLineInfo(sourceMapping));\n-        }\n-\n-        @Override\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        @Override\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface that allows line number info to be passed\n-     * to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int posbci = position.getBCI();\n-            this.bci = (posbci >= 0 ? posbci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-            computeFullFilePath();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-\n-        private void computeFullFilePath() {\n-            ResolvedJavaType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = null;\n-            if (declaringClass instanceof OriginalClassProvider) {\n-                clazz = ((OriginalClassProvider) declaringClass).getJavaClass();\n-            }\n-            /*\n-             * HostedType and AnalysisType punt calls to getSourceFilename to the wrapped class so\n-             * for consistency we need to do the path lookup relative to the wrapped class\n-             */\n-            if (declaringClass instanceof HostedType) {\n-                declaringClass = ((HostedType) declaringClass).getWrapped();\n-            }\n-            if (declaringClass instanceof AnalysisType) {\n-                declaringClass = ((AnalysisType) declaringClass).getWrapped();\n-            }\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(declaringClass, clazz);\n-        }\n-\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface that allows stack frame size change\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex f910ed54dee..30b121818e6 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -964,4 +971,299 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return lo;\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return hi;\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(bci);\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugFrameSizeChange API interface\n+     * that allows stack frame size change info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n+        private int offset;\n+        private Type type;\n+\n+        NativeImageDebugFrameSizeChange(int offset, Type type) {\n+            this.offset = offset;\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public int getOffset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public Type getType() {\n+            return type;\n+        }\n+    }\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 30b121818e6..50078e9ea84 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -971,299 +963,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface\n-     * that allows type, code and heap data info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        private final NativeImageHeap heap;\n-        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n-        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n-            this.heapIterator = heap.objects.entrySet().iterator();\n-        }\n-\n-        @Override\n-        public DebugTypeInfoProvider typeInfoProvider() {\n-            return () -> new Iterator<DebugTypeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugTypeInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugCodeInfoProvider codeInfoProvider() {\n-            return () -> new Iterator<DebugCodeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return codeCacheIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugCodeInfo next() {\n-                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n-                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugDataInfoProvider dataInfoProvider() {\n-            return () -> new Iterator<DebugDataInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugDataInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface\n-     * that allows code info to be passed to an ObjectFile\n-     * when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final CompilationResult compilation;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            this.compilation = compilation;\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            HostedType declaringClass = method.getDeclaringClass();\n-            String name = declaringClass.getSourceFileName();\n-            if (name != null) {\n-                // the file name will not include any path\n-                // use the package to create a path prefix\n-                Package pkg = declaringClass.getJavaClass().getPackage();\n-                if (pkg != null) {\n-                    String prefix = pkg.getName();\n-                    prefix = prefix.replace('.', '/');\n-                    name = prefix + \"/\" + name;\n-                }\n-            } else {\n-                // build file name from the class name which includes the package\n-                name = className();\n-                // try to map inner classes back to their parent class's file\n-                int idx = name.indexOf('$');\n-                if (idx == 0) {\n-                    // name is $XXX so cannot associate with a file\n-                    return \"\";\n-                }\n-                if (idx > 0) {\n-                    // name is XXX$YYY so use outer class to derive file name\n-                    name = name.substring(0, idx);\n-                }\n-                name = name.replace('.', '/') + \".java\";\n-            }\n-            return name;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n-            if (fileName().length() == 0) {\n-                return () -> new Iterator<DebugLineInfo>() {\n-                    @Override\n-                    public boolean hasNext() {\n-                        return false;\n-                    }\n-\n-                    @Override\n-                    public DebugLineInfo next() {\n-                        return null;\n-                    }\n-                };\n-            }\n-            return () -> new Iterator<DebugLineInfo>() {\n-                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n-\n-                @Override\n-                public boolean hasNext() {\n-                    return sourceIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugLineInfo next() {\n-                    return new NativeImageDebugLineInfo(sourceIterator.next());\n-                }\n-            };\n-        }\n-\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface\n-     * that allows line number info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int bci = position.getBCI();\n-            this.bci = (bci >= 0 ? bci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            String name = className();\n-            int idx = name.indexOf('$');\n-            if (idx == 0) {\n-                // name is $XXX so cannot associate with a file\n-                return \"\";\n-            }\n-            if (idx > 0) {\n-                // name is XXX$YYY so use outer class to derive file name\n-                name = name.substring(0, idx);\n-            }\n-            return name.replace('.', '/') + \".java\";\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface\n-     * that allows stack frame size change info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372390309", "body": "In Java 11 the module base-name is also part of the full file path with the src.zip. e.g.\r\n`src.zip` contains `/java.base/java/util/Set.class`", "bodyText": "In Java 11 the module base-name is also part of the full file path with the src.zip. e.g.\nsrc.zip contains /java.base/java/util/Set.class", "bodyHTML": "<p dir=\"auto\">In Java 11 the module base-name is also part of the full file path with the src.zip. e.g.<br>\n<code>src.zip</code> contains <code>/java.base/java/util/Set.class</code></p>", "author": "olpaw", "createdAt": "2020-01-29T13:47:11Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2MTAwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378261008", "bodyText": "Well, I finally managed to rebuild using jdk11 (I had to nuke all the mxbuild dirs to get it to stop using cached jdk8 code) and found out some interesting things about pathe that probably need to be discussed and decided upon.\nI tweaked the path generation to add the result of ModuleSupport.getModuleName(javaClass) to the head of the path expression. So, for jdk11 runtime classes that will add e.g. \"java.base\" to the list of Path elements whereas for jdk8 runtime classes it will add nothing since  the module name is returned as \"\". This means that unzipped jdk sources are now being located correctly on both jdk8 and jdk11 assuming the root dir for the unzipped src.zip is added to the source path.\nI prefixed the module name to the file path for all classes that belong to a module on the assumption that this action would only apply for JDK runtime code. However, this assumption is not strictly correct as some Graal classes reside in JDK runtime modules.\nI noticed that, for example, class AllocationSnippets in package org/graalvm/compiler/replacements turns out to belong to module jdk.internal.vm.compiler. The source for this class actually sits in the Graal tree under root compiler/src/org.graalvm.compiler.replacements/src. Another example is class PrefetchAllocateNode which also belongs to module jdk.internal.vm.compiler. The source for this class also sits in the Graal tree under root compiler/src/org.graalvm.compiler.nodes/src.\nI also noticed that various of the Graal class sources are bundled into the src.zip for the jdk11 release I am using (labsjdk-ce-11.0.6+9-jvmci-20.0-b02-linux-amd64) and indeed are bundled into stock jdk11u releases. The source for PrefetchAllocateNode is present under root jdk.internal.vm.compiler/org.graalvm.compiler.nodes/src. However, the source for AllocationSnippets is not present. It looks as if these are present by because they are present in the OpenJDK repo (which may explain why AllocationSnippets.java is missing).\nSo, in order to find the correct versions of these sources from the Graal tree rather than from the OpenJDK src.zip it appears I will need to special case classes that are in certain well-known org.graal and com.oracle packages and not prefix the module to the file path for those cases. For example, the file path for PrefetchAllocateNode will need to be org/graalvm/compiler/nodes rather than jdk.internal.vm.compiler/org/graalvm/compiler/nodes.\nIn order to minimize the number of source roots needed to locate Graal sources it might also be helpful to insert the required overarching src root into the file path. For example, PrefetchAllocateNode might be better associated with file path org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/. That would  mean that only  compiler/src, substratevm/src etc would need to be supplied as source root dirs.\nThe difficutly with this is that it is not always clear what the oevrarching top level directory needs to be. For example, class CodeInfo.java sits under dir com.oracle.svm.core/src but resides in subdir com/oracle/svm/core/code because its is in a subpackage com.oracle.svm.core.code. Given any Graal class the overarching root dir always comprises some initial segment of the package name but it is not always clear which elements to include. This is slightly complicated by the need to recognize that classes in package com.oracle.svm.core.code map to root dir com.oracle.svm.core/src but that classes in package com.oracle.svm.core.graal map to root dir com.oracle.svm.core.graal/src\nI did actually implement a variant of the filepath computation some while back which used a hard-wired list of known root packages. I could easily do that again. However, the problem is keeping the list of source roots up to date with any changes. Do you have any other suggestions as to how to do this? Input from other Graal community devs woudl be very welcome.", "author": "adinn", "createdAt": "2020-02-12T13:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNTAxNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378315017", "bodyText": "This means that unzipped jdk sources are now being located correctly on both jdk8 and jdk11 assuming the root dir for the unzipped src.zip is added to the source path.\n\nUnzipping should happen transparently. Just use Zip File System Provider instead of requiring the user to unzip src.zip. See https://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html - For examples in our code base where we make use of Zip File System Provider see e.g. com.oracle.svm.driver.NativeImage#processClasspathNativeImageMetaInf(java.nio.file.Path, com.oracle.svm.driver.NativeImage.NativeImageMetaInfResourceProcessor)", "author": "olpaw", "createdAt": "2020-02-12T15:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyNTgyMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378325821", "bodyText": "Another example is class PrefetchAllocateNode which also belongs to module jdk.internal.vm.compiler. The source for this class also sits in the Graal tree under root compiler/src/org.graalvm.compiler.nodes/src.\n\nAs you noticed even vanilla JDK11 releases contain Graal. For debuginfo generation this version of Graal should be ignored (it exists so that vanilla JDK can provide Graal as tier-4 JIT compiler when using -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler). When we build native images we always use the version of Graal that is shipped as part of a GraalVM release. Thus any Graal related source files that exist in src.zip are irrelevant for us.", "author": "olpaw", "createdAt": "2020-02-12T15:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNDA5NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378334095", "bodyText": "However, the problem is keeping the list of source roots up to date with any changes.\n\nSure you could diff each file do decide if you need to update a preexisting target file but it is probably easier to simply copy over based on timestamps (if src or zip file that contains src is newer -> update)", "author": "olpaw", "createdAt": "2020-02-12T15:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM3MjY3Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378372673", "bodyText": "source roots needed to locate Graal sources\n\nA good heuristic for the roots is to inspect the jar files that are on the image classpath and check if you find a corresponding sibling file. E.g. for <graalvm>/lib/svm/builder/svm.jar you probe for <graalvm>/lib/svm/builder/svm.src.zip. If the classpath entry is a directory <dir> instead you probe for <dir>/src and <dir>/src_gen as roots. For each source file lookup you check against these roots for a match. (src.zip from jdk is a special case and should always be in the list of roots (obviously as last entry))", "author": "olpaw", "createdAt": "2020-02-12T16:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc3NDAzNg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378774036", "bodyText": "Unzipping should happen transparently. Just use Zip File System Provider instead of requiring the user to unzip src.zip. See https://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html - For examples in our code base where we make use of Zip File System Provider see e.g. com.oracle.svm.driver.NativeImage#processClasspathNativeImageMetaInf(java.nio.file.Path, com.oracle.svm.driver.NativeImage.NativeImageMetaInfResourceProcessor)\n\nI'm not clear what you are suggesting here. I understand how to use a zip file provider from Java. However, the problem I am looking at is how to allow gdb to locate a source file for a JDK class when it is running. gdb needs to be pointed at a root directory under which it can locate the sources. It is not going to unzip any files to do that.\nI believe the model you are proposing for resolving that requirement is that the native image generator should attempt to locate all the relevant JDK, Graal (and, perhaps, application) source files at image build time, bundling them into a jar/zip file provided as a secondary deliverable. If that jar/zip deliverable is correctly structured then it could be unzipped into a single root source directory from which all file paths and name nstalled into the debuginfo could be successfully resolved to the required source file at debug time. Is that a fair summary?\n\nA good heuristic for the roots is to inspect the jar files that are on the image classpath and check if you find a corresponding sibling file. E.g. for /lib/svm/builder/svm.jar you probe for /lib/svm/builder/svm.src.zip. If the classpath entry is a directory  instead you probe for /src and /src_gen as roots. For each source file lookup you check against these roots for a match. (src.zip from jdk is a special case and should always be in the list of roots (obviously as last entry))\n\nYes, I am sure I can implement a lookup model like that.\n\nAs you noticed even vanilla JDK11 releases contain Graal.  . . . Thus any Graal related source files that exist in src.zip are irrelevant for us.\n\nYes, I will ignore those files.", "author": "adinn", "createdAt": "2020-02-13T10:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc5NjA3NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378796074", "bodyText": "I'm not clear what you are suggesting here.\n\nI'm just saying the mechanism should be able to process zip-files, jar-files & directories alike as inputs (roots) and copy files referenced in debuginfo (--x-->) from those roots into one single output directory (preferably named sources) (the one that gdb will then use for file retrival):\n[... foo/prjx/src]\n[... foo/lib/gson.sources.jar]\n[...]                                           --x-->     [... foo/sources]\n[<graalvm>/lib/svm/builder/svm.src.zip]\n[<graalvm> ...]\n[<graalvm>/src.zip]\n\n(assuming an image gets built to ... foo (e.g. ... foo/myimage)\n\nbundling them into a jar/zip file\n\nJust building them into a sources sibling directory next to the image so that gdb can use it as is (also a directory is easier to keep up to date with changes from the roots side if you are rebuilding the image).", "author": "olpaw", "createdAt": "2020-02-13T11:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgwMTAwMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378801002", "bodyText": "Ok, that sounds fine. I'll work on adding that.", "author": "adinn", "createdAt": "2020-02-13T11:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyMDE4Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378820186", "bodyText": "n.b. I just updated the issue to record this conversation with a more precise 'spec'", "author": "adinn", "createdAt": "2020-02-13T12:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MzI5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383973296", "bodyText": "This has now been implemented -- see my other comment", "author": "adinn", "createdAt": "2020-02-25T16:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 562dd1c040e..5787b086d2a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -975,119 +977,74 @@ public abstract class NativeBootImage extends AbstractBootImage {\n     }\n \n     /**\n-     * implementation of the DebugInfoProvider API interface\n-     * that allows type, code and heap data info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n+     * implementation of the DebugInfoProvider API interface that allows type, code and heap data\n+     * info to be passed to an ObjectFile when generation of debug info is enabled.\n      */\n     private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n         private final NativeImageCodeCache codeCache;\n+        @SuppressWarnings(\"unused\")\n         private final NativeImageHeap heap;\n-        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n-        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n \n         NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n             super();\n             this.codeCache = codeCache;\n             this.heap = heap;\n-            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n-            this.heapIterator = heap.objects.entrySet().iterator();\n         }\n \n         @Override\n-        public DebugTypeInfoProvider typeInfoProvider() {\n-            return () -> new Iterator<DebugTypeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugTypeInfo next() {\n-                    return null;\n-                }\n-            };\n+        public Stream<DebugTypeInfo> typeInfoProvider() {\n+            return Stream.empty();\n         }\n \n         @Override\n-        public DebugCodeInfoProvider codeInfoProvider() {\n-            return () -> new Iterator<DebugCodeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return codeCacheIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugCodeInfo next() {\n-                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n-                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n-                }\n-            };\n+        public Stream<DebugCodeInfo> codeInfoProvider() {\n+            return codeCache.compilations.entrySet().stream().map(entry -> new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue()));\n         }\n \n         @Override\n-        public DebugDataInfoProvider dataInfoProvider() {\n-            return () -> new Iterator<DebugDataInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugDataInfo next() {\n-                    return null;\n-                }\n-            };\n+        public Stream<DebugDataInfo> dataInfoProvider() {\n+            return Stream.empty();\n         }\n     }\n \n     /**\n-     * implementation of the DebugCodeInfo API interface\n-     * that allows code info to be passed to an ObjectFile\n-     * when generation of debug info is enabled.\n+     * implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n      */\n     private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n         private final HostedMethod method;\n+        private final ResolvedJavaType javaType;\n         private final CompilationResult compilation;\n+        private Path fullFilePath;\n \n         NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n             this.method = method;\n+            HostedType declaringClass = method.getDeclaringClass();\n+            Class<?> clazz = declaringClass.getJavaClass();\n+            this.javaType = declaringClass.getWrapped();\n             this.compilation = compilation;\n+            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(javaType, clazz);\n         }\n \n         @Override\n         public String fileName() {\n-            HostedType declaringClass = method.getDeclaringClass();\n-            String name = declaringClass.getSourceFileName();\n-            if (name != null) {\n-                // the file name will not include any path\n-                // use the package to create a path prefix\n-                Package pkg = declaringClass.getJavaClass().getPackage();\n-                if (pkg != null) {\n-                    String prefix = pkg.getName();\n-                    prefix = prefix.replace('.', '/');\n-                    name = prefix + \"/\" + name;\n-                }\n-            } else {\n-                // build file name from the class name which includes the package\n-                name = className();\n-                // try to map inner classes back to their parent class's file\n-                int idx = name.indexOf('$');\n-                if (idx == 0) {\n-                    // name is $XXX so cannot associate with a file\n-                    return \"\";\n-                }\n-                if (idx > 0) {\n-                    // name is XXX$YYY so use outer class to derive file name\n-                    name = name.substring(0, idx);\n-                }\n-                name = name.replace('.', '/') + \".java\";\n+            if (fullFilePath != null) {\n+                return fullFilePath.getFileName().toString();\n             }\n-            return name;\n+            return null;\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            if (fullFilePath != null) {\n+                return fullFilePath.getParent();\n+            }\n+            return null;\n         }\n \n         @Override\n         public String className() {\n-            return method.format(\"%H\");\n+            return javaType.toClassName();\n         }\n \n         @Override\n", "next_change": {"commit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 5787b086d2a..f910ed54dee 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -975,255 +964,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface that allows type, code and heap data\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        @SuppressWarnings(\"unused\")\n-        private final NativeImageHeap heap;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-        }\n-\n-        @Override\n-        public Stream<DebugTypeInfo> typeInfoProvider() {\n-            return Stream.empty();\n-        }\n-\n-        @Override\n-        public Stream<DebugCodeInfo> codeInfoProvider() {\n-            return codeCache.compilations.entrySet().stream().map(entry -> new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue()));\n-        }\n-\n-        @Override\n-        public Stream<DebugDataInfo> dataInfoProvider() {\n-            return Stream.empty();\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            HostedType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = declaringClass.getJavaClass();\n-            this.javaType = declaringClass.getWrapped();\n-            this.compilation = compilation;\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(javaType, clazz);\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return javaType.toClassName();\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public Stream<DebugLineInfo> lineInfoProvider() {\n-            if (fileName().toString().length() == 0) {\n-                return Stream.empty();\n-            }\n-            return compilation.getSourceMappings().stream().map(sourceMapping -> new NativeImageDebugLineInfo(sourceMapping));\n-        }\n-\n-        @Override\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        @Override\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface that allows line number info to be passed\n-     * to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int posbci = position.getBCI();\n-            this.bci = (posbci >= 0 ? posbci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-            computeFullFilePath();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-\n-        private void computeFullFilePath() {\n-            ResolvedJavaType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = null;\n-            if (declaringClass instanceof OriginalClassProvider) {\n-                clazz = ((OriginalClassProvider) declaringClass).getJavaClass();\n-            }\n-            /*\n-             * HostedType and AnalysisType punt calls to getSourceFilename to the wrapped class so\n-             * for consistency we need to do the path lookup relative to the wrapped class\n-             */\n-            if (declaringClass instanceof HostedType) {\n-                declaringClass = ((HostedType) declaringClass).getWrapped();\n-            }\n-            if (declaringClass instanceof AnalysisType) {\n-                declaringClass = ((AnalysisType) declaringClass).getWrapped();\n-            }\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(declaringClass, clazz);\n-        }\n-\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface that allows stack frame size change\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex f910ed54dee..30b121818e6 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -964,4 +971,299 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return lo;\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return hi;\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(bci);\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugFrameSizeChange API interface\n+     * that allows stack frame size change info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n+        private int offset;\n+        private Type type;\n+\n+        NativeImageDebugFrameSizeChange(int offset, Type type) {\n+            this.offset = offset;\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public int getOffset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public Type getType() {\n+            return type;\n+        }\n+    }\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 30b121818e6..50078e9ea84 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -971,299 +963,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface\n-     * that allows type, code and heap data info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        private final NativeImageHeap heap;\n-        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n-        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n-            this.heapIterator = heap.objects.entrySet().iterator();\n-        }\n-\n-        @Override\n-        public DebugTypeInfoProvider typeInfoProvider() {\n-            return () -> new Iterator<DebugTypeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugTypeInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugCodeInfoProvider codeInfoProvider() {\n-            return () -> new Iterator<DebugCodeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return codeCacheIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugCodeInfo next() {\n-                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n-                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugDataInfoProvider dataInfoProvider() {\n-            return () -> new Iterator<DebugDataInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugDataInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface\n-     * that allows code info to be passed to an ObjectFile\n-     * when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final CompilationResult compilation;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            this.compilation = compilation;\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            HostedType declaringClass = method.getDeclaringClass();\n-            String name = declaringClass.getSourceFileName();\n-            if (name != null) {\n-                // the file name will not include any path\n-                // use the package to create a path prefix\n-                Package pkg = declaringClass.getJavaClass().getPackage();\n-                if (pkg != null) {\n-                    String prefix = pkg.getName();\n-                    prefix = prefix.replace('.', '/');\n-                    name = prefix + \"/\" + name;\n-                }\n-            } else {\n-                // build file name from the class name which includes the package\n-                name = className();\n-                // try to map inner classes back to their parent class's file\n-                int idx = name.indexOf('$');\n-                if (idx == 0) {\n-                    // name is $XXX so cannot associate with a file\n-                    return \"\";\n-                }\n-                if (idx > 0) {\n-                    // name is XXX$YYY so use outer class to derive file name\n-                    name = name.substring(0, idx);\n-                }\n-                name = name.replace('.', '/') + \".java\";\n-            }\n-            return name;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n-            if (fileName().length() == 0) {\n-                return () -> new Iterator<DebugLineInfo>() {\n-                    @Override\n-                    public boolean hasNext() {\n-                        return false;\n-                    }\n-\n-                    @Override\n-                    public DebugLineInfo next() {\n-                        return null;\n-                    }\n-                };\n-            }\n-            return () -> new Iterator<DebugLineInfo>() {\n-                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n-\n-                @Override\n-                public boolean hasNext() {\n-                    return sourceIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugLineInfo next() {\n-                    return new NativeImageDebugLineInfo(sourceIterator.next());\n-                }\n-            };\n-        }\n-\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface\n-     * that allows line number info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int bci = position.getBCI();\n-            this.bci = (bci >= 0 ? bci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            String name = className();\n-            int idx = name.indexOf('$');\n-            if (idx == 0) {\n-                // name is $XXX so cannot associate with a file\n-                return \"\";\n-            }\n-            if (idx > 0) {\n-                // name is XXX$YYY so use outer class to derive file name\n-                name = name.substring(0, idx);\n-            }\n-            return name.replace('.', '/') + \".java\";\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface\n-     * that allows stack frame size change info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372406708", "body": "Sometimes the source file isn't actually a `.java` file.  Is there any way to get access to the source name that was specified in the original `.class` file?  Or is this code only used when there is no debug info available?", "bodyText": "Sometimes the source file isn't actually a .java file.  Is there any way to get access to the source name that was specified in the original .class file?  Or is this code only used when there is no debug info available?", "bodyHTML": "<p dir=\"auto\">Sometimes the source file isn't actually a <code>.java</code> file.  Is there any way to get access to the source name that was specified in the original <code>.class</code> file?  Or is this code only used when there is no debug info available?</p>", "author": "dmlloyd", "createdAt": "2020-01-29T14:17:29Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3OTc3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375879777", "bodyText": "That's what is going on here. The call to declaringClass.getSourceFileName() actually reads the value from the class file -- well, strictly it finds the underlying Java class and reads the name out of the constant poll associated with the corresponding JVM InstanceKlass. So the code that constructs a name with extension java is just a fallback for when the bytecode contains no such entry.", "author": "adinn", "createdAt": "2020-02-06T14:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxOTEyMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375919123", "bodyText": "Ah, understood.  Thanks!", "author": "dmlloyd", "createdAt": "2020-02-06T15:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NDMwNA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383974304", "bodyText": "This has been reworked but the new code is still using the classfile info where it exists and defaulting to append .java to the class name (or its initial segment up to $) otherwise.", "author": "adinn", "createdAt": "2020-02-25T16:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 562dd1c040e..5787b086d2a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -1180,38 +1117,40 @@ public abstract class NativeBootImage extends AbstractBootImage {\n     }\n \n     /**\n-     * implementation of the DebugLineInfo API interface\n-     * that allows line number info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+     * implementation of the DebugLineInfo API interface that allows line number info to be passed\n+     * to an ObjectFile when generation of debug info is enabled.\n      */\n     private class NativeImageDebugLineInfo implements DebugLineInfo {\n         private final int bci;\n         private final ResolvedJavaMethod method;\n         private final int lo;\n         private final int hi;\n+        private Path fullFilePath;\n \n         NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n             NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int bci = position.getBCI();\n-            this.bci = (bci >= 0 ? bci : 0);\n+            int posbci = position.getBCI();\n+            this.bci = (posbci >= 0 ? posbci : 0);\n             this.method = position.getMethod();\n             this.lo = sourceMapping.getStartOffset();\n             this.hi = sourceMapping.getEndOffset();\n+            computeFullFilePath();\n         }\n \n         @Override\n         public String fileName() {\n-            String name = className();\n-            int idx = name.indexOf('$');\n-            if (idx == 0) {\n-                // name is $XXX so cannot associate with a file\n-                return \"\";\n+            if (fullFilePath != null) {\n+                return fullFilePath.getFileName().toString();\n             }\n-            if (idx > 0) {\n-                // name is XXX$YYY so use outer class to derive file name\n-                name = name.substring(0, idx);\n+            return null;\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            if (fullFilePath != null) {\n+                return fullFilePath.getParent();\n             }\n-            return name.replace('.', '/') + \".java\";\n+            return null;\n         }\n \n         @Override\n", "next_change": {"commit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 5787b086d2a..f910ed54dee 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -975,255 +964,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface that allows type, code and heap data\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        @SuppressWarnings(\"unused\")\n-        private final NativeImageHeap heap;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-        }\n-\n-        @Override\n-        public Stream<DebugTypeInfo> typeInfoProvider() {\n-            return Stream.empty();\n-        }\n-\n-        @Override\n-        public Stream<DebugCodeInfo> codeInfoProvider() {\n-            return codeCache.compilations.entrySet().stream().map(entry -> new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue()));\n-        }\n-\n-        @Override\n-        public Stream<DebugDataInfo> dataInfoProvider() {\n-            return Stream.empty();\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            HostedType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = declaringClass.getJavaClass();\n-            this.javaType = declaringClass.getWrapped();\n-            this.compilation = compilation;\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(javaType, clazz);\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return javaType.toClassName();\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public Stream<DebugLineInfo> lineInfoProvider() {\n-            if (fileName().toString().length() == 0) {\n-                return Stream.empty();\n-            }\n-            return compilation.getSourceMappings().stream().map(sourceMapping -> new NativeImageDebugLineInfo(sourceMapping));\n-        }\n-\n-        @Override\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        @Override\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface that allows line number info to be passed\n-     * to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int posbci = position.getBCI();\n-            this.bci = (posbci >= 0 ? posbci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-            computeFullFilePath();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-\n-        private void computeFullFilePath() {\n-            ResolvedJavaType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = null;\n-            if (declaringClass instanceof OriginalClassProvider) {\n-                clazz = ((OriginalClassProvider) declaringClass).getJavaClass();\n-            }\n-            /*\n-             * HostedType and AnalysisType punt calls to getSourceFilename to the wrapped class so\n-             * for consistency we need to do the path lookup relative to the wrapped class\n-             */\n-            if (declaringClass instanceof HostedType) {\n-                declaringClass = ((HostedType) declaringClass).getWrapped();\n-            }\n-            if (declaringClass instanceof AnalysisType) {\n-                declaringClass = ((AnalysisType) declaringClass).getWrapped();\n-            }\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(declaringClass, clazz);\n-        }\n-\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface that allows stack frame size change\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex f910ed54dee..30b121818e6 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -964,4 +971,299 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return lo;\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return hi;\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(bci);\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugFrameSizeChange API interface\n+     * that allows stack frame size change info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n+        private int offset;\n+        private Type type;\n+\n+        NativeImageDebugFrameSizeChange(int offset, Type type) {\n+            this.offset = offset;\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public int getOffset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public Type getType() {\n+            return type;\n+        }\n+    }\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 30b121818e6..50078e9ea84 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -971,299 +963,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface\n-     * that allows type, code and heap data info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        private final NativeImageHeap heap;\n-        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n-        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n-            this.heapIterator = heap.objects.entrySet().iterator();\n-        }\n-\n-        @Override\n-        public DebugTypeInfoProvider typeInfoProvider() {\n-            return () -> new Iterator<DebugTypeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugTypeInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugCodeInfoProvider codeInfoProvider() {\n-            return () -> new Iterator<DebugCodeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return codeCacheIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugCodeInfo next() {\n-                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n-                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugDataInfoProvider dataInfoProvider() {\n-            return () -> new Iterator<DebugDataInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugDataInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface\n-     * that allows code info to be passed to an ObjectFile\n-     * when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final CompilationResult compilation;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            this.compilation = compilation;\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            HostedType declaringClass = method.getDeclaringClass();\n-            String name = declaringClass.getSourceFileName();\n-            if (name != null) {\n-                // the file name will not include any path\n-                // use the package to create a path prefix\n-                Package pkg = declaringClass.getJavaClass().getPackage();\n-                if (pkg != null) {\n-                    String prefix = pkg.getName();\n-                    prefix = prefix.replace('.', '/');\n-                    name = prefix + \"/\" + name;\n-                }\n-            } else {\n-                // build file name from the class name which includes the package\n-                name = className();\n-                // try to map inner classes back to their parent class's file\n-                int idx = name.indexOf('$');\n-                if (idx == 0) {\n-                    // name is $XXX so cannot associate with a file\n-                    return \"\";\n-                }\n-                if (idx > 0) {\n-                    // name is XXX$YYY so use outer class to derive file name\n-                    name = name.substring(0, idx);\n-                }\n-                name = name.replace('.', '/') + \".java\";\n-            }\n-            return name;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n-            if (fileName().length() == 0) {\n-                return () -> new Iterator<DebugLineInfo>() {\n-                    @Override\n-                    public boolean hasNext() {\n-                        return false;\n-                    }\n-\n-                    @Override\n-                    public DebugLineInfo next() {\n-                        return null;\n-                    }\n-                };\n-            }\n-            return () -> new Iterator<DebugLineInfo>() {\n-                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n-\n-                @Override\n-                public boolean hasNext() {\n-                    return sourceIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugLineInfo next() {\n-                    return new NativeImageDebugLineInfo(sourceIterator.next());\n-                }\n-            };\n-        }\n-\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface\n-     * that allows line number info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int bci = position.getBCI();\n-            this.bci = (bci >= 0 ? bci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            String name = className();\n-            int idx = name.indexOf('$');\n-            if (idx == 0) {\n-                // name is $XXX so cannot associate with a file\n-                return \"\";\n-            }\n-            if (idx > 0) {\n-                // name is XXX$YYY so use outer class to derive file name\n-                name = name.substring(0, idx);\n-            }\n-            return name.replace('.', '/') + \".java\";\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface\n-     * that allows stack frame size change info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372429201", "body": "How about something more modern than `Iterable`. E.g. like:\r\n```\r\n@Override\r\npublic Stream<DebugCodeInfo> codeInfoProvider() {\r\n    return compilations.entrySet().stream().map(NativeImageDebugCodeInfo::new);\r\n}\r\n```", "bodyText": "How about something more modern than Iterable. E.g. like:\n@Override\npublic Stream<DebugCodeInfo> codeInfoProvider() {\n    return compilations.entrySet().stream().map(NativeImageDebugCodeInfo::new);\n}", "bodyHTML": "<p dir=\"auto\">How about something more modern than <code>Iterable</code>. E.g. like:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"@Override\npublic Stream&lt;DebugCodeInfo&gt; codeInfoProvider() {\n    return compilations.entrySet().stream().map(NativeImageDebugCodeInfo::new);\n}\"><pre><code>@Override\npublic Stream&lt;DebugCodeInfo&gt; codeInfoProvider() {\n    return compilations.entrySet().stream().map(NativeImageDebugCodeInfo::new);\n}\n</code></pre></div>", "author": "olpaw", "createdAt": "2020-01-29T14:54:03Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjAzMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376332030", "bodyText": "Yes, that would be neater.", "author": "adinn", "createdAt": "2020-02-07T10:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MTc0Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383971742", "bodyText": "@olpaw I just pushed another fix where I modified the DebugInfo interfaces to use Stream and tweaked the producers and consumers accordingly.", "author": "adinn", "createdAt": "2020-02-25T15:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 562dd1c040e..5787b086d2a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -975,119 +977,74 @@ public abstract class NativeBootImage extends AbstractBootImage {\n     }\n \n     /**\n-     * implementation of the DebugInfoProvider API interface\n-     * that allows type, code and heap data info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n+     * implementation of the DebugInfoProvider API interface that allows type, code and heap data\n+     * info to be passed to an ObjectFile when generation of debug info is enabled.\n      */\n     private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n         private final NativeImageCodeCache codeCache;\n+        @SuppressWarnings(\"unused\")\n         private final NativeImageHeap heap;\n-        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n-        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n \n         NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n             super();\n             this.codeCache = codeCache;\n             this.heap = heap;\n-            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n-            this.heapIterator = heap.objects.entrySet().iterator();\n         }\n \n         @Override\n-        public DebugTypeInfoProvider typeInfoProvider() {\n-            return () -> new Iterator<DebugTypeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugTypeInfo next() {\n-                    return null;\n-                }\n-            };\n+        public Stream<DebugTypeInfo> typeInfoProvider() {\n+            return Stream.empty();\n         }\n \n         @Override\n-        public DebugCodeInfoProvider codeInfoProvider() {\n-            return () -> new Iterator<DebugCodeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return codeCacheIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugCodeInfo next() {\n-                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n-                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n-                }\n-            };\n+        public Stream<DebugCodeInfo> codeInfoProvider() {\n+            return codeCache.compilations.entrySet().stream().map(entry -> new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue()));\n         }\n \n         @Override\n-        public DebugDataInfoProvider dataInfoProvider() {\n-            return () -> new Iterator<DebugDataInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugDataInfo next() {\n-                    return null;\n-                }\n-            };\n+        public Stream<DebugDataInfo> dataInfoProvider() {\n+            return Stream.empty();\n         }\n     }\n \n     /**\n-     * implementation of the DebugCodeInfo API interface\n-     * that allows code info to be passed to an ObjectFile\n-     * when generation of debug info is enabled.\n+     * implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n      */\n     private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n         private final HostedMethod method;\n+        private final ResolvedJavaType javaType;\n         private final CompilationResult compilation;\n+        private Path fullFilePath;\n \n         NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n             this.method = method;\n+            HostedType declaringClass = method.getDeclaringClass();\n+            Class<?> clazz = declaringClass.getJavaClass();\n+            this.javaType = declaringClass.getWrapped();\n             this.compilation = compilation;\n+            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(javaType, clazz);\n         }\n \n         @Override\n         public String fileName() {\n-            HostedType declaringClass = method.getDeclaringClass();\n-            String name = declaringClass.getSourceFileName();\n-            if (name != null) {\n-                // the file name will not include any path\n-                // use the package to create a path prefix\n-                Package pkg = declaringClass.getJavaClass().getPackage();\n-                if (pkg != null) {\n-                    String prefix = pkg.getName();\n-                    prefix = prefix.replace('.', '/');\n-                    name = prefix + \"/\" + name;\n-                }\n-            } else {\n-                // build file name from the class name which includes the package\n-                name = className();\n-                // try to map inner classes back to their parent class's file\n-                int idx = name.indexOf('$');\n-                if (idx == 0) {\n-                    // name is $XXX so cannot associate with a file\n-                    return \"\";\n-                }\n-                if (idx > 0) {\n-                    // name is XXX$YYY so use outer class to derive file name\n-                    name = name.substring(0, idx);\n-                }\n-                name = name.replace('.', '/') + \".java\";\n+            if (fullFilePath != null) {\n+                return fullFilePath.getFileName().toString();\n             }\n-            return name;\n+            return null;\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            if (fullFilePath != null) {\n+                return fullFilePath.getParent();\n+            }\n+            return null;\n         }\n \n         @Override\n         public String className() {\n-            return method.format(\"%H\");\n+            return javaType.toClassName();\n         }\n \n         @Override\n", "next_change": {"commit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 5787b086d2a..f910ed54dee 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -975,255 +964,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface that allows type, code and heap data\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        @SuppressWarnings(\"unused\")\n-        private final NativeImageHeap heap;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-        }\n-\n-        @Override\n-        public Stream<DebugTypeInfo> typeInfoProvider() {\n-            return Stream.empty();\n-        }\n-\n-        @Override\n-        public Stream<DebugCodeInfo> codeInfoProvider() {\n-            return codeCache.compilations.entrySet().stream().map(entry -> new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue()));\n-        }\n-\n-        @Override\n-        public Stream<DebugDataInfo> dataInfoProvider() {\n-            return Stream.empty();\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            HostedType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = declaringClass.getJavaClass();\n-            this.javaType = declaringClass.getWrapped();\n-            this.compilation = compilation;\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(javaType, clazz);\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return javaType.toClassName();\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public Stream<DebugLineInfo> lineInfoProvider() {\n-            if (fileName().toString().length() == 0) {\n-                return Stream.empty();\n-            }\n-            return compilation.getSourceMappings().stream().map(sourceMapping -> new NativeImageDebugLineInfo(sourceMapping));\n-        }\n-\n-        @Override\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        @Override\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface that allows line number info to be passed\n-     * to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-        private Path fullFilePath;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int posbci = position.getBCI();\n-            this.bci = (posbci >= 0 ? posbci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-            computeFullFilePath();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getFileName().toString();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Path filePath() {\n-            if (fullFilePath != null) {\n-                return fullFilePath.getParent();\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-\n-        private void computeFullFilePath() {\n-            ResolvedJavaType declaringClass = method.getDeclaringClass();\n-            Class<?> clazz = null;\n-            if (declaringClass instanceof OriginalClassProvider) {\n-                clazz = ((OriginalClassProvider) declaringClass).getJavaClass();\n-            }\n-            /*\n-             * HostedType and AnalysisType punt calls to getSourceFilename to the wrapped class so\n-             * for consistency we need to do the path lookup relative to the wrapped class\n-             */\n-            if (declaringClass instanceof HostedType) {\n-                declaringClass = ((HostedType) declaringClass).getWrapped();\n-            }\n-            if (declaringClass instanceof AnalysisType) {\n-                declaringClass = ((AnalysisType) declaringClass).getWrapped();\n-            }\n-            fullFilePath = ImageSingletons.lookup(SourceManager.class).findAndCacheSource(declaringClass, clazz);\n-        }\n-\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface that allows stack frame size change\n-     * info to be passed to an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex f910ed54dee..30b121818e6 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -964,4 +971,299 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return lo;\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return hi;\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(bci);\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugFrameSizeChange API interface\n+     * that allows stack frame size change info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n+        private int offset;\n+        private Type type;\n+\n+        NativeImageDebugFrameSizeChange(int offset, Type type) {\n+            this.offset = offset;\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public int getOffset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public Type getType() {\n+            return type;\n+        }\n+    }\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\nindex 30b121818e6..50078e9ea84 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java\n", "chunk": "@@ -971,299 +963,4 @@ public abstract class NativeBootImage extends AbstractBootImage {\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n-\n-    /**\n-     * implementation of the DebugInfoProvider API interface\n-     * that allows type, code and heap data info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n-        private final NativeImageCodeCache codeCache;\n-        private final NativeImageHeap heap;\n-        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n-        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n-\n-        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n-            super();\n-            this.codeCache = codeCache;\n-            this.heap = heap;\n-            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n-            this.heapIterator = heap.objects.entrySet().iterator();\n-        }\n-\n-        @Override\n-        public DebugTypeInfoProvider typeInfoProvider() {\n-            return () -> new Iterator<DebugTypeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugTypeInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugCodeInfoProvider codeInfoProvider() {\n-            return () -> new Iterator<DebugCodeInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return codeCacheIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugCodeInfo next() {\n-                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n-                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public DebugDataInfoProvider dataInfoProvider() {\n-            return () -> new Iterator<DebugDataInfo>() {\n-                @Override\n-                public boolean hasNext() {\n-                    return false;\n-                }\n-\n-                @Override\n-                public DebugDataInfo next() {\n-                    return null;\n-                }\n-            };\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugCodeInfo API interface\n-     * that allows code info to be passed to an ObjectFile\n-     * when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final CompilationResult compilation;\n-\n-        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n-            this.method = method;\n-            this.compilation = compilation;\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            HostedType declaringClass = method.getDeclaringClass();\n-            String name = declaringClass.getSourceFileName();\n-            if (name != null) {\n-                // the file name will not include any path\n-                // use the package to create a path prefix\n-                Package pkg = declaringClass.getJavaClass().getPackage();\n-                if (pkg != null) {\n-                    String prefix = pkg.getName();\n-                    prefix = prefix.replace('.', '/');\n-                    name = prefix + \"/\" + name;\n-                }\n-            } else {\n-                // build file name from the class name which includes the package\n-                name = className();\n-                // try to map inner classes back to their parent class's file\n-                int idx = name.indexOf('$');\n-                if (idx == 0) {\n-                    // name is $XXX so cannot associate with a file\n-                    return \"\";\n-                }\n-                if (idx > 0) {\n-                    // name is XXX$YYY so use outer class to derive file name\n-                    name = name.substring(0, idx);\n-                }\n-                name = name.replace('.', '/') + \".java\";\n-            }\n-            return name;\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public String paramNames() {\n-            return method.format(\"%P\");\n-        }\n-\n-        @Override\n-        public String returnTypeName() {\n-            return method.format(\"%R\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return method.getCodeAddressOffset();\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(0);\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n-            if (fileName().length() == 0) {\n-                return () -> new Iterator<DebugLineInfo>() {\n-                    @Override\n-                    public boolean hasNext() {\n-                        return false;\n-                    }\n-\n-                    @Override\n-                    public DebugLineInfo next() {\n-                        return null;\n-                    }\n-                };\n-            }\n-            return () -> new Iterator<DebugLineInfo>() {\n-                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n-\n-                @Override\n-                public boolean hasNext() {\n-                    return sourceIterator.hasNext();\n-                }\n-\n-                @Override\n-                public DebugLineInfo next() {\n-                    return new NativeImageDebugLineInfo(sourceIterator.next());\n-                }\n-            };\n-        }\n-\n-        public int getFrameSize() {\n-            return compilation.getTotalFrameSize();\n-        }\n-\n-        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n-            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n-            for (Mark mark : compilation.getMarks()) {\n-                // we only need to observe stack increment or decrement points\n-                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n-                    // can ignore these\n-                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n-                    // can ignore these\n-                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n-                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n-                    frameSizeChanges.add(sizeChange);\n-                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n-                }\n-            }\n-            return frameSizeChanges;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugLineInfo API interface\n-     * that allows line number info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugLineInfo implements DebugLineInfo {\n-        private final int bci;\n-        private final ResolvedJavaMethod method;\n-        private final int lo;\n-        private final int hi;\n-\n-        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n-            NodeSourcePosition position = sourceMapping.getSourcePosition();\n-            int bci = position.getBCI();\n-            this.bci = (bci >= 0 ? bci : 0);\n-            this.method = position.getMethod();\n-            this.lo = sourceMapping.getStartOffset();\n-            this.hi = sourceMapping.getEndOffset();\n-        }\n-\n-        @Override\n-        public String fileName() {\n-            String name = className();\n-            int idx = name.indexOf('$');\n-            if (idx == 0) {\n-                // name is $XXX so cannot associate with a file\n-                return \"\";\n-            }\n-            if (idx > 0) {\n-                // name is XXX$YYY so use outer class to derive file name\n-                name = name.substring(0, idx);\n-            }\n-            return name.replace('.', '/') + \".java\";\n-        }\n-\n-        @Override\n-        public String className() {\n-            return method.format(\"%H\");\n-        }\n-\n-        @Override\n-        public String methodName() {\n-            return method.format(\"%n\");\n-        }\n-\n-        @Override\n-        public int addressLo() {\n-            return lo;\n-        }\n-\n-        @Override\n-        public int addressHi() {\n-            return hi;\n-        }\n-\n-        @Override\n-        public int line() {\n-            LineNumberTable lineNumberTable = method.getLineNumberTable();\n-            if (lineNumberTable != null) {\n-                return lineNumberTable.getLineNumber(bci);\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * implementation of the DebugFrameSizeChange API interface\n-     * that allows stack frame size change info to be passed to\n-     * an ObjectFile when generation of debug info is enabled.\n-     */\n-    private class NativeImageDebugFrameSizeChange implements DebugFrameSizeChange {\n-        private int offset;\n-        private Type type;\n-\n-        NativeImageDebugFrameSizeChange(int offset, Type type) {\n-            this.offset = offset;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public int getOffset() {\n-            return offset;\n-        }\n-\n-        @Override\n-        public Type getType() {\n-            return type;\n-        }\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372432668", "body": "Does DWARF have a fixed endianness, or should it be using the ELFDATA value to determine this?", "bodyText": "Does DWARF have a fixed endianness, or should it be using the ELFDATA value to determine this?", "bodyHTML": "<p dir=\"auto\">Does DWARF have a fixed endianness, or should it be using the ELFDATA value to determine this?</p>", "author": "dmlloyd", "createdAt": "2020-01-29T14:59:28Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNzc1NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375917754", "bodyText": "Hmm, the DWARF standard didn't really make that clear but I talked to one of our debug experts (Mark Wielaard) and he confirmed that most numeric values need to follow target arch endianness. The special cases are ULEB and SLEB encoded numerics. So, I will update the code accordingly.", "author": "adinn", "createdAt": "2020-02-06T15:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5NTI3NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376995274", "bodyText": "I have pushed a fix that addresses the byte order issue.", "author": "adinn", "createdAt": "2020-02-10T11:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 286871c7227..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -406,1939 +440,37 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n-        // the primary range should already have been seen\n-        // and associated with a primary class entry\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n+        /*\n+         * the primary range should already have been seen and associated with a primary class entry\n+         */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    private DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            // no path/package means use dir entry 0\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n \n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n \n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n \n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nnew file mode 100644\nindex 00000000000..474e74d2073\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -0,0 +1,2336 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // these can be used to ensure that all debug records are generated in increasing address order\n+    //\n+    // An alternative traversal option is\n+    //\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // A third option appears to be to traverse via files, then top level class within file etc.\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+                pos = putInt(length, buffer, pos);\n+                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n+                pos = putInt(cuIndex, buffer, pos);\n+                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n+                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n+                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n+                    pos = putByte((byte) 0, buffer, pos);\n+                }\n+                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n+                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n+                    Range primary = classPrimaryEntry.getPrimary();\n+                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n+                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n+                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n+                }\n+                pos = putLong(0, buffer, pos);\n+                pos = putLong(0, buffer, pos);\n+            }\n+\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        // .debug_aranges section content depends on .debug_info section content and offset\n+        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_line section.\n+     */\n+    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * line header section always contains fixed number of bytes.\n+         */\n+        private static final int DW_LN_HEADER_SIZE = 27;\n+        /**\n+         * current generator follows C++ with line base -5.\n+         */\n+        private static final int DW_LN_LINE_BASE = -5;\n+        /**\n+         * current generator follows C++ with line range 14\n+         * giving full range -5 to 8.\n+         */\n+        private static final int DW_LN_LINE_RANGE = 14;\n+        /**\n+         *  current generator uses opcode base of 13\n+         *  which must equal DW_LNS_define_file + 1.\n+         */\n+        private static final int DW_LN_OPCODE_BASE = 13;\n+\n+        /*\n+         * standard opcodes defined by Dwarf 2\n+         */\n+        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n+                                                               // invalid opcode\n+        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n+                                                               // extended opcodes\n+        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n+                                                               // 0 args\n+        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n+        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n+        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n+        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n+        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n+        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n+        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n+                                                               // 255 0 args\n+        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n+\n+        /*\n+         * extended opcodes defined by Dwarf 2\n+         */\n+        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n+        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n+        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n+        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n+\n+        DwarfLineSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_LINE_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need to create a header, dir table, file table and line\n+            // number table encoding for each CU\n+\n+            // write entries for each file listed in the primary list\n+            int pos = 0;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                classEntry.setLineIndex(startPos);\n+                int headerSize = headerSize();\n+                int dirTableSize = computeDirTableSize(classEntry);\n+                int fileTableSize = computeFileTableSize(classEntry);\n+                int prologueSize = headerSize + dirTableSize + fileTableSize;\n+                classEntry.setLinePrologueSize(prologueSize);\n+                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n+                int totalSize = prologueSize + lineNumberTableSize;\n+                classEntry.setTotalSize(totalSize);\n+                pos += totalSize;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        public int headerSize() {\n+            // header size is standard 31 bytes\n+            // uint32 total_length\n+            // uint16 version\n+            // uint32 prologue_length\n+            // uint8 min_insn_length\n+            // uint8 default_is_stmt\n+            // int8 line_base\n+            // uint8 line_range\n+            // uint8 opcode_base\n+            // uint8 li_opcode_base\n+            // uint8[opcode_base-1] standard_opcode_lengths\n+\n+            return DW_LN_HEADER_SIZE;\n+        }\n+\n+        public int computeDirTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int dirSize = 0;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                dirSize += dir.getPath().length() + 1;\n+            }\n+            // allow for separator nul\n+            dirSize++;\n+            return dirSize;\n+        }\n+\n+        public int computeFileTableSize(ClassEntry classEntry) {\n+            // table contains a sequence of 'nul'-terminated\n+            // dir name bytes followed by an extra 'nul'\n+            // and then a sequence of 'nul'-terminated\n+            // file name bytes followed by an extra 'nul'\n+\n+            // for now we assume dir and file names are ASCII\n+            // byte strings\n+            int fileSize = 0;\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we want the file base name excluding path\n+                String baseName = localEntry.getBaseName();\n+                int length = baseName.length();\n+                fileSize += length + 1;\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int idx = classEntry.localDirsIdx(dirEntry);\n+                fileSize += putULEB(idx, scratch, 0);\n+                // the two zero timestamps require 1 byte each\n+                fileSize += 2;\n+            }\n+            // allow for terminator nul\n+            fileSize++;\n+            return fileSize;\n+        }\n+\n+        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n+            // sigh -- we have to do this by generating the\n+            // content even though we cannot write it into a byte[]\n+            return writeLineNumberTable(classEntry, null, 0);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+\n+            int pos = 0;\n+            checkDebug(pos);\n+            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int startPos = pos;\n+                assert classEntry.getLineIndex() == startPos;\n+                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n+                pos = writeHeader(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n+                int dirTablePos = pos;\n+                pos = writeDirTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n+                int fileTablePos = pos;\n+                pos = writeFileTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n+                int lineNumberTablePos = pos;\n+                pos = writeLineNumberTable(classEntry, buffer, pos);\n+                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n+                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n+            }\n+            assert pos == buffer.length;\n+        }\n+\n+        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // 4 ubyte length field\n+            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n+            // 2 ubyte version is always 2\n+            pos = putShort(DW_VERSION_2, buffer, pos);\n+            // 4 ubyte prologue length includes rest of header and\n+            // dir + file table section\n+            int prologueSize = classEntry.getLinePrologueSize() - 6;\n+            pos = putInt(prologueSize, buffer, pos);\n+            // 1 ubyte min instruction length is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte default is_stmt is always 1\n+            pos = putByte((byte) 1, buffer, pos);\n+            // 1 byte line base is always -5\n+            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n+            // 1 ubyte line range is always 14 giving range -5 to 8\n+            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n+            // 1 ubyte opcode base is always 13\n+            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n+            // specify opcode arg sizes for the standard opcodes\n+            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n+            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n+            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n+            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n+            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n+            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n+            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n+            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n+            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n+            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n+            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n+            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n+            return pos;\n+        }\n+\n+        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n+            // write out the list of dirs referenced form this file entry\n+            int dirIdx = 1;\n+            for (DirEntry dir : classEntry.getLocalDirs()) {\n+                // write nul terminated string text.\n+                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n+                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n+                dirIdx++;\n+            }\n+            // separate dirs from files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n+            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n+                // we need the file name minus path, the associated dir index, and 0 for time stamps\n+                String baseName = localEntry.getBaseName();\n+                DirEntry dirEntry = localEntry.dirEntry;\n+                int dirIdx = classEntry.localDirsIdx(dirEntry);\n+                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n+                pos = putAsciiStringBytes(baseName, buffer, pos);\n+                pos = putULEB(dirIdx, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                pos = putULEB(0, buffer, pos);\n+                fileIdx++;\n+            }\n+            // terminate files with a nul\n+            pos = putByte((byte) 0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int debugLine = 1;\n+        public int debugCopyCount = 0;\n+\n+        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            // the primary file entry should always be first in the local files list\n+            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n+            String primaryClassName = classEntry.getClassName();\n+            String primaryFileName = classEntry.getFileName();\n+            String file = primaryFileName;\n+            int fileIdx = 1;\n+            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n+            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n+            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                Range primaryRange = primaryEntry.getPrimary();\n+                assert primaryRange.getFileName().equals(primaryFileName);\n+                // each primary represents a method i.e. a contiguous\n+                // sequence of subranges. we assume the default state\n+                // at the start of each sequence because we always post an\n+                // end_sequence when we finish all the subranges in the method\n+                long line = primaryRange.getLine();\n+                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n+                    line = primaryEntry.getSubranges().get(0).getLine();\n+                }\n+                if (line < 0) {\n+                    line = 0;\n+                }\n+                long address = primaryRange.getLo();\n+\n+                // set state for primary\n+                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n+                                primaryRange.getLine());\n+\n+                // initialize and write a row for the start of the primary method\n+                pos = putSetFile(file, fileIdx, buffer, pos);\n+                pos = putSetBasicBlock(buffer, pos);\n+                // address is currently 0\n+                pos = putSetAddress(address, buffer, pos);\n+                // state machine value of line is currently 1\n+                // increment to desired line\n+                if (line != 1) {\n+                    pos = putAdvanceLine(line - 1, buffer, pos);\n+                }\n+                pos = putCopy(buffer, pos);\n+\n+                // now write a row for each subrange lo and hi\n+                for (Range subrange : primaryEntry.getSubranges()) {\n+                    assert subrange.getLo() >= primaryRange.getLo();\n+                    assert subrange.getHi() <= primaryRange.getHi();\n+                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n+                    String subfile = subFileEntry.getFileName();\n+                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n+                    long subLine = subrange.getLine();\n+                    long subAddressLo = subrange.getLo();\n+                    long subAddressHi = subrange.getHi();\n+                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n+                    if (subLine < 0) {\n+                        // no line info so stay at previous file:line\n+                        subLine = line;\n+                        subfile = file;\n+                        subFileIdx = fileIdx;\n+                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n+                    }\n+                    // there is a temptation to append end sequence at here\n+                    // when the hiAddress lies strictly between the current\n+                    // address and the start of the next subrange because,\n+                    // ostensibly, we have void space between the end of\n+                    // the current subrange and the start of the next one.\n+                    // however, debug works better if we treat all the insns up\n+                    // to the next range start as belonging to the current line\n+                    //\n+                    // if we have to update to a new file then do so\n+                    if (subFileIdx != fileIdx) {\n+                        // update the current file\n+                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n+                        file = subfile;\n+                        fileIdx = subFileIdx;\n+                    }\n+                    // check if we can advance line and/or address in\n+                    // one byte with a special opcode\n+                    long lineDelta = subLine - line;\n+                    long addressDelta = subAddressLo - address;\n+                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n+                    if (opcode != DW_LNS_undefined) {\n+                        // ignore pointless write when addressDelta == lineDelta == 0\n+                        if (addressDelta != 0 || lineDelta != 0) {\n+                            pos = putSpecialOpcode(opcode, buffer, pos);\n+                        }\n+                    } else {\n+                        // does it help to divide and conquer using\n+                        // a fixed address increment\n+                        int remainder = isConstAddPC(addressDelta);\n+                        if (remainder > 0) {\n+                            pos = putConstAddPC(buffer, pos);\n+                            // the remaining address can be handled with a\n+                            // special opcode but what about the line delta\n+                            opcode = isSpecialOpcode(remainder, lineDelta);\n+                            if (opcode != DW_LNS_undefined) {\n+                                // address remainder and line now fit\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            } else {\n+                                // ok, bump the line separately then use a\n+                                // special opcode for the address remainder\n+                                opcode = isSpecialOpcode(remainder, 0);\n+                                assert opcode != DW_LNS_undefined;\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                                pos = putSpecialOpcode(opcode, buffer, pos);\n+                            }\n+                        } else {\n+                            // increment line and pc separately\n+                            if (lineDelta != 0) {\n+                                pos = putAdvanceLine(lineDelta, buffer, pos);\n+                            }\n+                            // n.b. we might just have had an out of range line increment\n+                            // with a zero address increment\n+                            if (addressDelta > 0) {\n+                                // see if we can use a ushort for the increment\n+                                if (isFixedAdvancePC(addressDelta)) {\n+                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n+                                } else {\n+                                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                                }\n+                            }\n+                            pos = putCopy(buffer, pos);\n+                        }\n+                    }\n+                    // move line and address range on\n+                    line += lineDelta;\n+                    address += addressDelta;\n+                }\n+                // append a final end sequence just below the next primary range\n+                if (address < primaryRange.getHi()) {\n+                    long addressDelta = primaryRange.getHi() - address;\n+                    // increment address before we write the end sequence\n+                    pos = putAdvancePC(addressDelta, buffer, pos);\n+                }\n+                pos = putEndSequence(buffer, pos);\n+            }\n+            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n+\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        public int putCopy(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_copy;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debugCopyCount++;\n+                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debugAddress += uleb;\n+                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_advance_line;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putSLEB(sleb, scratch, 0);\n+            } else {\n+                debugLine += sleb;\n+                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n+                pos = putByte(opcode, buffer, pos);\n+                return putSLEB(sleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_file;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetColumn(long uleb, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_column;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putULEB(uleb, scratch, 0);\n+            } else {\n+                pos = putByte(opcode, buffer, pos);\n+                return putULEB(uleb, buffer, pos);\n+            }\n+        }\n+\n+        public int putNegateStmt(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_negate_stmt;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetBasicBlock(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_set_basic_block;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Set basic block\\n\", pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putConstAddPC(byte[] buffer, int p) {\n+            byte opcode = DW_LNS_const_add_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                int advance = opcodeAddress((byte) 255);\n+                debugAddress += advance;\n+                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNS_fixed_advance_pc;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putShort(arg, scratch, 0);\n+            } else {\n+                debugAddress += arg;\n+                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n+                pos = putByte(opcode, buffer, pos);\n+                return putShort(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putEndSequence(byte[] buffer, int p) {\n+            byte opcode = DW_LNE_end_sequence;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(1, scratch, 0);\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n+                debugAddress = debugTextBase;\n+                debugLine = 1;\n+                debugCopyCount = 0;\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(1, buffer, pos);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        public int putSetAddress(long arg, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_set_address;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // insert extended insn byte count as ULEB\n+                pos = pos + putULEB(9, scratch, 0);\n+                pos = pos + putByte(opcode, scratch, 0);\n+                return pos + putLong(arg, scratch, 0);\n+            } else {\n+                debugAddress = debugTextBase + (int) arg;\n+                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert extended insn byte count as ULEB\n+                pos = putULEB(9, buffer, pos);\n+                pos = putByte(opcode, buffer, pos);\n+                return putRelocatableCodeOffset(arg, buffer, pos);\n+            }\n+        }\n+\n+        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n+            byte opcode = DW_LNE_define_file;\n+            int pos = p;\n+            // calculate bytes needed for opcode + args\n+            int fileBytes = file.length() + 1;\n+            long insnBytes = 1;\n+            insnBytes += fileBytes;\n+            insnBytes += putULEB(uleb1, scratch, 0);\n+            insnBytes += putULEB(uleb2, scratch, 0);\n+            insnBytes += putULEB(uleb3, scratch, 0);\n+            if (buffer == null) {\n+                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n+                // write insnBytes as a ULEB\n+                pos += putULEB(insnBytes, scratch, 0);\n+                return pos + (int) insnBytes;\n+            } else {\n+                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n+                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n+                // insert insn length as uleb\n+                pos = putULEB(insnBytes, buffer, pos);\n+                // insert opcode and args\n+                pos = putByte(opcode, buffer, pos);\n+                pos = putAsciiStringBytes(file, buffer, pos);\n+                pos = putULEB(uleb1, buffer, pos);\n+                pos = putULEB(uleb2, buffer, pos);\n+                return putULEB(uleb3, buffer, pos);\n+            }\n+        }\n+\n+        public int opcodeId(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return iopcode - DW_LN_OPCODE_BASE;\n+        }\n+\n+        public int opcodeAddress(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        }\n+\n+        public int opcodeLine(byte opcode) {\n+            int iopcode = opcode & 0xff;\n+            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n+        }\n+\n+        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putByte(opcode, scratch, 0);\n+            } else {\n+                if (debug && opcode == 0) {\n+                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n+                }\n+                debugAddress += opcodeAddress(opcode);\n+                debugLine += opcodeLine(opcode);\n+                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n+                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n+                return putByte(opcode, buffer, pos);\n+            }\n+        }\n+\n+        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n+        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n+\n+        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n+            if (addressDelta < 0) {\n+                return DW_LNS_undefined;\n+            }\n+            if (lineDelta >= DW_LN_LINE_BASE) {\n+                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n+                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n+                    // line_delta can be encoded\n+                    // check if address is ok\n+                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n+                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n+                        if (opcode <= 255) {\n+                            return (byte) opcode;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // return invalid opcode\n+            return DW_LNS_undefined;\n+        }\n+\n+        public int isConstAddPC(long addressDelta) {\n+            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n+                return 0;\n+            }\n+            if (addressDelta <= MAX_ADDPC_DELTA) {\n+                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n+            } else {\n+                return 0;\n+            }\n+        }\n+\n+        public boolean isFixedAdvancePC(long addressDiff) {\n+            return addressDiff >= 0 && addressDiff < 0xffff;\n+        }\n+\n+        /**\n+         * debug_line section content depends on debug_str section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex 474e74d2073..afd996cda14 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -420,1917 +464,13 @@ public class DwarfSections {\n         }\n         return dirEntry;\n     }\n-\n-    /**\n-     * class from which all DWARF debug section\n-     * inherit providing common behaviours.\n-     */\n-    // shared implementation methods to manage content creation\n-    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-        public boolean debug = false;\n-        public long debugTextBase = 0;\n-        public long debugAddress = 0;\n-        public int debugBase = 0;\n-\n-        public DwarfSectionImpl() {\n-        }\n-\n-        /**\n-         * creates the target byte[] array used to define the section\n-         * contents.\n-         *\n-         * the main task of this method is to precompute the\n-         * size of the debug section. given the complexity of the\n-         * data layouts that invariably requires performing a dummy\n-         * write of the contents, inserting bytes into a small,\n-         * scratch buffer only when absolutely necessary. subclasses\n-         * may also cache some information for use when writing the\n-         * contents.\n-         */\n-        public abstract void createContent();\n-\n-        /**\n-         * populates the byte[] array used to contain the section\n-         * contents.\n-         *\n-         * in most cases this task reruns the operations performed\n-         * under createContent but this time actually writing data\n-         * to the target byte[].\n-         */\n-        public abstract void writeContent();\n-\n-        @Override\n-        public boolean isLoadable() {\n-            // even though we're a progbits section impl we're not actually loadable\n-            return false;\n-        }\n-\n-        public void checkDebug(int pos) {\n-            // if the env var relevant to this element\n-            // type is set then switch on debugging\n-            String name = getSectionName();\n-            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n-            if (System.getenv(envVarName) != null) {\n-                debug = true;\n-                debugBase = pos;\n-                debugAddress = debugTextBase;\n-            }\n-        }\n-\n-        protected void debug(String format, Object... args) {\n-            if (debug) {\n-                System.out.format(format, args);\n-            }\n-        }\n-\n-        // base level put methods that assume a non-null buffer\n-\n-        public int putByte(byte b, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = b;\n-            return pos;\n-        }\n-\n-        public int putShort(short s, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putInt(int i, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putLong(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            return pos;\n-        }\n-\n-        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-            int pos = p;\n-            // mark address so it is relocated relative to the start of the text segment\n-            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-            pos = putLong(0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int putULEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >>> 7;\n-                boolean done = (l == 0);\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putSLEB(long val, byte[] buffer, int p) {\n-            long l = val;\n-            int pos = p;\n-            for (int i = 0; i < 9; i++) {\n-                byte b = (byte) (l & 0x7f);\n-                l = l >> 7;\n-                boolean bIsSigned = (b & 0x40) != 0;\n-                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-                if (!done) {\n-                    b = (byte) (b | 0x80);\n-                }\n-                pos = putByte(b, buffer, pos);\n-                if (done) {\n-                    break;\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-            return putAsciiStringBytes(s, 0, buffer, pos);\n-        }\n-\n-        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-            int pos = p;\n-            for (int l = startChar; l < s.length(); l++) {\n-                char c = s.charAt(l);\n-                if (c > 127) {\n-                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-                }\n-                buffer[pos++] = (byte) c;\n-            }\n-            buffer[pos++] = '\\0';\n-            return pos;\n-        }\n-\n-        // common write methods that check for a null buffer\n-\n-        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n-            if (buffer != null) {\n-                int length = pos - (lengthPos + 4);\n-                putInt(length, buffer, lengthPos);\n-            }\n-        }\n-\n-        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeTag(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeFlag(byte flag, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(flag, scratch, 0);\n-            } else {\n-                return putByte(flag, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + 8;\n-            } else {\n-                return putRelocatableCodeOffset(address, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData8(long value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putLong(value, scratch, 0);\n-            } else {\n-                return putLong(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData4(int value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putInt(value, scratch, 0);\n-            } else {\n-                return putInt(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putByte(value, scratch, 0);\n-            } else {\n-                return putByte(value, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrNull(byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(0, scratch, 0);\n-            } else {\n-                return putSLEB(0, buffer, pos);\n-            }\n-        }\n-\n-        /**\n-         * identify the section after which this debug section\n-         * needs to be ordered when sizing and creating content.\n-         * @return the name of the preceding section\n-         */\n-        public abstract String targetSectionName();\n-\n-        /**\n-         * identify the layout properties of the target section\n-         * which need to have been decided before the contents\n-         * of this section can be created.\n-         * @return an array of the relevant decision kinds\n-         */\n-        public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-        /**\n-         * identify this debug section by name.\n-         * @return the name of the debug section\n-         */\n-        public abstract String getSectionName();\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            // ensure content byte[] has been created before calling super method\n-            createContent();\n-\n-            // ensure content byte[] has been written before calling super method\n-            writeContent();\n-\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n-            Set<BuildDependency> deps = super.getDependencies(decisions);\n-            String targetName = targetSectionName();\n-            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n-            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-            // make our content depend on the size and content of the target\n-            for (LayoutDecision.Kind targetKind : targetKinds) {\n-                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-            }\n-            // make our size depend on our content\n-            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-            return deps;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_str section.\n-     */\n-    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n-        public DwarfStrSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_STR_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    stringEntry.setOffset(pos);\n-                    String string = stringEntry.getString();\n-                    pos += string.length() + 1;\n-                }\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            for (StringEntry stringEntry : stringTable) {\n-                if (stringEntry.isAddToStrSection()) {\n-                    assert stringEntry.getOffset() == pos;\n-                    String string = stringEntry.getString();\n-                    pos = putAsciiStringBytes(string, buffer, pos);\n-                }\n-            }\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        /**\n-         * debug_str section content depends on text section content and offset.\n-         */\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_abbrev section.\n-     */\n-    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfAbbrevSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ABBREV_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // an abbrev table contains abbrev entries for one or\n-            // more CUs. the table includes a sequence of abbrev\n-            // entries each of which defines a specific DIE layout\n-            // employed to describe some DIE in a CU. a table is\n-            // terminated by a null entry\n-            //\n-            // a null entry has consists of just a 0 abbrev code\n-            // LEB128 abbrev_code; ...... == 0\n-            //\n-            // non-null entries have the following format\n-            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n-            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n-            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n-            // <attribute_spec>* ........ zero or more attributes\n-            // <null_attribute_spec> .... terminator\n-            //\n-            // An attribute_spec consists of an attribute name and form\n-            // LEB128 attr_name; ........ 0 for the null attribute name\n-            // LEB128 attr_form; ........ 0 for the null attribute form\n-            //\n-            // For the moment we only use one abbrev table for all CUs.\n-            // It contains two DIEs, the first to describe the compilation\n-            // unit itself and the second to describe each method within\n-            // that compilation unit.\n-            //\n-            // The DIE layouts are as follows:\n-            //\n-            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n-            // DW_AT_language : ... DW_FORM_data1\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_address\n-            // DW_AT_hi_pc : ...... DW_FORM_address\n-            // DW_AT_stmt_list : .. DW_FORM_data4\n-            //\n-            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n-            // DW_AT_name : ....... DW_FORM_strp\n-            // DW_AT_low_pc : ..... DW_FORM_addr\n-            // DW_AT_hi_pc : ...... DW_FORM_addr\n-            // DW_AT_external : ... DW_FORM_flag\n-\n-            pos = writeAbbrev1(null, pos);\n-            pos = writeAbbrev2(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            pos = writeAbbrev1(buffer, pos);\n-            pos = writeAbbrev2(buffer, pos);\n-            assert pos == size;\n-        }\n-\n-        public int writeAttrType(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrForm(long code, byte[] buffer, int pos) {\n-            if (buffer == null) {\n-                return pos + putSLEB(code, scratch, 0);\n-            } else {\n-                return putSLEB(code, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAbbrev1(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 1 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n-            pos = writeAttrType(DW_AT_language, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeAbbrev2(byte[] buffer, int p) {\n-            int pos = p;\n-            // abbrev 2 compile unit\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n-            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n-            pos = writeAttrType(DW_AT_name, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n-            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n-            pos = writeAttrType(DW_AT_external, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n-            // now terminate\n-            pos = writeAttrType(DW_AT_null, buffer, pos);\n-            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_abbrev section content depends on debug_frame section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-    }\n-\n-    /**\n-     * generic generator for debug_frame section.\n-     */\n-    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n-\n-        public DwarfFrameSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_FRAME_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-\n-            // the frame section contains one CIE at offset 0\n-            // followed by an FIE for each method\n-            pos = writeCIE(null, pos);\n-            pos = writeMethodFrames(null, pos);\n-\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            // there are entries for the prologue region where the\n-            // stack is being built, the method body region(s) where\n-            // the code executes with a fixed size frame and the\n-            // epilogue region(s) where the stack is torn down\n-            pos = writeCIE(buffer, pos);\n-            pos = writeMethodFrames(buffer, pos);\n-\n-            if (pos != size) {\n-                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCIE(byte[] buffer, int p) {\n-            // we only need a vanilla CIE with default fields\n-            // because we have to have at least one\n-            // the layout is\n-            //\n-            // uint32 : length ............... length of remaining fields in this CIE\n-            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n-            // uint8 : version ................ == 1\n-            // uint8[] : augmentation ......... == \"\" so always 1 byte\n-            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n-            // ULEB : data_alignment_factor ... == -8\n-            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n-            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // don't care about length\n-                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n-                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n-                pos += putAsciiStringBytes(\"\", scratch, 0);\n-                pos += putULEB(1, scratch, 0);\n-                pos += putSLEB(-8, scratch, 0);\n-                pos += putByte((byte) getPCIdx(), scratch, 0);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                // no need to write length\n-                return pos;\n-            } else {\n-                int lengthPos = pos;\n-                pos = putInt(0, buffer, pos);\n-                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n-                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n-                pos = putAsciiStringBytes(\"\", buffer, pos);\n-                pos = putULEB(1, buffer, pos);\n-                pos = putSLEB(-8, buffer, pos);\n-                pos = putByte((byte) getPCIdx(), buffer, pos);\n-                // write insns to set up empty frame\n-                pos = writeInitialInstructions(buffer, pos);\n-                // pad to word alignment\n-                pos = writePaddingNops(8, buffer, pos);\n-                patchLength(lengthPos, buffer, pos);\n-                return pos;\n-            }\n-        }\n-\n-        public int writeMethodFrames(byte[] buffer, int p) {\n-            int pos = p;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                    long lo = primaryEntry.getPrimary().getLo();\n-                    long hi = primaryEntry.getPrimary().getHi();\n-                    int frameSize = primaryEntry.getFrameSize();\n-                    int currentOffset = 0;\n-                    int lengthPos = pos;\n-                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n-                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n-                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n-                        currentOffset += advance;\n-                        pos = writeAdvanceLoc(advance, buffer, pos);\n-                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n-                            // SP has been extended so rebase CFA using full frame\n-                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n-                        } else {\n-                            // SP has been contracted so rebase CFA using empty frame\n-                            pos = writeDefCFAOffset(8, buffer, pos);\n-                        }\n-                    }\n-                    pos = writePaddingNops(8, buffer, pos);\n-                    patchLength(lengthPos, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n-            // we only need a vanilla FDE header with default fields\n-            // the layout is\n-            //\n-            // uint32 : length ........... length of remaining fields in this FDE\n-            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n-            // uint64 : initial_location .. i.e. method lo address\n-            // uint64 : address_range ..... i.e. method hi - lo\n-            // byte[] : instructions ...... includes pad to 8-byte boundary\n-\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0); // dummy length\n-                pos += putInt(0, scratch, 0); // CIE_offset\n-                pos += putLong(lo, scratch, 0); // initial address\n-                return pos + putLong(hi - lo, scratch, 0); // address range\n-            } else {\n-                pos = putInt(0, buffer, pos); // dummy length\n-                pos = putInt(0, buffer, pos); // CIE_offset\n-                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n-                return putLong(hi - lo, buffer, pos); // address range\n-            }\n-        }\n-\n-        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n-            int pos = p;\n-            assert (alignment & (alignment - 1)) == 0;\n-            while ((pos & (alignment - 1)) != 0) {\n-                if (buffer == null) {\n-                    pos++;\n-                } else {\n-                    pos = putByte(DW_CFA_nop, buffer, pos);\n-                }\n-            }\n-            return pos;\n-        }\n-\n-        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n-                pos += putSLEB(register, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n-                pos = putULEB(register, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n-            if (offset <= 0x3f) {\n-                return writeAdvanceLoc0((byte) offset, buffer, pos);\n-            } else if (offset <= 0xff) {\n-                return writeAdvanceLoc1((byte) offset, buffer, pos);\n-            } else if (offset <= 0xffff) {\n-                return writeAdvanceLoc2((short) offset, buffer, pos);\n-            } else {\n-                return writeAdvanceLoc4(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n-            byte op = advanceLoc0Op(offset);\n-            if (buffer == null) {\n-                return pos + putByte(op, scratch, 0);\n-            } else {\n-                return putByte(op, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n-            int pos = p;\n-            byte op = DW_CFA_advance_loc1;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putByte(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putByte(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc2;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putShort(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putShort(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n-            byte op = DW_CFA_advance_loc4;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putInt(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putInt(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n-            byte op = offsetOp(register);\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(op, scratch, 0);\n-                return pos + putULEB(offset, scratch, 0);\n-            } else {\n-                pos = putByte(op, buffer, pos);\n-                return putULEB(offset, buffer, pos);\n-            }\n-        }\n-\n-        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putByte(DW_CFA_register, scratch, 0);\n-                pos += putULEB(savedReg, scratch, 0);\n-                return pos + putULEB(savedToReg, scratch, 0);\n-            } else {\n-                pos = putByte(DW_CFA_register, buffer, pos);\n-                pos = putULEB(savedReg, buffer, pos);\n-                return putULEB(savedToReg, buffer, pos);\n-            }\n-        }\n-\n-        public abstract int getPCIdx();\n-\n-        public abstract int getSPIdx();\n-\n-        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        /**\n-         * debug_frame section content depends on debug_line section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n-\n-        private byte offsetOp(int register) {\n-            assert (register >> 6) == 0;\n-            return (byte) ((DW_CFA_offset << 6) | register);\n-        }\n-\n-        private byte advanceLoc0Op(int offset) {\n-            assert (offset >= 0 && offset <= 0x3f);\n-            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n-        }\n-    }\n-\n-    /**\n-     * x86_64-specific generator for debug_frame section\n-     * that knows details of x86_64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_RSP_IDX = 7;\n-        public static final int DW_CFA_RIP_IDX = 16;\n-\n-        public DwarfFrameSectionImplX86_64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_RIP_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_RSP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp points at the word containing the saved rip\n-            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n-            // def_cfa r7 (sp) offset 8\n-            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n-            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n-            // (why not -1 ???)\n-            // offset r16 (rip) cfa - 8\n-            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * AArch64-specific generator for debug_frame section\n-     * that knows details of AArch64 registers and frame layout.\n-     */\n-    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n-        public static final int DW_CFA_FP_IDX = 29;\n-        public static final int DW_CFA_LR_IDX = 30;\n-        public static final int DW_CFA_SP_IDX = 31;\n-        public static final int DW_CFA_PC_IDX = 32;\n-\n-        public DwarfFrameSectionImplAArch64() {\n-            super();\n-        }\n-\n-        @Override\n-        public int getPCIdx() {\n-            return DW_CFA_PC_IDX;\n-        }\n-\n-        @Override\n-        public int getSPIdx() {\n-            return DW_CFA_SP_IDX;\n-        }\n-\n-        @Override\n-        public int writeInitialInstructions(byte[] buffer, int p) {\n-            int pos = p;\n-            // rsp has not been updated\n-            // caller pc is in lr\n-            // register r32 (rpc), r30 (lr)\n-            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n-            return pos;\n-        }\n-    }\n-\n-    /**\n-     * generator for debug_info section.\n-     */\n-    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * an info header section always contains a fixed number of bytes.\n-         */\n-        private static final int DW_DIE_HEADER_SIZE = 11;\n-\n-        public DwarfInfoSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_INFO_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need a single level 0 DIE for each compilation unit (CU)\n-            // Each CU's Level 0 DIE is preceded by a fixed header:\n-            // and terminated by a null DIE\n-            // uint32 length ......... excluding this length field\n-            // uint16 dwarf_version .. always 2 ??\n-            // uint32 abbrev offset .. always 0 ??\n-            // uint8 address_size .... always 8\n-            // <DIE>* ................ sequence of top-level and nested child entries\n-            // <null_DIE> ............ == 0\n-            //\n-            // a DIE is a recursively defined structure\n-            // it starts with a code for the associated\n-            // abbrev entry followed by a series of attribute\n-            // values as determined by the entry terminated by\n-            // a null value and followed by zero or more child\n-            // DIEs (zero iff has_children == no_children)\n-            //\n-            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n-            // <attribute_value>* ....... value sequence as determined by abbrev entry\n-            // <DIE>* ................... sequence of child DIEs (if appropriate)\n-            // <null_value> ............. == 0\n-            //\n-            // note that a null_DIE looks like\n-            // LEB128 abbrev_code ....... == 0\n-            // i.e. it also looks like a null_value\n-\n-            byte[] buffer = null;\n-            int pos = 0;\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // no need to backpatch length at lengthPos\n-            }\n-            buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n-            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                // save the offset of this file's CU so it can\n-                // be used when writing the aranges section\n-                classEntry.setCUIndex(pos);\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(classEntry, buffer, pos);\n-                // backpatch length at lengthPos (excluding length field)\n-                patchLength(lengthPos, buffer, pos);\n-            }\n-            assert pos == size;\n-        }\n-\n-        public int writeCUHeader(byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                pos += putInt(0, scratch, 0);            // CU length\n-                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n-                pos += putInt(0, scratch, 0);            // abbrev offset\n-                return pos + putByte((byte) 8, scratch, 0); // address size\n-            } else {\n-                pos = putInt(0, buffer, pos);                 // CU length\n-                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n-                pos = putInt(0, buffer, pos);                 // abbrev offset\n-                return putByte((byte) 8, buffer, pos);           // address size\n-            }\n-        }\n-\n-        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n-            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n-            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n-            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n-            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n-            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n-            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n-            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n-            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n-                pos = writePrimary(primaryEntry, buffer, pos);\n-            }\n-            // write a terminating null attribute for the the level 2 primaries\n-            return writeAttrNull(buffer, pos);\n-\n-        }\n-\n-        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            Range primary = primaryEntry.getPrimary();\n-            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n-            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n-            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n-            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n-            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n-            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n-            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n-            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n-            // need to pass true only if method is public\n-            debug(\"  [0x%08x]     external  true\\n\", pos);\n-            return writeFlag(DW_FLAG_true, buffer, pos);\n-        }\n-\n-        public int writeAttrStrp(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putInt(0, scratch, 0);\n-            } else {\n-                int idx = debugStringIndex(value);\n-                return putInt(idx, buffer, pos);\n-            }\n-        }\n-\n-        public int writeAttrString(String value, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + value.length() + 1;\n-            } else {\n-                return putAsciiStringBytes(value, buffer, pos);\n-            }\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        /**\n-         * debug_info section content depends on abbrev section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public StringTable getStringTable() {\n+        return stringTable;\n     }\n-\n-    /**\n-     * generator for debug_aranges section.\n-     */\n-    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n-        private static final int DW_AR_HEADER_SIZE = 12;\n-        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n-\n-        public DwarfARangesSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_ARANGES_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            int pos = 0;\n-            // we need an entry for each compilation unit\n-            //\n-            // uint32 length ............ in bytes (not counting these 4 bytes)\n-            // uint16 dwarf_version ..... always 2\n-            // uint32 info_offset ....... offset of compilation unit on debug_info\n-            // uint8 address_size ....... always 8\n-            // uint8 segment_desc_size .. ???\n-            //\n-            // i.e. 12 bytes followed by padding\n-            // aligning up to 2 * address size\n-            //\n-            // uint8 pad[4]\n-            //\n-            // followed by N + 1 times\n-            //\n-            // uint64 lo ................ lo address of range\n-            // uint64 length ............ number of bytes in range\n-            //\n-            // where N is the number of ranges belonging to the compilation unit\n-            // and the last range contains two zeroes\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                pos += DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                pos += DW_AR_HEADER_PAD_SIZE;\n-                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n-                pos += 2 * 8;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-            int size = buffer.length;\n-            int pos = 0;\n-\n-            checkDebug(pos);\n-\n-            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int lastpos = pos;\n-                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n-                int cuIndex = classEntry.getCUIndex();\n-                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n-                // add room for each entry into length count\n-                length += classPrimaryEntries.size() * 2 * 8;\n-                length += 2 * 8;\n-                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n-                pos = putInt(length, buffer, pos);\n-                pos = putShort(DW_VERSION_2, buffer, pos); // dwarf version is always 2\n-                pos = putInt(cuIndex, buffer, pos);\n-                pos = putByte((byte) 8, buffer, pos); // address size is always 8\n-                pos = putByte((byte) 0, buffer, pos); // segment size is always 0\n-                assert (pos - lastpos) == DW_AR_HEADER_SIZE;\n-                // align to 2 * address size\n-                for (int i = 0; i < DW_AR_HEADER_PAD_SIZE; i++) {\n-                    pos = putByte((byte) 0, buffer, pos);\n-                }\n-                debug(\"  [0x%08x] Address          Length           Name\\n\", pos);\n-                for (PrimaryEntry classPrimaryEntry : classPrimaryEntries) {\n-                    Range primary = classPrimaryEntry.getPrimary();\n-                    debug(\"  [0x%08x] %016x %016x %s\\n\", pos, debugTextBase + primary.getLo(), primary.getHi() - primary.getLo(), primary.getFullMethodName());\n-                    pos = putRelocatableCodeOffset(primary.getLo(), buffer, pos);\n-                    pos = putLong(primary.getHi() - primary.getLo(), buffer, pos);\n-                }\n-                pos = putLong(0, buffer, pos);\n-                pos = putLong(0, buffer, pos);\n-            }\n-\n-            assert pos == size;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            super.debug(format, args);\n-        }\n-\n-        // .debug_aranges section content depends on .debug_info section content and offset\n-        public static final String TARGET_SECTION_NAME = DW_INFO_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public LinkedList<ClassEntry> getPrimaryClasses() {\n+        return primaryClasses;\n     }\n-\n-    /**\n-     * generator for debug_line section.\n-     */\n-    public class DwarfLineSectionImpl extends DwarfSectionImpl {\n-        /**\n-         * line header section always contains fixed number of bytes.\n-         */\n-        private static final int DW_LN_HEADER_SIZE = 27;\n-        /**\n-         * current generator follows C++ with line base -5.\n-         */\n-        private static final int DW_LN_LINE_BASE = -5;\n-        /**\n-         * current generator follows C++ with line range 14\n-         * giving full range -5 to 8.\n-         */\n-        private static final int DW_LN_LINE_RANGE = 14;\n-        /**\n-         *  current generator uses opcode base of 13\n-         *  which must equal DW_LNS_define_file + 1.\n-         */\n-        private static final int DW_LN_OPCODE_BASE = 13;\n-\n-        /*\n-         * standard opcodes defined by Dwarf 2\n-         */\n-        private static final byte DW_LNS_undefined = 0;        // 0 can be returned to indicate an\n-                                                               // invalid opcode\n-        private static final byte DW_LNS_extended_prefix = 0;  // 0 can be inserted as a prefix for\n-                                                               // extended opcodes\n-        private static final byte DW_LNS_copy = 1;             // append current state as matrix row\n-                                                               // 0 args\n-        private static final byte DW_LNS_advance_pc = 2;       // increment address 1 uleb arg\n-        private static final byte DW_LNS_advance_line = 3;     // increment line 1 sleb arg\n-        private static final byte DW_LNS_set_file = 4;         // set file 1 uleb arg\n-        private static final byte DW_LNS_set_column = 5;       // set column 1 uleb arg\n-        private static final byte DW_LNS_negate_stmt = 6;      // flip is_stmt 0 args\n-        private static final byte DW_LNS_set_basic_block = 7;  // set end sequence and copy row\n-        private static final byte DW_LNS_const_add_pc = 8;     // increment address as per opcode\n-                                                               // 255 0 args\n-        private static final byte DW_LNS_fixed_advance_pc = 9; // increment address 1 ushort arg\n-\n-        /*\n-         * extended opcodes defined by Dwarf 2\n-         */\n-        // private static final byte DW_LNE_undefined = 0;        // there is no extended opcode 0\n-        private static final byte DW_LNE_end_sequence = 1;     // end sequence of addresses\n-        private static final byte DW_LNE_set_address = 2;      // there is no extended opcode 0\n-        private static final byte DW_LNE_define_file = 3;      // there is no extended opcode 0\n-\n-        DwarfLineSectionImpl() {\n-            super();\n-        }\n-\n-        @Override\n-        public String getSectionName() {\n-            return DW_LINE_SECTION_NAME;\n-        }\n-\n-        @Override\n-        public void createContent() {\n-            // we need to create a header, dir table, file table and line\n-            // number table encoding for each CU\n-\n-            // write entries for each file listed in the primary list\n-            int pos = 0;\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                classEntry.setLineIndex(startPos);\n-                int headerSize = headerSize();\n-                int dirTableSize = computeDirTableSize(classEntry);\n-                int fileTableSize = computeFileTableSize(classEntry);\n-                int prologueSize = headerSize + dirTableSize + fileTableSize;\n-                classEntry.setLinePrologueSize(prologueSize);\n-                int lineNumberTableSize = computeLineNUmberTableSize(classEntry);\n-                int totalSize = prologueSize + lineNumberTableSize;\n-                classEntry.setTotalSize(totalSize);\n-                pos += totalSize;\n-            }\n-            byte[] buffer = new byte[pos];\n-            super.setContent(buffer);\n-        }\n-\n-        public int headerSize() {\n-            // header size is standard 31 bytes\n-            // uint32 total_length\n-            // uint16 version\n-            // uint32 prologue_length\n-            // uint8 min_insn_length\n-            // uint8 default_is_stmt\n-            // int8 line_base\n-            // uint8 line_range\n-            // uint8 opcode_base\n-            // uint8 li_opcode_base\n-            // uint8[opcode_base-1] standard_opcode_lengths\n-\n-            return DW_LN_HEADER_SIZE;\n-        }\n-\n-        public int computeDirTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int dirSize = 0;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                dirSize += dir.getPath().length() + 1;\n-            }\n-            // allow for separator nul\n-            dirSize++;\n-            return dirSize;\n-        }\n-\n-        public int computeFileTableSize(ClassEntry classEntry) {\n-            // table contains a sequence of 'nul'-terminated\n-            // dir name bytes followed by an extra 'nul'\n-            // and then a sequence of 'nul'-terminated\n-            // file name bytes followed by an extra 'nul'\n-\n-            // for now we assume dir and file names are ASCII\n-            // byte strings\n-            int fileSize = 0;\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we want the file base name excluding path\n-                String baseName = localEntry.getBaseName();\n-                int length = baseName.length();\n-                fileSize += length + 1;\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int idx = classEntry.localDirsIdx(dirEntry);\n-                fileSize += putULEB(idx, scratch, 0);\n-                // the two zero timestamps require 1 byte each\n-                fileSize += 2;\n-            }\n-            // allow for terminator nul\n-            fileSize++;\n-            return fileSize;\n-        }\n-\n-        public int computeLineNUmberTableSize(ClassEntry classEntry) {\n-            // sigh -- we have to do this by generating the\n-            // content even though we cannot write it into a byte[]\n-            return writeLineNumberTable(classEntry, null, 0);\n-        }\n-\n-        @Override\n-        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-            Element textElement = getElement().getOwner().elementForName(\".text\");\n-            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n-            if (decisionMap != null) {\n-                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n-                if (valueObj != null && valueObj instanceof Number) {\n-                    // this may not be the final vaddr for the text segment\n-                    // but it will be close enough to make debug easier\n-                    // i.e. to within a 4k page or two\n-                    debugTextBase = ((Number) valueObj).longValue();\n-                }\n-            }\n-            return super.getOrDecideContent(alreadyDecided, contentHint);\n-        }\n-\n-        @Override\n-        public void writeContent() {\n-            byte[] buffer = getContent();\n-\n-            int pos = 0;\n-            checkDebug(pos);\n-            debug(\"  [0x%08x] DEBUG_LINE\\n\", pos);\n-\n-            for (ClassEntry classEntry : primaryClasses) {\n-                int startPos = pos;\n-                assert classEntry.getLineIndex() == startPos;\n-                debug(\"  [0x%08x] Compile Unit for %s\\n\", pos, classEntry.getFileName());\n-                pos = writeHeader(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] headerSize = 0x%08x\\n\", pos, pos - startPos);\n-                int dirTablePos = pos;\n-                pos = writeDirTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] dirTableSize = 0x%08x\\n\", pos, pos - dirTablePos);\n-                int fileTablePos = pos;\n-                pos = writeFileTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] fileTableSize = 0x%08x\\n\", pos, pos - fileTablePos);\n-                int lineNumberTablePos = pos;\n-                pos = writeLineNumberTable(classEntry, buffer, pos);\n-                debug(\"  [0x%08x] lineNumberTableSize = 0x%x\\n\", pos, pos - lineNumberTablePos);\n-                debug(\"  [0x%08x] size = 0x%x\\n\", pos, pos - startPos);\n-            }\n-            assert pos == buffer.length;\n-        }\n-\n-        public int writeHeader(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // 4 ubyte length field\n-            pos = putInt(classEntry.getTotalSize() - 4, buffer, pos);\n-            // 2 ubyte version is always 2\n-            pos = putShort(DW_VERSION_2, buffer, pos);\n-            // 4 ubyte prologue length includes rest of header and\n-            // dir + file table section\n-            int prologueSize = classEntry.getLinePrologueSize() - 6;\n-            pos = putInt(prologueSize, buffer, pos);\n-            // 1 ubyte min instruction length is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte default is_stmt is always 1\n-            pos = putByte((byte) 1, buffer, pos);\n-            // 1 byte line base is always -5\n-            pos = putByte((byte) DW_LN_LINE_BASE, buffer, pos);\n-            // 1 ubyte line range is always 14 giving range -5 to 8\n-            pos = putByte((byte) DW_LN_LINE_RANGE, buffer, pos);\n-            // 1 ubyte opcode base is always 13\n-            pos = putByte((byte) DW_LN_OPCODE_BASE, buffer, pos);\n-            // specify opcode arg sizes for the standard opcodes\n-            putByte((byte) 0, buffer, pos);               // DW_LNS_copy\n-            putByte((byte) 1, buffer, pos + 1);      // DW_LNS_advance_pc\n-            putByte((byte) 1, buffer, pos + 2);      // DW_LNS_advance_line\n-            putByte((byte) 1, buffer, pos + 3);      // DW_LNS_set_file\n-            putByte((byte) 1, buffer, pos + 4);      // DW_LNS_set_column\n-            putByte((byte) 0, buffer, pos + 5);      // DW_LNS_negate_stmt\n-            putByte((byte) 0, buffer, pos + 6);      // DW_LNS_set_basic_block\n-            putByte((byte) 0, buffer, pos + 7);      // DW_LNS_const_add_pc\n-            putByte((byte) 1, buffer, pos + 8);      // DW_LNS_fixed_advance_pc\n-            putByte((byte) 0, buffer, pos + 9);      // DW_LNS_end_sequence\n-            putByte((byte) 0, buffer, pos + 10);     // DW_LNS_set_address\n-            pos = putByte((byte) 1, buffer, pos + 11); // DW_LNS_define_file\n-            return pos;\n-        }\n-\n-        public int writeDirTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            debug(\"  [0x%08x] Dir  Name\\n\", pos);\n-            // write out the list of dirs referenced form this file entry\n-            int dirIdx = 1;\n-            for (DirEntry dir : classEntry.getLocalDirs()) {\n-                // write nul terminated string text.\n-                debug(\"  [0x%08x] %-4d %s\\n\", pos, dirIdx, dir.getPath());\n-                pos = putAsciiStringBytes(dir.getPath(), buffer, pos);\n-                dirIdx++;\n-            }\n-            // separate dirs from files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int writeFileTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] Entry Dir  Name\\n\", pos);\n-            for (FileEntry localEntry : classEntry.getLocalFiles()) {\n-                // we need the file name minus path, the associated dir index, and 0 for time stamps\n-                String baseName = localEntry.getBaseName();\n-                DirEntry dirEntry = localEntry.dirEntry;\n-                int dirIdx = classEntry.localDirsIdx(dirEntry);\n-                debug(\"  [0x%08x] %-5d %-5d %s\\n\", pos, fileIdx, dirIdx, baseName);\n-                pos = putAsciiStringBytes(baseName, buffer, pos);\n-                pos = putULEB(dirIdx, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                pos = putULEB(0, buffer, pos);\n-                fileIdx++;\n-            }\n-            // terminate files with a nul\n-            pos = putByte((byte) 0, buffer, pos);\n-            return pos;\n-        }\n-\n-        public int debugLine = 1;\n-        public int debugCopyCount = 0;\n-\n-        public int writeLineNumberTable(ClassEntry classEntry, byte[] buffer, int p) {\n-            int pos = p;\n-            // the primary file entry should always be first in the local files list\n-            assert classEntry.localFilesIdx(classEntry.getFileEntry()) == 1;\n-            String primaryClassName = classEntry.getClassName();\n-            String primaryFileName = classEntry.getFileName();\n-            String file = primaryFileName;\n-            int fileIdx = 1;\n-            debug(\"  [0x%08x] primary class %s\\n\", pos, primaryClassName);\n-            debug(\"  [0x%08x] primary file %s\\n\", pos, primaryFileName);\n-            for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n-                Range primaryRange = primaryEntry.getPrimary();\n-                assert primaryRange.getFileName().equals(primaryFileName);\n-                // each primary represents a method i.e. a contiguous\n-                // sequence of subranges. we assume the default state\n-                // at the start of each sequence because we always post an\n-                // end_sequence when we finish all the subranges in the method\n-                long line = primaryRange.getLine();\n-                if (line < 0 && primaryEntry.getSubranges().size() > 0) {\n-                    line = primaryEntry.getSubranges().get(0).getLine();\n-                }\n-                if (line < 0) {\n-                    line = 0;\n-                }\n-                long address = primaryRange.getLo();\n-\n-                // set state for primary\n-                debug(\"  [0x%08x] primary range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + primaryRange.getLo(), debugTextBase + primaryRange.getHi(), primaryRange.getFullMethodName(),\n-                                primaryRange.getLine());\n-\n-                // initialize and write a row for the start of the primary method\n-                pos = putSetFile(file, fileIdx, buffer, pos);\n-                pos = putSetBasicBlock(buffer, pos);\n-                // address is currently 0\n-                pos = putSetAddress(address, buffer, pos);\n-                // state machine value of line is currently 1\n-                // increment to desired line\n-                if (line != 1) {\n-                    pos = putAdvanceLine(line - 1, buffer, pos);\n-                }\n-                pos = putCopy(buffer, pos);\n-\n-                // now write a row for each subrange lo and hi\n-                for (Range subrange : primaryEntry.getSubranges()) {\n-                    assert subrange.getLo() >= primaryRange.getLo();\n-                    assert subrange.getHi() <= primaryRange.getHi();\n-                    FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subrange);\n-                    String subfile = subFileEntry.getFileName();\n-                    int subFileIdx = classEntry.localFilesIdx(subFileEntry);\n-                    long subLine = subrange.getLine();\n-                    long subAddressLo = subrange.getLo();\n-                    long subAddressHi = subrange.getHi();\n-                    debug(\"  [0x%08x] sub range [0x%08x, 0x%08x] %s:%d\\n\", pos, debugTextBase + subAddressLo, debugTextBase + subAddressHi, subrange.getFullMethodName(), subLine);\n-                    if (subLine < 0) {\n-                        // no line info so stay at previous file:line\n-                        subLine = line;\n-                        subfile = file;\n-                        subFileIdx = fileIdx;\n-                        debug(\"  [0x%08x] missing line info - staying put at %s:%d\\n\", pos, file, line);\n-                    }\n-                    // there is a temptation to append end sequence at here\n-                    // when the hiAddress lies strictly between the current\n-                    // address and the start of the next subrange because,\n-                    // ostensibly, we have void space between the end of\n-                    // the current subrange and the start of the next one.\n-                    // however, debug works better if we treat all the insns up\n-                    // to the next range start as belonging to the current line\n-                    //\n-                    // if we have to update to a new file then do so\n-                    if (subFileIdx != fileIdx) {\n-                        // update the current file\n-                        pos = putSetFile(subfile, subFileIdx, buffer, pos);\n-                        file = subfile;\n-                        fileIdx = subFileIdx;\n-                    }\n-                    // check if we can advance line and/or address in\n-                    // one byte with a special opcode\n-                    long lineDelta = subLine - line;\n-                    long addressDelta = subAddressLo - address;\n-                    byte opcode = isSpecialOpcode(addressDelta, lineDelta);\n-                    if (opcode != DW_LNS_undefined) {\n-                        // ignore pointless write when addressDelta == lineDelta == 0\n-                        if (addressDelta != 0 || lineDelta != 0) {\n-                            pos = putSpecialOpcode(opcode, buffer, pos);\n-                        }\n-                    } else {\n-                        // does it help to divide and conquer using\n-                        // a fixed address increment\n-                        int remainder = isConstAddPC(addressDelta);\n-                        if (remainder > 0) {\n-                            pos = putConstAddPC(buffer, pos);\n-                            // the remaining address can be handled with a\n-                            // special opcode but what about the line delta\n-                            opcode = isSpecialOpcode(remainder, lineDelta);\n-                            if (opcode != DW_LNS_undefined) {\n-                                // address remainder and line now fit\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            } else {\n-                                // ok, bump the line separately then use a\n-                                // special opcode for the address remainder\n-                                opcode = isSpecialOpcode(remainder, 0);\n-                                assert opcode != DW_LNS_undefined;\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                                pos = putSpecialOpcode(opcode, buffer, pos);\n-                            }\n-                        } else {\n-                            // increment line and pc separately\n-                            if (lineDelta != 0) {\n-                                pos = putAdvanceLine(lineDelta, buffer, pos);\n-                            }\n-                            // n.b. we might just have had an out of range line increment\n-                            // with a zero address increment\n-                            if (addressDelta > 0) {\n-                                // see if we can use a ushort for the increment\n-                                if (isFixedAdvancePC(addressDelta)) {\n-                                    pos = putFixedAdvancePC((short) addressDelta, buffer, pos);\n-                                } else {\n-                                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                                }\n-                            }\n-                            pos = putCopy(buffer, pos);\n-                        }\n-                    }\n-                    // move line and address range on\n-                    line += lineDelta;\n-                    address += addressDelta;\n-                }\n-                // append a final end sequence just below the next primary range\n-                if (address < primaryRange.getHi()) {\n-                    long addressDelta = primaryRange.getHi() - address;\n-                    // increment address before we write the end sequence\n-                    pos = putAdvancePC(addressDelta, buffer, pos);\n-                }\n-                pos = putEndSequence(buffer, pos);\n-            }\n-            debug(\"  [0x%08x] primary file processed %s\\n\", pos, primaryFileName);\n-\n-            return pos;\n-        }\n-\n-        @Override\n-        protected void debug(String format, Object... args) {\n-            if (((int) args[0] - debugBase) < 0x100000) {\n-                super.debug(format, args);\n-            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n-                super.debug(format, args);\n-            }\n-        }\n-\n-        public int putCopy(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_copy;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debugCopyCount++;\n-                debug(\"  [0x%08x] Copy %d\\n\", pos, debugCopyCount);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvancePC(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debugAddress += uleb;\n-                debug(\"  [0x%08x] Advance PC by %d to 0x%08x\\n\", pos, uleb, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putAdvanceLine(long sleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_advance_line;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putSLEB(sleb, scratch, 0);\n-            } else {\n-                debugLine += sleb;\n-                debug(\"  [0x%08x] Advance Line by %d to %d\\n\", pos, sleb, debugLine);\n-                pos = putByte(opcode, buffer, pos);\n-                return putSLEB(sleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetFile(String file, long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_file;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set File Name to entry %d in the File Name Table (%s)\\n\", pos, uleb, file);\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetColumn(long uleb, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_column;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putULEB(uleb, scratch, 0);\n-            } else {\n-                pos = putByte(opcode, buffer, pos);\n-                return putULEB(uleb, buffer, pos);\n-            }\n-        }\n-\n-        public int putNegateStmt(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_negate_stmt;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetBasicBlock(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_set_basic_block;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Set basic block\\n\", pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putConstAddPC(byte[] buffer, int p) {\n-            byte opcode = DW_LNS_const_add_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                int advance = opcodeAddress((byte) 255);\n-                debugAddress += advance;\n-                debug(\"  [0x%08x] Advance PC by constant %d to 0x%08x\\n\", pos, advance, debugAddress);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putFixedAdvancePC(short arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNS_fixed_advance_pc;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putShort(arg, scratch, 0);\n-            } else {\n-                debugAddress += arg;\n-                debug(\"  [0x%08x] Fixed advance Address by %d to 0x%08x\\n\", pos, arg, debugAddress);\n-                pos = putByte(opcode, buffer, pos);\n-                return putShort(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putEndSequence(byte[] buffer, int p) {\n-            byte opcode = DW_LNE_end_sequence;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(1, scratch, 0);\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 1: End sequence\\n\", pos);\n-                debugAddress = debugTextBase;\n-                debugLine = 1;\n-                debugCopyCount = 0;\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(1, buffer, pos);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        public int putSetAddress(long arg, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_set_address;\n-            int pos = p;\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // insert extended insn byte count as ULEB\n-                pos = pos + putULEB(9, scratch, 0);\n-                pos = pos + putByte(opcode, scratch, 0);\n-                return pos + putLong(arg, scratch, 0);\n-            } else {\n-                debugAddress = debugTextBase + (int) arg;\n-                debug(\"  [0x%08x] Extended opcode 2: Set Address to 0x%08x\\n\", pos, debugAddress);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert extended insn byte count as ULEB\n-                pos = putULEB(9, buffer, pos);\n-                pos = putByte(opcode, buffer, pos);\n-                return putRelocatableCodeOffset(arg, buffer, pos);\n-            }\n-        }\n-\n-        public int putDefineFile(String file, long uleb1, long uleb2, long uleb3, byte[] buffer, int p) {\n-            byte opcode = DW_LNE_define_file;\n-            int pos = p;\n-            // calculate bytes needed for opcode + args\n-            int fileBytes = file.length() + 1;\n-            long insnBytes = 1;\n-            insnBytes += fileBytes;\n-            insnBytes += putULEB(uleb1, scratch, 0);\n-            insnBytes += putULEB(uleb2, scratch, 0);\n-            insnBytes += putULEB(uleb3, scratch, 0);\n-            if (buffer == null) {\n-                pos = pos + putByte(DW_LNS_extended_prefix, scratch, 0);\n-                // write insnBytes as a ULEB\n-                pos += putULEB(insnBytes, scratch, 0);\n-                return pos + (int) insnBytes;\n-            } else {\n-                debug(\"  [0x%08x] Extended opcode 3: Define File %s idx %d ts1 %d ts2 %d\\n\", pos, file, uleb1, uleb2, uleb3);\n-                pos = putByte(DW_LNS_extended_prefix, buffer, pos);\n-                // insert insn length as uleb\n-                pos = putULEB(insnBytes, buffer, pos);\n-                // insert opcode and args\n-                pos = putByte(opcode, buffer, pos);\n-                pos = putAsciiStringBytes(file, buffer, pos);\n-                pos = putULEB(uleb1, buffer, pos);\n-                pos = putULEB(uleb2, buffer, pos);\n-                return putULEB(uleb3, buffer, pos);\n-            }\n-        }\n-\n-        public int opcodeId(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return iopcode - DW_LN_OPCODE_BASE;\n-        }\n-\n-        public int opcodeAddress(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return (iopcode - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        }\n-\n-        public int opcodeLine(byte opcode) {\n-            int iopcode = opcode & 0xff;\n-            return ((iopcode - DW_LN_OPCODE_BASE) % DW_LN_LINE_RANGE) + DW_LN_LINE_BASE;\n-        }\n-\n-        public int putSpecialOpcode(byte opcode, byte[] buffer, int p) {\n-            int pos = p;\n-            if (buffer == null) {\n-                return pos + putByte(opcode, scratch, 0);\n-            } else {\n-                if (debug && opcode == 0) {\n-                    debug(\"  [0x%08x] ERROR Special Opcode %d: Address 0x%08x Line %d\\n\", debugAddress, debugLine);\n-                }\n-                debugAddress += opcodeAddress(opcode);\n-                debugLine += opcodeLine(opcode);\n-                debug(\"  [0x%08x] Special Opcode %d: advance Address by %d to 0x%08x and Line by %d to %d\\n\",\n-                                pos, opcodeId(opcode), opcodeAddress(opcode), debugAddress, opcodeLine(opcode), debugLine);\n-                return putByte(opcode, buffer, pos);\n-            }\n-        }\n-\n-        private static final int MAX_ADDRESS_ONLY_DELTA = (0xff - DW_LN_OPCODE_BASE) / DW_LN_LINE_RANGE;\n-        private static final int MAX_ADDPC_DELTA = MAX_ADDRESS_ONLY_DELTA + (MAX_ADDRESS_ONLY_DELTA - 1);\n-\n-        public byte isSpecialOpcode(long addressDelta, long lineDelta) {\n-            if (addressDelta < 0) {\n-                return DW_LNS_undefined;\n-            }\n-            if (lineDelta >= DW_LN_LINE_BASE) {\n-                long offsetLineDelta = lineDelta - DW_LN_LINE_BASE;\n-                if (offsetLineDelta < DW_LN_LINE_RANGE) {\n-                    // line_delta can be encoded\n-                    // check if address is ok\n-                    if (addressDelta <= MAX_ADDRESS_ONLY_DELTA) {\n-                        long opcode = DW_LN_OPCODE_BASE + (addressDelta * DW_LN_LINE_RANGE) + offsetLineDelta;\n-                        if (opcode <= 255) {\n-                            return (byte) opcode;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // return invalid opcode\n-            return DW_LNS_undefined;\n-        }\n-\n-        public int isConstAddPC(long addressDelta) {\n-            if (addressDelta < MAX_ADDRESS_ONLY_DELTA) {\n-                return 0;\n-            }\n-            if (addressDelta <= MAX_ADDPC_DELTA) {\n-                return (int) (addressDelta - MAX_ADDRESS_ONLY_DELTA);\n-            } else {\n-                return 0;\n-            }\n-        }\n-\n-        public boolean isFixedAdvancePC(long addressDiff) {\n-            return addressDiff >= 0 && addressDiff < 0xffff;\n-        }\n-\n-        /**\n-         * debug_line section content depends on debug_str section content and offset.\n-         */\n-        public static final String TARGET_SECTION_NAME = DW_STR_SECTION_NAME;\n-\n-        @Override\n-        public String targetSectionName() {\n-            return TARGET_SECTION_NAME;\n-        }\n-\n-        public final LayoutDecision.Kind[] targetSectionKinds = {\n-                        LayoutDecision.Kind.CONTENT,\n-                        LayoutDecision.Kind.OFFSET,\n-        };\n-\n-        @Override\n-        public LayoutDecision.Kind[] targetSectionKinds() {\n-            return targetSectionKinds;\n-        }\n+    public ByteOrder getByteOrder() {\n+        return byteOrder;\n     }\n }\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\nindex afd996cda14..5d26129bf74 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n", "chunk": "@@ -438,38 +440,36 @@ public class DwarfSections {\n         assert !subrange.isPrimary();\n         String className = primaryRange.getClassName();\n         ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n         /*\n-         * the primary range should already have been seen\n-         * and associated with a primary class entry\n+         * the primary range should already have been seen and associated with a primary class entry\n          */\n         assert classEntry.primaryIndexFor(primaryRange) != null;\n-        classEntry.addSubRange(subrange, subrangeEntry);\n+        if (subrangeFileEntry != null) {\n+            classEntry.addSubRange(subrange, subrangeFileEntry);\n+        }\n     }\n \n-    public DirEntry ensureDirEntry(String file) {\n-        int pathLength = file.lastIndexOf('/');\n-        if (pathLength < 0) {\n-            /*\n-             * no path/package means use dir entry 0\n-             */\n+    public DirEntry ensureDirEntry(Path filePath) {\n+        if (filePath == null) {\n             return null;\n         }\n-        String filePath = file.substring(0, pathLength);\n         DirEntry dirEntry = dirsIndex.get(filePath);\n         if (dirEntry == null) {\n-            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirEntry = new DirEntry(filePath);\n             dirsIndex.put(filePath, dirEntry);\n-            dirs.add(dirEntry);\n         }\n         return dirEntry;\n     }\n+\n     public StringTable getStringTable() {\n         return stringTable;\n     }\n+\n     public LinkedList<ClassEntry> getPrimaryClasses() {\n         return primaryClasses;\n     }\n+\n     public ByteOrder getByteOrder() {\n         return byteOrder;\n     }\n", "next_change": {"commit": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\ndeleted file mode 100644\nindex 5d26129bf74..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java\n+++ /dev/null\n", "chunk": "@@ -1,476 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.debugentry.DirEntry;\n-import com.oracle.objectfile.debugentry.FileEntry;\n-import com.oracle.objectfile.debugentry.Range;\n-import com.oracle.objectfile.debugentry.StringTable;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n-import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n-import com.oracle.objectfile.elf.ELFMachine;\n-\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * A class that models the debug info in an organization that facilitates generation of the required\n- * DWARF sections. It groups common data and behaviours for use by the various subclasses of class\n- * DwarfSectionImpl that take responsibility for generating content for a specific section type.\n- */\n-public class DwarfSections {\n-\n-    /*\n-     * names of the different ELF sections we create or reference in reverse dependency order\n-     */\n-    public static final String TEXT_SECTION_NAME = \".text\";\n-    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n-    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n-    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n-    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n-    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n-    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n-\n-    /**\n-     * currently generated debug info relies on DWARF spec vesion 2.\n-     */\n-    public static final short DW_VERSION_2 = 2;\n-\n-    /*\n-     * define all the abbrev section codes we need for our DIEs\n-     */\n-    // public static final int DW_ABBREV_CODE_null = 0;\n-    public static final int DW_ABBREV_CODE_compile_unit = 1;\n-    public static final int DW_ABBREV_CODE_subprogram = 2;\n-\n-    /*\n-     * define all the Dwarf tags we need for our DIEs\n-     */\n-    public static final int DW_TAG_compile_unit = 0x11;\n-    public static final int DW_TAG_subprogram = 0x2e;\n-    /*\n-     * define all the Dwarf attributes we need for our DIEs\n-     */\n-    public static final int DW_AT_null = 0x0;\n-    public static final int DW_AT_name = 0x3;\n-    /*\n-     * public static final int DW_AT_comp_dir = 0x1b;\n-     */\n-    public static final int DW_AT_stmt_list = 0x10;\n-    public static final int DW_AT_low_pc = 0x11;\n-    public static final int DW_AT_hi_pc = 0x12;\n-    public static final int DW_AT_language = 0x13;\n-    public static final int DW_AT_external = 0x3f;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_return_addr = 0x2a;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_frame_base = 0x40;\n-    /*\n-     * define all the Dwarf attribute forms we need for our DIEs\n-     */\n-    public static final int DW_FORM_null = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    private static final int DW_FORM_string = 0x8;\n-    public static final int DW_FORM_strp = 0xe;\n-    public static final int DW_FORM_addr = 0x1;\n-    public static final int DW_FORM_data1 = 0x0b;\n-    public static final int DW_FORM_data4 = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_data8 = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_FORM_block1 = 0x0a;\n-    public static final int DW_FORM_flag = 0xc;\n-\n-    /*\n-     * define specific attribute values for given attribute or form types\n-     */\n-    /*\n-     * DIE header has_children attribute values\n-     */\n-    public static final byte DW_CHILDREN_no = 0;\n-    public static final byte DW_CHILDREN_yes = 1;\n-    /*\n-     * DW_FORM_flag attribute values\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_FLAG_false = 0;\n-    public static final byte DW_FLAG_true = 1;\n-    /*\n-     * value for DW_AT_language attribute with form DATA1\n-     */\n-    public static final byte DW_LANG_Java = 0xb;\n-\n-    /*\n-     * DW_AT_Accessibility attribute values\n-     *\n-     * not needed until we make functions members\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_public = 1;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_protected = 2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_ACCESS_private = 3;\n-\n-    /*\n-     * others not yet needed\n-     */\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_type = 0; // only present for non-void\n-                                                                        // functions\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_AT_accessibility = 0;\n-\n-    /*\n-     * CIE and FDE entries\n-     */\n-\n-    /* full byte/word values */\n-    public static final int DW_CFA_CIE_id = -1;\n-    @SuppressWarnings(\"unused\")\n-    public static final int DW_CFA_FDE_id = 0;\n-\n-    public static final byte DW_CFA_CIE_version = 1;\n-\n-    /* values encoded in high 2 bits */\n-    public static final byte DW_CFA_advance_loc = 0x1;\n-    public static final byte DW_CFA_offset = 0x2;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore = 0x3;\n-\n-    /* values encoded in low 6 bits */\n-    public static final byte DW_CFA_nop = 0x0;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_set_loc1 = 0x1;\n-    public static final byte DW_CFA_advance_loc1 = 0x2;\n-    public static final byte DW_CFA_advance_loc2 = 0x3;\n-    public static final byte DW_CFA_advance_loc4 = 0x4;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_offset_extended = 0x5;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_restore_extended = 0x6;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_undefined = 0x7;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_same_value = 0x8;\n-    public static final byte DW_CFA_register = 0x9;\n-    public static final byte DW_CFA_def_cfa = 0xc;\n-    @SuppressWarnings(\"unused\")\n-    public static final byte DW_CFA_def_cfa_register = 0xd;\n-    public static final byte DW_CFA_def_cfa_offset = 0xe;\n-\n-    private ByteOrder byteOrder;\n-    private DwarfStrSectionImpl dwarfStrSection;\n-    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n-    private DwarfInfoSectionImpl dwarfInfoSection;\n-    private DwarfARangesSectionImpl dwarfARangesSection;\n-    private DwarfLineSectionImpl dwarfLineSection;\n-    private DwarfFrameSectionImpl dwarfFameSection;\n-\n-    public DwarfSections(ELFMachine elfMachine, ByteOrder byteOrder) {\n-        this.byteOrder = byteOrder;\n-        dwarfStrSection = new DwarfStrSectionImpl(this);\n-        dwarfAbbrevSection = new DwarfAbbrevSectionImpl(this);\n-        dwarfInfoSection = new DwarfInfoSectionImpl(this);\n-        dwarfARangesSection = new DwarfARangesSectionImpl(this);\n-        dwarfLineSection = new DwarfLineSectionImpl(this);\n-        if (elfMachine == ELFMachine.AArch64) {\n-            dwarfFameSection = new DwarfFrameSectionImplAArch64(this);\n-        } else {\n-            dwarfFameSection = new DwarfFrameSectionImplX86_64(this);\n-        }\n-    }\n-\n-    public DwarfStrSectionImpl getStrSectionImpl() {\n-        return dwarfStrSection;\n-    }\n-\n-    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n-        return dwarfAbbrevSection;\n-    }\n-\n-    public DwarfFrameSectionImpl getFrameSectionImpl() {\n-        return dwarfFameSection;\n-    }\n-\n-    public DwarfInfoSectionImpl getInfoSectionImpl() {\n-        return dwarfInfoSection;\n-    }\n-\n-    public DwarfARangesSectionImpl getARangesSectionImpl() {\n-        return dwarfARangesSection;\n-    }\n-\n-    public DwarfLineSectionImpl getLineSectionImpl() {\n-        return dwarfLineSection;\n-    }\n-\n-    /**\n-     * a table listing all known strings, some of which may be marked for insertion into the\n-     * debug_str section.\n-     */\n-    private StringTable stringTable = new StringTable();\n-\n-    /**\n-     * index of all dirs in which files are found to reside either as part of substrate/compiler or\n-     * user code.\n-     */\n-    private Map<Path, DirEntry> dirsIndex = new HashMap<>();\n-\n-    /*\n-     * The obvious traversal structure for debug records is:\n-     *\n-     * 1) by top level compiled method (primary Range) ordered by ascending address\n-     *\n-     * 2) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * these can be used to ensure that all debug records are generated in increasing address order\n-     *\n-     * An alternative traversal option is\n-     *\n-     * 1) by top level class (String id)\n-     *\n-     * 2) by top level compiled method (primary Range) within a class ordered by ascending address\n-     *\n-     * 3) by inlined method (sub range) within top level method ordered by ascending address\n-     *\n-     * this relies on the (current) fact that methods of a given class always appear in a single\n-     * continuous address range with no intervening code from other methods or data values. this\n-     * means we can treat each class as a compilation unit, allowing data common to all methods of\n-     * the class to be shared.\n-     *\n-     * A third option appears to be to traverse via files, then top level class within file etc.\n-     * Unfortunately, files cannot be treated as the compilation unit. A file F may contain multiple\n-     * classes, say C1 and C2. There is no guarantee that methods for some other class C' in file F'\n-     * will not be compiled into the address space interleaved between methods of C1 and C2. That is\n-     * a shame because generating debug info records one file at a time would allow more sharing\n-     * e.g. enabling all classes in a file to share a single copy of the file and dir tables.\n-     */\n-\n-    /**\n-     * list of class entries detailing class info for primary ranges.\n-     */\n-    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n-    /**\n-     * index of already seen classes.\n-     */\n-    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n-\n-    /**\n-     * index of files which contain primary or secondary ranges.\n-     */\n-    private Map<Path, FileEntry> filesIndex = new HashMap<>();\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string to be inserted\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueString(String string) {\n-        return stringTable.uniqueString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table, ensuring the table entry is marked for inclusion in\n-     * the debug_str section.\n-     * \n-     * @param string the string to be inserted and marked for inclusion in the debug_str section\n-     * @return a unique equivalent String\n-     */\n-    public String uniqueDebugString(String string) {\n-        return stringTable.uniqueDebugString(string);\n-    }\n-\n-    /**\n-     * indirects this call to the string table.\n-     * \n-     * @param string the string whose index is required\n-     * @return the offset of the string in the .debug_str section\n-     */\n-    public int debugStringIndex(String string) {\n-        return stringTable.debugStringIndex(string);\n-    }\n-\n-    /**\n-     * entry point allowing ELFObjectFile to pass on information about types, code and heap data.\n-     * \n-     * @param debugInfoProvider provider instance passed by ObjectFile client\n-     */\n-    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n-        /*\n-         * DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider(); for\n-         * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n-         */\n-\n-        /*\n-         * ensure we have a null string in the string section\n-         */\n-        uniqueDebugString(\"\");\n-\n-        debugInfoProvider.codeInfoProvider().forEach(debugCodeInfo -> {\n-            /*\n-             * primary file name and full method name need to be written to the debug_str section\n-             */\n-            String fileName = debugCodeInfo.fileName();\n-            Path filePath = debugCodeInfo.filePath();\n-            // switch '$' in class names for '.'\n-            String className = debugCodeInfo.className().replaceAll(\"\\\\$\", \".\");\n-            String methodName = debugCodeInfo.methodName();\n-            String paramNames = debugCodeInfo.paramNames();\n-            String returnTypeName = debugCodeInfo.returnTypeName();\n-            int lo = debugCodeInfo.addressLo();\n-            int hi = debugCodeInfo.addressHi();\n-            int primaryLine = debugCodeInfo.line();\n-            Range primaryRange = new Range(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n-            /*\n-             * System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n-             * returnTypeName, className, methodName, paramNames, fileName); create an infoSection\n-             * entry for the method\n-             */\n-            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n-            debugCodeInfo.lineInfoProvider().forEach(debugLineInfo -> {\n-                String fileNameAtLine = debugLineInfo.fileName();\n-                Path filePathAtLine = debugLineInfo.filePath();\n-                // switch '$' in class names for '.'\n-                String classNameAtLine = debugLineInfo.className().replaceAll(\"\\\\$\", \".\");\n-                String methodNameAtLine = debugLineInfo.methodName();\n-                int loAtLine = lo + debugLineInfo.addressLo();\n-                int hiAtLine = lo + debugLineInfo.addressHi();\n-                int line = debugLineInfo.line();\n-                /*\n-                 * record all subranges even if they have no line or file so we at least get a\n-                 * symbol for them\n-                 */\n-                Range subRange = new Range(fileNameAtLine, filePathAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n-                addSubRange(primaryRange, subRange);\n-            });\n-        });\n-        /*\n-         * DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider(); for\n-         * (DebugDataInfo debugDataInfo : dataInfoProvider) { install details of heap elements\n-         * String name = debugDataInfo.toString(); }\n-         */\n-    }\n-\n-    public ClassEntry ensureClassEntry(Range range) {\n-        String className = range.getClassName();\n-        /*\n-         * see if we already have an entry\n-         */\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        if (classEntry == null) {\n-            /*\n-             * create and index the entry associating it with the right file\n-             */\n-            FileEntry fileEntry = ensureFileEntry(range);\n-            classEntry = new ClassEntry(className, fileEntry);\n-            primaryClasses.add(classEntry);\n-            primaryClassesIndex.put(className, classEntry);\n-        }\n-        assert classEntry.getClassName().equals(className);\n-        return classEntry;\n-    }\n-\n-    public FileEntry ensureFileEntry(Range range) {\n-        String fileName = range.getFileName();\n-        if (fileName == null) {\n-            return null;\n-        }\n-        Path filePath = range.getFilePath();\n-        Path fileAsPath = range.getFileAsPath();\n-        /*\n-         * ensure we have an entry\n-         */\n-        FileEntry fileEntry = filesIndex.get(fileAsPath);\n-        if (fileEntry == null) {\n-            DirEntry dirEntry = ensureDirEntry(filePath);\n-            fileEntry = new FileEntry(fileName, dirEntry);\n-            /*\n-             * index the file entry by file path\n-             */\n-            filesIndex.put(fileAsPath, fileEntry);\n-            if (!range.isPrimary()) {\n-                /* check we have a file for the corresponding primary range */\n-                Range primaryRange = range.getPrimary();\n-                FileEntry primaryFileEntry = filesIndex.get(primaryRange.getFileAsPath());\n-                assert primaryFileEntry != null;\n-            }\n-        }\n-        return fileEntry;\n-    }\n-\n-    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n-        assert primaryRange.isPrimary();\n-        ClassEntry classEntry = ensureClassEntry(primaryRange);\n-        classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n-    }\n-\n-    public void addSubRange(Range primaryRange, Range subrange) {\n-        assert primaryRange.isPrimary();\n-        assert !subrange.isPrimary();\n-        String className = primaryRange.getClassName();\n-        ClassEntry classEntry = primaryClassesIndex.get(className);\n-        FileEntry subrangeFileEntry = ensureFileEntry(subrange);\n-        /*\n-         * the primary range should already have been seen and associated with a primary class entry\n-         */\n-        assert classEntry.primaryIndexFor(primaryRange) != null;\n-        if (subrangeFileEntry != null) {\n-            classEntry.addSubRange(subrange, subrangeFileEntry);\n-        }\n-    }\n-\n-    public DirEntry ensureDirEntry(Path filePath) {\n-        if (filePath == null) {\n-            return null;\n-        }\n-        DirEntry dirEntry = dirsIndex.get(filePath);\n-        if (dirEntry == null) {\n-            dirEntry = new DirEntry(filePath);\n-            dirsIndex.put(filePath, dirEntry);\n-        }\n-        return dirEntry;\n-    }\n-\n-    public StringTable getStringTable() {\n-        return stringTable;\n-    }\n-\n-    public LinkedList<ClassEntry> getPrimaryClasses() {\n-        return primaryClasses;\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        return byteOrder;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyODg5Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384528893", "body": "Typo", "bodyText": "Typo", "bodyHTML": "<p dir=\"auto\">Typo</p>", "author": "olpaw", "createdAt": "2020-02-26T14:32:49Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringTable.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+ * Allows incoming strings to be reduced to unique (up\n+ * to equals) instances and supports marking of strings\n+ * which need to be written to the debug_str section\n+ * and retrieval of the location offset after writing.\n+ */\n+public class StringTable implements Iterable<StringEntry> {\n+\n+    private final HashMap<String, StringEntry> table;\n+\n+    public StringTable() {\n+        this.table = new HashMap<>();\n+    }\n+\n+    /**\n+     * Wnsures a unique instance of a string exists in the", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDY5OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384570699", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyODg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringTable.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/StringTable.java\nsimilarity index 69%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringTable.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/StringTable.java\nindex 1ba2def55f7..9ea823ff00d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringTable.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/StringTable.java\n", "chunk": "@@ -44,10 +43,10 @@ public class StringTable implements Iterable<StringEntry> {\n     }\n \n     /**\n-     * Wnsures a unique instance of a string exists in the\n-     * table, inserting the supplied String if no equivalent\n-     * String is already present. This should only be called\n-     * before the string section has been written.\n+     * Ensures a unique instance of a string exists in the table, inserting the supplied String if\n+     * no equivalent String is already present. This should only be called before the string section\n+     * has been written.\n+     * \n      * @param string the string to be included in the table\n      * @return the unique instance of the String\n      */\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyOTU3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384529577", "body": "I still see many of these comments starting with lowercase letters", "bodyText": "I still see many of these comments starting with lowercase letters", "bodyHTML": "<p dir=\"auto\">I still see many of these comments starting with lowercase letters</p>", "author": "olpaw", "createdAt": "2020-02-26T14:33:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringEntry.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * Used to retain a unique (up to equals) copy of a\n+ * String. Also flag swhether the String needs to be\n+ * located in the debug_string section and, if so,\n+ * tracks the offset at which it gets written.\n+ */\n+public class StringEntry {\n+    private String string;\n+    private int offset;\n+    private boolean addToStrSection;\n+\n+    StringEntry(String string) {\n+        this.string = string;\n+        this.offset = -1;\n+    }\n+\n+    public String getString() {\n+        return string;\n+    }\n+\n+    public int getOffset() {\n+        /*\n+         * offset must be set before this can be fetched", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NjgwOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384546809", "bodyText": "Yes. I cleaned up a lot of them before fixing the other issues but I have not yet done a second pass over them. I will do that as part of the next cleanup that handles all this feedback.", "author": "adinn", "createdAt": "2020-02-26T14:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyOTU3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringEntry.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/StringEntry.java\nsimilarity index 89%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringEntry.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/StringEntry.java\nindex b7963faf966..f8fe7445d8d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringEntry.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/StringEntry.java\n", "chunk": "@@ -48,7 +46,7 @@ public class StringEntry {\n \n     public int getOffset() {\n         /*\n-         * offset must be set before this can be fetched\n+         * Offset must be set before this can be fetched\n          */\n         assert offset >= 0;\n         return offset;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDg5OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550899", "body": "dead code", "bodyText": "dead code", "bodyHTML": "<p dir=\"auto\">dead code</p>", "author": "olpaw", "createdAt": "2020-02-26T15:05:11Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODA1NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558055", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 937e40c108f..185de9e86e8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -167,30 +172,6 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n-    }\n-\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 185de9e86e8..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -172,9 +177,11 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 63523cb2234..13e8cb73dab 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -177,11 +102,33 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    Stream<DebugTypeInfo> typeInfoProvider();\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n+    }\n+\n+    DebugTypeInfoProvider typeInfoProvider();\n \n-    Stream<DebugCodeInfo> codeInfoProvider();\n+    DebugCodeInfoProvider codeInfoProvider();\n \n-    @SuppressWarnings(\"unused\")\n-    Stream<DebugDataInfo> dataInfoProvider();\n+    DebugDataInfoProvider dataInfoProvider();\n }\n", "next_change": {"commit": "4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 13e8cb73dab..444be49613a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -102,33 +167,9 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n-    }\n-\n-    DebugTypeInfoProvider typeInfoProvider();\n+    Stream<DebugTypeInfo> typeInfoProvider();\n \n-    DebugCodeInfoProvider codeInfoProvider();\n+    Stream<DebugCodeInfo> codeInfoProvider();\n \n-    DebugDataInfoProvider dataInfoProvider();\n+    Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 444be49613a..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -167,9 +177,11 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDk3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550977", "body": "dead code", "bodyText": "dead code", "bodyHTML": "<p dir=\"auto\">dead code</p>", "author": "olpaw", "createdAt": "2020-02-26T15:05:19Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODQxMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558412", "bodyText": "fixed", "author": "adinn", "createdAt": "2020-02-26T15:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 937e40c108f..185de9e86e8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -167,30 +172,6 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n-    }\n-\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 185de9e86e8..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -172,9 +177,11 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 63523cb2234..13e8cb73dab 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -177,11 +102,33 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    Stream<DebugTypeInfo> typeInfoProvider();\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n+    }\n+\n+    DebugTypeInfoProvider typeInfoProvider();\n \n-    Stream<DebugCodeInfo> codeInfoProvider();\n+    DebugCodeInfoProvider codeInfoProvider();\n \n-    @SuppressWarnings(\"unused\")\n-    Stream<DebugDataInfo> dataInfoProvider();\n+    DebugDataInfoProvider dataInfoProvider();\n }\n", "next_change": {"commit": "4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 13e8cb73dab..444be49613a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -102,33 +167,9 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n-    }\n-\n-    DebugTypeInfoProvider typeInfoProvider();\n+    Stream<DebugTypeInfo> typeInfoProvider();\n \n-    DebugCodeInfoProvider codeInfoProvider();\n+    Stream<DebugCodeInfo> codeInfoProvider();\n \n-    DebugDataInfoProvider dataInfoProvider();\n+    Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 444be49613a..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -167,9 +177,11 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MTA3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384551072", "body": "dead code", "bodyText": "dead code", "bodyHTML": "<p dir=\"auto\">dead code</p>", "author": "olpaw", "createdAt": "2020-02-26T15:05:27Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODE4NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558184", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MTA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 937e40c108f..185de9e86e8 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -167,30 +172,6 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n-    }\n-\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 185de9e86e8..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -172,9 +177,11 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 63523cb2234..13e8cb73dab 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -177,11 +102,33 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    Stream<DebugTypeInfo> typeInfoProvider();\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n+    }\n+\n+    DebugTypeInfoProvider typeInfoProvider();\n \n-    Stream<DebugCodeInfo> codeInfoProvider();\n+    DebugCodeInfoProvider codeInfoProvider();\n \n-    @SuppressWarnings(\"unused\")\n-    Stream<DebugDataInfo> dataInfoProvider();\n+    DebugDataInfoProvider dataInfoProvider();\n }\n", "next_change": {"commit": "4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 13e8cb73dab..444be49613a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -102,33 +167,9 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {\n-    }\n-\n-    /**\n-     * convenience interface defining iterator type.\n-     */\n-    interface DebugDataInfoProvider extends Iterable<DebugDataInfo> {\n-    }\n-\n-    DebugTypeInfoProvider typeInfoProvider();\n+    Stream<DebugTypeInfo> typeInfoProvider();\n \n-    DebugCodeInfoProvider codeInfoProvider();\n+    Stream<DebugCodeInfo> codeInfoProvider();\n \n-    DebugDataInfoProvider dataInfoProvider();\n+    Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\nindex 444be49613a..63523cb2234 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java\n", "chunk": "@@ -167,9 +177,11 @@ public interface DebugInfoProvider {\n         DebugFrameSizeChange.Type getType();\n     }\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugTypeInfo> typeInfoProvider();\n \n     Stream<DebugCodeInfo> codeInfoProvider();\n \n+    @SuppressWarnings(\"unused\")\n     Stream<DebugDataInfo> dataInfoProvider();\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384562450", "body": "How about\r\n```java\r\npublic enum SourceCacheType {\r\n    JDK(\"jdk\"),\r\n    GRAALVM(\"graal\"),\r\n    APPLICATION(\"src\");\r\n\r\n    final Path subdir;\r\n\r\n    SourceCacheType(String subdir) {\r\n        this.subdir = Paths.get(subdir);\r\n    }\r\n}\r\n```\r\ninstead of those `protected static final` fields ?", "bodyText": "How about\npublic enum SourceCacheType {\n    JDK(\"jdk\"),\n    GRAALVM(\"graal\"),\n    APPLICATION(\"src\");\n\n    final Path subdir;\n\n    SourceCacheType(String subdir) {\n        this.subdir = Paths.get(subdir);\n    }\n}\ninstead of those protected static final fields ?", "bodyHTML": "<p dir=\"auto\">How about</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public enum SourceCacheType {\n    JDK(&quot;jdk&quot;),\n    GRAALVM(&quot;graal&quot;),\n    APPLICATION(&quot;src&quot;);\n\n    final Path subdir;\n\n    SourceCacheType(String subdir) {\n        this.subdir = Paths.get(subdir);\n    }\n}\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">enum</span> <span class=\"pl-en\">SourceCacheType</span> {\n    <span class=\"pl-c1\">JDK</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>jdk<span class=\"pl-pds\">\"</span></span>),\n    <span class=\"pl-c1\">GRAALVM</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>graal<span class=\"pl-pds\">\"</span></span>),\n    <span class=\"pl-c1\">APPLICATION</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>src<span class=\"pl-pds\">\"</span></span>);\n\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Path</span> subdir;\n\n    <span class=\"pl-en\">SourceCacheType</span>(<span class=\"pl-smi\">String</span> <span class=\"pl-v\">subdir</span>) {\n        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>subdir <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Paths</span><span class=\"pl-k\">.</span>get(subdir);\n    }\n}</pre></div>\n<p dir=\"auto\">instead of those <code>protected static final</code> fields ?</p>", "author": "olpaw", "createdAt": "2020-02-26T15:21:52Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {\n+\n+    /*\n+     * properties needed to locate relevant JDK and app source roots\n+     */\n+    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n+    protected static final String JAVA_HOME_PROP = \"java.home\";\n+    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    /**\n+     * A list of root directories which may contain source files\n+     * from which this cache can be populated\n+     */\n+    protected List<Path> srcRoots;\n+\n+    /**\n+     * Create a source cache with a specific base type.\n+     * @param key a String identifying the subdir under\n+     * which sources should be cached which should also\n+     * match the type of content being cached\n+     */\n+    protected SourceCache(String key) {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+        srcRoots = new ArrayList<>();\n+\n+    }\n+\n+    /**\n+     * A local directory serving as the root for all\n+     * source trees maintained by the different\n+     * available source caches.\n+     */\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n+    /**\n+     * The top level path relative to the root directory\n+     * under which files belonging to this specific cache\n+     * are located.\n+     */\n+    private Path basePath;\n+    /**\n+     * JDK runtime code sources are cached using this key as a\n+     * leading path prefix with a module name as a sub-path\n+     * prefix when we have a modular JDK.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n+     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     */\n+    protected static final String JDK_CACHE_KEY = \"jdk\";", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MjY4OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384582688", "bodyText": "Yes, that looks better.", "author": "adinn", "createdAt": "2020-02-26T15:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNzM3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385127372", "bodyText": "I pushed this and used it to clean up the constructors for SourceCache and its subclasses", "author": "adinn", "createdAt": "2020-02-27T13:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\nindex 91384cfcb55..0507702ea3a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n", "chunk": "@@ -34,106 +42,67 @@ import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.FileTime;\n import java.util.ArrayList;\n import java.util.List;\n+\n /**\n- * An abstract cache manager for some subspace of the\n- * JDK, GraalVM or application source file space. This class\n- * implements core behaviours that manage a cache of source\n- * files in a specific subdirectory of the local sources\n- * directory. It allows source files to be located\n- * when present in the local cache or cached when not\n- * already present. Subclasses are responsible for providing\n- * behaviours that identify an original source for addition\n- * to the cache and for verifying that a cached file is not\n- * out of date with respect to its original.\n+ * An abstract cache manager for some subspace of the JDK, GraalVM or application source file space.\n+ * This class implements core behaviours that manage a cache of source files in a specific\n+ * subdirectory of the local sources directory. It allows source files to be located when present in\n+ * the local cache or cached when not already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition to the cache and for verifying that a\n+ * cached file is not out of date with respect to its original.\n  */\n \n public abstract class SourceCache {\n \n-    /*\n-     * properties needed to locate relevant JDK and app source roots\n+    /**\n+     * A list of all entries in the classpath used by the native image classloader\n      */\n-    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n-    protected static final String JAVA_HOME_PROP = \"java.home\";\n-    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    protected static final List<String> classPathEntries = new ArrayList<>();\n     /**\n-     * A list of root directories which may contain source files\n-     * from which this cache can be populated\n+     * A list of all entries in the classpath used by the native image classloader\n+     */\n+    protected static final List<String> sourcePathEntries = new ArrayList<>();\n+    /**\n+     * A list of root directories which may contain source files from which this cache can be\n+     * populated\n      */\n     protected List<Path> srcRoots;\n \n     /**\n-     * Create a source cache with a specific base type.\n-     * @param key a String identifying the subdir under\n-     * which sources should be cached which should also\n-     * match the type of content being cached\n+     * Create some flavour of source cache.\n      */\n-    protected SourceCache(String key) {\n-        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+    protected SourceCache() {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR).resolve(getType().getSubdir());\n         srcRoots = new ArrayList<>();\n-\n     }\n \n     /**\n-     * A local directory serving as the root for all\n-     * source trees maintained by the different\n-     * available source caches.\n-     */\n-    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n-    /**\n-     * The top level path relative to the root directory\n-     * under which files belonging to this specific cache\n-     * are located.\n-     */\n-    private Path basePath;\n-    /**\n-     * JDK runtime code sources are cached using this key as a\n-     * leading path prefix with a module name as a sub-path\n-     * prefix when we have a modular JDK.\n-     *\n-     * For example, the full file path to a file under the cache\n-     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n-     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     * Identify the specific type of this source cache\n+     * \n+     * @return the source cache type\n      */\n-    protected static final String JDK_CACHE_KEY = \"jdk\";\n+    protected abstract SourceCacheType getType();\n+\n     /**\n-     * GraalVM code sources are cached using this key as a\n-     * leading path prefix with an enclosing package name\n-     * and the name src or src_gen forming a sub-path prefix.\n-     *\n-     * For example, the full file path to a file under the cache\n-     * root directory might be\n-     * graal/com/oracle/svm/core/Isolates.java\n-     * or\n-     * graal/org/graalvm/compiler/core/phases/LowTier_OptionDescriptors.java\n+     * A local directory serving as the root for all source trees maintained by the different\n+     * available source caches.\n      */\n-    protected static final String GRAALVM_CACHE_KEY = \"graal\";\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n     /**\n-     * Application code sources are cached using this key as\n-     * a leading path prefix with a name or sequence of\n-     * names derived from a classpath jar or dir entry\n-     * employed as a sub-path prefix.\n-     *\n-     * For example, the full file path to a file under the cache\n-     * root directory might be\n-     * src/Hello.java\n-     * or\n-     * src/hello/impl/HelloImpl.java\n-     * or\n-     * src/hibernate-core-5.4.4.Final/org/hibernate/annotations/Entity.java\n+     * The top level path relative to the root directory under which files belonging to this\n+     * specific cache are located.\n      */\n-    protected static final String APPLICATION_CACHE_KEY = \"src\";\n+    private final Path basePath;\n+\n     /**\n-     * Cache the source file identified by the supplied prototype\n-     * path if a legitimate candidate for inclusion in this cache\n-     * can be identified and is not yet included in the cache or\n-     * alternatively identify and validate any existing candidate\n-     * cache entry to ensure it is not out of date refreshing it\n-     * if need be.\n+     * Cache the source file identified by the supplied prototype path if a legitimate candidate for\n+     * inclusion in this cache can be identified and is not yet included in the cache or\n+     * alternatively identify and validate any existing candidate cache entry to ensure it is not\n+     * out of date refreshing it if need be.\n      *\n-     * @param filePath a prototype path for a file to be included\n-     * in the cache derived from the name of some associated class.\n-     * @return a path identifying the cached file or null\n-     * if the candidate cannot be found.\n+     * @param filePath a prototype path for a file to be included in the cache derived from the name\n+     *            of some associated class.\n+     * @return a path identifying the cached file or null if the candidate cannot be found.\n      */\n     public Path resolve(Path filePath) {\n         File cachedFile = findCandidate(filePath);\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\ndeleted file mode 100644\nindex 0507702ea3a..00000000000\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n+++ /dev/null\n", "chunk": "@@ -1,336 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.svm.hosted.image.sources;\n-\n-import com.oracle.svm.core.SubstrateOptions;\n-import com.oracle.svm.core.annotate.AutomaticFeature;\n-import com.oracle.svm.core.option.OptionUtils;\n-import com.oracle.svm.hosted.FeatureImpl;\n-import com.oracle.svm.hosted.ImageClassLoader;\n-import org.graalvm.nativeimage.hosted.Feature;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.FileTime;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * An abstract cache manager for some subspace of the JDK, GraalVM or application source file space.\n- * This class implements core behaviours that manage a cache of source files in a specific\n- * subdirectory of the local sources directory. It allows source files to be located when present in\n- * the local cache or cached when not already present. Subclasses are responsible for providing\n- * behaviours that identify an original source for addition to the cache and for verifying that a\n- * cached file is not out of date with respect to its original.\n- */\n-\n-public abstract class SourceCache {\n-\n-    /**\n-     * A list of all entries in the classpath used by the native image classloader\n-     */\n-    protected static final List<String> classPathEntries = new ArrayList<>();\n-    /**\n-     * A list of all entries in the classpath used by the native image classloader\n-     */\n-    protected static final List<String> sourcePathEntries = new ArrayList<>();\n-    /**\n-     * A list of root directories which may contain source files from which this cache can be\n-     * populated\n-     */\n-    protected List<Path> srcRoots;\n-\n-    /**\n-     * Create some flavour of source cache.\n-     */\n-    protected SourceCache() {\n-        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR).resolve(getType().getSubdir());\n-        srcRoots = new ArrayList<>();\n-    }\n-\n-    /**\n-     * Identify the specific type of this source cache\n-     * \n-     * @return the source cache type\n-     */\n-    protected abstract SourceCacheType getType();\n-\n-    /**\n-     * A local directory serving as the root for all source trees maintained by the different\n-     * available source caches.\n-     */\n-    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n-    /**\n-     * The top level path relative to the root directory under which files belonging to this\n-     * specific cache are located.\n-     */\n-    private final Path basePath;\n-\n-    /**\n-     * Cache the source file identified by the supplied prototype path if a legitimate candidate for\n-     * inclusion in this cache can be identified and is not yet included in the cache or\n-     * alternatively identify and validate any existing candidate cache entry to ensure it is not\n-     * out of date refreshing it if need be.\n-     *\n-     * @param filePath a prototype path for a file to be included in the cache derived from the name\n-     *            of some associated class.\n-     * @return a path identifying the cached file or null if the candidate cannot be found.\n-     */\n-    public Path resolve(Path filePath) {\n-        File cachedFile = findCandidate(filePath);\n-        if (cachedFile == null) {\n-            return tryCacheFile(filePath);\n-        } else {\n-            return checkCacheFile(filePath);\n-        }\n-    }\n-\n-    /**\n-     * Given a prototype path for a file to be resolved return a File identifying a cached candidate\n-     * for for that Path or null if no cached candidate exists.\n-     * \n-     * @param filePath a prototype path for a file to be included in the cache derived from the name\n-     *            of some associated class.\n-     * @return a File identifying a cached candidate or null.\n-     */\n-    public File findCandidate(Path filePath) {\n-        /*\n-         * JDK source candidates are stored in the src.zip file using the path we are being asked\n-         * for. A cached version should exist under this cache's root using that same path.\n-         */\n-        File file = cachedFile(filePath);\n-        if (file.exists()) {\n-            return file;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Attempt to copy a source file from one of this cache's source roots to the local sources\n-     * directory storing it in the subdirectory that belongs to this cache.\n-     * \n-     * @param filePath a path appended to each of the cache's source roots in turn until an\n-     *            acceptable source file is found and copied to the local source directory.\n-     * @return the supplied path if the file has been located and copied to the local sources\n-     *         directory or null if it was not found or the copy failed.\n-     */\n-    public Path tryCacheFile(Path filePath) {\n-        for (Path root : srcRoots) {\n-            Path targetPath = cachedPath(filePath);\n-            Path sourcePath = extendPath(root, filePath);\n-            try {\n-                if (checkSourcePath(sourcePath)) {\n-                    ensureTargetDirs(targetPath.getParent());\n-                    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n-                    // return the original filePath\n-                    // we don't want the sources/jdk prefix to go into the debuginfo\n-                    return filePath;\n-                }\n-            } catch (IOException e) {\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Check whether the copy of a given source file in the local source cache is up to date with\n-     * respect to any original located in this cache's and if not copy the original to the\n-     * subdirectory that belongs to this cache.\n-     * \n-     * @param filePath a path appended to each of the cache's source roots in turn until an matching\n-     *            original source is found for comparison against the local source directory.\n-     * @return the supplied path if the file is up to date or if an updated version has been copied\n-     *         to the local sources directory or null if was not found or the copy failed.\n-     */\n-    public Path checkCacheFile(Path filePath) {\n-        Path targetPath = cachedPath(filePath);\n-        for (Path root : srcRoots) {\n-            Path sourcePath = extendPath(root, filePath);\n-            try {\n-                if (checkSourcePath(sourcePath)) {\n-                    FileTime sourceTime = Files.getLastModifiedTime(sourcePath);\n-                    FileTime destTime = Files.getLastModifiedTime(targetPath);\n-                    if (destTime.compareTo(sourceTime) < 0) {\n-                        try {\n-                            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n-                        } catch (IOException e) {\n-                            /* delete the target file as it is invalid */\n-                            targetPath.toFile().delete();\n-                            return null;\n-                        }\n-                    }\n-                    return filePath;\n-                }\n-            } catch (IOException e) {\n-                /* delete the target file as it is invalid */\n-                targetPath.toFile().delete();\n-                /* have another go at caching it */\n-                return tryCacheFile(filePath);\n-            }\n-        }\n-        /* delete the target file as it is invalid */\n-        targetPath.toFile().delete();\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Create and intialize the source cache used to locate and cache sources of a given type as\n-     * determined by the supplied key.\n-     * \n-     * @param type an enum identifying both the type of Java sources cached by the returned cache\n-     *            and the subdir of the cached source subdirectory in which those sources are\n-     *            located.\n-     * @return the desired source cache.\n-     */\n-    public static SourceCache createSourceCache(SourceCacheType type) {\n-        SourceCache sourceCache = null;\n-        switch (type) {\n-            case JDK:\n-                sourceCache = new JDKSourceCache();\n-                break;\n-            case GRAALVM:\n-                sourceCache = new GraalVMSourceCache();\n-                break;\n-            case APPLICATION:\n-                sourceCache = new ApplicationSourceCache();\n-                break;\n-            default:\n-                assert false;\n-        }\n-        return sourceCache;\n-    }\n-\n-    /**\n-     * Extend a root path form one file system using a path potentially derived from another file\n-     * system by converting he latter to a text string and replacing the file separator if\n-     * necessary.\n-     * \n-     * @param root the path to be extended\n-     * @param filePath the subpath to extend it with\n-     * @return the extended path\n-     */\n-    protected Path extendPath(Path root, Path filePath) {\n-        String filePathString = filePath.toString();\n-        String fileSeparator = filePath.getFileSystem().getSeparator();\n-        String newSeparator = root.getFileSystem().getSeparator();\n-        if (!fileSeparator.equals(newSeparator)) {\n-            filePathString = filePathString.replace(fileSeparator, newSeparator);\n-        }\n-        return root.resolve(filePathString);\n-    }\n-\n-    /**\n-     * Convert a potential resolved candidate path to the corresponding local Path in this cache.\n-     * \n-     * @param candidate a resolved candidate path for some given resolution request\n-     * @return the corresponding local Path\n-     */\n-    protected Path cachedPath(Path candidate) {\n-        return basePath.resolve(candidate);\n-    }\n-\n-    /**\n-     * Convert a potential resolved candidate path to the corresponding local File in this cache.\n-     * \n-     * @param candidate a resolved candidate path for some given resolution request\n-     * @return the corresponding local File\n-     */\n-    protected File cachedFile(Path candidate) {\n-        return cachedPath(candidate).toFile();\n-    }\n-\n-    /**\n-     * Indicate whether a source path identifies a file in the associated file system.\n-     * \n-     * @param sourcePath\n-     * @return true if the path identifies a file or false if no such file can be found.\n-     * @throws IOException if there is some error in resolving the path.\n-     */\n-    private static boolean checkSourcePath(Path sourcePath) throws IOException {\n-        return Files.isRegularFile(sourcePath);\n-    }\n-\n-    /**\n-     * Ensure the directory hierarchy for a path exists creating any missing directories if needed.\n-     * \n-     * @param targetDir a path to the desired directory\n-     * @throws IOException if it is not possible to create one or more directories in the path\n-     */\n-    private static void ensureTargetDirs(Path targetDir) throws IOException {\n-        if (targetDir != null) {\n-            File targetFile = targetDir.toFile();\n-            if (!targetFile.exists()) {\n-                targetDir.toFile().mkdirs();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Add a path to the list of classpath entries\n-     * \n-     * @param path The path to add.\n-     */\n-    private static void addClassPathEntry(String path) {\n-        classPathEntries.add(path);\n-    }\n-\n-    /**\n-     * Add a path to the list of source path entries\n-     * \n-     * @param path The path to add.\n-     */\n-    private static void addSourcePathEntry(String path) {\n-        sourcePathEntries.add(path);\n-    }\n-\n-    /**\n-     * An automatic feature class which acquires the image loader class path via the afterAnalysis\n-     * callback.\n-     */\n-    @AutomaticFeature\n-    public static class SourceCacheFeature implements Feature {\n-        @Override\n-        public void afterAnalysis(AfterAnalysisAccess access) {\n-            FeatureImpl.AfterAnalysisAccessImpl accessImpl = (FeatureImpl.AfterAnalysisAccessImpl) access;\n-            ImageClassLoader loader = accessImpl.getImageClassLoader();\n-            for (String entry : loader.getClasspath()) {\n-                addClassPathEntry(entry);\n-            }\n-            // also add any necessary source path entries\n-            if (SubstrateOptions.DebugInfoSourceSearchPath.getValue() != null) {\n-                for (String searchPathEntry : OptionUtils.flatten(\",\", SubstrateOptions.DebugInfoSourceSearchPath.getValue())) {\n-                    addSourcePathEntry(searchPathEntry);\n-                }\n-            }\n-        }\n-    }\n-}\n", "next_change": {"commit": "53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\nnew file mode 100644\nindex 00000000000..91384cfcb55\n--- /dev/null\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n", "chunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {\n+\n+    /*\n+     * properties needed to locate relevant JDK and app source roots\n+     */\n+    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n+    protected static final String JAVA_HOME_PROP = \"java.home\";\n+    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    /**\n+     * A list of root directories which may contain source files\n+     * from which this cache can be populated\n+     */\n+    protected List<Path> srcRoots;\n+\n+    /**\n+     * Create a source cache with a specific base type.\n+     * @param key a String identifying the subdir under\n+     * which sources should be cached which should also\n+     * match the type of content being cached\n+     */\n+    protected SourceCache(String key) {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+        srcRoots = new ArrayList<>();\n+\n+    }\n+\n+    /**\n+     * A local directory serving as the root for all\n+     * source trees maintained by the different\n+     * available source caches.\n+     */\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n+    /**\n+     * The top level path relative to the root directory\n+     * under which files belonging to this specific cache\n+     * are located.\n+     */\n+    private Path basePath;\n+    /**\n+     * JDK runtime code sources are cached using this key as a\n+     * leading path prefix with a module name as a sub-path\n+     * prefix when we have a modular JDK.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n+     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     */\n+    protected static final String JDK_CACHE_KEY = \"jdk\";\n+    /**\n+     * GraalVM code sources are cached using this key as a\n+     * leading path prefix with an enclosing package name\n+     * and the name src or src_gen forming a sub-path prefix.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be\n+     * graal/com/oracle/svm/core/Isolates.java\n+     * or\n+     * graal/org/graalvm/compiler/core/phases/LowTier_OptionDescriptors.java\n+     */\n+    protected static final String GRAALVM_CACHE_KEY = \"graal\";\n+    /**\n+     * Application code sources are cached using this key as\n+     * a leading path prefix with a name or sequence of\n+     * names derived from a classpath jar or dir entry\n+     * employed as a sub-path prefix.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be\n+     * src/Hello.java\n+     * or\n+     * src/hello/impl/HelloImpl.java\n+     * or\n+     * src/hibernate-core-5.4.4.Final/org/hibernate/annotations/Entity.java\n+     */\n+    protected static final String APPLICATION_CACHE_KEY = \"src\";\n+    /**\n+     * Cache the source file identified by the supplied prototype\n+     * path if a legitimate candidate for inclusion in this cache\n+     * can be identified and is not yet included in the cache or\n+     * alternatively identify and validate any existing candidate\n+     * cache entry to ensure it is not out of date refreshing it\n+     * if need be.\n+     *\n+     * @param filePath a prototype path for a file to be included\n+     * in the cache derived from the name of some associated class.\n+     * @return a path identifying the cached file or null\n+     * if the candidate cannot be found.\n+     */\n+    public Path resolve(Path filePath) {\n+        File cachedFile = findCandidate(filePath);\n+        if (cachedFile == null) {\n+            return tryCacheFile(filePath);\n+        } else {\n+            return checkCacheFile(filePath);\n+        }\n+    }\n+\n+    /**\n+     * Given a prototype path for a file to be resolved\n+     * return a File identifying a cached candidate for\n+     * for that Path or null if no cached candidate exists.\n+     * @param filePath  a prototype path for a file to be included\n+     * in the cache derived from the name of some associated class.\n+     * @return a File identifying a cached candidate or null.\n+     */\n+    public File findCandidate(Path filePath) {\n+        /*\n+         * JDK source candidates are stored in the src.zip file\n+         * using the path we are being asked for. A cached version\n+         * should exist under this cache's root using that same\n+         * path.\n+         */\n+        File file = cachedFile(filePath);\n+        if (file.exists()) {\n+            return file;\n+        }\n+        return null;\n+    }\n+    public Path tryCacheFile(Path filePath) {\n+        for (Path root : srcRoots) {\n+            Path targetPath = cachedPath(filePath);\n+            Path sourcePath = extendPath(root, filePath);\n+            try {\n+                if (checkSourcePath(sourcePath)) {\n+                    ensureTargetDirs(targetPath.getParent());\n+                    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n+                    // return the original filePath\n+                    // we don't want the sources/jdk prefix to go into the debuginfo\n+                    return filePath;\n+                }\n+            } catch (IOException e) {\n+            }\n+        }\n+        return null;\n+    }\n+    public Path checkCacheFile(Path filePath) {\n+        for (Path root : srcRoots) {\n+            Path targetPath = cachedPath(filePath);\n+            Path sourcePath = extendPath(root, filePath);\n+            try {\n+                if (checkSourcePath(sourcePath)) {\n+                    FileTime sourceTime = Files.getLastModifiedTime(sourcePath);\n+                    FileTime destTime = Files.getLastModifiedTime(targetPath);\n+                    if (destTime.compareTo(sourceTime) < 0) {\n+                        try {\n+                            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n+                        } catch (IOException e) {\n+                            return null;\n+                        }\n+                    }\n+                    return filePath;\n+                } else {\n+                    /* delete the target file as it is out of date */\n+                    targetPath.toFile().delete();\n+                }\n+            } catch (IOException e) {\n+                // hmm last modified time blew up?\n+                return tryCacheFile(filePath);\n+            }\n+        }\n+        return null;\n+    }\n+    /**\n+     * Create and intialize the source cache used to locate and cache\n+     * sources of a given type as determined by the supplied key.\n+     * @param type an enum identifying both the type of Java sources\n+     * cached by the returned cache and the subdir of the cached\n+     * source subdirectory in which those sources are located.\n+     * @return the desired source cache.\n+     */\n+    public static SourceCache createSourceCache(SourceCacheType type) {\n+        SourceCache sourceCache = null;\n+        switch (type) {\n+            case JDK:\n+                sourceCache = new JDKSourceCache();\n+                break;\n+            case GRAALVM:\n+                sourceCache = new GraalVMSourceCache();\n+                break;\n+            case APPLICATION:\n+                sourceCache = new ApplicationSourceCache();\n+                break;\n+            default:\n+                assert false;\n+        }\n+        return sourceCache;\n+    }\n+    /**\n+     * Extend a root path form one file system using a path potentially derived\n+     * from another file system by converting he latter to a text string and\n+     * replacing the file separator if necessary.\n+     * @param root the path to be extended\n+     * @param filePath the subpath to extend it with\n+     * @return the extended path\n+     */\n+    protected Path extendPath(Path root, Path filePath) {\n+        String filePathString = filePath.toString();\n+        String fileSeparator = filePath.getFileSystem().getSeparator();\n+        String newSeparator = root.getFileSystem().getSeparator();\n+        if (!fileSeparator.equals(newSeparator)) {\n+            filePathString = filePathString.replaceAll(fileSeparator, newSeparator);\n+        }\n+        return root.resolve(filePathString);\n+    }\n+\n+    /**\n+     * convert a potential resolved candidate path to\n+     * the corresponding local Path in this cache.\n+     * @param candidate a resolved candidate path for\n+     * some given resolution request\n+     * @return the corresponding local Path\n+     */\n+    protected Path cachedPath(Path candidate) {\n+        return basePath.resolve(candidate);\n+    }\n+    /**\n+     * convert a potential resolved candidate path to\n+     * the corresponding local File in this cache.\n+     * @param candidate a resolved candidate path for\n+     * some given resolution request\n+     * @return the corresponding local File\n+     */\n+    protected File cachedFile(Path candidate) {\n+        return cachedPath(candidate).toFile();\n+    }\n+    /**\n+     * indicate whether a source path identifies a fie in the associated file system\n+     * @param sourcePath\n+     * @return true if the path identifies a file or false if no such file can be found\n+     * @throws IOException if there is some error in resolving the path\n+     */\n+    private boolean checkSourcePath(Path sourcePath) throws IOException {\n+        return Files.isRegularFile(sourcePath);\n+    }\n+    /**\n+     * ensure the directory hierarchy for a path exists\n+     * creating any missing directories if needed\n+     * @param targetDir a path to the desired directory\n+     * @throws IOException if it is not possible to create\n+     * one or more directories in the path\n+     */\n+    private void ensureTargetDirs(Path targetDir) throws IOException {\n+        if (targetDir != null) {\n+            File targetFile = targetDir.toFile();\n+            if (!targetFile.exists()) {\n+                targetDir.toFile().mkdirs();\n+            }\n+        }\n+    }\n+}\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\nindex 91384cfcb55..0507702ea3a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n", "chunk": "@@ -296,4 +293,44 @@ public abstract class SourceCache {\n             }\n         }\n     }\n+\n+    /**\n+     * Add a path to the list of classpath entries\n+     * \n+     * @param path The path to add.\n+     */\n+    private static void addClassPathEntry(String path) {\n+        classPathEntries.add(path);\n+    }\n+\n+    /**\n+     * Add a path to the list of source path entries\n+     * \n+     * @param path The path to add.\n+     */\n+    private static void addSourcePathEntry(String path) {\n+        sourcePathEntries.add(path);\n+    }\n+\n+    /**\n+     * An automatic feature class which acquires the image loader class path via the afterAnalysis\n+     * callback.\n+     */\n+    @AutomaticFeature\n+    public static class SourceCacheFeature implements Feature {\n+        @Override\n+        public void afterAnalysis(AfterAnalysisAccess access) {\n+            FeatureImpl.AfterAnalysisAccessImpl accessImpl = (FeatureImpl.AfterAnalysisAccessImpl) access;\n+            ImageClassLoader loader = accessImpl.getImageClassLoader();\n+            for (String entry : loader.getClasspath()) {\n+                addClassPathEntry(entry);\n+            }\n+            // also add any necessary source path entries\n+            if (SubstrateOptions.DebugInfoSourceSearchPath.getValue() != null) {\n+                for (String searchPathEntry : OptionUtils.flatten(\",\", SubstrateOptions.DebugInfoSourceSearchPath.getValue())) {\n+                    addSourcePathEntry(searchPathEntry);\n+                }\n+            }\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDA4OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384580088", "body": "adding\r\n```\r\nabstract SourceCacheType getType();\r\n```\r\ncould probably be handy at some point. ", "bodyText": "adding\nabstract SourceCacheType getType();\n\ncould probably be handy at some point.", "bodyHTML": "<p dir=\"auto\">adding</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"abstract SourceCacheType getType();\"><pre><code>abstract SourceCacheType getType();\n</code></pre></div>\n<p dir=\"auto\">could probably be handy at some point.</p>", "author": "olpaw", "createdAt": "2020-02-26T15:46:25Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNzYzOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385127639", "bodyText": "Yes, I now use this in the cache constructors.", "author": "adinn", "createdAt": "2020-02-27T13:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDA4OA=="}], "type": "inlineReview", "revised_code": {"commit": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\nindex 91384cfcb55..0507702ea3a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n", "chunk": "@@ -34,106 +42,67 @@ import java.nio.file.StandardCopyOption;\n import java.nio.file.attribute.FileTime;\n import java.util.ArrayList;\n import java.util.List;\n+\n /**\n- * An abstract cache manager for some subspace of the\n- * JDK, GraalVM or application source file space. This class\n- * implements core behaviours that manage a cache of source\n- * files in a specific subdirectory of the local sources\n- * directory. It allows source files to be located\n- * when present in the local cache or cached when not\n- * already present. Subclasses are responsible for providing\n- * behaviours that identify an original source for addition\n- * to the cache and for verifying that a cached file is not\n- * out of date with respect to its original.\n+ * An abstract cache manager for some subspace of the JDK, GraalVM or application source file space.\n+ * This class implements core behaviours that manage a cache of source files in a specific\n+ * subdirectory of the local sources directory. It allows source files to be located when present in\n+ * the local cache or cached when not already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition to the cache and for verifying that a\n+ * cached file is not out of date with respect to its original.\n  */\n \n public abstract class SourceCache {\n \n-    /*\n-     * properties needed to locate relevant JDK and app source roots\n+    /**\n+     * A list of all entries in the classpath used by the native image classloader\n      */\n-    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n-    protected static final String JAVA_HOME_PROP = \"java.home\";\n-    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    protected static final List<String> classPathEntries = new ArrayList<>();\n     /**\n-     * A list of root directories which may contain source files\n-     * from which this cache can be populated\n+     * A list of all entries in the classpath used by the native image classloader\n+     */\n+    protected static final List<String> sourcePathEntries = new ArrayList<>();\n+    /**\n+     * A list of root directories which may contain source files from which this cache can be\n+     * populated\n      */\n     protected List<Path> srcRoots;\n \n     /**\n-     * Create a source cache with a specific base type.\n-     * @param key a String identifying the subdir under\n-     * which sources should be cached which should also\n-     * match the type of content being cached\n+     * Create some flavour of source cache.\n      */\n-    protected SourceCache(String key) {\n-        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+    protected SourceCache() {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR).resolve(getType().getSubdir());\n         srcRoots = new ArrayList<>();\n-\n     }\n \n     /**\n-     * A local directory serving as the root for all\n-     * source trees maintained by the different\n-     * available source caches.\n-     */\n-    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n-    /**\n-     * The top level path relative to the root directory\n-     * under which files belonging to this specific cache\n-     * are located.\n-     */\n-    private Path basePath;\n-    /**\n-     * JDK runtime code sources are cached using this key as a\n-     * leading path prefix with a module name as a sub-path\n-     * prefix when we have a modular JDK.\n-     *\n-     * For example, the full file path to a file under the cache\n-     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n-     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     * Identify the specific type of this source cache\n+     * \n+     * @return the source cache type\n      */\n-    protected static final String JDK_CACHE_KEY = \"jdk\";\n+    protected abstract SourceCacheType getType();\n+\n     /**\n-     * GraalVM code sources are cached using this key as a\n-     * leading path prefix with an enclosing package name\n-     * and the name src or src_gen forming a sub-path prefix.\n-     *\n-     * For example, the full file path to a file under the cache\n-     * root directory might be\n-     * graal/com/oracle/svm/core/Isolates.java\n-     * or\n-     * graal/org/graalvm/compiler/core/phases/LowTier_OptionDescriptors.java\n+     * A local directory serving as the root for all source trees maintained by the different\n+     * available source caches.\n      */\n-    protected static final String GRAALVM_CACHE_KEY = \"graal\";\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n     /**\n-     * Application code sources are cached using this key as\n-     * a leading path prefix with a name or sequence of\n-     * names derived from a classpath jar or dir entry\n-     * employed as a sub-path prefix.\n-     *\n-     * For example, the full file path to a file under the cache\n-     * root directory might be\n-     * src/Hello.java\n-     * or\n-     * src/hello/impl/HelloImpl.java\n-     * or\n-     * src/hibernate-core-5.4.4.Final/org/hibernate/annotations/Entity.java\n+     * The top level path relative to the root directory under which files belonging to this\n+     * specific cache are located.\n      */\n-    protected static final String APPLICATION_CACHE_KEY = \"src\";\n+    private final Path basePath;\n+\n     /**\n-     * Cache the source file identified by the supplied prototype\n-     * path if a legitimate candidate for inclusion in this cache\n-     * can be identified and is not yet included in the cache or\n-     * alternatively identify and validate any existing candidate\n-     * cache entry to ensure it is not out of date refreshing it\n-     * if need be.\n+     * Cache the source file identified by the supplied prototype path if a legitimate candidate for\n+     * inclusion in this cache can be identified and is not yet included in the cache or\n+     * alternatively identify and validate any existing candidate cache entry to ensure it is not\n+     * out of date refreshing it if need be.\n      *\n-     * @param filePath a prototype path for a file to be included\n-     * in the cache derived from the name of some associated class.\n-     * @return a path identifying the cached file or null\n-     * if the candidate cannot be found.\n+     * @param filePath a prototype path for a file to be included in the cache derived from the name\n+     *            of some associated class.\n+     * @return a path identifying the cached file or null if the candidate cannot be found.\n      */\n     public Path resolve(Path filePath) {\n         File cachedFile = findCandidate(filePath);\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\ndeleted file mode 100644\nindex 0507702ea3a..00000000000\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n+++ /dev/null\n", "chunk": "@@ -1,336 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.svm.hosted.image.sources;\n-\n-import com.oracle.svm.core.SubstrateOptions;\n-import com.oracle.svm.core.annotate.AutomaticFeature;\n-import com.oracle.svm.core.option.OptionUtils;\n-import com.oracle.svm.hosted.FeatureImpl;\n-import com.oracle.svm.hosted.ImageClassLoader;\n-import org.graalvm.nativeimage.hosted.Feature;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.FileTime;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * An abstract cache manager for some subspace of the JDK, GraalVM or application source file space.\n- * This class implements core behaviours that manage a cache of source files in a specific\n- * subdirectory of the local sources directory. It allows source files to be located when present in\n- * the local cache or cached when not already present. Subclasses are responsible for providing\n- * behaviours that identify an original source for addition to the cache and for verifying that a\n- * cached file is not out of date with respect to its original.\n- */\n-\n-public abstract class SourceCache {\n-\n-    /**\n-     * A list of all entries in the classpath used by the native image classloader\n-     */\n-    protected static final List<String> classPathEntries = new ArrayList<>();\n-    /**\n-     * A list of all entries in the classpath used by the native image classloader\n-     */\n-    protected static final List<String> sourcePathEntries = new ArrayList<>();\n-    /**\n-     * A list of root directories which may contain source files from which this cache can be\n-     * populated\n-     */\n-    protected List<Path> srcRoots;\n-\n-    /**\n-     * Create some flavour of source cache.\n-     */\n-    protected SourceCache() {\n-        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR).resolve(getType().getSubdir());\n-        srcRoots = new ArrayList<>();\n-    }\n-\n-    /**\n-     * Identify the specific type of this source cache\n-     * \n-     * @return the source cache type\n-     */\n-    protected abstract SourceCacheType getType();\n-\n-    /**\n-     * A local directory serving as the root for all source trees maintained by the different\n-     * available source caches.\n-     */\n-    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n-    /**\n-     * The top level path relative to the root directory under which files belonging to this\n-     * specific cache are located.\n-     */\n-    private final Path basePath;\n-\n-    /**\n-     * Cache the source file identified by the supplied prototype path if a legitimate candidate for\n-     * inclusion in this cache can be identified and is not yet included in the cache or\n-     * alternatively identify and validate any existing candidate cache entry to ensure it is not\n-     * out of date refreshing it if need be.\n-     *\n-     * @param filePath a prototype path for a file to be included in the cache derived from the name\n-     *            of some associated class.\n-     * @return a path identifying the cached file or null if the candidate cannot be found.\n-     */\n-    public Path resolve(Path filePath) {\n-        File cachedFile = findCandidate(filePath);\n-        if (cachedFile == null) {\n-            return tryCacheFile(filePath);\n-        } else {\n-            return checkCacheFile(filePath);\n-        }\n-    }\n-\n-    /**\n-     * Given a prototype path for a file to be resolved return a File identifying a cached candidate\n-     * for for that Path or null if no cached candidate exists.\n-     * \n-     * @param filePath a prototype path for a file to be included in the cache derived from the name\n-     *            of some associated class.\n-     * @return a File identifying a cached candidate or null.\n-     */\n-    public File findCandidate(Path filePath) {\n-        /*\n-         * JDK source candidates are stored in the src.zip file using the path we are being asked\n-         * for. A cached version should exist under this cache's root using that same path.\n-         */\n-        File file = cachedFile(filePath);\n-        if (file.exists()) {\n-            return file;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Attempt to copy a source file from one of this cache's source roots to the local sources\n-     * directory storing it in the subdirectory that belongs to this cache.\n-     * \n-     * @param filePath a path appended to each of the cache's source roots in turn until an\n-     *            acceptable source file is found and copied to the local source directory.\n-     * @return the supplied path if the file has been located and copied to the local sources\n-     *         directory or null if it was not found or the copy failed.\n-     */\n-    public Path tryCacheFile(Path filePath) {\n-        for (Path root : srcRoots) {\n-            Path targetPath = cachedPath(filePath);\n-            Path sourcePath = extendPath(root, filePath);\n-            try {\n-                if (checkSourcePath(sourcePath)) {\n-                    ensureTargetDirs(targetPath.getParent());\n-                    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n-                    // return the original filePath\n-                    // we don't want the sources/jdk prefix to go into the debuginfo\n-                    return filePath;\n-                }\n-            } catch (IOException e) {\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Check whether the copy of a given source file in the local source cache is up to date with\n-     * respect to any original located in this cache's and if not copy the original to the\n-     * subdirectory that belongs to this cache.\n-     * \n-     * @param filePath a path appended to each of the cache's source roots in turn until an matching\n-     *            original source is found for comparison against the local source directory.\n-     * @return the supplied path if the file is up to date or if an updated version has been copied\n-     *         to the local sources directory or null if was not found or the copy failed.\n-     */\n-    public Path checkCacheFile(Path filePath) {\n-        Path targetPath = cachedPath(filePath);\n-        for (Path root : srcRoots) {\n-            Path sourcePath = extendPath(root, filePath);\n-            try {\n-                if (checkSourcePath(sourcePath)) {\n-                    FileTime sourceTime = Files.getLastModifiedTime(sourcePath);\n-                    FileTime destTime = Files.getLastModifiedTime(targetPath);\n-                    if (destTime.compareTo(sourceTime) < 0) {\n-                        try {\n-                            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n-                        } catch (IOException e) {\n-                            /* delete the target file as it is invalid */\n-                            targetPath.toFile().delete();\n-                            return null;\n-                        }\n-                    }\n-                    return filePath;\n-                }\n-            } catch (IOException e) {\n-                /* delete the target file as it is invalid */\n-                targetPath.toFile().delete();\n-                /* have another go at caching it */\n-                return tryCacheFile(filePath);\n-            }\n-        }\n-        /* delete the target file as it is invalid */\n-        targetPath.toFile().delete();\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Create and intialize the source cache used to locate and cache sources of a given type as\n-     * determined by the supplied key.\n-     * \n-     * @param type an enum identifying both the type of Java sources cached by the returned cache\n-     *            and the subdir of the cached source subdirectory in which those sources are\n-     *            located.\n-     * @return the desired source cache.\n-     */\n-    public static SourceCache createSourceCache(SourceCacheType type) {\n-        SourceCache sourceCache = null;\n-        switch (type) {\n-            case JDK:\n-                sourceCache = new JDKSourceCache();\n-                break;\n-            case GRAALVM:\n-                sourceCache = new GraalVMSourceCache();\n-                break;\n-            case APPLICATION:\n-                sourceCache = new ApplicationSourceCache();\n-                break;\n-            default:\n-                assert false;\n-        }\n-        return sourceCache;\n-    }\n-\n-    /**\n-     * Extend a root path form one file system using a path potentially derived from another file\n-     * system by converting he latter to a text string and replacing the file separator if\n-     * necessary.\n-     * \n-     * @param root the path to be extended\n-     * @param filePath the subpath to extend it with\n-     * @return the extended path\n-     */\n-    protected Path extendPath(Path root, Path filePath) {\n-        String filePathString = filePath.toString();\n-        String fileSeparator = filePath.getFileSystem().getSeparator();\n-        String newSeparator = root.getFileSystem().getSeparator();\n-        if (!fileSeparator.equals(newSeparator)) {\n-            filePathString = filePathString.replace(fileSeparator, newSeparator);\n-        }\n-        return root.resolve(filePathString);\n-    }\n-\n-    /**\n-     * Convert a potential resolved candidate path to the corresponding local Path in this cache.\n-     * \n-     * @param candidate a resolved candidate path for some given resolution request\n-     * @return the corresponding local Path\n-     */\n-    protected Path cachedPath(Path candidate) {\n-        return basePath.resolve(candidate);\n-    }\n-\n-    /**\n-     * Convert a potential resolved candidate path to the corresponding local File in this cache.\n-     * \n-     * @param candidate a resolved candidate path for some given resolution request\n-     * @return the corresponding local File\n-     */\n-    protected File cachedFile(Path candidate) {\n-        return cachedPath(candidate).toFile();\n-    }\n-\n-    /**\n-     * Indicate whether a source path identifies a file in the associated file system.\n-     * \n-     * @param sourcePath\n-     * @return true if the path identifies a file or false if no such file can be found.\n-     * @throws IOException if there is some error in resolving the path.\n-     */\n-    private static boolean checkSourcePath(Path sourcePath) throws IOException {\n-        return Files.isRegularFile(sourcePath);\n-    }\n-\n-    /**\n-     * Ensure the directory hierarchy for a path exists creating any missing directories if needed.\n-     * \n-     * @param targetDir a path to the desired directory\n-     * @throws IOException if it is not possible to create one or more directories in the path\n-     */\n-    private static void ensureTargetDirs(Path targetDir) throws IOException {\n-        if (targetDir != null) {\n-            File targetFile = targetDir.toFile();\n-            if (!targetFile.exists()) {\n-                targetDir.toFile().mkdirs();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Add a path to the list of classpath entries\n-     * \n-     * @param path The path to add.\n-     */\n-    private static void addClassPathEntry(String path) {\n-        classPathEntries.add(path);\n-    }\n-\n-    /**\n-     * Add a path to the list of source path entries\n-     * \n-     * @param path The path to add.\n-     */\n-    private static void addSourcePathEntry(String path) {\n-        sourcePathEntries.add(path);\n-    }\n-\n-    /**\n-     * An automatic feature class which acquires the image loader class path via the afterAnalysis\n-     * callback.\n-     */\n-    @AutomaticFeature\n-    public static class SourceCacheFeature implements Feature {\n-        @Override\n-        public void afterAnalysis(AfterAnalysisAccess access) {\n-            FeatureImpl.AfterAnalysisAccessImpl accessImpl = (FeatureImpl.AfterAnalysisAccessImpl) access;\n-            ImageClassLoader loader = accessImpl.getImageClassLoader();\n-            for (String entry : loader.getClasspath()) {\n-                addClassPathEntry(entry);\n-            }\n-            // also add any necessary source path entries\n-            if (SubstrateOptions.DebugInfoSourceSearchPath.getValue() != null) {\n-                for (String searchPathEntry : OptionUtils.flatten(\",\", SubstrateOptions.DebugInfoSourceSearchPath.getValue())) {\n-                    addSourcePathEntry(searchPathEntry);\n-                }\n-            }\n-        }\n-    }\n-}\n", "next_change": {"commit": "53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\nnew file mode 100644\nindex 00000000000..91384cfcb55\n--- /dev/null\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n", "chunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {\n+\n+    /*\n+     * properties needed to locate relevant JDK and app source roots\n+     */\n+    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n+    protected static final String JAVA_HOME_PROP = \"java.home\";\n+    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    /**\n+     * A list of root directories which may contain source files\n+     * from which this cache can be populated\n+     */\n+    protected List<Path> srcRoots;\n+\n+    /**\n+     * Create a source cache with a specific base type.\n+     * @param key a String identifying the subdir under\n+     * which sources should be cached which should also\n+     * match the type of content being cached\n+     */\n+    protected SourceCache(String key) {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+        srcRoots = new ArrayList<>();\n+\n+    }\n+\n+    /**\n+     * A local directory serving as the root for all\n+     * source trees maintained by the different\n+     * available source caches.\n+     */\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n+    /**\n+     * The top level path relative to the root directory\n+     * under which files belonging to this specific cache\n+     * are located.\n+     */\n+    private Path basePath;\n+    /**\n+     * JDK runtime code sources are cached using this key as a\n+     * leading path prefix with a module name as a sub-path\n+     * prefix when we have a modular JDK.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n+     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     */\n+    protected static final String JDK_CACHE_KEY = \"jdk\";\n+    /**\n+     * GraalVM code sources are cached using this key as a\n+     * leading path prefix with an enclosing package name\n+     * and the name src or src_gen forming a sub-path prefix.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be\n+     * graal/com/oracle/svm/core/Isolates.java\n+     * or\n+     * graal/org/graalvm/compiler/core/phases/LowTier_OptionDescriptors.java\n+     */\n+    protected static final String GRAALVM_CACHE_KEY = \"graal\";\n+    /**\n+     * Application code sources are cached using this key as\n+     * a leading path prefix with a name or sequence of\n+     * names derived from a classpath jar or dir entry\n+     * employed as a sub-path prefix.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be\n+     * src/Hello.java\n+     * or\n+     * src/hello/impl/HelloImpl.java\n+     * or\n+     * src/hibernate-core-5.4.4.Final/org/hibernate/annotations/Entity.java\n+     */\n+    protected static final String APPLICATION_CACHE_KEY = \"src\";\n+    /**\n+     * Cache the source file identified by the supplied prototype\n+     * path if a legitimate candidate for inclusion in this cache\n+     * can be identified and is not yet included in the cache or\n+     * alternatively identify and validate any existing candidate\n+     * cache entry to ensure it is not out of date refreshing it\n+     * if need be.\n+     *\n+     * @param filePath a prototype path for a file to be included\n+     * in the cache derived from the name of some associated class.\n+     * @return a path identifying the cached file or null\n+     * if the candidate cannot be found.\n+     */\n+    public Path resolve(Path filePath) {\n+        File cachedFile = findCandidate(filePath);\n+        if (cachedFile == null) {\n+            return tryCacheFile(filePath);\n+        } else {\n+            return checkCacheFile(filePath);\n+        }\n+    }\n+\n+    /**\n+     * Given a prototype path for a file to be resolved\n+     * return a File identifying a cached candidate for\n+     * for that Path or null if no cached candidate exists.\n+     * @param filePath  a prototype path for a file to be included\n+     * in the cache derived from the name of some associated class.\n+     * @return a File identifying a cached candidate or null.\n+     */\n+    public File findCandidate(Path filePath) {\n+        /*\n+         * JDK source candidates are stored in the src.zip file\n+         * using the path we are being asked for. A cached version\n+         * should exist under this cache's root using that same\n+         * path.\n+         */\n+        File file = cachedFile(filePath);\n+        if (file.exists()) {\n+            return file;\n+        }\n+        return null;\n+    }\n+    public Path tryCacheFile(Path filePath) {\n+        for (Path root : srcRoots) {\n+            Path targetPath = cachedPath(filePath);\n+            Path sourcePath = extendPath(root, filePath);\n+            try {\n+                if (checkSourcePath(sourcePath)) {\n+                    ensureTargetDirs(targetPath.getParent());\n+                    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n+                    // return the original filePath\n+                    // we don't want the sources/jdk prefix to go into the debuginfo\n+                    return filePath;\n+                }\n+            } catch (IOException e) {\n+            }\n+        }\n+        return null;\n+    }\n+    public Path checkCacheFile(Path filePath) {\n+        for (Path root : srcRoots) {\n+            Path targetPath = cachedPath(filePath);\n+            Path sourcePath = extendPath(root, filePath);\n+            try {\n+                if (checkSourcePath(sourcePath)) {\n+                    FileTime sourceTime = Files.getLastModifiedTime(sourcePath);\n+                    FileTime destTime = Files.getLastModifiedTime(targetPath);\n+                    if (destTime.compareTo(sourceTime) < 0) {\n+                        try {\n+                            Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);\n+                        } catch (IOException e) {\n+                            return null;\n+                        }\n+                    }\n+                    return filePath;\n+                } else {\n+                    /* delete the target file as it is out of date */\n+                    targetPath.toFile().delete();\n+                }\n+            } catch (IOException e) {\n+                // hmm last modified time blew up?\n+                return tryCacheFile(filePath);\n+            }\n+        }\n+        return null;\n+    }\n+    /**\n+     * Create and intialize the source cache used to locate and cache\n+     * sources of a given type as determined by the supplied key.\n+     * @param type an enum identifying both the type of Java sources\n+     * cached by the returned cache and the subdir of the cached\n+     * source subdirectory in which those sources are located.\n+     * @return the desired source cache.\n+     */\n+    public static SourceCache createSourceCache(SourceCacheType type) {\n+        SourceCache sourceCache = null;\n+        switch (type) {\n+            case JDK:\n+                sourceCache = new JDKSourceCache();\n+                break;\n+            case GRAALVM:\n+                sourceCache = new GraalVMSourceCache();\n+                break;\n+            case APPLICATION:\n+                sourceCache = new ApplicationSourceCache();\n+                break;\n+            default:\n+                assert false;\n+        }\n+        return sourceCache;\n+    }\n+    /**\n+     * Extend a root path form one file system using a path potentially derived\n+     * from another file system by converting he latter to a text string and\n+     * replacing the file separator if necessary.\n+     * @param root the path to be extended\n+     * @param filePath the subpath to extend it with\n+     * @return the extended path\n+     */\n+    protected Path extendPath(Path root, Path filePath) {\n+        String filePathString = filePath.toString();\n+        String fileSeparator = filePath.getFileSystem().getSeparator();\n+        String newSeparator = root.getFileSystem().getSeparator();\n+        if (!fileSeparator.equals(newSeparator)) {\n+            filePathString = filePathString.replaceAll(fileSeparator, newSeparator);\n+        }\n+        return root.resolve(filePathString);\n+    }\n+\n+    /**\n+     * convert a potential resolved candidate path to\n+     * the corresponding local Path in this cache.\n+     * @param candidate a resolved candidate path for\n+     * some given resolution request\n+     * @return the corresponding local Path\n+     */\n+    protected Path cachedPath(Path candidate) {\n+        return basePath.resolve(candidate);\n+    }\n+    /**\n+     * convert a potential resolved candidate path to\n+     * the corresponding local File in this cache.\n+     * @param candidate a resolved candidate path for\n+     * some given resolution request\n+     * @return the corresponding local File\n+     */\n+    protected File cachedFile(Path candidate) {\n+        return cachedPath(candidate).toFile();\n+    }\n+    /**\n+     * indicate whether a source path identifies a fie in the associated file system\n+     * @param sourcePath\n+     * @return true if the path identifies a file or false if no such file can be found\n+     * @throws IOException if there is some error in resolving the path\n+     */\n+    private boolean checkSourcePath(Path sourcePath) throws IOException {\n+        return Files.isRegularFile(sourcePath);\n+    }\n+    /**\n+     * ensure the directory hierarchy for a path exists\n+     * creating any missing directories if needed\n+     * @param targetDir a path to the desired directory\n+     * @throws IOException if it is not possible to create\n+     * one or more directories in the path\n+     */\n+    private void ensureTargetDirs(Path targetDir) throws IOException {\n+        if (targetDir != null) {\n+            File targetFile = targetDir.toFile();\n+            if (!targetFile.exists()) {\n+                targetDir.toFile().mkdirs();\n+            }\n+        }\n+    }\n+}\n", "next_change": {"commit": "259171c5618e71769cbc7610e0ffc136d7d77562", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\nindex 91384cfcb55..0507702ea3a 100644\n--- a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n+++ b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java\n", "chunk": "@@ -296,4 +293,44 @@ public abstract class SourceCache {\n             }\n         }\n     }\n+\n+    /**\n+     * Add a path to the list of classpath entries\n+     * \n+     * @param path The path to add.\n+     */\n+    private static void addClassPathEntry(String path) {\n+        classPathEntries.add(path);\n+    }\n+\n+    /**\n+     * Add a path to the list of source path entries\n+     * \n+     * @param path The path to add.\n+     */\n+    private static void addSourcePathEntry(String path) {\n+        sourcePathEntries.add(path);\n+    }\n+\n+    /**\n+     * An automatic feature class which acquires the image loader class path via the afterAnalysis\n+     * callback.\n+     */\n+    @AutomaticFeature\n+    public static class SourceCacheFeature implements Feature {\n+        @Override\n+        public void afterAnalysis(AfterAnalysisAccess access) {\n+            FeatureImpl.AfterAnalysisAccessImpl accessImpl = (FeatureImpl.AfterAnalysisAccessImpl) access;\n+            ImageClassLoader loader = accessImpl.getImageClassLoader();\n+            for (String entry : loader.getClasspath()) {\n+                addClassPathEntry(entry);\n+            }\n+            // also add any necessary source path entries\n+            if (SubstrateOptions.DebugInfoSourceSearchPath.getValue() != null) {\n+                for (String searchPathEntry : OptionUtils.flatten(\",\", SubstrateOptions.DebugInfoSourceSearchPath.getValue())) {\n+                    addSourcePathEntry(searchPathEntry);\n+                }\n+            }\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"oid": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "url": "https://github.com/oracle/graal/commit/ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "message": "more format changes and fix some small errors in graal cache", "committedDate": "2020-03-10T14:47:11Z", "type": "forcePushed"}, {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "url": "https://github.com/oracle/graal/commit/c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "message": "support tracing of DWARF debug info modelling and generation to file using a debugContext provided via either the DebugInfoProvider API or via the ObjectFile", "committedDate": "2020-03-17T15:13:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395079448", "body": "If the return value is not used anywhere use `java.util.function.Consumer` instead `Function` of to avoid pointless code such as\r\n```\r\n    // doesn't actually matter what we return\r\n    return true;\r\n```", "bodyText": "If the return value is not used anywhere use java.util.function.Consumer instead Function of to avoid pointless code such as\n    // doesn't actually matter what we return\n    return true;", "bodyHTML": "<p dir=\"auto\">If the return value is not used anywhere use <code>java.util.function.Consumer</code> instead <code>Function</code> of to avoid pointless code such as</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    // doesn't actually matter what we return\n    return true;\"><pre><code>    // doesn't actually matter what we return\n    return true;\n</code></pre></div>", "author": "olpaw", "createdAt": "2020-03-19T14:43:33Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java", "diffHunk": "@@ -1725,4 +1741,49 @@ public final SymbolTable getOrCreateSymbolTable() {\n             return createSymbolTable();\n         }\n     }\n+\n+    /**\n+     * Temporary storage for a debug context installed in a nested scope under a call.\n+     * to {@link #withDebugContext}\n+     */\n+    private DebugContext debugContext = null;\n+\n+    /**\n+     * Allows a function to be executed with a specific debug context in a named subscope bound to\n+     * the object file and accessible to code invoked during the lifetime of the function. Invoked\n+     * code may obtain access to the debug context using method {@link #debugContext}.\n+     * @param context a context to be bound toin the object file for the duration of the function\n+     *        execution.\n+     * @param scopeName a name to be used to define a subscope current while the function is being\n+     *        executed.\n+     * @param t a value to be injected into the function that performs the action.\n+     * @param function a function to be executed while the context is bound to the object file.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public <T, R> R withDebugContext(DebugContext context,  String scopeName, T t, Function<T, R> function) {", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MTU3MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395091570", "bodyText": "Actually you can even make that a Runnable. The passing of the channel like this is pointless ceremony.\nThen in com/oracle/svm/hosted/image/NativeBootImage.java you just have\ntry (FileChannel channel = FileChannel.open(outputFile, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE)) {\n    objectFile.withDebugContext(context, \"ObjectFile.write\", () -> {\n        objectFile.write(channel);\n    });\n}\n\nRemember this is not C++ ;-)", "author": "olpaw", "createdAt": "2020-03-19T14:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0MDAwNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395140007", "bodyText": "Well, I did start with a Consumer and then changed to a Function just in case you might want a more future-proof API. I was thinking it might later be decided that some other step of the ObjectFile write might need tracing and we could employ this Function flavour of withDebugContext where the operation needs to return a result. I'll happily switch to Consumer/Runnable. We can always switch back to Function if the need arises.\nAnd don't worry I have as little urge to use C++ features as the next OpenJDK programmer (well, modulo a few project 'enthusiasts' whose love of obscure C++ truly baffles me). Now Lisp would be a different matter . . . ;-)", "author": "adinn", "createdAt": "2020-03-19T16:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA=="}], "type": "inlineReview", "revised_code": {"commit": "648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex c21e161625a..e5013c66b3a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -1749,21 +1748,20 @@ public abstract class ObjectFile {\n     private DebugContext debugContext = null;\n \n     /**\n-     * Allows a function to be executed with a specific debug context in a named subscope bound to\n-     * the object file and accessible to code invoked during the lifetime of the function. Invoked\n+     * Allows a task to be executed with a debug context in a named subscope bound to the\n+     * object file and accessible to code executed during the lifetime of the task. Invoked\n      * code may obtain access to the debug context using method {@link #debugContext}.\n-     * @param context a context to be bound toin the object file for the duration of the function\n+     * @param context a context to be bound to the object file for the duration of the task\n      *        execution.\n-     * @param scopeName a name to be used to define a subscope current while the function is being\n+     * @param scopeName a name to be used to define a subscope current while the task is being\n      *        executed.\n-     * @param t a value to be injected into the function that performs the action.\n-     * @param function a function to be executed while the context is bound to the object file.\n+     * @param task a task to be executed while the context is bound to the object file.\n      */\n     @SuppressWarnings(\"try\")\n-    public <T, R> R withDebugContext(DebugContext context,  String scopeName, T t, Function<T, R> function) {\n+    public void withDebugContext(DebugContext context,  String scopeName, Runnable task) {\n         try (DebugContext.Scope s = context.scope(scopeName)) {\n             this.debugContext = context;\n-            return function.apply(t);\n+            task.run();\n         } catch (Throwable e) {\n             throw debugContext.handle(e);\n         } finally {\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex e5013c66b3a..c9dabe238e1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -1742,23 +1741,24 @@ public abstract class ObjectFile {\n     }\n \n     /**\n-     * Temporary storage for a debug context installed in a nested scope under a call.\n-     * to {@link #withDebugContext}\n+     * Temporary storage for a debug context installed in a nested scope under a call. to\n+     * {@link #withDebugContext}\n      */\n     private DebugContext debugContext = null;\n \n     /**\n-     * Allows a task to be executed with a debug context in a named subscope bound to the\n-     * object file and accessible to code executed during the lifetime of the task. Invoked\n-     * code may obtain access to the debug context using method {@link #debugContext}.\n+     * Allows a task to be executed with a debug context in a named subscope bound to the object\n+     * file and accessible to code executed during the lifetime of the task. Invoked code may obtain\n+     * access to the debug context using method {@link #debugContext}.\n+     * \n      * @param context a context to be bound to the object file for the duration of the task\n-     *        execution.\n+     *            execution.\n      * @param scopeName a name to be used to define a subscope current while the task is being\n-     *        executed.\n+     *            executed.\n      * @param task a task to be executed while the context is bound to the object file.\n      */\n     @SuppressWarnings(\"try\")\n-    public void withDebugContext(DebugContext context,  String scopeName, Runnable task) {\n+    public void withDebugContext(DebugContext context, String scopeName, Runnable task) {\n         try (DebugContext.Scope s = context.scope(scopeName)) {\n             this.debugContext = context;\n             task.run();\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex c9dabe238e1..518b171882d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -1739,50 +1736,4 @@ public abstract class ObjectFile {\n             return createSymbolTable();\n         }\n     }\n-\n-    /**\n-     * Temporary storage for a debug context installed in a nested scope under a call. to\n-     * {@link #withDebugContext}\n-     */\n-    private DebugContext debugContext = null;\n-\n-    /**\n-     * Allows a task to be executed with a debug context in a named subscope bound to the object\n-     * file and accessible to code executed during the lifetime of the task. Invoked code may obtain\n-     * access to the debug context using method {@link #debugContext}.\n-     * \n-     * @param context a context to be bound to the object file for the duration of the task\n-     *            execution.\n-     * @param scopeName a name to be used to define a subscope current while the task is being\n-     *            executed.\n-     * @param task a task to be executed while the context is bound to the object file.\n-     */\n-    @SuppressWarnings(\"try\")\n-    public void withDebugContext(DebugContext context, String scopeName, Runnable task) {\n-        try (DebugContext.Scope s = context.scope(scopeName)) {\n-            this.debugContext = context;\n-            task.run();\n-        } catch (Throwable e) {\n-            throw debugContext.handle(e);\n-        } finally {\n-            debugContext = null;\n-        }\n-    }\n-\n-    /**\n-     * Allows a consumer to retrieve the debug context currently bound to this object file. This\n-     * method must only called underneath an invocation of method {@link #withDebugContext}.\n-     * \n-     * @param scopeName a name to be used to define a subscope current while the consumer is active.\n-     * @param action an action parameterised by the debug context.\n-     */\n-    @SuppressWarnings(\"try\")\n-    public void debugContext(String scopeName, Consumer<DebugContext> action) {\n-        assert debugContext != null;\n-        try (DebugContext.Scope s = debugContext.scope(scopeName)) {\n-            action.accept(debugContext);\n-        } catch (Throwable e) {\n-            throw debugContext.handle(e);\n-        }\n-    }\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex 518b171882d..c9dabe238e1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -1736,4 +1739,50 @@ public abstract class ObjectFile {\n             return createSymbolTable();\n         }\n     }\n+\n+    /**\n+     * Temporary storage for a debug context installed in a nested scope under a call. to\n+     * {@link #withDebugContext}\n+     */\n+    private DebugContext debugContext = null;\n+\n+    /**\n+     * Allows a task to be executed with a debug context in a named subscope bound to the object\n+     * file and accessible to code executed during the lifetime of the task. Invoked code may obtain\n+     * access to the debug context using method {@link #debugContext}.\n+     * \n+     * @param context a context to be bound to the object file for the duration of the task\n+     *            execution.\n+     * @param scopeName a name to be used to define a subscope current while the task is being\n+     *            executed.\n+     * @param task a task to be executed while the context is bound to the object file.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public void withDebugContext(DebugContext context, String scopeName, Runnable task) {\n+        try (DebugContext.Scope s = context.scope(scopeName)) {\n+            this.debugContext = context;\n+            task.run();\n+        } catch (Throwable e) {\n+            throw debugContext.handle(e);\n+        } finally {\n+            debugContext = null;\n+        }\n+    }\n+\n+    /**\n+     * Allows a consumer to retrieve the debug context currently bound to this object file. This\n+     * method must only called underneath an invocation of method {@link #withDebugContext}.\n+     * \n+     * @param scopeName a name to be used to define a subscope current while the consumer is active.\n+     * @param action an action parameterised by the debug context.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public void debugContext(String scopeName, Consumer<DebugContext> action) {\n+        assert debugContext != null;\n+        try (DebugContext.Scope s = debugContext.scope(scopeName)) {\n+            action.accept(debugContext);\n+        } catch (Throwable e) {\n+            throw debugContext.handle(e);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}, {"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex e5013c66b3a..c9dabe238e1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -1770,8 +1770,9 @@ public abstract class ObjectFile {\n     }\n \n     /**\n-     * Allows a consumer to retrieve the debug context currently bound to this object file. This method\n-     * must only called underneath an invocation of method {@link #withDebugContext}.\n+     * Allows a consumer to retrieve the debug context currently bound to this object file. This\n+     * method must only called underneath an invocation of method {@link #withDebugContext}.\n+     * \n      * @param scopeName a name to be used to define a subscope current while the consumer is active.\n      * @param action an action parameterised by the debug context.\n      */\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex c9dabe238e1..518b171882d 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -1739,50 +1736,4 @@ public abstract class ObjectFile {\n             return createSymbolTable();\n         }\n     }\n-\n-    /**\n-     * Temporary storage for a debug context installed in a nested scope under a call. to\n-     * {@link #withDebugContext}\n-     */\n-    private DebugContext debugContext = null;\n-\n-    /**\n-     * Allows a task to be executed with a debug context in a named subscope bound to the object\n-     * file and accessible to code executed during the lifetime of the task. Invoked code may obtain\n-     * access to the debug context using method {@link #debugContext}.\n-     * \n-     * @param context a context to be bound to the object file for the duration of the task\n-     *            execution.\n-     * @param scopeName a name to be used to define a subscope current while the task is being\n-     *            executed.\n-     * @param task a task to be executed while the context is bound to the object file.\n-     */\n-    @SuppressWarnings(\"try\")\n-    public void withDebugContext(DebugContext context, String scopeName, Runnable task) {\n-        try (DebugContext.Scope s = context.scope(scopeName)) {\n-            this.debugContext = context;\n-            task.run();\n-        } catch (Throwable e) {\n-            throw debugContext.handle(e);\n-        } finally {\n-            debugContext = null;\n-        }\n-    }\n-\n-    /**\n-     * Allows a consumer to retrieve the debug context currently bound to this object file. This\n-     * method must only called underneath an invocation of method {@link #withDebugContext}.\n-     * \n-     * @param scopeName a name to be used to define a subscope current while the consumer is active.\n-     * @param action an action parameterised by the debug context.\n-     */\n-    @SuppressWarnings(\"try\")\n-    public void debugContext(String scopeName, Consumer<DebugContext> action) {\n-        assert debugContext != null;\n-        try (DebugContext.Scope s = debugContext.scope(scopeName)) {\n-            action.accept(debugContext);\n-        } catch (Throwable e) {\n-            throw debugContext.handle(e);\n-        }\n-    }\n }\n", "next_change": {"commit": "4b0aec7af896b5b20a0cbee931cf963906187669", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\nindex 518b171882d..c9dabe238e1 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java\n", "chunk": "@@ -1736,4 +1739,50 @@ public abstract class ObjectFile {\n             return createSymbolTable();\n         }\n     }\n+\n+    /**\n+     * Temporary storage for a debug context installed in a nested scope under a call. to\n+     * {@link #withDebugContext}\n+     */\n+    private DebugContext debugContext = null;\n+\n+    /**\n+     * Allows a task to be executed with a debug context in a named subscope bound to the object\n+     * file and accessible to code executed during the lifetime of the task. Invoked code may obtain\n+     * access to the debug context using method {@link #debugContext}.\n+     * \n+     * @param context a context to be bound to the object file for the duration of the task\n+     *            execution.\n+     * @param scopeName a name to be used to define a subscope current while the task is being\n+     *            executed.\n+     * @param task a task to be executed while the context is bound to the object file.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public void withDebugContext(DebugContext context, String scopeName, Runnable task) {\n+        try (DebugContext.Scope s = context.scope(scopeName)) {\n+            this.debugContext = context;\n+            task.run();\n+        } catch (Throwable e) {\n+            throw debugContext.handle(e);\n+        } finally {\n+            debugContext = null;\n+        }\n+    }\n+\n+    /**\n+     * Allows a consumer to retrieve the debug context currently bound to this object file. This\n+     * method must only called underneath an invocation of method {@link #withDebugContext}.\n+     * \n+     * @param scopeName a name to be used to define a subscope current while the consumer is active.\n+     * @param action an action parameterised by the debug context.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public void debugContext(String scopeName, Consumer<DebugContext> action) {\n+        assert debugContext != null;\n+        try (DebugContext.Scope s = debugContext.scope(scopeName)) {\n+            action.accept(debugContext);\n+        } catch (Throwable e) {\n+            throw debugContext.handle(e);\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395097513", "body": "Since we will also have Windows debug info generation it might be better to use\r\n```\r\nreturn \"debug.dwarf.\" + getSectionName();\r\n```\r\nhere so that we can have\r\n```\r\nreturn \"debug.pdb.\" + getSectionName();\r\n```\r\nfor Windows.", "bodyText": "Since we will also have Windows debug info generation it might be better to use\nreturn \"debug.dwarf.\" + getSectionName();\n\nhere so that we can have\nreturn \"debug.pdb.\" + getSectionName();\n\nfor Windows.", "bodyHTML": "<p dir=\"auto\">Since we will also have Windows debug info generation it might be better to use</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"return &quot;debug.dwarf.&quot; + getSectionName();\"><pre><code>return \"debug.dwarf.\" + getSectionName();\n</code></pre></div>\n<p dir=\"auto\">here so that we can have</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"return &quot;debug.pdb.&quot; + getSectionName();\"><pre><code>return \"debug.pdb.\" + getSectionName();\n</code></pre></div>\n<p dir=\"auto\">for Windows.</p>", "author": "olpaw", "createdAt": "2020-03-19T15:07:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;\n+\n+    public DwarfSectionImpl(DwarfSections dwarfSections) {\n+        this.dwarfSections = dwarfSections;\n+    }\n+\n+    /**\n+     * creates the target byte[] array used to define the section contents.\n+     *\n+     * the main task of this method is to precompute the size of the debug section. given the\n+     * complexity of the data layouts that invariably requires performing a dummy write of the\n+     * contents, inserting bytes into a small, scratch buffer only when absolutely necessary.\n+     * subclasses may also cache some information for use when writing the contents.\n+     */\n+    public abstract void createContent();\n+\n+    /**\n+     * populates the byte[] array used to contain the section contents.\n+     *\n+     * in most cases this task reruns the operations performed under createContent but this time\n+     * actually writing data to the target byte[].\n+     */\n+    public abstract void writeContent(DebugContext debugContext);\n+\n+    @Override\n+    public boolean isLoadable() {\n+        /*\n+         * even though we're a progbits section impl we're not actually loadable\n+         */\n+        return false;\n+    }\n+\n+    public String debugSectionLogName() {", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzMTc4Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395131787", "bodyText": "Sure will correct that. I guess I should also leave the section name in lower case as well.", "author": "adinn", "createdAt": "2020-03-19T15:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzNTUwMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395135503", "bodyText": "I guess I should also leave the section name in lower case as well.\n\nYes. That would fit better to our existing use of scope names.", "author": "olpaw", "createdAt": "2020-03-19T15:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\nindex ae5bf59b796..c600795f3fc 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n", "chunk": "@@ -82,7 +82,13 @@ public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n     }\n \n     public String debugSectionLogName() {\n-        return \"DWARF_\" + getSectionName().substring(1).toUpperCase();\n+        /*\n+         * Use prefix dwarf plus the section name (which already includes a dot separator) for the\n+         * context key. For example messages for info section will be keyed using dwarf.debug_info.\n+         * Other info formats use their own format-specific prefix.\n+         */\n+        assert getSectionName().startsWith(\".debug\");\n+        return \"dwarf.\" + getSectionName();\n     }\n \n     public void enableLog(DebugContext context, int pos) {\n", "next_change": {"commit": "536baf5fca1685afe4205fc2bca846568ab5043b", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\nindex c600795f3fc..4e04d1d9288 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n", "chunk": "@@ -88,7 +88,7 @@ public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n          * Other info formats use their own format-specific prefix.\n          */\n         assert getSectionName().startsWith(\".debug\");\n-        return \"dwarf.\" + getSectionName();\n+        return \"dwarf\" + getSectionName();\n     }\n \n     public void enableLog(DebugContext context, int pos) {\n", "next_change": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\nindex 4e04d1d9288..fad408696d9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n", "chunk": "@@ -91,11 +91,11 @@ public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n         return \"dwarf\" + getSectionName();\n     }\n \n-    public void enableLog(DebugContext context, int pos) {\n+    protected void enableLog(DebugContext context, int pos) {\n         /*\n-         * debug output is disabled during the first pass where we size the buffer.\n-         * this is called to enable it during the second pass where the buffer gets written,\n-         * but only if the scope is enabled.\n+         * Debug output is disabled during the first pass where we size the buffer. this is called\n+         * to enable it during the second pass where the buffer gets written, but only if the scope\n+         * is enabled.\n          */\n         if (context.areScopesEnabled()) {\n             debug = true;\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\ndeleted file mode 100644\nindex fad408696d9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,401 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.BasicProgbitsSectionImpl;\n-import com.oracle.objectfile.BuildDependency;\n-import com.oracle.objectfile.LayoutDecision;\n-import com.oracle.objectfile.LayoutDecisionMap;\n-import com.oracle.objectfile.ObjectFile;\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.elf.ELFObjectFile;\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-import java.nio.ByteOrder;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.TEXT_SECTION_NAME;\n-\n-/**\n- * A class from which all DWARF debug sections inherit providing common behaviours.\n- */\n-public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-    protected DwarfDebugInfo dwarfSections;\n-    protected boolean debug = false;\n-    protected long debugTextBase = 0;\n-    protected long debugAddress = 0;\n-    protected int debugBase = 0;\n-\n-    public DwarfSectionImpl(DwarfDebugInfo dwarfSections) {\n-        this.dwarfSections = dwarfSections;\n-    }\n-\n-    /**\n-     * Creates the target byte[] array used to define the section contents.\n-     *\n-     * The main task of this method is to precompute the size of the debug section. given the\n-     * complexity of the data layouts that invariably requires performing a dummy write of the\n-     * contents, inserting bytes into a small, scratch buffer only when absolutely necessary.\n-     * subclasses may also cache some information for use when writing the contents.\n-     */\n-    public abstract void createContent();\n-\n-    /**\n-     * Populates the byte[] array used to contain the section contents.\n-     *\n-     * In most cases this task reruns the operations performed under createContent but this time\n-     * actually writing data to the target byte[].\n-     */\n-    public abstract void writeContent(DebugContext debugContext);\n-\n-    @Override\n-    public boolean isLoadable() {\n-        /*\n-         * Even though we're a progbits section impl we're not actually loadable.\n-         */\n-        return false;\n-    }\n-\n-    private String debugSectionLogName() {\n-        /*\n-         * Use prefix dwarf plus the section name (which already includes a dot separator) for the\n-         * context key. For example messages for info section will be keyed using dwarf.debug_info.\n-         * Other info formats use their own format-specific prefix.\n-         */\n-        assert getSectionName().startsWith(\".debug\");\n-        return \"dwarf\" + getSectionName();\n-    }\n-\n-    protected void enableLog(DebugContext context, int pos) {\n-        /*\n-         * Debug output is disabled during the first pass where we size the buffer. this is called\n-         * to enable it during the second pass where the buffer gets written, but only if the scope\n-         * is enabled.\n-         */\n-        if (context.areScopesEnabled()) {\n-            debug = true;\n-            debugBase = pos;\n-            debugAddress = debugTextBase;\n-        }\n-    }\n-\n-    protected void log(DebugContext context, String format, Object... args) {\n-        if (debug) {\n-            context.logv(DebugContext.INFO_LEVEL, format, args);\n-        }\n-    }\n-\n-    protected void verboseLog(DebugContext context, String format, Object... args) {\n-        if (debug) {\n-            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n-        }\n-    }\n-\n-    protected boolean littleEndian() {\n-        return dwarfSections.getByteOrder() == ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n-    /*\n-     * Base level put methods that assume a non-null buffer.\n-     */\n-\n-    protected int putByte(byte b, byte[] buffer, int p) {\n-        int pos = p;\n-        buffer[pos++] = b;\n-        return pos;\n-    }\n-\n-    protected int putShort(short s, byte[] buffer, int p) {\n-        int pos = p;\n-        if (littleEndian()) {\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-        } else {\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            buffer[pos++] = (byte) (s & 0xff);\n-        }\n-        return pos;\n-    }\n-\n-    protected int putInt(int i, byte[] buffer, int p) {\n-        int pos = p;\n-        if (littleEndian()) {\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-        } else {\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) (i & 0xff);\n-        }\n-        return pos;\n-    }\n-\n-    protected int putLong(long l, byte[] buffer, int p) {\n-        int pos = p;\n-        if (littleEndian()) {\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-        } else {\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) (l & 0xff);\n-        }\n-        return pos;\n-    }\n-\n-    protected int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-        int pos = p;\n-        /*\n-         * Mark address so it is relocated relative to the start of the text segment.\n-         */\n-        markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-        pos = putLong(0, buffer, pos);\n-        return pos;\n-    }\n-\n-    protected int putULEB(long val, byte[] buffer, int p) {\n-        long l = val;\n-        int pos = p;\n-        for (int i = 0; i < 9; i++) {\n-            byte b = (byte) (l & 0x7f);\n-            l = l >>> 7;\n-            boolean done = (l == 0);\n-            if (!done) {\n-                b = (byte) (b | 0x80);\n-            }\n-            pos = putByte(b, buffer, pos);\n-            if (done) {\n-                break;\n-            }\n-        }\n-        return pos;\n-    }\n-\n-    protected int putSLEB(long val, byte[] buffer, int p) {\n-        long l = val;\n-        int pos = p;\n-        for (int i = 0; i < 9; i++) {\n-            byte b = (byte) (l & 0x7f);\n-            l = l >> 7;\n-            boolean bIsSigned = (b & 0x40) != 0;\n-            boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-            if (!done) {\n-                b = (byte) (b | 0x80);\n-            }\n-            pos = putByte(b, buffer, pos);\n-            if (done) {\n-                break;\n-            }\n-        }\n-        return pos;\n-    }\n-\n-    protected int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-        return putAsciiStringBytes(s, 0, buffer, pos);\n-    }\n-\n-    protected int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-        int pos = p;\n-        for (int l = startChar; l < s.length(); l++) {\n-            char c = s.charAt(l);\n-            if (c > 127) {\n-                throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-            }\n-            buffer[pos++] = (byte) c;\n-        }\n-        buffer[pos++] = '\\0';\n-        return pos;\n-    }\n-\n-    /*\n-     * Common write methods that check for a null buffer.\n-     */\n-\n-    protected void patchLength(int lengthPos, byte[] buffer, int pos) {\n-        if (buffer != null) {\n-            int length = pos - (lengthPos + 4);\n-            putInt(length, buffer, lengthPos);\n-        }\n-    }\n-\n-    protected int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putSLEB(code, scratch, 0);\n-        } else {\n-            return putSLEB(code, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeTag(long code, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putSLEB(code, scratch, 0);\n-        } else {\n-            return putSLEB(code, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeFlag(byte flag, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putByte(flag, scratch, 0);\n-        } else {\n-            return putByte(flag, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrAddress(long address, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + 8;\n-        } else {\n-            return putRelocatableCodeOffset(address, buffer, pos);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    protected int writeAttrData8(long value, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putLong(value, scratch, 0);\n-        } else {\n-            return putLong(value, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrData4(int value, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putInt(value, scratch, 0);\n-        } else {\n-            return putInt(value, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrData1(byte value, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putByte(value, scratch, 0);\n-        } else {\n-            return putByte(value, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrNull(byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putSLEB(0, scratch, 0);\n-        } else {\n-            return putSLEB(0, buffer, pos);\n-        }\n-    }\n-\n-    /**\n-     * Identify the section after which this debug section needs to be ordered when sizing and\n-     * creating content.\n-     * \n-     * @return the name of the preceding section.\n-     */\n-    public abstract String targetSectionName();\n-\n-    /**\n-     * Identify the layout properties of the target section which need to have been decided before\n-     * the contents of this section can be created.\n-     * \n-     * @return an array of the relevant decision kinds.\n-     */\n-    public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-    /**\n-     * Identify this debug section by name.\n-     * \n-     * @return the name of the debug section.\n-     */\n-    public abstract String getSectionName();\n-\n-    @Override\n-    public byte[] getOrDecideContent(Map<ObjectFile.Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-        /*\n-         * Ensure content byte[] has been created before calling super method.\n-         */\n-        createContent();\n-\n-        /*\n-         * Ensure content byte[] has been written before calling super method.\n-         *\n-         * we do this in a nested debug scope derived from the one set up under the object file\n-         * write\n-         */\n-        getOwner().debugContext(debugSectionLogName(), this::writeContent);\n-\n-        return super.getOrDecideContent(alreadyDecided, contentHint);\n-    }\n-\n-    @Override\n-    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n-        Set<BuildDependency> deps = super.getDependencies(decisions);\n-        String targetName = targetSectionName();\n-        ELFObjectFile.ELFSection targetSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(targetName);\n-        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-        LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-        /*\n-         * Make our content depend on the size and content of the target.\n-         */\n-        for (LayoutDecision.Kind targetKind : targetKinds) {\n-            LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-            deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-        }\n-        /*\n-         * Make our size depend on our content.\n-         */\n-        deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-        return deps;\n-    }\n-\n-    /**\n-     * A scratch buffer used during computation of a section's size.\n-     */\n-    protected static final byte[] scratch = new byte[10];\n-\n-    protected Iterable<? extends ClassEntry> getPrimaryClasses() {\n-        return dwarfSections.getPrimaryClasses();\n-    }\n-\n-    protected int debugStringIndex(String str) {\n-        return dwarfSections.debugStringIndex(str);\n-    }\n-}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\nnew file mode 100644\nindex 00000000000..b508ef12f6a\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n", "chunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections\n+ * inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;\n+\n+    public DwarfSectionImpl(DwarfSections dwarfSections) {\n+        this.dwarfSections = dwarfSections;\n+    }\n+\n+    /**\n+     * creates the target byte[] array used to define the section\n+     * contents.\n+     *\n+     * the main task of this method is to precompute the\n+     * size of the debug section. given the complexity of the\n+     * data layouts that invariably requires performing a dummy\n+     * write of the contents, inserting bytes into a small,\n+     * scratch buffer only when absolutely necessary. subclasses\n+     * may also cache some information for use when writing the\n+     * contents.\n+     */\n+    public abstract void createContent();\n+\n+    /**\n+     * populates the byte[] array used to contain the section\n+     * contents.\n+     *\n+     * in most cases this task reruns the operations performed\n+     * under createContent but this time actually writing data\n+     * to the target byte[].\n+     */\n+    public abstract void writeContent();\n+\n+    @Override\n+    public boolean isLoadable() {\n+        /*\n+         * even though we're a progbits section impl we're not actually loadable\n+         */\n+        return false;\n+    }\n+\n+    public void checkDebug(int pos) {\n+        /*\n+         * if the env var relevant to this element\n+         * type is set then switch on debugging\n+         */\n+        String name = getSectionName();\n+        String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+        if (System.getenv(envVarName) != null) {\n+            debug = true;\n+            debugBase = pos;\n+            debugAddress = debugTextBase;\n+        }\n+    }\n+\n+    protected void debug(String format, Object... args) {\n+        if (debug) {\n+            System.out.format(format, args);\n+        }\n+    }\n+\n+    protected boolean littleEndian() {\n+        return dwarfSections.getByteOrder() == ByteOrder.LITTLE_ENDIAN;\n+    }\n+\n+    /*\n+     * base level put methods that assume a non-null buffer\n+     */\n+\n+    public int putByte(byte b, byte[] buffer, int p) {\n+        int pos = p;\n+        buffer[pos++] = b;\n+        return pos;\n+    }\n+\n+    public int putShort(short s, byte[] buffer, int p) {\n+        int pos = p;\n+        if (littleEndian()) {\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        } else {\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            buffer[pos++] = (byte) (s & 0xff);\n+        }\n+        return pos;\n+    }\n+\n+    public int putInt(int i, byte[] buffer, int p) {\n+        int pos = p;\n+        if (littleEndian()) {\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        } else {\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) (i & 0xff);\n+        }\n+        return pos;\n+    }\n+\n+    public int putLong(long l, byte[] buffer, int p) {\n+        int pos = p;\n+        if (littleEndian()) {\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        } else {\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) (l & 0xff);\n+        }\n+        return pos;\n+    }\n+\n+    public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+        int pos = p;\n+        /*\n+         * mark address so it is relocated relative to the start of the text segment\n+         */\n+        markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+        pos = putLong(0, buffer, pos);\n+        return pos;\n+    }\n+\n+    public int putULEB(long val, byte[] buffer, int p) {\n+        long l = val;\n+        int pos = p;\n+        for (int i = 0; i < 9; i++) {\n+            byte b = (byte) (l & 0x7f);\n+            l = l >>> 7;\n+            boolean done = (l == 0);\n+            if (!done) {\n+                b = (byte) (b | 0x80);\n+            }\n+            pos = putByte(b, buffer, pos);\n+            if (done) {\n+                break;\n+            }\n+        }\n+        return pos;\n+    }\n+\n+    public int putSLEB(long val, byte[] buffer, int p) {\n+        long l = val;\n+        int pos = p;\n+        for (int i = 0; i < 9; i++) {\n+            byte b = (byte) (l & 0x7f);\n+            l = l >> 7;\n+            boolean bIsSigned = (b & 0x40) != 0;\n+            boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+            if (!done) {\n+                b = (byte) (b | 0x80);\n+            }\n+            pos = putByte(b, buffer, pos);\n+            if (done) {\n+                break;\n+            }\n+        }\n+        return pos;\n+    }\n+\n+    public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+        return putAsciiStringBytes(s, 0, buffer, pos);\n+    }\n+\n+    public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+        int pos = p;\n+        for (int l = startChar; l < s.length(); l++) {\n+            char c = s.charAt(l);\n+            if (c > 127) {\n+                throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+            }\n+            buffer[pos++] = (byte) c;\n+        }\n+        buffer[pos++] = '\\0';\n+        return pos;\n+    }\n+\n+    /*\n+     * common write methods that check for a null buffer\n+     */\n+\n+    public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+        if (buffer != null) {\n+            int length = pos - (lengthPos + 4);\n+            putInt(length, buffer, lengthPos);\n+        }\n+    }\n+\n+    public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putSLEB(code, scratch, 0);\n+        } else {\n+            return putSLEB(code, buffer, pos);\n+        }\n+    }\n+\n+    public int writeTag(long code, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putSLEB(code, scratch, 0);\n+        } else {\n+            return putSLEB(code, buffer, pos);\n+        }\n+    }\n+\n+    public int writeFlag(byte flag, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putByte(flag, scratch, 0);\n+        } else {\n+            return putByte(flag, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + 8;\n+        } else {\n+            return putRelocatableCodeOffset(address, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrData8(long value, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putLong(value, scratch, 0);\n+        } else {\n+            return putLong(value, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrData4(int value, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putInt(value, scratch, 0);\n+        } else {\n+            return putInt(value, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putByte(value, scratch, 0);\n+        } else {\n+            return putByte(value, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrNull(byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putSLEB(0, scratch, 0);\n+        } else {\n+            return putSLEB(0, buffer, pos);\n+        }\n+    }\n+\n+    /**\n+     * identify the section after which this debug section\n+     * needs to be ordered when sizing and creating content.\n+     * @return the name of the preceding section\n+     */\n+    public abstract String targetSectionName();\n+\n+    /**\n+     * identify the layout properties of the target section\n+     * which need to have been decided before the contents\n+     * of this section can be created.\n+     * @return an array of the relevant decision kinds\n+     */\n+    public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+    /**\n+     * identify this debug section by name.\n+     * @return the name of the debug section\n+     */\n+    public abstract String getSectionName();\n+\n+    @Override\n+    public byte[] getOrDecideContent(Map<ObjectFile.Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+        /*\n+         * ensure content byte[] has been created before calling super method\n+         */\n+        createContent();\n+\n+        /*\n+         * ensure content byte[] has been written before calling super method\n+         */\n+        writeContent();\n+\n+        return super.getOrDecideContent(alreadyDecided, contentHint);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        String targetName = targetSectionName();\n+        ELFObjectFile.ELFSection targetSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(targetName);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+        /*\n+         * make our content depend on the size and content of the target\n+         */\n+        for (LayoutDecision.Kind targetKind : targetKinds) {\n+            LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+            deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+        }\n+        /*\n+         * make our size depend on our content\n+         */\n+        deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+        return deps;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    protected Iterable<? extends ClassEntry> getPrimaryClasses() {\n+        return dwarfSections.getPrimaryClasses();\n+    }\n+\n+    protected int debugStringIndex(String str) {\n+        return dwarfSections.debugStringIndex(str);\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExOTA0OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395119048", "body": "Is this a write-only field?", "bodyText": "Is this a write-only field?", "bodyHTML": "<p dir=\"auto\">Is this a write-only field?</p>", "author": "olpaw", "createdAt": "2020-03-19T15:35:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzMTA4Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395131087", "bodyText": "These are used when trace logging is enabled. They are updated in method enableLog(). n.b. currently only 3 of the DwarfSectionImpl subclasses generate trace. However, I have added the trace log functionality at the superclass level so that all Impl classes use it if/when it turns out to be needed.", "author": "adinn", "createdAt": "2020-03-19T15:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExOTA0OA=="}], "type": "inlineReview", "revised_code": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\nindex ae5bf59b796..fad408696d9 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n", "chunk": "@@ -39,26 +39,26 @@ import java.nio.ByteOrder;\n import java.util.Map;\n import java.util.Set;\n \n-import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.TEXT_SECTION_NAME;\n \n /**\n- * class from which all DWARF debug sections inherit providing common behaviours.\n+ * A class from which all DWARF debug sections inherit providing common behaviours.\n  */\n public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-    protected DwarfSections dwarfSections;\n-    public boolean debug = false;\n-    public long debugTextBase = 0;\n-    public long debugAddress = 0;\n-    public int debugBase = 0;\n+    protected DwarfDebugInfo dwarfSections;\n+    protected boolean debug = false;\n+    protected long debugTextBase = 0;\n+    protected long debugAddress = 0;\n+    protected int debugBase = 0;\n \n-    public DwarfSectionImpl(DwarfSections dwarfSections) {\n+    public DwarfSectionImpl(DwarfDebugInfo dwarfSections) {\n         this.dwarfSections = dwarfSections;\n     }\n \n     /**\n-     * creates the target byte[] array used to define the section contents.\n+     * Creates the target byte[] array used to define the section contents.\n      *\n-     * the main task of this method is to precompute the size of the debug section. given the\n+     * The main task of this method is to precompute the size of the debug section. given the\n      * complexity of the data layouts that invariably requires performing a dummy write of the\n      * contents, inserting bytes into a small, scratch buffer only when absolutely necessary.\n      * subclasses may also cache some information for use when writing the contents.\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\ndeleted file mode 100644\nindex fad408696d9..00000000000\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,401 +0,0 @@\n-/*\n- * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- */\n-\n-package com.oracle.objectfile.elf.dwarf;\n-\n-import com.oracle.objectfile.BasicProgbitsSectionImpl;\n-import com.oracle.objectfile.BuildDependency;\n-import com.oracle.objectfile.LayoutDecision;\n-import com.oracle.objectfile.LayoutDecisionMap;\n-import com.oracle.objectfile.ObjectFile;\n-import com.oracle.objectfile.debugentry.ClassEntry;\n-import com.oracle.objectfile.elf.ELFObjectFile;\n-import org.graalvm.compiler.debug.DebugContext;\n-\n-import java.nio.ByteOrder;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.TEXT_SECTION_NAME;\n-\n-/**\n- * A class from which all DWARF debug sections inherit providing common behaviours.\n- */\n-public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n-    protected DwarfDebugInfo dwarfSections;\n-    protected boolean debug = false;\n-    protected long debugTextBase = 0;\n-    protected long debugAddress = 0;\n-    protected int debugBase = 0;\n-\n-    public DwarfSectionImpl(DwarfDebugInfo dwarfSections) {\n-        this.dwarfSections = dwarfSections;\n-    }\n-\n-    /**\n-     * Creates the target byte[] array used to define the section contents.\n-     *\n-     * The main task of this method is to precompute the size of the debug section. given the\n-     * complexity of the data layouts that invariably requires performing a dummy write of the\n-     * contents, inserting bytes into a small, scratch buffer only when absolutely necessary.\n-     * subclasses may also cache some information for use when writing the contents.\n-     */\n-    public abstract void createContent();\n-\n-    /**\n-     * Populates the byte[] array used to contain the section contents.\n-     *\n-     * In most cases this task reruns the operations performed under createContent but this time\n-     * actually writing data to the target byte[].\n-     */\n-    public abstract void writeContent(DebugContext debugContext);\n-\n-    @Override\n-    public boolean isLoadable() {\n-        /*\n-         * Even though we're a progbits section impl we're not actually loadable.\n-         */\n-        return false;\n-    }\n-\n-    private String debugSectionLogName() {\n-        /*\n-         * Use prefix dwarf plus the section name (which already includes a dot separator) for the\n-         * context key. For example messages for info section will be keyed using dwarf.debug_info.\n-         * Other info formats use their own format-specific prefix.\n-         */\n-        assert getSectionName().startsWith(\".debug\");\n-        return \"dwarf\" + getSectionName();\n-    }\n-\n-    protected void enableLog(DebugContext context, int pos) {\n-        /*\n-         * Debug output is disabled during the first pass where we size the buffer. this is called\n-         * to enable it during the second pass where the buffer gets written, but only if the scope\n-         * is enabled.\n-         */\n-        if (context.areScopesEnabled()) {\n-            debug = true;\n-            debugBase = pos;\n-            debugAddress = debugTextBase;\n-        }\n-    }\n-\n-    protected void log(DebugContext context, String format, Object... args) {\n-        if (debug) {\n-            context.logv(DebugContext.INFO_LEVEL, format, args);\n-        }\n-    }\n-\n-    protected void verboseLog(DebugContext context, String format, Object... args) {\n-        if (debug) {\n-            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n-        }\n-    }\n-\n-    protected boolean littleEndian() {\n-        return dwarfSections.getByteOrder() == ByteOrder.LITTLE_ENDIAN;\n-    }\n-\n-    /*\n-     * Base level put methods that assume a non-null buffer.\n-     */\n-\n-    protected int putByte(byte b, byte[] buffer, int p) {\n-        int pos = p;\n-        buffer[pos++] = b;\n-        return pos;\n-    }\n-\n-    protected int putShort(short s, byte[] buffer, int p) {\n-        int pos = p;\n-        if (littleEndian()) {\n-            buffer[pos++] = (byte) (s & 0xff);\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-        } else {\n-            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n-            buffer[pos++] = (byte) (s & 0xff);\n-        }\n-        return pos;\n-    }\n-\n-    protected int putInt(int i, byte[] buffer, int p) {\n-        int pos = p;\n-        if (littleEndian()) {\n-            buffer[pos++] = (byte) (i & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-        } else {\n-            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n-            buffer[pos++] = (byte) (i & 0xff);\n-        }\n-        return pos;\n-    }\n-\n-    protected int putLong(long l, byte[] buffer, int p) {\n-        int pos = p;\n-        if (littleEndian()) {\n-            buffer[pos++] = (byte) (l & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-        } else {\n-            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n-            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n-            buffer[pos++] = (byte) (l & 0xff);\n-        }\n-        return pos;\n-    }\n-\n-    protected int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n-        int pos = p;\n-        /*\n-         * Mark address so it is relocated relative to the start of the text segment.\n-         */\n-        markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n-        pos = putLong(0, buffer, pos);\n-        return pos;\n-    }\n-\n-    protected int putULEB(long val, byte[] buffer, int p) {\n-        long l = val;\n-        int pos = p;\n-        for (int i = 0; i < 9; i++) {\n-            byte b = (byte) (l & 0x7f);\n-            l = l >>> 7;\n-            boolean done = (l == 0);\n-            if (!done) {\n-                b = (byte) (b | 0x80);\n-            }\n-            pos = putByte(b, buffer, pos);\n-            if (done) {\n-                break;\n-            }\n-        }\n-        return pos;\n-    }\n-\n-    protected int putSLEB(long val, byte[] buffer, int p) {\n-        long l = val;\n-        int pos = p;\n-        for (int i = 0; i < 9; i++) {\n-            byte b = (byte) (l & 0x7f);\n-            l = l >> 7;\n-            boolean bIsSigned = (b & 0x40) != 0;\n-            boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n-            if (!done) {\n-                b = (byte) (b | 0x80);\n-            }\n-            pos = putByte(b, buffer, pos);\n-            if (done) {\n-                break;\n-            }\n-        }\n-        return pos;\n-    }\n-\n-    protected int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n-        return putAsciiStringBytes(s, 0, buffer, pos);\n-    }\n-\n-    protected int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n-        int pos = p;\n-        for (int l = startChar; l < s.length(); l++) {\n-            char c = s.charAt(l);\n-            if (c > 127) {\n-                throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n-            }\n-            buffer[pos++] = (byte) c;\n-        }\n-        buffer[pos++] = '\\0';\n-        return pos;\n-    }\n-\n-    /*\n-     * Common write methods that check for a null buffer.\n-     */\n-\n-    protected void patchLength(int lengthPos, byte[] buffer, int pos) {\n-        if (buffer != null) {\n-            int length = pos - (lengthPos + 4);\n-            putInt(length, buffer, lengthPos);\n-        }\n-    }\n-\n-    protected int writeAbbrevCode(long code, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putSLEB(code, scratch, 0);\n-        } else {\n-            return putSLEB(code, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeTag(long code, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putSLEB(code, scratch, 0);\n-        } else {\n-            return putSLEB(code, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeFlag(byte flag, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putByte(flag, scratch, 0);\n-        } else {\n-            return putByte(flag, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrAddress(long address, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + 8;\n-        } else {\n-            return putRelocatableCodeOffset(address, buffer, pos);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    protected int writeAttrData8(long value, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putLong(value, scratch, 0);\n-        } else {\n-            return putLong(value, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrData4(int value, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putInt(value, scratch, 0);\n-        } else {\n-            return putInt(value, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrData1(byte value, byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putByte(value, scratch, 0);\n-        } else {\n-            return putByte(value, buffer, pos);\n-        }\n-    }\n-\n-    protected int writeAttrNull(byte[] buffer, int pos) {\n-        if (buffer == null) {\n-            return pos + putSLEB(0, scratch, 0);\n-        } else {\n-            return putSLEB(0, buffer, pos);\n-        }\n-    }\n-\n-    /**\n-     * Identify the section after which this debug section needs to be ordered when sizing and\n-     * creating content.\n-     * \n-     * @return the name of the preceding section.\n-     */\n-    public abstract String targetSectionName();\n-\n-    /**\n-     * Identify the layout properties of the target section which need to have been decided before\n-     * the contents of this section can be created.\n-     * \n-     * @return an array of the relevant decision kinds.\n-     */\n-    public abstract LayoutDecision.Kind[] targetSectionKinds();\n-\n-    /**\n-     * Identify this debug section by name.\n-     * \n-     * @return the name of the debug section.\n-     */\n-    public abstract String getSectionName();\n-\n-    @Override\n-    public byte[] getOrDecideContent(Map<ObjectFile.Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n-        /*\n-         * Ensure content byte[] has been created before calling super method.\n-         */\n-        createContent();\n-\n-        /*\n-         * Ensure content byte[] has been written before calling super method.\n-         *\n-         * we do this in a nested debug scope derived from the one set up under the object file\n-         * write\n-         */\n-        getOwner().debugContext(debugSectionLogName(), this::writeContent);\n-\n-        return super.getOrDecideContent(alreadyDecided, contentHint);\n-    }\n-\n-    @Override\n-    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n-        Set<BuildDependency> deps = super.getDependencies(decisions);\n-        String targetName = targetSectionName();\n-        ELFObjectFile.ELFSection targetSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(targetName);\n-        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n-        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n-        LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n-        /*\n-         * Make our content depend on the size and content of the target.\n-         */\n-        for (LayoutDecision.Kind targetKind : targetKinds) {\n-            LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n-            deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n-        }\n-        /*\n-         * Make our size depend on our content.\n-         */\n-        deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n-\n-        return deps;\n-    }\n-\n-    /**\n-     * A scratch buffer used during computation of a section's size.\n-     */\n-    protected static final byte[] scratch = new byte[10];\n-\n-    protected Iterable<? extends ClassEntry> getPrimaryClasses() {\n-        return dwarfSections.getPrimaryClasses();\n-    }\n-\n-    protected int debugStringIndex(String str) {\n-        return dwarfSections.debugStringIndex(str);\n-    }\n-}\n", "next_change": {"commit": "84516d367c30a9493ceab8b96043512a45442536", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\nnew file mode 100644\nindex 00000000000..b508ef12f6a\n--- /dev/null\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java\n", "chunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections\n+ * inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;\n+\n+    public DwarfSectionImpl(DwarfSections dwarfSections) {\n+        this.dwarfSections = dwarfSections;\n+    }\n+\n+    /**\n+     * creates the target byte[] array used to define the section\n+     * contents.\n+     *\n+     * the main task of this method is to precompute the\n+     * size of the debug section. given the complexity of the\n+     * data layouts that invariably requires performing a dummy\n+     * write of the contents, inserting bytes into a small,\n+     * scratch buffer only when absolutely necessary. subclasses\n+     * may also cache some information for use when writing the\n+     * contents.\n+     */\n+    public abstract void createContent();\n+\n+    /**\n+     * populates the byte[] array used to contain the section\n+     * contents.\n+     *\n+     * in most cases this task reruns the operations performed\n+     * under createContent but this time actually writing data\n+     * to the target byte[].\n+     */\n+    public abstract void writeContent();\n+\n+    @Override\n+    public boolean isLoadable() {\n+        /*\n+         * even though we're a progbits section impl we're not actually loadable\n+         */\n+        return false;\n+    }\n+\n+    public void checkDebug(int pos) {\n+        /*\n+         * if the env var relevant to this element\n+         * type is set then switch on debugging\n+         */\n+        String name = getSectionName();\n+        String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+        if (System.getenv(envVarName) != null) {\n+            debug = true;\n+            debugBase = pos;\n+            debugAddress = debugTextBase;\n+        }\n+    }\n+\n+    protected void debug(String format, Object... args) {\n+        if (debug) {\n+            System.out.format(format, args);\n+        }\n+    }\n+\n+    protected boolean littleEndian() {\n+        return dwarfSections.getByteOrder() == ByteOrder.LITTLE_ENDIAN;\n+    }\n+\n+    /*\n+     * base level put methods that assume a non-null buffer\n+     */\n+\n+    public int putByte(byte b, byte[] buffer, int p) {\n+        int pos = p;\n+        buffer[pos++] = b;\n+        return pos;\n+    }\n+\n+    public int putShort(short s, byte[] buffer, int p) {\n+        int pos = p;\n+        if (littleEndian()) {\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        } else {\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            buffer[pos++] = (byte) (s & 0xff);\n+        }\n+        return pos;\n+    }\n+\n+    public int putInt(int i, byte[] buffer, int p) {\n+        int pos = p;\n+        if (littleEndian()) {\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        } else {\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) (i & 0xff);\n+        }\n+        return pos;\n+    }\n+\n+    public int putLong(long l, byte[] buffer, int p) {\n+        int pos = p;\n+        if (littleEndian()) {\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        } else {\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) (l & 0xff);\n+        }\n+        return pos;\n+    }\n+\n+    public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+        int pos = p;\n+        /*\n+         * mark address so it is relocated relative to the start of the text segment\n+         */\n+        markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+        pos = putLong(0, buffer, pos);\n+        return pos;\n+    }\n+\n+    public int putULEB(long val, byte[] buffer, int p) {\n+        long l = val;\n+        int pos = p;\n+        for (int i = 0; i < 9; i++) {\n+            byte b = (byte) (l & 0x7f);\n+            l = l >>> 7;\n+            boolean done = (l == 0);\n+            if (!done) {\n+                b = (byte) (b | 0x80);\n+            }\n+            pos = putByte(b, buffer, pos);\n+            if (done) {\n+                break;\n+            }\n+        }\n+        return pos;\n+    }\n+\n+    public int putSLEB(long val, byte[] buffer, int p) {\n+        long l = val;\n+        int pos = p;\n+        for (int i = 0; i < 9; i++) {\n+            byte b = (byte) (l & 0x7f);\n+            l = l >> 7;\n+            boolean bIsSigned = (b & 0x40) != 0;\n+            boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+            if (!done) {\n+                b = (byte) (b | 0x80);\n+            }\n+            pos = putByte(b, buffer, pos);\n+            if (done) {\n+                break;\n+            }\n+        }\n+        return pos;\n+    }\n+\n+    public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+        return putAsciiStringBytes(s, 0, buffer, pos);\n+    }\n+\n+    public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+        int pos = p;\n+        for (int l = startChar; l < s.length(); l++) {\n+            char c = s.charAt(l);\n+            if (c > 127) {\n+                throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+            }\n+            buffer[pos++] = (byte) c;\n+        }\n+        buffer[pos++] = '\\0';\n+        return pos;\n+    }\n+\n+    /*\n+     * common write methods that check for a null buffer\n+     */\n+\n+    public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+        if (buffer != null) {\n+            int length = pos - (lengthPos + 4);\n+            putInt(length, buffer, lengthPos);\n+        }\n+    }\n+\n+    public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putSLEB(code, scratch, 0);\n+        } else {\n+            return putSLEB(code, buffer, pos);\n+        }\n+    }\n+\n+    public int writeTag(long code, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putSLEB(code, scratch, 0);\n+        } else {\n+            return putSLEB(code, buffer, pos);\n+        }\n+    }\n+\n+    public int writeFlag(byte flag, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putByte(flag, scratch, 0);\n+        } else {\n+            return putByte(flag, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + 8;\n+        } else {\n+            return putRelocatableCodeOffset(address, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrData8(long value, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putLong(value, scratch, 0);\n+        } else {\n+            return putLong(value, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrData4(int value, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putInt(value, scratch, 0);\n+        } else {\n+            return putInt(value, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putByte(value, scratch, 0);\n+        } else {\n+            return putByte(value, buffer, pos);\n+        }\n+    }\n+\n+    public int writeAttrNull(byte[] buffer, int pos) {\n+        if (buffer == null) {\n+            return pos + putSLEB(0, scratch, 0);\n+        } else {\n+            return putSLEB(0, buffer, pos);\n+        }\n+    }\n+\n+    /**\n+     * identify the section after which this debug section\n+     * needs to be ordered when sizing and creating content.\n+     * @return the name of the preceding section\n+     */\n+    public abstract String targetSectionName();\n+\n+    /**\n+     * identify the layout properties of the target section\n+     * which need to have been decided before the contents\n+     * of this section can be created.\n+     * @return an array of the relevant decision kinds\n+     */\n+    public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+    /**\n+     * identify this debug section by name.\n+     * @return the name of the debug section\n+     */\n+    public abstract String getSectionName();\n+\n+    @Override\n+    public byte[] getOrDecideContent(Map<ObjectFile.Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+        /*\n+         * ensure content byte[] has been created before calling super method\n+         */\n+        createContent();\n+\n+        /*\n+         * ensure content byte[] has been written before calling super method\n+         */\n+        writeContent();\n+\n+        return super.getOrDecideContent(alreadyDecided, contentHint);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        String targetName = targetSectionName();\n+        ELFObjectFile.ELFSection targetSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(targetName);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+        /*\n+         * make our content depend on the size and content of the target\n+         */\n+        for (LayoutDecision.Kind targetKind : targetKinds) {\n+            LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+            deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+        }\n+        /*\n+         * make our size depend on our content\n+         */\n+        deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+        return deps;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    protected Iterable<? extends ClassEntry> getPrimaryClasses() {\n+        return dwarfSections.getPrimaryClasses();\n+    }\n+\n+    protected int debugStringIndex(String str) {\n+        return dwarfSections.debugStringIndex(str);\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"oid": "648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "url": "https://github.com/oracle/graal/commit/648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "message": "Checkstyle adjustments for copyright header", "committedDate": "2020-03-20T12:00:30Z", "type": "forcePushed"}, {"oid": "536baf5fca1685afe4205fc2bca846568ab5043b", "url": "https://github.com/oracle/graal/commit/536baf5fca1685afe4205fc2bca846568ab5043b", "message": "avoid repeated dot in scope name", "committedDate": "2020-03-20T16:16:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTk3OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400235978", "body": "@adinn, I think I already mentioned it, it's rather unusual in our codebase to start comments with lowercase.", "bodyText": "@adinn, I think I already mentioned it, it's rather unusual in our codebase to start comments with lowercase.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/adinn/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/adinn\">@adinn</a>, I think I already mentioned it, it's rather unusual in our codebase to start comments with lowercase.</p>", "author": "olpaw", "createdAt": "2020-03-30T14:28:07Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debugentry;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Details of a specific address range in a compiled method either a primary range identifying a\n+ * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n+ * method.\n+ */\n+\n+public class Range {\n+    private String fileName;\n+    private Path filePath;\n+    private String className;\n+    private String methodName;\n+    private String paramNames;\n+    private String returnTypeName;\n+    private String fullMethodName;\n+    private int lo;\n+    private int hi;\n+    private int line;\n+    /*\n+     * this is null for a primary range", "originalCommit": "b17a12e2847085772f41ef3e9762d957865bcd05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NjU3MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400396571", "bodyText": "Hmm, yes. A-and also this specific case is very wrong ... this can never be null :-)\nI'll get my coat . . .\nSorry. I thought I had fixed all these but I clearly missed some. I have just done a full pass through all the new/changed files. I am fairly sure I now have all comments starting with a capital letter and ending with a full stop.", "author": "adinn", "createdAt": "2020-03-30T18:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTk3OA=="}], "type": "inlineReview", "revised_code": {"commit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nindex 58519d4e72e..1b65c315e8a 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n", "chunk": "@@ -47,24 +47,24 @@ public class Range {\n     private int hi;\n     private int line;\n     /*\n-     * this is null for a primary range\n+     * This is null for a primary range.\n      */\n     private Range primary;\n \n     /*\n-     * create a primary range\n+     * Create a primary range.\n      */\n     public Range(String fileName, Path filePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line) {\n         this(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, null);\n     }\n \n     /*\n-     * create a primary or secondary range\n+     * Create a primary or secondary range.\n      */\n     public Range(String fileName, Path filePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line, Range primary) {\n         /*\n-         * currently file name and full method name need to go into the debug_str section other\n-         * strings just need to be deduplicated to save space\n+         * Currently file name and full method name need to go into the debug_str section other\n+         * strings just need to be deduplicated to save space.\n          */\n         this.fileName = (fileName == null ? null : stringTable.uniqueDebugString(fileName));\n         this.filePath = filePath;\n", "next_change": {"commit": "ab1cb427a768786f0e6a70ae58e907861d8969de", "changed_code": [{"header": "diff --git a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java\nsimilarity index 65%\nrename from substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\nrename to substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java\nindex 1b65c315e8a..758825272a7 100644\n--- a/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java\n+++ b/substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java\n", "chunk": "@@ -46,28 +43,19 @@ public class Range {\n     private int lo;\n     private int hi;\n     private int line;\n-    /*\n-     * This is null for a primary range.\n-     */\n+    // this is null for a primary range\n     private Range primary;\n \n-    /*\n-     * Create a primary range.\n-     */\n-    public Range(String fileName, Path filePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line) {\n-        this(fileName, filePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, null);\n+    // create a primary range\n+    Range(String fileName, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line) {\n+        this(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, null);\n     }\n \n-    /*\n-     * Create a primary or secondary range.\n-     */\n-    public Range(String fileName, Path filePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line, Range primary) {\n-        /*\n-         * Currently file name and full method name need to go into the debug_str section other\n-         * strings just need to be deduplicated to save space.\n-         */\n-        this.fileName = (fileName == null ? null : stringTable.uniqueDebugString(fileName));\n-        this.filePath = filePath;\n+    // create a primary or secondary range\n+    Range(String fileName, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line, Range primary) {\n+        // currently file name and full method name need to go into the debug_str section\n+        // other strings just need to be deduplicated to save space\n+        this.fileName = stringTable.uniqueDebugString(fileName);\n         this.className = stringTable.uniqueString(className);\n         this.methodName = stringTable.uniqueString(methodName);\n         this.paramNames = stringTable.uniqueString(paramNames);\n", "next_change": null}]}}]}}, {"oid": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "url": "https://github.com/oracle/graal/commit/0a0b19984f6a90726dbff59cd65e05e260de6d81", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-03-31T11:25:21Z", "type": "forcePushed"}, {"oid": "b4680c224c85730ac0221155bab5881b98ea5bc1", "url": "https://github.com/oracle/graal/commit/b4680c224c85730ac0221155bab5881b98ea5bc1", "message": "Code cleanups", "committedDate": "2020-03-31T13:30:27Z", "type": "forcePushed"}, {"oid": "51c8f8f55d012aa5f073a608de6b66931c419c00", "url": "https://github.com/oracle/graal/commit/51c8f8f55d012aa5f073a608de6b66931c419c00", "message": "Code cleanups", "committedDate": "2020-03-31T13:46:17Z", "type": "forcePushed"}, {"oid": "dc16efa8528c7fb20a3bee0671214eee15edecff", "url": "https://github.com/oracle/graal/commit/dc16efa8528c7fb20a3bee0671214eee15edecff", "message": "use unique name for debuginfo gate test", "committedDate": "2020-04-01T09:41:07Z", "type": "forcePushed"}, {"oid": "ab1cb427a768786f0e6a70ae58e907861d8969de", "url": "https://github.com/oracle/graal/commit/ab1cb427a768786f0e6a70ae58e907861d8969de", "message": "Implement basic debuginfo generation for ELF objects", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "84516d367c30a9493ceab8b96043512a45442536", "url": "https://github.com/oracle/graal/commit/84516d367c30a9493ceab8b96043512a45442536", "message": "Add option GenerateDebugInfo=<level>", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "25c7101fcc02d41865ef60545b6177ee7842dbef", "url": "https://github.com/oracle/graal/commit/25c7101fcc02d41865ef60545b6177ee7842dbef", "message": "Use Path expressions for directories and file names", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "url": "https://github.com/oracle/graal/commit/53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "message": "Implement source file cache", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "url": "https://github.com/oracle/graal/commit/4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "message": "Modify debug info API to use streams instead of iterators", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "259171c5618e71769cbc7610e0ffc136d7d77562", "url": "https://github.com/oracle/graal/commit/259171c5618e71769cbc7610e0ffc136d7d77562", "message": "Added option DebugInfoSourceSearchPath=<path>\n\nTweak SourceCacheType enum\n\nClean up SourceCache initialization\n\nMemoize source cache checks", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "4b0aec7af896b5b20a0cbee931cf963906187669", "url": "https://github.com/oracle/graal/commit/4b0aec7af896b5b20a0cbee931cf963906187669", "message": "Support hierarchical logging", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "url": "https://github.com/oracle/graal/commit/1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-03T10:55:26Z", "type": "forcePushed"}, {"oid": "e4c876066b1122091bcaf68d869f94961d751724", "url": "https://github.com/oracle/graal/commit/e4c876066b1122091bcaf68d869f94961d751724", "message": "Abstract generic code for modelling debug info from DwarfSections into DebugInfoBase\n\nRename subclass DwarfSections to DwarfDebugInfo", "committedDate": "2020-04-06T09:44:26Z", "type": "commit"}, {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-06T09:45:25Z", "type": "commit"}, {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-06T09:45:25Z", "type": "forcePushed"}]}