{"pr_number": 219, "pr_title": "Verify that next page is not empty in the history iterator", "pr_author": "vitarb", "pr_createdAt": "2020-09-23T04:36:04Z", "pr_url": "https://github.com/temporalio/sdk-java/pull/219", "merge_commit": "cfa22296f8b795adc1ade7880e602be830118a4c", "timeline": [{"oid": "33e4d01d197bcca1bd19580856584cee414767f4", "url": "https://github.com/temporalio/sdk-java/commit/33e4d01d197bcca1bd19580856584cee414767f4", "message": "Verify that next page is not empty in the history iterator", "committedDate": "2020-09-23T04:42:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NDM2Nw==", "url": "https://github.com/temporalio/sdk-java/pull/219#discussion_r493194367", "body": "I think you can avoid this call here if line 111 calls this.hasNext", "bodyText": "I think you can avoid this call here if line 111 calls this.hasNext", "bodyHTML": "<p dir=\"auto\">I think you can avoid this call here if line 111 calls this.hasNext</p>", "author": "mfateev", "createdAt": "2020-09-23T04:46:05Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java", "diffHunk": "@@ -77,6 +112,24 @@ public HistoryEvent next() {\n       return current.next();\n     }\n \n+    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory(", "originalCommit": "33e4d01d197bcca1bd19580856584cee414767f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyNzE4OQ==", "url": "https://github.com/temporalio/sdk-java/pull/219#discussion_r493227189", "bodyText": "That call is to current.hasNext() (not this.hasNext()), which is just cached history.\nWe should make a server call if current is empty and page token is available.\nThis would make it possible to safely call it.next() without calling it.hasNext() first.\nThat being said I've updated implementation, added tests and verified that it's working in bench, please take a look", "author": "vitarb", "createdAt": "2020-09-23T06:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NDM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b845eff787e131007414996e8e373e7baba7aaf8", "changed_code": [{"header": "diff --git a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\nindex c7357a45..ee6474b7 100644\n--- a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n+++ b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n", "chunk": "@@ -112,24 +97,14 @@ class WorkflowHistoryIterator implements Iterator<HistoryEvent> {\n       return current.next();\n     }\n \n-    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory(\n-        GetWorkflowExecutionHistoryRequest.newBuilder()\n-            .setNamespace(namespace)\n-            .setExecution(task.getWorkflowExecution())\n-            .setNextPageToken(nextPageToken)\n-            .build());\n-\n-    current = response.getHistory().getEventsList().iterator();\n-    nextPageToken = response.getNextPageToken();\n+    current = nextResponse.getHistory().getEventsList().iterator();\n+    nextPageToken = nextResponse.getNextPageToken();\n \n     return current.next();\n   }\n \n   private GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory(\n       GetWorkflowExecutionHistoryRequest request) {\n-    if (cachedResponse != null && request.equals(cachedResponse.request)) {\n-      return cachedResponse.response;\n-    }\n     Duration passed = Duration.ofMillis(System.currentTimeMillis()).minus(paginationStart);\n     Duration expiration = workflowTaskTimeout.minus(passed);\n     if (expiration.isZero() || expiration.isNegative()) {\n", "next_change": {"commit": "fd1134daee974dcb68f26a43f859e324d7c26c4b", "changed_code": [{"header": "diff --git a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\nindex ee6474b7..a8bf7bec 100644\n--- a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n+++ b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n", "chunk": "@@ -82,29 +79,24 @@ class WorkflowHistoryIterator implements Iterator<HistoryEvent> {\n     if (nextPageToken.isEmpty()) {\n       return false;\n     }\n-    GetWorkflowExecutionHistoryRequest request = GetWorkflowExecutionHistoryRequest.newBuilder()\n-        .setNamespace(namespace)\n-        .setExecution(task.getWorkflowExecution())\n-        .setNextPageToken(nextPageToken)\n-        .build();\n-    nextResponse = queryWorkflowExecutionHistory(request);\n-    return nextResponse.hasHistory() && !nextResponse.getHistory().getEventsList().isEmpty();\n+\n+    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();\n+\n+    current = response.getHistory().getEventsList().iterator();\n+    nextPageToken = response.getNextPageToken();\n+\n+    return current.hasNext();\n   }\n \n   @Override\n   public HistoryEvent next() {\n-    if (current.hasNext()) {\n+    if (hasNext()) {\n       return current.next();\n     }\n-\n-    current = nextResponse.getHistory().getEventsList().iterator();\n-    nextPageToken = nextResponse.getNextPageToken();\n-\n-    return current.next();\n+    throw new NoSuchElementException();\n   }\n \n-  private GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory(\n-      GetWorkflowExecutionHistoryRequest request) {\n+  GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory() {\n     Duration passed = Duration.ofMillis(System.currentTimeMillis()).minus(paginationStart);\n     Duration expiration = workflowTaskTimeout.minus(passed);\n     if (expiration.isZero() || expiration.isNegative()) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "cfa22296f8b795adc1ade7880e602be830118a4c", "changed_code": [{"header": "diff --git a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\nindex c7357a45..08c268d9 100644\n--- a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n+++ b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n", "chunk": "@@ -95,41 +79,24 @@ class WorkflowHistoryIterator implements Iterator<HistoryEvent> {\n     if (nextPageToken.isEmpty()) {\n       return false;\n     }\n-    GetWorkflowExecutionHistoryRequest request = GetWorkflowExecutionHistoryRequest.newBuilder()\n-        .setNamespace(namespace)\n-        .setExecution(task.getWorkflowExecution())\n-        .setNextPageToken(nextPageToken)\n-        .build();\n-    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory(request);\n-    cachedResponse = new NextWorkflowExecutionHistoryResponse(request, response);\n \n-    return response.hasHistory() && !response.getHistory().getEventsList().isEmpty();\n+    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();\n+\n+    current = response.getHistory().getEventsList().iterator();\n+    nextPageToken = response.getNextPageToken();\n+\n+    return current.hasNext();\n   }\n \n   @Override\n   public HistoryEvent next() {\n-    if (current.hasNext()) {\n+    if (hasNext()) {\n       return current.next();\n     }\n-\n-    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory(\n-        GetWorkflowExecutionHistoryRequest.newBuilder()\n-            .setNamespace(namespace)\n-            .setExecution(task.getWorkflowExecution())\n-            .setNextPageToken(nextPageToken)\n-            .build());\n-\n-    current = response.getHistory().getEventsList().iterator();\n-    nextPageToken = response.getNextPageToken();\n-\n-    return current.next();\n+    throw new NoSuchElementException();\n   }\n \n-  private GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory(\n-      GetWorkflowExecutionHistoryRequest request) {\n-    if (cachedResponse != null && request.equals(cachedResponse.request)) {\n-      return cachedResponse.response;\n-    }\n+  GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory() {\n     Duration passed = Duration.ofMillis(System.currentTimeMillis()).minus(paginationStart);\n     Duration expiration = workflowTaskTimeout.minus(passed);\n     if (expiration.isZero() || expiration.isNegative()) {\n", "next_change": {"commit": "8f093115930b7f3a71258bbbeec41fb74adcc701", "changed_code": [{"header": "diff --git a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\nindex 08c268d9..799726b9 100644\n--- a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n+++ b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n", "chunk": "@@ -1,132 +1,29 @@\n /*\n- *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ * Copyright (C) 2022 Temporal Technologies, Inc. All Rights Reserved.\n  *\n- *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (C) 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n  *\n- *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ * Modifications copyright (C) 2017 Uber Technologies, Inc.\n  *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n- *  use this file except in compliance with the License. A copy of the License is\n- *  located at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this material except in compliance with the License.\n+ * You may obtain a copy of the License at\n  *\n- *  http://aws.amazon.com/apache2.0\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n- *  or in the \"license\" file accompanying this file. This file is distributed on\n- *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- *  express or implied. See the License for the specific language governing\n- *  permissions and limitations under the License.\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n \n package io.temporal.internal.replay;\n \n-import static io.temporal.serviceclient.MetricsTag.METRICS_TAGS_CALL_OPTIONS_KEY;\n-\n-import com.google.protobuf.ByteString;\n-import com.uber.m3.tally.Scope;\n-import io.grpc.Status;\n-import io.temporal.api.history.v1.History;\n+import io.grpc.Deadline;\n import io.temporal.api.history.v1.HistoryEvent;\n-import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest;\n-import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse;\n-import io.temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponseOrBuilder;\n-import io.temporal.internal.common.GrpcRetryer;\n-import io.temporal.internal.common.RpcRetryOptions;\n-import io.temporal.serviceclient.WorkflowServiceStubs;\n-import java.time.Duration;\n import java.util.Iterator;\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-\n-/** Supports iteration over history while loading new pages through calls to the service. */\n-class WorkflowHistoryIterator implements Iterator<HistoryEvent> {\n-\n-  private final Duration retryServiceOperationInitialInterval = Duration.ofMillis(200);\n-  private final Duration retryServiceOperationMaxInterval = Duration.ofSeconds(4);\n-  private final Duration paginationStart = Duration.ofMillis(System.currentTimeMillis());\n-  public final WorkflowServiceStubs service;\n-  private final Duration workflowTaskTimeout;\n-  private final String namespace;\n-  private final Scope metricsScope;\n-  private final PollWorkflowTaskQueueResponseOrBuilder task;\n-  private Iterator<HistoryEvent> current;\n-  ByteString nextPageToken;\n-\n-  WorkflowHistoryIterator(\n-      WorkflowServiceStubs service,\n-      String namespace,\n-      PollWorkflowTaskQueueResponseOrBuilder task,\n-      Duration workflowTaskTimeout,\n-      Scope metricsScope) {\n-    this.service = service;\n-    this.namespace = namespace;\n-    this.task = task;\n-    this.workflowTaskTimeout = Objects.requireNonNull(workflowTaskTimeout);\n-    this.metricsScope = metricsScope;\n-    History history = task.getHistory();\n-    current = history.getEventsList().iterator();\n-    nextPageToken = task.getNextPageToken();\n-  }\n-\n-  // Returns true if more history events are available.\n-  // Server can return page tokens that point to empty pages.\n-  // We need to verify that page is valid before returning true.\n-  // Otherwise next() method would throw NoSuchElementException after hasNext() returning true.\n-  @Override\n-  public boolean hasNext() {\n-    if (current.hasNext()) {\n-      return true;\n-    }\n-    if (nextPageToken.isEmpty()) {\n-      return false;\n-    }\n-\n-    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();\n-\n-    current = response.getHistory().getEventsList().iterator();\n-    nextPageToken = response.getNextPageToken();\n-\n-    return current.hasNext();\n-  }\n-\n-  @Override\n-  public HistoryEvent next() {\n-    if (hasNext()) {\n-      return current.next();\n-    }\n-    throw new NoSuchElementException();\n-  }\n \n-  GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory() {\n-    Duration passed = Duration.ofMillis(System.currentTimeMillis()).minus(paginationStart);\n-    Duration expiration = workflowTaskTimeout.minus(passed);\n-    if (expiration.isZero() || expiration.isNegative()) {\n-      throw Status.DEADLINE_EXCEEDED\n-          .withDescription(\n-              \"getWorkflowExecutionHistory pagination took longer than workflow task timeout\")\n-          .asRuntimeException();\n-    }\n-    RpcRetryOptions retryOptions =\n-        RpcRetryOptions.newBuilder()\n-            .setExpiration(expiration)\n-            .setInitialInterval(retryServiceOperationInitialInterval)\n-            .setMaximumInterval(retryServiceOperationMaxInterval)\n-            .build();\n-    GetWorkflowExecutionHistoryRequest request =\n-        GetWorkflowExecutionHistoryRequest.newBuilder()\n-            .setNamespace(namespace)\n-            .setExecution(task.getWorkflowExecution())\n-            .setNextPageToken(nextPageToken)\n-            .build();\n-    try {\n-      return GrpcRetryer.retryWithResult(\n-          retryOptions,\n-          () ->\n-              service\n-                  .blockingStub()\n-                  .withOption(METRICS_TAGS_CALL_OPTIONS_KEY, metricsScope)\n-                  .getWorkflowExecutionHistory(request));\n-    } catch (Exception e) {\n-      throw new Error(e);\n-    }\n-  }\n+public interface WorkflowHistoryIterator extends Iterator<HistoryEvent> {\n+  void initDeadline(Deadline deadline);\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "cfa22296f8b795adc1ade7880e602be830118a4c", "message": "Merge commit", "committedDate": null}, {"oid": "ad8831d4a4d9d257baf3482ab49f1aa681895c0e", "committedDate": "2021-02-24 11:55:41 -0800", "message": "Make rpc retry options configurable (#359)"}, {"oid": "b0199150b69bb5a4eaf6c13ba4b89c2a8746a113", "committedDate": "2021-05-28 13:57:13 -0700", "message": "Health Check (#504)"}, {"oid": "0c09e62a3debcb0e9df92da719b63beb9c132328", "committedDate": "2021-08-24 17:54:12 -0400", "message": "GrpcRetryer now respects DEADLINE_EXCEEDED as non-retryable (#654)"}, {"oid": "94aac37986a2068527f20dba832572e5046823de", "committedDate": "2022-05-15 23:52:25 -0400", "message": "Make getResult methods to throw TimeoutException instead of raw gRPC DEADLINE_EXCEEDED (#1209)"}, {"oid": "37a0e463fae2312882b5c946f423a0dbf85f9666", "committedDate": "2022-06-03 11:06:34 -0400", "message": "Update license so Github and licensee recognise it correctly as Apache (#1245)"}, {"oid": "e41341a03b756adc7b9b2ce1ef9c05d5acfc2c4a", "committedDate": "2022-07-21 10:33:13 -0400", "message": "Refactor GrpcRetryer to enforce usage of GrpcRetryerOptions (#1316)"}, {"oid": "883f814afbfffabb81c173e8f0655d6dbe9878d6", "committedDate": "2022-07-21 15:37:11 -0400", "message": "No retrying on INTERNAL gRPC errors with the new Server versions (#1317)"}, {"oid": "8f093115930b7f3a71258bbbeec41fb74adcc701", "committedDate": "2022-08-23 16:49:24 -0400", "message": "Fix situation when direct query comes outdated (inconsistent) and applied to a more advanced cached workflow instance (#1375)"}]}, {"oid": "b845eff787e131007414996e8e373e7baba7aaf8", "url": "https://github.com/temporalio/sdk-java/commit/b845eff787e131007414996e8e373e7baba7aaf8", "message": "Verify that next page is not empty in the history iterator", "committedDate": "2020-09-23T04:53:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NTY5Mg==", "url": "https://github.com/temporalio/sdk-java/pull/219#discussion_r493855692", "body": "I don't think it is correct. As it is still going to blow up with the response contains an empty history and hasNext is not called from outside.\r\n\r\nMy proposal is to change the line 94 to:\r\n```java\r\nif (this.hasNext()) {\r\n   return current.next();\r\n}\r\n```\r\nand ensure that hasNext either caches non empty events in current or returns false.", "bodyText": "I don't think it is correct. As it is still going to blow up with the response contains an empty history and hasNext is not called from outside.\nMy proposal is to change the line 94 to:\nif (this.hasNext()) {\n   return current.next();\n}\nand ensure that hasNext either caches non empty events in current or returns false.", "bodyHTML": "<p dir=\"auto\">I don't think it is correct. As it is still going to blow up with the response contains an empty history and hasNext is not called from outside.</p>\n<p dir=\"auto\">My proposal is to change the line 94 to:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (this.hasNext()) {\n   return current.next();\n}\n\"><pre><span class=\"pl-k\">if</span> (<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>hasNext()) {\n   <span class=\"pl-k\">return</span> current<span class=\"pl-k\">.</span>next();\n}</pre></div>\n<p dir=\"auto\">and ensure that hasNext either caches non empty events in current or returns false.</p>", "author": "mfateev", "createdAt": "2020-09-23T19:51:46Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java", "diffHunk": "@@ -66,17 +66,44 @@\n     nextPageToken = task.getNextPageToken();\n   }\n \n+  // Returns true if more history events are available.\n+  // Server can return page tokens that point to empty pages.\n+  // We need to verify that page is valid before returning true.\n+  // Otherwise next() method would throw NoSuchElementException after hasNext() returning true.\n   @Override\n   public boolean hasNext() {\n-    return current.hasNext() || !nextPageToken.isEmpty();\n+    if (current.hasNext()) {\n+      return true;\n+    }\n+    if (nextPageToken.isEmpty()) {\n+      return false;\n+    }\n+\n+    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();\n+\n+    current = response.getHistory().getEventsList().iterator();\n+    nextPageToken = response.getNextPageToken();\n+\n+    return current.hasNext();\n   }\n \n   @Override\n   public HistoryEvent next() {\n-    if (current.hasNext()) {\n+    // If current has next element then simply return it, otherwise check if we have next page token\n+    // If no page token available then we should call next() which throws NoSuchElementException.\n+    if (current.hasNext() || nextPageToken.isEmpty()) {\n       return current.next();\n     }\n \n+    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();", "originalCommit": "9e97f80f5a4f8a0172329fa2c1edb415858dbfc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3MDM3OA==", "url": "https://github.com/temporalio/sdk-java/pull/219#discussion_r493870378", "bodyText": "Simplified the code a bit, but kept behavior same.", "author": "vitarb", "createdAt": "2020-09-23T20:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NTY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "fd1134daee974dcb68f26a43f859e324d7c26c4b", "changed_code": [{"header": "diff --git a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\nindex 421ec90d..a8bf7bec 100644\n--- a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n+++ b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n", "chunk": "@@ -89,18 +90,10 @@ class WorkflowHistoryIterator implements Iterator<HistoryEvent> {\n \n   @Override\n   public HistoryEvent next() {\n-    // If current has next element then simply return it, otherwise check if we have next page token\n-    // If no page token available then we should call next() which throws NoSuchElementException.\n-    if (current.hasNext() || nextPageToken.isEmpty()) {\n+    if (hasNext()) {\n       return current.next();\n     }\n-\n-    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();\n-\n-    current = response.getHistory().getEventsList().iterator();\n-    nextPageToken = response.getNextPageToken();\n-\n-    return current.next();\n+    throw new NoSuchElementException();\n   }\n \n   GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory() {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "cfa22296f8b795adc1ade7880e602be830118a4c", "changed_code": [{"header": "diff --git a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\nindex 421ec90d..08c268d9 100644\n--- a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n+++ b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n", "chunk": "@@ -89,18 +90,10 @@ class WorkflowHistoryIterator implements Iterator<HistoryEvent> {\n \n   @Override\n   public HistoryEvent next() {\n-    // If current has next element then simply return it, otherwise check if we have next page token\n-    // If no page token available then we should call next() which throws NoSuchElementException.\n-    if (current.hasNext() || nextPageToken.isEmpty()) {\n+    if (hasNext()) {\n       return current.next();\n     }\n-\n-    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();\n-\n-    current = response.getHistory().getEventsList().iterator();\n-    nextPageToken = response.getNextPageToken();\n-\n-    return current.next();\n+    throw new NoSuchElementException();\n   }\n \n   GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory() {\n", "next_change": {"commit": "8f093115930b7f3a71258bbbeec41fb74adcc701", "changed_code": [{"header": "diff --git a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\nindex 08c268d9..799726b9 100644\n--- a/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n+++ b/temporal-sdk/src/main/java/io/temporal/internal/replay/WorkflowHistoryIterator.java\n", "chunk": "@@ -1,132 +1,29 @@\n /*\n- *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ * Copyright (C) 2022 Temporal Technologies, Inc. All Rights Reserved.\n  *\n- *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (C) 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n  *\n- *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ * Modifications copyright (C) 2017 Uber Technologies, Inc.\n  *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n- *  use this file except in compliance with the License. A copy of the License is\n- *  located at\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this material except in compliance with the License.\n+ * You may obtain a copy of the License at\n  *\n- *  http://aws.amazon.com/apache2.0\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n  *\n- *  or in the \"license\" file accompanying this file. This file is distributed on\n- *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- *  express or implied. See the License for the specific language governing\n- *  permissions and limitations under the License.\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n \n package io.temporal.internal.replay;\n \n-import static io.temporal.serviceclient.MetricsTag.METRICS_TAGS_CALL_OPTIONS_KEY;\n-\n-import com.google.protobuf.ByteString;\n-import com.uber.m3.tally.Scope;\n-import io.grpc.Status;\n-import io.temporal.api.history.v1.History;\n+import io.grpc.Deadline;\n import io.temporal.api.history.v1.HistoryEvent;\n-import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest;\n-import io.temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse;\n-import io.temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponseOrBuilder;\n-import io.temporal.internal.common.GrpcRetryer;\n-import io.temporal.internal.common.RpcRetryOptions;\n-import io.temporal.serviceclient.WorkflowServiceStubs;\n-import java.time.Duration;\n import java.util.Iterator;\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-\n-/** Supports iteration over history while loading new pages through calls to the service. */\n-class WorkflowHistoryIterator implements Iterator<HistoryEvent> {\n-\n-  private final Duration retryServiceOperationInitialInterval = Duration.ofMillis(200);\n-  private final Duration retryServiceOperationMaxInterval = Duration.ofSeconds(4);\n-  private final Duration paginationStart = Duration.ofMillis(System.currentTimeMillis());\n-  public final WorkflowServiceStubs service;\n-  private final Duration workflowTaskTimeout;\n-  private final String namespace;\n-  private final Scope metricsScope;\n-  private final PollWorkflowTaskQueueResponseOrBuilder task;\n-  private Iterator<HistoryEvent> current;\n-  ByteString nextPageToken;\n-\n-  WorkflowHistoryIterator(\n-      WorkflowServiceStubs service,\n-      String namespace,\n-      PollWorkflowTaskQueueResponseOrBuilder task,\n-      Duration workflowTaskTimeout,\n-      Scope metricsScope) {\n-    this.service = service;\n-    this.namespace = namespace;\n-    this.task = task;\n-    this.workflowTaskTimeout = Objects.requireNonNull(workflowTaskTimeout);\n-    this.metricsScope = metricsScope;\n-    History history = task.getHistory();\n-    current = history.getEventsList().iterator();\n-    nextPageToken = task.getNextPageToken();\n-  }\n-\n-  // Returns true if more history events are available.\n-  // Server can return page tokens that point to empty pages.\n-  // We need to verify that page is valid before returning true.\n-  // Otherwise next() method would throw NoSuchElementException after hasNext() returning true.\n-  @Override\n-  public boolean hasNext() {\n-    if (current.hasNext()) {\n-      return true;\n-    }\n-    if (nextPageToken.isEmpty()) {\n-      return false;\n-    }\n-\n-    GetWorkflowExecutionHistoryResponse response = queryWorkflowExecutionHistory();\n-\n-    current = response.getHistory().getEventsList().iterator();\n-    nextPageToken = response.getNextPageToken();\n-\n-    return current.hasNext();\n-  }\n-\n-  @Override\n-  public HistoryEvent next() {\n-    if (hasNext()) {\n-      return current.next();\n-    }\n-    throw new NoSuchElementException();\n-  }\n \n-  GetWorkflowExecutionHistoryResponse queryWorkflowExecutionHistory() {\n-    Duration passed = Duration.ofMillis(System.currentTimeMillis()).minus(paginationStart);\n-    Duration expiration = workflowTaskTimeout.minus(passed);\n-    if (expiration.isZero() || expiration.isNegative()) {\n-      throw Status.DEADLINE_EXCEEDED\n-          .withDescription(\n-              \"getWorkflowExecutionHistory pagination took longer than workflow task timeout\")\n-          .asRuntimeException();\n-    }\n-    RpcRetryOptions retryOptions =\n-        RpcRetryOptions.newBuilder()\n-            .setExpiration(expiration)\n-            .setInitialInterval(retryServiceOperationInitialInterval)\n-            .setMaximumInterval(retryServiceOperationMaxInterval)\n-            .build();\n-    GetWorkflowExecutionHistoryRequest request =\n-        GetWorkflowExecutionHistoryRequest.newBuilder()\n-            .setNamespace(namespace)\n-            .setExecution(task.getWorkflowExecution())\n-            .setNextPageToken(nextPageToken)\n-            .build();\n-    try {\n-      return GrpcRetryer.retryWithResult(\n-          retryOptions,\n-          () ->\n-              service\n-                  .blockingStub()\n-                  .withOption(METRICS_TAGS_CALL_OPTIONS_KEY, metricsScope)\n-                  .getWorkflowExecutionHistory(request));\n-    } catch (Exception e) {\n-      throw new Error(e);\n-    }\n-  }\n+public interface WorkflowHistoryIterator extends Iterator<HistoryEvent> {\n+  void initDeadline(Deadline deadline);\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "cfa22296f8b795adc1ade7880e602be830118a4c", "message": "Merge commit", "committedDate": null}, {"oid": "ad8831d4a4d9d257baf3482ab49f1aa681895c0e", "committedDate": "2021-02-24 11:55:41 -0800", "message": "Make rpc retry options configurable (#359)"}, {"oid": "b0199150b69bb5a4eaf6c13ba4b89c2a8746a113", "committedDate": "2021-05-28 13:57:13 -0700", "message": "Health Check (#504)"}, {"oid": "0c09e62a3debcb0e9df92da719b63beb9c132328", "committedDate": "2021-08-24 17:54:12 -0400", "message": "GrpcRetryer now respects DEADLINE_EXCEEDED as non-retryable (#654)"}, {"oid": "94aac37986a2068527f20dba832572e5046823de", "committedDate": "2022-05-15 23:52:25 -0400", "message": "Make getResult methods to throw TimeoutException instead of raw gRPC DEADLINE_EXCEEDED (#1209)"}, {"oid": "37a0e463fae2312882b5c946f423a0dbf85f9666", "committedDate": "2022-06-03 11:06:34 -0400", "message": "Update license so Github and licensee recognise it correctly as Apache (#1245)"}, {"oid": "e41341a03b756adc7b9b2ce1ef9c05d5acfc2c4a", "committedDate": "2022-07-21 10:33:13 -0400", "message": "Refactor GrpcRetryer to enforce usage of GrpcRetryerOptions (#1316)"}, {"oid": "883f814afbfffabb81c173e8f0655d6dbe9878d6", "committedDate": "2022-07-21 15:37:11 -0400", "message": "No retrying on INTERNAL gRPC errors with the new Server versions (#1317)"}, {"oid": "8f093115930b7f3a71258bbbeec41fb74adcc701", "committedDate": "2022-08-23 16:49:24 -0400", "message": "Fix situation when direct query comes outdated (inconsistent) and applied to a more advanced cached workflow instance (#1375)"}]}, {"oid": "fd1134daee974dcb68f26a43f859e324d7c26c4b", "url": "https://github.com/temporalio/sdk-java/commit/fd1134daee974dcb68f26a43f859e324d7c26c4b", "message": "Verify that next page is not empty in the history iterator", "committedDate": "2020-09-23T20:16:24Z", "type": "commit"}, {"oid": "fd1134daee974dcb68f26a43f859e324d7c26c4b", "url": "https://github.com/temporalio/sdk-java/commit/fd1134daee974dcb68f26a43f859e324d7c26c4b", "message": "Verify that next page is not empty in the history iterator", "committedDate": "2020-09-23T20:16:24Z", "type": "forcePushed"}, {"oid": "66aa6afaf41944dd020d1f96a0b25b8f03c871d0", "url": "https://github.com/temporalio/sdk-java/commit/66aa6afaf41944dd020d1f96a0b25b8f03c871d0", "message": "remove test service from the test", "committedDate": "2020-09-23T20:22:50Z", "type": "commit"}, {"oid": "f859e575f04eb11af1d49c99ad3306984076e1a2", "url": "https://github.com/temporalio/sdk-java/commit/f859e575f04eb11af1d49c99ad3306984076e1a2", "message": "Improve test scenario to process an empty page", "committedDate": "2020-09-23T20:38:32Z", "type": "commit"}, {"oid": "7c0784496f75732a7e1d830d118f6f114a810259", "url": "https://github.com/temporalio/sdk-java/commit/7c0784496f75732a7e1d830d118f6f114a810259", "message": "update comment", "committedDate": "2020-09-23T20:40:42Z", "type": "commit"}]}