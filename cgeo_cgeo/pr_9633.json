{"pr_number": 9633, "pr_title": "Parse formula for waypoint in personal cache note (related to #9211)", "pr_author": "murggel", "pr_createdAt": "2020-12-30T20:05:10Z", "pr_url": "https://github.com/cgeo/cgeo/pull/9633", "timeline": [{"oid": "2adf4f7a99da07e6b5495fae0b2bb5cd45c16a1d", "url": "https://github.com/cgeo/cgeo/commit/2adf4f7a99da07e6b5495fae0b2bb5cd45c16a1d", "message": "remove duplicate files and fix codacy-issues", "committedDate": "2020-12-30T21:14:12Z", "type": "forcePushed"}, {"oid": "070f222ae7cc1832c63c629c5aee38e384cf8bd2", "url": "https://github.com/cgeo/cgeo/commit/070f222ae7cc1832c63c629c5aee38e384cf8bd2", "message": "remove duplicate files and fix codacy-issues", "committedDate": "2020-12-30T21:23:33Z", "type": "forcePushed"}, {"oid": "b9acd6af856174f0ca316af097822d3db2835a4f", "url": "https://github.com/cgeo/cgeo/commit/b9acd6af856174f0ca316af097822d3db2835a4f", "message": "refactor WaypointParser and FormulaParser to non-static class\nsplit up WaypointTest", "committedDate": "2021-01-04T11:03:39Z", "type": "forcePushed"}, {"oid": "9943521178d19ab8c1af75cf8a27e1c5dd2a1f2a", "url": "https://github.com/cgeo/cgeo/commit/9943521178d19ab8c1af75cf8a27e1c5dd2a1f2a", "message": "adapt comments and order of keywords", "committedDate": "2021-01-07T22:37:50Z", "type": "forcePushed"}, {"oid": "1c6ff72fb2d4d59b90acf7e9e2f9df22c1d2b355", "url": "https://github.com/cgeo/cgeo/commit/1c6ff72fb2d4d59b90acf7e9e2f9df22c1d2b355", "message": "adapt comments and order of keywords, fix codacy issues", "committedDate": "2021-01-07T22:48:24Z", "type": "forcePushed"}, {"oid": "d989ccc96d8969a70d220f4db22b9875a3291609", "url": "https://github.com/cgeo/cgeo/commit/d989ccc96d8969a70d220f4db22b9875a3291609", "message": "add Formula-Parser to parse coordinates with formula,\nquery valid formula-operators from CalculationUtils", "committedDate": "2021-01-08T09:09:04Z", "type": "forcePushed"}, {"oid": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "url": "https://github.com/cgeo/cgeo/commit/a402ec75a5ddba61ae9d5ad9664c02a578275580", "message": "add Formula-Parser to parse coordinates with formula,\nquery valid formula-operators from CalculationUtils", "committedDate": "2021-01-08T09:15:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554308937", "body": "c:geo does not use Serializable put Parcelable. But also the later only if needed. I assume here it is probably not needed at all? (since you use json)", "bodyText": "c:geo does not use Serializable put Parcelable. But also the later only if needed. I assume here it is probably not needed at all? (since you use json)", "bodyHTML": "<p dir=\"auto\">c:geo does not use Serializable put Parcelable. But also the later only if needed. I assume here it is probably not needed at all? (since you use json)</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:17:25Z", "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTY1OQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479659", "bodyText": "Done", "author": "murggel", "createdAt": "2021-01-09T22:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ4NDAwOA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554484008", "bodyText": "Hm, I am not sure, if it's needed for storing in DB? But I guess, there only the JSON-String is stored.\nOn testing on the emulator, I got some leaks-messages, which I have not seen before. I will switch to local master-branch, to check, whether they appear there as well or I have to take a closer look at this. Probably I will need your help then ...", "author": "murggel", "createdAt": "2021-01-09T23:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDUyODMxNw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554528317", "bodyText": "I can assure you that serialization is not needed for db store.\nWas this also in the classes before? (In case you moved them) I have the strong feeling it is not needed, but it also doesn't hurt.", "author": "eddiemuc", "createdAt": "2021-01-10T08:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDUzOTU2Mw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554539563", "bodyText": "It was already in the class before move.\nI moved it then for VariableData as well.", "author": "murggel", "createdAt": "2021-01-10T09:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwODkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/ButtonData.java b/main/src/cgeo/geocaching/calculator/ButtonData.java\nindex e278d90bd..13e6ed9c6 100644\n--- a/main/src/cgeo/geocaching/calculator/ButtonData.java\n+++ b/main/src/cgeo/geocaching/calculator/ButtonData.java\n", "chunk": "@@ -2,15 +2,13 @@ package cgeo.geocaching.calculator;\n \n import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n \n-import java.io.Serializable;\n-\n import org.json.JSONException;\n import org.json.JSONObject;\n \n /**\n  * Data used to capture the state of this particular button such that it can be restored again later\n  */\n-public final class ButtonData implements Serializable, JSONAble {\n+public final class ButtonData implements JSONAble {\n \n     /** The three states the button can be put into */\n     public enum ValueType {\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/ButtonData.java b/main/src/cgeo/geocaching/calculator/ButtonData.java\nindex 13e6ed9c6..e278d90bd 100644\n--- a/main/src/cgeo/geocaching/calculator/ButtonData.java\n+++ b/main/src/cgeo/geocaching/calculator/ButtonData.java\n", "chunk": "@@ -2,13 +2,15 @@ package cgeo.geocaching.calculator;\n \n import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n \n+import java.io.Serializable;\n+\n import org.json.JSONException;\n import org.json.JSONObject;\n \n /**\n  * Data used to capture the state of this particular button such that it can be restored again later\n  */\n-public final class ButtonData implements JSONAble {\n+public final class ButtonData implements Serializable, JSONAble {\n \n     /** The three states the button can be put into */\n     public enum ValueType {\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/ButtonData.java b/main/src/cgeo/geocaching/calculator/ButtonData.java\nindex e278d90bd..13e6ed9c6 100644\n--- a/main/src/cgeo/geocaching/calculator/ButtonData.java\n+++ b/main/src/cgeo/geocaching/calculator/ButtonData.java\n", "chunk": "@@ -2,15 +2,13 @@ package cgeo.geocaching.calculator;\n \n import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n \n-import java.io.Serializable;\n-\n import org.json.JSONException;\n import org.json.JSONObject;\n \n /**\n  * Data used to capture the state of this particular button such that it can be restored again later\n  */\n-public final class ButtonData implements Serializable, JSONAble {\n+public final class ButtonData implements JSONAble {\n \n     /** The three states the button can be put into */\n     public enum ValueType {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTIzNg==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309236", "body": "I think \"getLabel\" and \"setAutoChar\" could be instance methods of class \"ButtonData\" instead of moving them into the enum. Or am I missing something?", "bodyText": "I think \"getLabel\" and \"setAutoChar\" could be instance methods of class \"ButtonData\" instead of moving them into the enum. Or am I missing something?", "bodyHTML": "<p dir=\"auto\">I think \"getLabel\" and \"setAutoChar\" could be instance methods of class \"ButtonData\" instead of moving them into the enum. Or am I missing something?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:21:21Z", "path": "main/src/cgeo/geocaching/calculator/ButtonData.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package cgeo.geocaching.calculator;\n+\n+import static cgeo.geocaching.models.CalcState.ERROR_CHAR;\n+\n+import java.io.Serializable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+/**\n+ * Data used to capture the state of this particular button such that it can be restored again later\n+ */\n+public final class ButtonData implements Serializable, JSONAble {\n+\n+    /** The three states the button can be put into */\n+    public enum ValueType {\n+        INPUT_VAL {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.inputVal;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char nextChar) {\n+                buttonData.autoChar = nextChar;\n+                return nextChar;\n+            }\n+\n+        },\n+        AUTO_CHAR {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.autoChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar++;\n+                return nextChar;\n+            }\n+        },\n+        BLANK {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return ButtonData.BLANK;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                buttonData.autoChar = autoChar;\n+                return autoChar;\n+            }\n+        },\n+        CUSTOM {\n+            @Override\n+            public char getLabel(final ButtonData buttonData) {\n+                return buttonData.customChar;\n+            }\n+\n+            @Override\n+            public char setAutoChar(final ButtonData buttonData, final char autoChar) {\n+                char nextChar = autoChar;\n+                buttonData.autoChar = nextChar;\n+                if ('A' <= buttonData.customChar && buttonData.customChar <= 'Z') {\n+                    nextChar = buttonData.customChar;\n+                    nextChar++;\n+                }\n+\n+                return nextChar;\n+            }\n+        };\n+\n+        public abstract char getLabel(ButtonData buttonData);", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQxNTYwNA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554415604", "bodyText": "I just moved the class out of the CalculatorDialog as whole.\nBut since there are different types of Buttons, (CustomInput, Blank, AutoChar and CustomChar) which leads to different behaviour, this is handled via the abstract methods getLabel and setAutoChar of the enum", "author": "murggel", "createdAt": "2021-01-09T12:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTIzNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTM2MQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309361", "body": "+1 for making a separate package out of this! :-)", "bodyText": "+1 for making a separate package out of this! :-)", "bodyHTML": "<p dir=\"auto\">+1 for making a separate package out of this! :-)</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:23:12Z", "path": "main/src/cgeo/geocaching/calculator/CalculationUtils.java", "diffHunk": "@@ -1,4 +1,4 @@\n-package cgeo.geocaching.utils;\n+package cgeo.geocaching.calculator;", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTYxNQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554309615", "body": "Could org.apache.commons.lang3.CharUtils be used instead?\r\n\r\nIf not: can this be moved as method to an existing Utils class? Maybe TextUtils?", "bodyText": "Could org.apache.commons.lang3.CharUtils be used instead?\nIf not: can this be moved as method to an existing Utils class? Maybe TextUtils?", "bodyHTML": "<p dir=\"auto\">Could org.apache.commons.lang3.CharUtils be used instead?</p>\n<p dir=\"auto\">If not: can this be moved as method to an existing Utils class? Maybe TextUtils?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:25:30Z", "path": "main/src/cgeo/geocaching/calculator/CaseCheck.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package cgeo.geocaching.calculator;\n+\n+/**\n+ * Class used for checking that a value is with in a given range.\n+ * This is used to check for upper-case an lower-case letters.\n+ */\n+public final class CaseCheck {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQxNzIzOQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554417239", "bodyText": "I just moved the class out of the CalculatorDialog as whole.\nBut I will have a look into the package if it fits the needs", "author": "murggel", "createdAt": "2021-01-09T12:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTYwNA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479604", "bodyText": "Moved it as method to TextUtils", "author": "murggel", "createdAt": "2021-01-09T22:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwOTYxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CaseCheck.java b/main/src/cgeo/geocaching/calculator/CaseCheck.java\ndeleted file mode 100644\nindex 3be8db346..000000000\n--- a/main/src/cgeo/geocaching/calculator/CaseCheck.java\n+++ /dev/null\n", "chunk": "@@ -1,25 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-/**\n- * Class used for checking that a value is with in a given range.\n- * This is used to check for upper-case an lower-case letters.\n- */\n-public final class CaseCheck {\n-    private final boolean useUpper;\n-\n-    public CaseCheck(final boolean upper) {\n-        useUpper = upper;\n-    }\n-\n-    public boolean check(final char ch) {\n-\n-        boolean returnValue = Character.isLetterOrDigit(ch);\n-        if (useUpper) {\n-            returnValue &= Character.isUpperCase(ch);\n-        } else {\n-            returnValue &= Character.isLowerCase(ch);\n-        }\n-\n-        return returnValue;\n-    }\n-}\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CaseCheck.java b/main/src/cgeo/geocaching/calculator/CaseCheck.java\nnew file mode 100644\nindex 000000000..3be8db346\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/calculator/CaseCheck.java\n", "chunk": "@@ -0,0 +1,25 @@\n+package cgeo.geocaching.calculator;\n+\n+/**\n+ * Class used for checking that a value is with in a given range.\n+ * This is used to check for upper-case an lower-case letters.\n+ */\n+public final class CaseCheck {\n+    private final boolean useUpper;\n+\n+    public CaseCheck(final boolean upper) {\n+        useUpper = upper;\n+    }\n+\n+    public boolean check(final char ch) {\n+\n+        boolean returnValue = Character.isLetterOrDigit(ch);\n+        if (useUpper) {\n+            returnValue &= Character.isUpperCase(ch);\n+        } else {\n+            returnValue &= Character.isLowerCase(ch);\n+        }\n+\n+        return returnValue;\n+    }\n+}\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CaseCheck.java b/main/src/cgeo/geocaching/calculator/CaseCheck.java\ndeleted file mode 100644\nindex 3be8db346..000000000\n--- a/main/src/cgeo/geocaching/calculator/CaseCheck.java\n+++ /dev/null\n", "chunk": "@@ -1,25 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-/**\n- * Class used for checking that a value is with in a given range.\n- * This is used to check for upper-case an lower-case letters.\n- */\n-public final class CaseCheck {\n-    private final boolean useUpper;\n-\n-    public CaseCheck(final boolean upper) {\n-        useUpper = upper;\n-    }\n-\n-    public boolean check(final char ch) {\n-\n-        boolean returnValue = Character.isLetterOrDigit(ch);\n-        if (useUpper) {\n-            returnValue &= Character.isUpperCase(ch);\n-        } else {\n-            returnValue &= Character.isLowerCase(ch);\n-        }\n-\n-        return returnValue;\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDE4Nw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310187", "body": "Kudos for extraction of the parsing methods into an own class! :-)", "bodyText": "Kudos for extraction of the parsing methods into an own class! :-)", "bodyHTML": "<p dir=\"auto\">Kudos for extraction of the parsing methods into an own class! :-)</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:32:01Z", "path": "main/src/cgeo/geocaching/models/WaypointParser.java", "diffHunk": "@@ -0,0 +1,454 @@\n+package cgeo.geocaching.models;\n+\n+import cgeo.geocaching.calculator.CoordinatesCalculateUtils;\n+import cgeo.geocaching.calculator.FormulaParser;\n+import cgeo.geocaching.calculator.VariableData;\n+import cgeo.geocaching.enumerations.WaypointType;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.location.GeopointFormatter;\n+import cgeo.geocaching.location.GeopointParser;\n+import cgeo.geocaching.location.GeopointWrapper;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.TextUtils;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.jetbrains.annotations.NotNull;\n+\n+public class WaypointParser {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1NzAxNg==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554557016", "bodyText": "As reminder for me:\ncheck, if there are more changes in parsing methods in master which has to be adapted to WaypointParser", "author": "murggel", "createdAt": "2021-01-10T11:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDE4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f70bd2ae6f7f28b857bc005ee787f438ffa42921", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointParser.java b/main/src/cgeo/geocaching/models/WaypointParser.java\nindex 6a59b3f0b..31becaaa2 100644\n--- a/main/src/cgeo/geocaching/models/WaypointParser.java\n+++ b/main/src/cgeo/geocaching/models/WaypointParser.java\n", "chunk": "@@ -26,6 +27,8 @@ import org.jetbrains.annotations.NotNull;\n \n public class WaypointParser {\n \n+    public static final String PARSING_COORD_FORMULA_PLAIN = \"(F-PLAIN)\";\n+\n     //Constants for waypoint parsing\n     private static final String PARSING_NAME_PRAEFIX = \"@\";\n     private static final char PARSING_USERNOTE_DELIM = '\"';\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointParser.java b/main/src/cgeo/geocaching/models/WaypointParser.java\ndeleted file mode 100644\nindex 31becaaa2..000000000\n--- a/main/src/cgeo/geocaching/models/WaypointParser.java\n+++ /dev/null\n", "chunk": "@@ -1,458 +0,0 @@\n-package cgeo.geocaching.models;\n-\n-import cgeo.geocaching.calculator.CalcStateEvaluator;\n-import cgeo.geocaching.calculator.CoordinatesCalculateUtils;\n-import cgeo.geocaching.calculator.FormulaParser;\n-import cgeo.geocaching.calculator.FormulaWrapper;\n-import cgeo.geocaching.calculator.VariableData;\n-import cgeo.geocaching.enumerations.WaypointType;\n-import cgeo.geocaching.location.Geopoint;\n-import cgeo.geocaching.location.GeopointFormatter;\n-import cgeo.geocaching.location.GeopointParser;\n-import cgeo.geocaching.location.GeopointWrapper;\n-import cgeo.geocaching.settings.Settings;\n-import cgeo.geocaching.utils.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Locale;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-import org.jetbrains.annotations.NotNull;\n-\n-public class WaypointParser {\n-\n-    public static final String PARSING_COORD_FORMULA_PLAIN = \"(F-PLAIN)\";\n-\n-    //Constants for waypoint parsing\n-    private static final String PARSING_NAME_PRAEFIX = \"@\";\n-    private static final char PARSING_USERNOTE_DELIM = '\"';\n-    private static final char PARSING_USERNOTE_ESCAPE = '\\\\';\n-    private static final String PARSING_USERNOTE_CONTINUED = \"...\";\n-    private static final String PARSING_PREFIX_OPEN = \"[\";\n-    private static final String PARSING_PREFIX_CLOSE = \"]\";\n-    private static final String PARSING_TYPE_OPEN = \"(\";\n-    private static final String PARSING_TYPE_CLOSE = \")\";\n-    private static final String PARSING_COORD_EMPTY = \"(NO-COORD)\";\n-    private static final String BACKUP_TAG_OPEN = \"{c:geo-start}\";\n-    private static final String BACKUP_TAG_CLOSE = \"{c:geo-end}\";\n-\n-    private Collection<Waypoint> waypoints;\n-    private final String namePrefix;\n-    private int count;\n-\n-    /**\n-     * Detect coordinates in the given text and converts them to user-defined waypoints.\n-     * Works by rule of thumb.\n-     *\n-     * @param namePrefix Prefix of the name of the waypoint\n-     */\n-    public WaypointParser(@NonNull final String namePrefix) {\n-        this.namePrefix = namePrefix;\n-    }\n-\n-    /**\n-     * Detect coordinates in the given text and converts them to user-defined waypoints.\n-     * Works by rule of thumb.\n-     *\n-     * @param text       Text to parse for waypoints\n-     * @return a collection of found waypoints\n-     */\n-    public Collection<Waypoint> parseWaypoints(@NonNull final String text) {\n-        this.count = 1;\n-        if (null == waypoints) {\n-            waypoints = new LinkedList<>();\n-        } else {\n-            waypoints.clear();\n-        }\n-\n-        //if a backup is found, we parse it first\n-        for (final String backup : TextUtils.getAll(text, BACKUP_TAG_OPEN, BACKUP_TAG_CLOSE)) {\n-            parseWaypointsFromString(backup);\n-        }\n-        parseWaypointsFromString(TextUtils.replaceAll(text, BACKUP_TAG_OPEN, BACKUP_TAG_CLOSE, \"\"));\n-\n-        return waypoints;\n-    }\n-\n-    private void parseWaypointsFromString(final String text) {\n-        // search waypoints with coordinates\n-        parseWaypointsWithCoords(text);\n-\n-        // search waypoints with empty coordinates\n-        parseWaypointsWithSpecificCoords(text, PARSING_COORD_EMPTY, null);\n-\n-        // search waypoints with formula\n-        parseWaypointsWithSpecificCoords(text, PARSING_COORD_FORMULA_PLAIN, Settings.CoordInputFormatEnum.Plain);\n-    }\n-\n-    private void parseWaypointsWithCoords(final String text) {\n-        final Collection<GeopointWrapper> matches = GeopointParser.parseAll(text);\n-        for (final GeopointWrapper match : matches) {\n-            final Waypoint wp = parseSingleWaypoint(match, null);\n-            if (wp != null) {\n-                waypoints.add(wp);\n-                count++;\n-            }\n-        }\n-    }\n-\n-    private void parseWaypointsWithSpecificCoords(final String text, final String parsingCoord, final Settings.CoordInputFormatEnum coordFormat) {\n-        int idxWaypoint = text.indexOf(parsingCoord);\n-\n-        while (idxWaypoint >= 0) {\n-            final GeopointWrapper match = new GeopointWrapper(null, idxWaypoint, parsingCoord.length(), text);\n-            final Waypoint wp = parseSingleWaypoint(match, coordFormat);\n-            if (wp != null) {\n-                waypoints.add(wp);\n-                count++;\n-            }\n-            idxWaypoint = text.indexOf(parsingCoord, idxWaypoint + parsingCoord.length());\n-        }\n-    }\n-\n-    private Waypoint parseSingleWaypoint(final GeopointWrapper match, final Settings.CoordInputFormatEnum coordFormat) {\n-        final Geopoint point = match.getGeopoint();\n-        final Integer start = match.getStart();\n-        final Integer end = match.getEnd();\n-        final String text = match.getText();\n-\n-        final String[] wordsBefore = TextUtils.getWords(TextUtils.getTextBeforeIndexUntil(text, start, \"\\n\"));\n-        final String lastWordBefore = wordsBefore.length == 0 ? \"\" : wordsBefore[wordsBefore.length - 1];\n-\n-        //try to get a waypointType\n-        final WaypointType wpType = parseWaypointType(text.substring(Math.max(0, start - 20), start), lastWordBefore);\n-\n-        //try to get a name and a prefix\n-        final ImmutablePair<String, String> parsedNameAndPrefix = parseNameAndPrefix(wordsBefore, wpType);\n-        String name = parsedNameAndPrefix.getLeft();\n-        final String prefix = parsedNameAndPrefix.getRight();\n-        if (name == null) {\n-            name = namePrefix + \" \" + count;\n-        }\n-\n-        //create the waypoint\n-        final Waypoint waypoint = new Waypoint(name, wpType, true);\n-        waypoint.setCoords(point);\n-        waypoint.setPrefix(prefix);\n-\n-        String afterCoords = TextUtils.getTextAfterIndexUntil(text, end - 1, null);\n-\n-        if (null != coordFormat) {\n-            // try to get a formula\n-            final ImmutablePair<CalcState, String> coordFormula = parseFormula(afterCoords, coordFormat);\n-            final CalcState calcState = coordFormula.left;\n-            if (null != calcState) {\n-                waypoint.setCalcStateJson(calcState.toJSON().toString());\n-                // try to evaluate valid coordinates\n-                final CalcStateEvaluator eval = new CalcStateEvaluator(calcState.equations, calcState.freeVariables, null);\n-                final Geopoint gp = eval.evaluate(calcState.plainLat, calcState.plainLon);\n-                waypoint.setCoords(gp);\n-            }\n-\n-            afterCoords = coordFormula.right;\n-        }\n-\n-        //try to get a user note\n-        final String userNote = parseUserNote(afterCoords, 0);\n-        if (!StringUtils.isBlank(userNote)) {\n-            waypoint.setUserNote(userNote.trim());\n-        }\n-\n-        return waypoint;\n-    }\n-\n-    private String parseUserNote(final String text, final int end) {\n-        final String after = TextUtils.getTextAfterIndexUntil(text, end - 1, null).trim();\n-        if (after.startsWith(\"\" + PARSING_USERNOTE_DELIM)) {\n-            return TextUtils.parseNextDelimitedValue(after, PARSING_USERNOTE_DELIM, PARSING_USERNOTE_ESCAPE);\n-        }\n-        return TextUtils.getTextAfterIndexUntil(text, end - 1, \"\\n\");\n-    }\n-\n-    /**\n-     * try to parse a name out of given words. If not possible, null is returned\n-     */\n-    @NotNull\n-    private ImmutablePair<String, String> parseNameAndPrefix(final String[] words, final WaypointType wpType) {\n-        if (words.length == 0 || !words[0].startsWith(PARSING_NAME_PRAEFIX)) {\n-            return new ImmutablePair<>(null, null);\n-        }\n-        //first word handling\n-        String name = words[0].substring(PARSING_NAME_PRAEFIX.length());\n-        String prefix = null;\n-        final int idx = name.indexOf(PARSING_PREFIX_CLOSE);\n-        if (idx > 0 && name.startsWith(PARSING_PREFIX_OPEN)) {\n-            prefix = name.substring(PARSING_PREFIX_OPEN.length(), idx).trim();\n-            name = name.substring(idx + 1);\n-        }\n-\n-        //handle additional words if any\n-        for (int i = 1; i < words.length; i++) {\n-            if (useWordForParsedName(words[i], i == words.length - 1, wpType)) {\n-                if (name.length() > 0) {\n-                    name += \" \";\n-                }\n-                name += words[i];\n-            }\n-        }\n-        return new ImmutablePair<>(StringUtils.isBlank(name) ? null : name.trim(), prefix);\n-    }\n-\n-    private boolean useWordForParsedName(final String word, final boolean isLast, final WaypointType wpType) {\n-        return\n-            (!StringUtils.isBlank(word)) &&\n-                //remove words which are in parenthesis (is usually the waypoint type)\n-                !(word.startsWith(PARSING_TYPE_OPEN) && word.endsWith(PARSING_TYPE_CLOSE)) &&\n-                //remove last word if it is just the waypoint type id\n-                !(isLast && word.toLowerCase(Locale.getDefault()).equals(wpType.getShortId().toLowerCase(Locale.getDefault())));\n-    }\n-\n-    /**\n-     * Detect waypoint types in the personal note text. Tries to find various ways that\n-     * the waypoints name or id is written in given text.\n-     */\n-    @SuppressWarnings(\"PMD.NPathComplexity\") // method readability will not improve by splitting it up or using lambda-expressions\n-    private WaypointType parseWaypointType(final String input, final String lastWord) {\n-        final String lowerInput = input.toLowerCase(Locale.getDefault());\n-        final String lowerLastWord = lastWord.toLowerCase(Locale.getDefault());\n-\n-        //find the LAST (if any) enclosed one-letter-word in the input\n-        String enclosedShortIdCandidate = null;\n-        final int lastClosingIdx = lowerInput.lastIndexOf(PARSING_TYPE_CLOSE);\n-        if (lastClosingIdx > 0) {\n-            final int lastOpeningIdx = lowerInput.lastIndexOf(PARSING_TYPE_OPEN, lastClosingIdx);\n-            if (lastOpeningIdx >= 0 && lastOpeningIdx + PARSING_TYPE_OPEN.length() + 1 == lastClosingIdx) {\n-                enclosedShortIdCandidate = lowerInput.substring(lastClosingIdx - 1, lastClosingIdx);\n-            }\n-        }\n-\n-        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n-            final String lowerShortId = wpType.getShortId().toLowerCase(Locale.getDefault());\n-            if (lowerLastWord.equals(lowerShortId) || lowerLastWord.contains(PARSING_TYPE_OPEN + lowerShortId + PARSING_TYPE_CLOSE)) {\n-                return wpType;\n-            }\n-        }\n-        if (enclosedShortIdCandidate != null) {\n-            for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n-                if (enclosedShortIdCandidate.equals(wpType.getShortId().toLowerCase(Locale.getDefault()))) {\n-                    return wpType;\n-                }\n-            }\n-        }\n-        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n-            // check the old, longer waypoint names first (to not interfere with the shortened versions)\n-            if (lowerInput.contains(wpType.getL10n().toLowerCase(Locale.getDefault()))) {\n-                return wpType;\n-            }\n-        }\n-        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n-            // then check the new, shortened versions\n-            if (lowerInput.contains(wpType.getNameForNewWaypoint().toLowerCase(Locale.getDefault()))) {\n-                return wpType;\n-            }\n-        }\n-        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n-            if (lowerInput.contains(wpType.id)) {\n-                return wpType;\n-            }\n-        }\n-        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n-            if (lowerInput.contains(wpType.name().toLowerCase(Locale.US))) {\n-                return wpType;\n-            }\n-        }\n-        return WaypointType.WAYPOINT;\n-    }\n-\n-    /**\n-     * try to parse a name out of given words. If not possible, null is returned\n-     */\n-    @NotNull\n-    private ImmutablePair<CalcState, String> parseFormula(final String text, final Settings.CoordInputFormatEnum formulaFormat) {\n-        try {\n-            final FormulaParser formulaParser = new FormulaParser(formulaFormat);\n-            final FormulaWrapper parsedFullCoordinates = formulaParser.parse(text);\n-            if (null != parsedFullCoordinates) {\n-                final String latText = parsedFullCoordinates.getFormulaLat();\n-                final String lonText = parsedFullCoordinates.getFormulaLon();\n-                final List<VariableData> variables = new ArrayList<>();\n-\n-                // all text after the formula\n-                String remainingString = parsedFullCoordinates.getText().substring(parsedFullCoordinates.getEnd()).trim();\n-\n-                final String[] formulaList = remainingString.split(FormulaParser.WPC_DELIM_PATTERN_STRING);\n-                for (final String varText : formulaList\n-                ) {\n-                    boolean removeDelimiter = varText.isEmpty();\n-                    final String[] equations = varText.split(\"=\", -1);\n-                    if (1 <= equations.length) {\n-                        final String varName = equations[0].trim();\n-                        if (1 == varName.length()) {\n-                            removeDelimiter = true;\n-                            final String varExpression = equations[1].trim();\n-                            if (!varExpression.isEmpty()) {\n-                                variables.add(new VariableData(varName.charAt(0), varExpression));\n-                            }\n-                        }\n-                    }\n-                    if (removeDelimiter) {\n-                        final int idxWpcDelim = remainingString.indexOf(FormulaParser.WPC_DELIM);\n-                        remainingString = remainingString.substring(idxWpcDelim + 1);\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                final CalcState calcState = CoordinatesCalculateUtils.createCalcState(latText, lonText, variables);\n-\n-                return new ImmutablePair<>(calcState, remainingString);\n-            }\n-        } catch (final FormulaParser.ParseException ignored) {\n-            // no formula\n-        }\n-\n-        return new ImmutablePair<>(null, text);\n-    }\n-\n-    public static String removeParseableWaypointsFromText(final String text) {\n-        return TextUtils.replaceAll(text, BACKUP_TAG_OPEN, BACKUP_TAG_CLOSE, \"\").trim();\n-    }\n-\n-    /**\n-     * Replaces waypoints stored in text with the ones passed as parameter.\n-     *\n-     * @param text      text to search and replace waypoints in\n-     * @param waypoints new waypoints to store\n-     * @param maxSize   if >0 then total size of returned text may not exceed this parameter\n-     * @return new text, or null if waypoints could not be placed due to size restrictions\n-     */\n-    public static String putParseableWaypointsInText(final String text, final Collection<Waypoint> waypoints, final int maxSize) {\n-        final String cleanText = removeParseableWaypointsFromText(text) + \"\\n\\n\";\n-        if (maxSize > -1 && cleanText.length() > maxSize) {\n-            return null;\n-        }\n-        final String newWaypoints = getParseableText(waypoints, maxSize - cleanText.length(), true);\n-        if (newWaypoints == null) {\n-            return null;\n-        }\n-        return cleanText + newWaypoints;\n-    }\n-\n-    /**\n-     * Tries to create a parseable text containing all  information from given waypoints\n-     * and meeting a given maximum text size. Different strategies are applied to meet\n-     * that text size.\n-     * if 'includeBackupTags' is set, then returned text is surrounded by tags\n-     *\n-     * @return parseable text for wayppints, or null if maxsize cannot be met\n-     */\n-    public static String getParseableText(final Collection<Waypoint> waypoints, final int maxSize, final boolean includeBackupTags) {\n-        String text = getParseableTextWithRestrictedUserNote(waypoints, -1, includeBackupTags);\n-        if (maxSize < 0 || text.length() <= maxSize) {\n-            return text;\n-        }\n-\n-        //try to shrink size by reducing maximum user note length\n-        for (int maxUserNoteLength = 50; maxUserNoteLength >= 0; maxUserNoteLength -= 10) {\n-            text = getParseableTextWithRestrictedUserNote(waypoints, maxUserNoteLength, includeBackupTags);\n-            if (text.length() <= maxSize) {\n-                return text;\n-            }\n-        }\n-\n-        //not possible to meet size requirements\n-        return null;\n-    }\n-\n-    public static String getParseableTextWithRestrictedUserNote(final Collection<Waypoint> waypoints, final int maxUserNoteSize, final boolean includeBackupTags) {\n-        //no streaming allowed\n-        final List<String> waypointsAsStrings = new ArrayList<>();\n-        for (final Waypoint wp : waypoints) {\n-            waypointsAsStrings.add(getParseableText(wp, maxUserNoteSize));\n-        }\n-        return (includeBackupTags ? BACKUP_TAG_OPEN + \"\\n\" : \"\") +\n-            StringUtils.join(waypointsAsStrings, \"\\n\") +\n-            (includeBackupTags ? \"\\n\" + BACKUP_TAG_CLOSE : \"\");\n-    }\n-\n-    /**\n-     * creates parseable waypoint text\n-     *\n-     * @param maxUserNoteSize if -1, user notes size is not limited. if 0, user note is omitted.\n-     *                        if >0 user note size is limited to given size\n-     * @return parseable waypoint text\n-     */\n-    public static String getParseableText(final Waypoint wp, final int maxUserNoteSize) {\n-        final StringBuilder sb = new StringBuilder();\n-        //name\n-        sb.append(PARSING_NAME_PRAEFIX);\n-        if (!wp.isUserDefined()) {\n-            sb.append(PARSING_PREFIX_OPEN).append(wp.getPrefix()).append(PARSING_PREFIX_CLOSE);\n-        }\n-        sb.append(wp.getName()).append(\" \");\n-\n-        //type\n-        sb.append(PARSING_TYPE_OPEN).append(wp.getWaypointType().getShortId().toUpperCase(Locale.US))\n-            .append(PARSING_TYPE_CLOSE).append(\" \");\n-        //coordinate\n-        if (wp.getCoords() == null) {\n-            final String calcStateJson = wp.getCalcStateJson();\n-            if (null != calcStateJson) {\n-                sb.append(getParseableFormula(wp));\n-            } else {\n-                sb.append(PARSING_COORD_EMPTY);\n-            }\n-        } else {\n-            sb.append(wp.getCoords().format(GeopointFormatter.Format.LAT_LON_DECMINUTE_SHORT_RAW));\n-        }\n-\n-        //user note\n-        String userNote = wp.getUserNote();\n-        if (maxUserNoteSize != 0 && !StringUtils.isBlank(userNote)) {\n-            if (maxUserNoteSize > 0 && userNote.length() > maxUserNoteSize) {\n-                userNote = userNote.substring(0, maxUserNoteSize) + PARSING_USERNOTE_CONTINUED;\n-            }\n-            //if user note contains itself newlines, then start user note on a second line\n-            sb.append(userNote.contains(\"\\n\") ? \"\\n\" : \" \");\n-            sb.append(TextUtils.createDelimitedValue(userNote, PARSING_USERNOTE_DELIM, PARSING_USERNOTE_ESCAPE));\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    public static String getParseableFormula(final Waypoint wp) {\n-        return getPlainFormula(wp);\n-    }\n-\n-    private static String getPlainFormula(final Waypoint wp) {\n-        final StringBuilder sb = new StringBuilder();\n-\n-        final String calcStateJson = wp.getCalcStateJson();\n-        if (null != calcStateJson) {\n-            final CalcState calcState = CalcState.fromJSON(calcStateJson);\n-            if (calcState.format == Settings.CoordInputFormatEnum.Plain) {\n-                sb.append(PARSING_COORD_FORMULA_PLAIN + \" \");\n-                sb.append(calcState.plainLat + \" \" + calcState.plainLon + \" \");\n-                for (VariableData equ : calcState.equations) {\n-                    final String equExpr = equ.getExpression().trim();\n-                    if (!equExpr.isEmpty()) {\n-                        sb.append(\"\" + FormulaParser.WPC_DELIM + equ.getName() + \"=\" + equExpr);\n-                    }\n-                }\n-                for (VariableData var : calcState.freeVariables) {\n-                    final String varExpr = var.getExpression().trim();\n-                    if (!varExpr.isEmpty()) {\n-                        sb.append(\"\" + FormulaParser.WPC_DELIM + var.getName() + \"=\" + varExpr);\n-                    }\n-                }\n-                sb.append(\"\" + FormulaParser.WPC_DELIM);\n-            }\n-        }\n-        return sb.toString();\n-    }\n-}\n", "next_change": {"commit": "857908a08c9b5652a36600c7c081d46dbdf33803", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointParser.java b/main/src/cgeo/geocaching/models/WaypointParser.java\nnew file mode 100644\nindex 000000000..575bf105c\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/models/WaypointParser.java\n", "chunk": "@@ -0,0 +1,337 @@\n+package cgeo.geocaching.models;\n+\n+import cgeo.geocaching.enumerations.WaypointType;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.location.GeopointFormatter;\n+import cgeo.geocaching.location.GeopointParser;\n+import cgeo.geocaching.location.GeopointWrapper;\n+import cgeo.geocaching.utils.TextUtils;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.jetbrains.annotations.NotNull;\n+\n+public class WaypointParser {\n+\n+    //Constants for waypoint parsing\n+    private static final String PARSING_NAME_PRAEFIX = \"@\";\n+    private static final char PARSING_USERNOTE_DELIM = '\"';\n+    private static final char PARSING_USERNOTE_ESCAPE = '\\\\';\n+    private static final String PARSING_USERNOTE_CONTINUED = \"...\";\n+    private static final String PARSING_PREFIX_OPEN = \"[\";\n+    private static final String PARSING_PREFIX_CLOSE = \"]\";\n+    private static final String PARSING_TYPE_OPEN = \"(\";\n+    private static final String PARSING_TYPE_CLOSE = \")\";\n+    private static final String PARSING_COORD_EMPTY = \"(NO-COORD)\";\n+    private static final String BACKUP_TAG_OPEN = \"{c:geo-start}\";\n+    private static final String BACKUP_TAG_CLOSE = \"{c:geo-end}\";\n+\n+    private Collection<Waypoint> waypoints;\n+    private final String namePrefix;\n+    private int count;\n+\n+    /**\n+     * Detect coordinates in the given text and converts them to user-defined waypoints.\n+     * Works by rule of thumb.\n+     *\n+     * @param namePrefix Prefix of the name of the waypoint\n+     */\n+    public WaypointParser(@NonNull final String namePrefix) {\n+        this.namePrefix = namePrefix;\n+    }\n+\n+    /**\n+     * Detect coordinates in the given text and converts them to user-defined waypoints.\n+     * Works by rule of thumb.\n+     *\n+     * @param text       Text to parse for waypoints\n+     * @return a collection of found waypoints\n+     */\n+    public Collection<Waypoint> parseWaypoints(@NonNull final String text) {\n+        this.count = 1;\n+        if (null == waypoints) {\n+            waypoints = new LinkedList<>();\n+        } else {\n+            waypoints.clear();\n+        }\n+\n+        //if a backup is found, we parse it first\n+        for (final String backup : TextUtils.getAll(text, BACKUP_TAG_OPEN, BACKUP_TAG_CLOSE)) {\n+            parseWaypointsFromString(backup);\n+        }\n+        parseWaypointsFromString(TextUtils.replaceAll(text, BACKUP_TAG_OPEN, BACKUP_TAG_CLOSE, \"\"));\n+\n+        return waypoints;\n+    }\n+\n+    private void parseWaypointsFromString(final String text) {\n+        final Collection<GeopointWrapper> matches = GeopointParser.parseAll(text);\n+        for (final GeopointWrapper match : matches) {\n+            final Waypoint wp = parseSingleWaypoint(match, count);\n+            if (wp != null) {\n+                waypoints.add(wp);\n+                count++;\n+            }\n+        }\n+\n+        // search waypoints with empty coordinates\n+        int idxCoord = text.indexOf(PARSING_COORD_EMPTY);\n+        while (idxCoord >= 0) {\n+            final GeopointWrapper match = new GeopointWrapper(null, idxCoord, PARSING_COORD_EMPTY.length(), text);\n+            final Waypoint wp = parseSingleWaypoint(match, count);\n+            if (wp != null) {\n+                waypoints.add(wp);\n+                count++;\n+            }\n+            idxCoord = text.indexOf(PARSING_COORD_EMPTY, idxCoord + PARSING_COORD_EMPTY.length());\n+        }\n+    }\n+\n+    public Waypoint parseSingleWaypoint(final GeopointWrapper match, final int count) {\n+        final Geopoint point = match.getGeopoint();\n+        final Integer start = match.getStart();\n+        final Integer end = match.getEnd();\n+        final String text = match.getText();\n+\n+        final String[] wordsBefore = TextUtils.getWords(TextUtils.getTextBeforeIndexUntil(text, start, \"\\n\"));\n+        final String lastWordBefore = wordsBefore.length == 0 ? \"\" : wordsBefore[wordsBefore.length - 1];\n+\n+        //try to get a waypointType\n+        final WaypointType wpType = parseWaypointType(text.substring(Math.max(0, start - 20), start), lastWordBefore);\n+\n+        //try to get a name and a prefix\n+        final ImmutablePair<String, String> parsedNameAndPrefix = parseNameAndPrefix(wordsBefore, wpType);\n+        String name = parsedNameAndPrefix.getLeft();\n+        final String prefix = parsedNameAndPrefix.getRight();\n+        if (name == null) {\n+            name = namePrefix + \" \" + count;\n+        }\n+\n+        //create the waypoint\n+        final Waypoint waypoint = new Waypoint(name, wpType, true);\n+        waypoint.setCoords(point);\n+        waypoint.setPrefix(prefix);\n+\n+        final String afterCoords = TextUtils.getTextAfterIndexUntil(text, end - 1, null);\n+\n+        //try to get a user note\n+        final String userNote = parseUserNote(afterCoords, 0);\n+        if (!StringUtils.isBlank(userNote)) {\n+            waypoint.setUserNote(userNote.trim());\n+        }\n+\n+        return waypoint;\n+    }\n+\n+    private String parseUserNote(final String text, final int end) {\n+        final String after = TextUtils.getTextAfterIndexUntil(text, end - 1, null).trim();\n+        if (after.startsWith(\"\" + PARSING_USERNOTE_DELIM)) {\n+            return TextUtils.parseNextDelimitedValue(after, PARSING_USERNOTE_DELIM, PARSING_USERNOTE_ESCAPE);\n+        }\n+        return TextUtils.getTextAfterIndexUntil(text, end - 1, \"\\n\");\n+    }\n+\n+    /**\n+     * try to parse a name out of given words. If not possible, null is returned\n+     */\n+    @NotNull\n+    private ImmutablePair<String, String> parseNameAndPrefix(final String[] words, final WaypointType wpType) {\n+        if (words.length == 0 || !words[0].startsWith(PARSING_NAME_PRAEFIX)) {\n+            return new ImmutablePair<>(null, null);\n+        }\n+        //first word handling\n+        String name = words[0].substring(PARSING_NAME_PRAEFIX.length());\n+        String prefix = null;\n+        final int idx = name.indexOf(PARSING_PREFIX_CLOSE);\n+        if (idx > 0 && name.startsWith(PARSING_PREFIX_OPEN)) {\n+            prefix = name.substring(PARSING_PREFIX_OPEN.length(), idx).trim();\n+            name = name.substring(idx + 1);\n+        }\n+\n+        //handle additional words if any\n+        for (int i = 1; i < words.length; i++) {\n+            if (useWordForParsedName(words[i], i == words.length - 1, wpType)) {\n+                if (name.length() > 0) {\n+                    name += \" \";\n+                }\n+                name += words[i];\n+            }\n+        }\n+        return new ImmutablePair<>(StringUtils.isBlank(name) ? null : name.trim(), prefix);\n+    }\n+\n+    private boolean useWordForParsedName(final String word, final boolean isLast, final WaypointType wpType) {\n+        return\n+            (!StringUtils.isBlank(word)) &&\n+                //remove words which are in parenthesis (is usually the waypoint type)\n+                !(word.startsWith(PARSING_TYPE_OPEN) && word.endsWith(PARSING_TYPE_CLOSE)) &&\n+                //remove last word if it is just the waypoint type id\n+                !(isLast && word.toLowerCase(Locale.getDefault()).equals(wpType.getShortId().toLowerCase(Locale.getDefault())));\n+    }\n+\n+    /**\n+     * Detect waypoint types in the personal note text. Tries to find various ways that\n+     * the waypoints name or id is written in given text.\n+     */\n+    @SuppressWarnings(\"PMD.NPathComplexity\") // method readability will not improve by splitting it up or using lambda-expressions\n+    private WaypointType parseWaypointType(final String input, final String lastWord) {\n+        final String lowerInput = input.toLowerCase(Locale.getDefault());\n+        final String lowerLastWord = lastWord.toLowerCase(Locale.getDefault());\n+\n+        //find the LAST (if any) enclosed one-letter-word in the input\n+        String enclosedShortIdCandidate = null;\n+        final int lastClosingIdx = lowerInput.lastIndexOf(PARSING_TYPE_CLOSE);\n+        if (lastClosingIdx > 0) {\n+            final int lastOpeningIdx = lowerInput.lastIndexOf(PARSING_TYPE_OPEN, lastClosingIdx);\n+            if (lastOpeningIdx >= 0 && lastOpeningIdx + PARSING_TYPE_OPEN.length() + 1 == lastClosingIdx) {\n+                enclosedShortIdCandidate = lowerInput.substring(lastClosingIdx - 1, lastClosingIdx);\n+            }\n+        }\n+\n+        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n+            final String lowerShortId = wpType.getShortId().toLowerCase(Locale.getDefault());\n+            if (lowerLastWord.equals(lowerShortId) || lowerLastWord.contains(PARSING_TYPE_OPEN + lowerShortId + PARSING_TYPE_CLOSE)) {\n+                return wpType;\n+            }\n+        }\n+        if (enclosedShortIdCandidate != null) {\n+            for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n+                if (enclosedShortIdCandidate.equals(wpType.getShortId().toLowerCase(Locale.getDefault()))) {\n+                    return wpType;\n+                }\n+            }\n+        }\n+        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n+            // check the old, longer waypoint names first (to not interfere with the shortened versions)\n+            if (lowerInput.contains(wpType.getL10n().toLowerCase(Locale.getDefault()))) {\n+                return wpType;\n+            }\n+        }\n+        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n+            // then check the new, shortened versions\n+            if (lowerInput.contains(wpType.getNameForNewWaypoint().toLowerCase(Locale.getDefault()))) {\n+                return wpType;\n+            }\n+        }\n+        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n+            if (lowerInput.contains(wpType.id)) {\n+                return wpType;\n+            }\n+        }\n+        for (final WaypointType wpType : WaypointType.ALL_TYPES) {\n+            if (lowerInput.contains(wpType.name().toLowerCase(Locale.US))) {\n+                return wpType;\n+            }\n+        }\n+        return WaypointType.WAYPOINT;\n+    }\n+\n+    public static String removeParseableWaypointsFromText(final String text) {\n+        return TextUtils.replaceAll(text, BACKUP_TAG_OPEN, BACKUP_TAG_CLOSE, \"\").trim();\n+    }\n+\n+    /**\n+     * Replaces waypoints stored in text with the ones passed as parameter.\n+     *\n+     * @param text      text to search and replace waypoints in\n+     * @param waypoints new waypoints to store\n+     * @param maxSize   if >0 then total size of returned text may not exceed this parameter\n+     * @return new text, or null if waypoints could not be placed due to size restrictions\n+     */\n+    public static String putParseableWaypointsInText(final String text, final Collection<Waypoint> waypoints, final int maxSize) {\n+        final String cleanText = removeParseableWaypointsFromText(text) + \"\\n\\n\";\n+        if (maxSize > -1 && cleanText.length() > maxSize) {\n+            return null;\n+        }\n+        final String newWaypoints = getParseableText(waypoints, maxSize - cleanText.length(), true);\n+        if (newWaypoints == null) {\n+            return null;\n+        }\n+        return cleanText + newWaypoints;\n+    }\n+\n+    /**\n+     * Tries to create a parseable text containing all  information from given waypoints\n+     * and meeting a given maximum text size. Different strategies are applied to meet\n+     * that text size.\n+     * if 'includeBackupTags' is set, then returned text is surrounded by tags\n+     *\n+     * @return parseable text for wayppints, or null if maxsize cannot be met\n+     */\n+    public static String getParseableText(final Collection<Waypoint> waypoints, final int maxSize, final boolean includeBackupTags) {\n+        String text = getParseableTextWithRestrictedUserNote(waypoints, -1, includeBackupTags);\n+        if (maxSize < 0 || text.length() <= maxSize) {\n+            return text;\n+        }\n+\n+        //try to shrink size by reducing maximum user note length\n+        for (int maxUserNoteLength = 50; maxUserNoteLength >= 0; maxUserNoteLength -= 10) {\n+            text = getParseableTextWithRestrictedUserNote(waypoints, maxUserNoteLength, includeBackupTags);\n+            if (text.length() <= maxSize) {\n+                return text;\n+            }\n+        }\n+\n+        //not possible to meet size requirements\n+        return null;\n+    }\n+\n+    public static String getParseableTextWithRestrictedUserNote(final Collection<Waypoint> waypoints, final int maxUserNoteSize, final boolean includeBackupTags) {\n+        //no streaming allowed\n+        final List<String> waypointsAsStrings = new ArrayList<>();\n+        for (final Waypoint wp : waypoints) {\n+            waypointsAsStrings.add(getParseableText(wp, maxUserNoteSize));\n+        }\n+        return (includeBackupTags ? BACKUP_TAG_OPEN + \"\\n\" : \"\") +\n+            StringUtils.join(waypointsAsStrings, \"\\n\") +\n+            (includeBackupTags ? \"\\n\" + BACKUP_TAG_CLOSE : \"\");\n+    }\n+\n+    /**\n+     * creates parseable waypoint text\n+     *\n+     * @param maxUserNoteSize if -1, user notes size is not limited. if 0, user note is omitted.\n+     *                        if >0 user note size is limited to given size\n+     * @return parseable waypoint text\n+     */\n+    public static String getParseableText(final Waypoint wp, final int maxUserNoteSize) {\n+        final StringBuilder sb = new StringBuilder();\n+        //name\n+        sb.append(PARSING_NAME_PRAEFIX);\n+        if (!wp.isUserDefined()) {\n+            sb.append(PARSING_PREFIX_OPEN).append(wp.getPrefix()).append(PARSING_PREFIX_CLOSE);\n+        }\n+        sb.append(wp.getName()).append(\" \");\n+\n+        //type\n+        sb.append(PARSING_TYPE_OPEN).append(wp.getWaypointType().getShortId().toUpperCase(Locale.US))\n+            .append(PARSING_TYPE_CLOSE).append(\" \");\n+        //coordinate\n+        if (wp.getCoords() == null) {\n+            sb.append(PARSING_COORD_EMPTY);\n+        } else {\n+            sb.append(wp.getCoords().format(GeopointFormatter.Format.LAT_LON_DECMINUTE_SHORT_RAW));\n+        }\n+\n+        //user note\n+        String userNote = wp.getUserNote();\n+        if (maxUserNoteSize != 0 && !StringUtils.isBlank(userNote)) {\n+            if (maxUserNoteSize > 0 && userNote.length() > maxUserNoteSize) {\n+                userNote = userNote.substring(0, maxUserNoteSize) + PARSING_USERNOTE_CONTINUED;\n+            }\n+            //if user note contains itself newlines, then start user note on a second line\n+            sb.append(userNote.contains(\"\\n\") ? \"\\n\" : \" \");\n+            sb.append(TextUtils.createDelimitedValue(userNote, PARSING_USERNOTE_DELIM, PARSING_USERNOTE_ESCAPE));\n+        }\n+\n+        return sb.toString();\n+    }\n+}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointParser.java b/main/src/cgeo/geocaching/models/WaypointParser.java\nindex 575bf105c..6a59b3f0b 100644\n--- a/main/src/cgeo/geocaching/models/WaypointParser.java\n+++ b/main/src/cgeo/geocaching/models/WaypointParser.java\n", "chunk": "@@ -334,4 +414,41 @@ public class WaypointParser {\n \n         return sb.toString();\n     }\n+\n+    public static String getParseableFormula(final Waypoint wp) {\n+        return getPlainFormula(wp);\n+    }\n+\n+    private static String getPlainFormula(final Waypoint wp) {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        final String calcStateJson = wp.getCalcStateJson();\n+        final String plainFormula = exportPlainFormula(calcStateJson, FormulaParser.WPC_DELIM);\n+        if (null != plainFormula) {\n+            sb.append(PARSING_COORD_FORMULA_PLAIN);\n+            sb.append(plainFormula + \"\\n\");\n+            sb.append(FormulaParser.WPC_DELIM);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static String exportPlainFormula(final String calcStateJson, final char delimiter) {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        if (null != calcStateJson) {\n+            final CalcState calcState = CalcState.fromJSON(calcStateJson);\n+            if (calcState.format == Settings.CoordInputFormatEnum.Plain) {\n+                sb.append(calcState.plainLat + delimiter + calcState.plainLon + \"\\n\");\n+                for (VariableData equ : calcState.equations) {\n+                    sb.append(delimiter + equ.getName() + \" = \" + equ.getExpression());\n+                }\n+                sb.append(\"\\n\");\n+                for (VariableData var : calcState.freeVariables) {\n+                    sb.append(delimiter + var.getName() + \" = \" + var.getExpression());\n+                }\n+                sb.append(\"\\n\");\n+            }\n+        }\n+        return sb.toString();\n+    }\n }\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointParser.java b/main/src/cgeo/geocaching/models/WaypointParser.java\nindex 6a59b3f0b..3bda5aed3 100644\n--- a/main/src/cgeo/geocaching/models/WaypointParser.java\n+++ b/main/src/cgeo/geocaching/models/WaypointParser.java\n", "chunk": "@@ -432,19 +430,19 @@ public class WaypointParser {\n         return sb.toString();\n     }\n \n-    private static String exportPlainFormula(final String calcStateJson, final char delimiter) {\n+    private static String exportPlainFormula(final String calcStateJson) {\n         final StringBuilder sb = new StringBuilder();\n \n         if (null != calcStateJson) {\n             final CalcState calcState = CalcState.fromJSON(calcStateJson);\n             if (calcState.format == Settings.CoordInputFormatEnum.Plain) {\n-                sb.append(calcState.plainLat + delimiter + calcState.plainLon + \"\\n\");\n+                sb.append(calcState.plainLat + FormulaParser.WPC_DELIM + calcState.plainLon + \"\\n\");\n                 for (VariableData equ : calcState.equations) {\n-                    sb.append(delimiter + equ.getName() + \" = \" + equ.getExpression());\n+                    sb.append(FormulaParser.WPC_DELIM + equ.getName() + \" = \" + equ.getExpression());\n                 }\n                 sb.append(\"\\n\");\n                 for (VariableData var : calcState.freeVariables) {\n-                    sb.append(delimiter + var.getName() + \" = \" + var.getExpression());\n+                    sb.append(FormulaParser.WPC_DELIM + var.getName() + \" = \" + var.getExpression());\n                 }\n                 sb.append(\"\\n\");\n             }\n", "next_change": {"commit": "af91323ed99f67b76dc4479a659b5a48bae865a9", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointParser.java b/main/src/cgeo/geocaching/models/WaypointParser.java\nindex 3bda5aed3..151fb56ee 100644\n--- a/main/src/cgeo/geocaching/models/WaypointParser.java\n+++ b/main/src/cgeo/geocaching/models/WaypointParser.java\n", "chunk": "@@ -421,30 +419,24 @@ public class WaypointParser {\n         final StringBuilder sb = new StringBuilder();\n \n         final String calcStateJson = wp.getCalcStateJson();\n-        final String plainFormula = exportPlainFormula(calcStateJson);\n-        if (null != plainFormula) {\n-            sb.append(PARSING_COORD_FORMULA_PLAIN);\n-            sb.append(plainFormula + \"\\n\");\n-            sb.append(FormulaParser.WPC_DELIM);\n-        }\n-        return sb.toString();\n-    }\n-\n-    private static String exportPlainFormula(final String calcStateJson) {\n-        final StringBuilder sb = new StringBuilder();\n-\n         if (null != calcStateJson) {\n             final CalcState calcState = CalcState.fromJSON(calcStateJson);\n             if (calcState.format == Settings.CoordInputFormatEnum.Plain) {\n-                sb.append(calcState.plainLat + FormulaParser.WPC_DELIM + calcState.plainLon + \"\\n\");\n+                sb.append(PARSING_COORD_FORMULA_PLAIN + \" \");\n+                sb.append(calcState.plainLat + \" \" + calcState.plainLon + \" \");\n                 for (VariableData equ : calcState.equations) {\n-                    sb.append(FormulaParser.WPC_DELIM + equ.getName() + \" = \" + equ.getExpression());\n+                    final String equExpr = equ.getExpression().trim();\n+                    if (!equExpr.isEmpty()) {\n+                        sb.append(\"\" + FormulaParser.WPC_DELIM + equ.getName() + \"=\" + equExpr);\n+                    }\n                 }\n-                sb.append(\"\\n\");\n                 for (VariableData var : calcState.freeVariables) {\n-                    sb.append(FormulaParser.WPC_DELIM + var.getName() + \" = \" + var.getExpression());\n+                    final String varExpr = var.getExpression().trim();\n+                    if (!varExpr.isEmpty()) {\n+                        sb.append(\"\" + FormulaParser.WPC_DELIM + var.getName() + \"=\" + varExpr);\n+                    }\n                 }\n-                sb.append(\"\\n\");\n+                sb.append(\"\" + FormulaParser.WPC_DELIM);\n             }\n         }\n         return sb.toString();\n", "next_change": {"commit": "30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointParser.java b/main/src/cgeo/geocaching/models/WaypointParser.java\nindex 151fb56ee..eb0c51fef 100644\n--- a/main/src/cgeo/geocaching/models/WaypointParser.java\n+++ b/main/src/cgeo/geocaching/models/WaypointParser.java\n", "chunk": "@@ -412,31 +426,45 @@ public class WaypointParser {\n     }\n \n     public static String getParseableFormula(final Waypoint wp) {\n-        return getPlainFormula(wp);\n-    }\n-\n-    private static String getPlainFormula(final Waypoint wp) {\n         final StringBuilder sb = new StringBuilder();\n \n         final String calcStateJson = wp.getCalcStateJson();\n         if (null != calcStateJson) {\n             final CalcState calcState = CalcState.fromJSON(calcStateJson);\n-            if (calcState.format == Settings.CoordInputFormatEnum.Plain) {\n-                sb.append(PARSING_COORD_FORMULA_PLAIN + \" \");\n-                sb.append(calcState.plainLat + \" \" + calcState.plainLon + \" \");\n-                for (VariableData equ : calcState.equations) {\n-                    final String equExpr = equ.getExpression().trim();\n-                    if (!equExpr.isEmpty()) {\n-                        sb.append(\"\" + FormulaParser.WPC_DELIM + equ.getName() + \"=\" + equExpr);\n-                    }\n-                }\n-                for (VariableData var : calcState.freeVariables) {\n-                    final String varExpr = var.getExpression().trim();\n-                    if (!varExpr.isEmpty()) {\n-                        sb.append(\"\" + FormulaParser.WPC_DELIM + var.getName() + \"=\" + varExpr);\n-                    }\n+\n+            final String formulaString = getParseableFormulaString(calcState);\n+            if (!formulaString.isEmpty()) {\n+                sb.append(formulaString);\n+                final String variableString = getParseableVariablesString(calcState);\n+                if (!variableString.isEmpty()) {\n+                    sb.append(FormulaParser.WPC_DELIM + variableString);\n                 }\n-                sb.append(\"\" + FormulaParser.WPC_DELIM);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static String getParseableFormulaString(final CalcState calcState) {\n+        final StringBuilder sb = new StringBuilder();\n+        if (calcState.format == Settings.CoordInputFormatEnum.Plain) {\n+            sb.append(PARSING_COORD_FORMULA_PLAIN + \" \");\n+            sb.append(calcState.plainLat + \" \" + calcState.plainLon + \" \");\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static String getParseableVariablesString(final CalcState calcState) {\n+        final StringBuilder sb = new StringBuilder();\n+        for (VariableData equ : calcState.equations) {\n+            final String equExpr = equ.getExpression().trim();\n+            if (!equExpr.isEmpty()) {\n+                sb.append(equ.getName() + \"=\" + equExpr + FormulaParser.WPC_DELIM);\n+            }\n+        }\n+        for (VariableData var : calcState.freeVariables) {\n+            final String varExpr = var.getExpression().trim();\n+            if (!varExpr.isEmpty()) {\n+                sb.append(var.getName() + \"=\" + varExpr + FormulaParser.WPC_DELIM);\n             }\n         }\n         return sb.toString();\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDMyMA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310320", "body": "Use the constant here instead of hardcoded --", "bodyText": "Use the constant here instead of hardcoded --", "bodyHTML": "<p dir=\"auto\">Use the constant here instead of hardcoded --</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:33:28Z", "path": "main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package cgeo.geocaching.models;\n+\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class WaypointUserNoteCombiner {\n+\n+    private static final String SEPARATOR = \"\\n--\\n\";\n+    private static final Pattern PATTERN_SEPARATOR_SPLIT = Pattern.compile(\"\\\\s*\" + SEPARATOR + \"\\\\s*\");\n+\n+    private Waypoint waypoint;\n+\n+    /**\n+     *\n+     */\n+    public WaypointUserNoteCombiner(final Waypoint waypoint) {\n+        this.waypoint = waypoint;\n+    }\n+\n+\n+    /**\n+     * Combine note and user note. Separated with Separator \"\\n--\\n\"\n+     *\n+     * @return string with combined note\n+     */\n+    public final String getCombinedNoteAndUserNote() {\n+        final String userNote = this.waypoint.getUserNote();\n+        if (this.waypoint.isUserDefined()) {\n+            return userNote;\n+        } else {\n+            final StringBuilder newNote = new StringBuilder(this.waypoint.getNote());\n+            if (StringUtils.isNotEmpty(userNote)) {\n+                newNote.append(SEPARATOR);\n+                newNote.append(userNote);\n+            }\n+            return newNote.toString();\n+        }\n+    }\n+\n+    /**\n+     * Split up given string into note and user note (separated with \\n--\\n).\n+     * For userDefined waypoints only userNote is set.\n+     *\n+     * @param combinedNote note to split up\n+     */\n+    public void updateNoteAndUserNote(final String combinedNote) {\n+        if (combinedNote != null) {\n+            String fixedCombinedNote = combinedNote;\n+            // \\n was removed via validate\n+            if (combinedNote.startsWith(\"--\\n\")) {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTU3MA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479570", "bodyText": "Done", "author": "murggel", "createdAt": "2021-01-09T22:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java b/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java\nindex 129701b60..17c835c33 100644\n--- a/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java\n+++ b/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java\n", "chunk": "@@ -48,7 +49,7 @@ public class WaypointUserNoteCombiner {\n         if (combinedNote != null) {\n             String fixedCombinedNote = combinedNote;\n             // \\n was removed via validate\n-            if (combinedNote.startsWith(\"--\\n\")) {\n+            if (combinedNote.startsWith (SEPARATOR + \"\\n\")) {\n                 fixedCombinedNote = \"\\n\" + combinedNote;\n             }\n \n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java b/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java\ndeleted file mode 100644\nindex 17c835c33..000000000\n--- a/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java\n+++ /dev/null\n", "chunk": "@@ -1,85 +0,0 @@\n-package cgeo.geocaching.models;\n-\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-\n-public class WaypointUserNoteCombiner {\n-\n-    private static final String SEPARATOR = \"--\";\n-    private static final String LF_SEPARATOR_LF = \"\\n\" + SEPARATOR + \"\\n\";\n-    private static final Pattern PATTERN_SEPARATOR_SPLIT = Pattern.compile(\"\\\\s*\" + LF_SEPARATOR_LF + \"\\\\s*\");\n-\n-    private Waypoint waypoint;\n-\n-    /**\n-     *\n-     */\n-    public WaypointUserNoteCombiner(final Waypoint waypoint) {\n-        this.waypoint = waypoint;\n-    }\n-\n-\n-    /**\n-     * Combine note and user note. Separated with Separator \"\\n--\\n\"\n-     *\n-     * @return string with combined note\n-     */\n-    public final String getCombinedNoteAndUserNote() {\n-        final String userNote = this.waypoint.getUserNote();\n-        if (this.waypoint.isUserDefined()) {\n-            return userNote;\n-        } else {\n-            final StringBuilder newNote = new StringBuilder(this.waypoint.getNote());\n-            if (StringUtils.isNotEmpty(userNote)) {\n-                newNote.append(LF_SEPARATOR_LF);\n-                newNote.append(userNote);\n-            }\n-            return newNote.toString();\n-        }\n-    }\n-\n-    /**\n-     * Split up given string into note and user note (separated with \\n--\\n).\n-     * For userDefined waypoints only userNote is set.\n-     *\n-     * @param combinedNote note to split up\n-     */\n-    public void updateNoteAndUserNote(final String combinedNote) {\n-        if (combinedNote != null) {\n-            String fixedCombinedNote = combinedNote;\n-            // \\n was removed via validate\n-            if (combinedNote.startsWith (SEPARATOR + \"\\n\")) {\n-                fixedCombinedNote = \"\\n\" + combinedNote;\n-            }\n-\n-            if (this.waypoint.isUserDefined()) {\n-                this.waypoint.setUserNote(fixedCombinedNote);\n-            } else {\n-                setNoteAndUserNoteFromCombinedNote(fixedCombinedNote);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Split up given string into note and user note (separated with \\n--\\n).\n-     *\n-     * @param combinedNote note to split up\n-     */\n-    private void setNoteAndUserNoteFromCombinedNote(final String combinedNote) {\n-        if (combinedNote != null) {\n-            String newNote = combinedNote;\n-            String newUserNote = \"\";\n-            if (!StringUtils.isEmpty(combinedNote)) {\n-                final String[] token = PATTERN_SEPARATOR_SPLIT.split(combinedNote, 2);\n-                if (token.length > 1) {\n-                    newNote = token[0].trim();\n-                    newUserNote = token[1].trim();\n-                }\n-            }\n-            this.waypoint.setNote(newNote);\n-            this.waypoint.setUserNote(newUserNote);\n-        }\n-    }\n-\n-}\n", "next_change": {"commit": "167826d3ae8b30dcdeea3206217079af9b92d9a0", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java b/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java\nnew file mode 100644\nindex 000000000..129701b60\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/models/WaypointUserNoteCombiner.java\n", "chunk": "@@ -0,0 +1,84 @@\n+package cgeo.geocaching.models;\n+\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class WaypointUserNoteCombiner {\n+\n+    private static final String SEPARATOR = \"\\n--\\n\";\n+    private static final Pattern PATTERN_SEPARATOR_SPLIT = Pattern.compile(\"\\\\s*\" + SEPARATOR + \"\\\\s*\");\n+\n+    private Waypoint waypoint;\n+\n+    /**\n+     *\n+     */\n+    public WaypointUserNoteCombiner(final Waypoint waypoint) {\n+        this.waypoint = waypoint;\n+    }\n+\n+\n+    /**\n+     * Combine note and user note. Separated with Separator \"\\n--\\n\"\n+     *\n+     * @return string with combined note\n+     */\n+    public final String getCombinedNoteAndUserNote() {\n+        final String userNote = this.waypoint.getUserNote();\n+        if (this.waypoint.isUserDefined()) {\n+            return userNote;\n+        } else {\n+            final StringBuilder newNote = new StringBuilder(this.waypoint.getNote());\n+            if (StringUtils.isNotEmpty(userNote)) {\n+                newNote.append(SEPARATOR);\n+                newNote.append(userNote);\n+            }\n+            return newNote.toString();\n+        }\n+    }\n+\n+    /**\n+     * Split up given string into note and user note (separated with \\n--\\n).\n+     * For userDefined waypoints only userNote is set.\n+     *\n+     * @param combinedNote note to split up\n+     */\n+    public void updateNoteAndUserNote(final String combinedNote) {\n+        if (combinedNote != null) {\n+            String fixedCombinedNote = combinedNote;\n+            // \\n was removed via validate\n+            if (combinedNote.startsWith(\"--\\n\")) {\n+                fixedCombinedNote = \"\\n\" + combinedNote;\n+            }\n+\n+            if (this.waypoint.isUserDefined()) {\n+                this.waypoint.setUserNote(fixedCombinedNote);\n+            } else {\n+                setNoteAndUserNoteFromCombinedNote(fixedCombinedNote);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Split up given string into note and user note (separated with \\n--\\n).\n+     *\n+     * @param combinedNote note to split up\n+     */\n+    private void setNoteAndUserNoteFromCombinedNote(final String combinedNote) {\n+        if (combinedNote != null) {\n+            String newNote = combinedNote;\n+            String newUserNote = \"\";\n+            if (!StringUtils.isEmpty(combinedNote)) {\n+                final String[] token = PATTERN_SEPARATOR_SPLIT.split(combinedNote, 2);\n+                if (token.length > 1) {\n+                    newNote = token[0].trim();\n+                    newUserNote = token[1].trim();\n+                }\n+            }\n+            this.waypoint.setNote(newNote);\n+            this.waypoint.setUserNote(newUserNote);\n+        }\n+    }\n+\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDczMA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310730", "body": "I am not sure I understand what this method is doing. Is there a Unit test for it?", "bodyText": "I am not sure I understand what this method is doing. Is there a Unit test for it?", "bodyHTML": "<p dir=\"auto\">I am not sure I understand what this method is doing. Is there a Unit test for it?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:37:10Z", "path": "main/src/cgeo/geocaching/utils/TextUtils.java", "diffHunk": "@@ -420,6 +428,29 @@ public static String replaceAll(final String text, final String startToken, fina\n         return result;\n     }\n \n+    @NonNull\n+    public static List<String> getAll(final String text, final char delimiter, final  Boolean ignoreEmpty) {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTUwOA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479508", "bodyText": "I remove it with String.split ;-)", "author": "murggel", "createdAt": "2021-01-09T22:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDczMA=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/utils/TextUtils.java b/main/src/cgeo/geocaching/utils/TextUtils.java\nindex 749c93ef9..43258a4bd 100644\n--- a/main/src/cgeo/geocaching/utils/TextUtils.java\n+++ b/main/src/cgeo/geocaching/utils/TextUtils.java\n", "chunk": "@@ -428,29 +429,6 @@ public final class TextUtils {\n         return result;\n     }\n \n-    @NonNull\n-    public static List<String> getAll(final String text, final char delimiter, final  Boolean ignoreEmpty) {\n-        final List<String> result = new ArrayList<>();\n-\n-        String matchText = text;\n-\n-        List<String> textMatches = TextUtils.getAll(matchText, \"\", \"\" + delimiter);\n-        while (1 == textMatches.size()) {\n-            final String matchedText = textMatches.iterator().next();\n-            if (!StringUtils.isBlank(matchedText) || ignoreEmpty) {\n-                result.add(matchedText);\n-            }\n-            matchText = TextUtils.replaceFirst(matchText, \"\", \"\" + delimiter, \"\");\n-            textMatches = TextUtils.getAll(matchText, \"\", \"\" + delimiter);\n-        }\n-\n-        if (!StringUtils.isBlank(matchText) || ignoreEmpty) {\n-            result.add(matchText);\n-        }\n-\n-        return result;\n-    }\n-\n     /**\n      * Shortens a given text to a maximum given number of characters. In case the text is too long it\n      * is shortened according to a given begin-end-distribution-value. Deleted text part is marked with '...'\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/utils/TextUtils.java b/main/src/cgeo/geocaching/utils/TextUtils.java\nindex 43258a4bd..749c93ef9 100644\n--- a/main/src/cgeo/geocaching/utils/TextUtils.java\n+++ b/main/src/cgeo/geocaching/utils/TextUtils.java\n", "chunk": "@@ -429,6 +428,29 @@ public final class TextUtils {\n         return result;\n     }\n \n+    @NonNull\n+    public static List<String> getAll(final String text, final char delimiter, final  Boolean ignoreEmpty) {\n+        final List<String> result = new ArrayList<>();\n+\n+        String matchText = text;\n+\n+        List<String> textMatches = TextUtils.getAll(matchText, \"\", \"\" + delimiter);\n+        while (1 == textMatches.size()) {\n+            final String matchedText = textMatches.iterator().next();\n+            if (!StringUtils.isBlank(matchedText) || ignoreEmpty) {\n+                result.add(matchedText);\n+            }\n+            matchText = TextUtils.replaceFirst(matchText, \"\", \"\" + delimiter, \"\");\n+            textMatches = TextUtils.getAll(matchText, \"\", \"\" + delimiter);\n+        }\n+\n+        if (!StringUtils.isBlank(matchText) || ignoreEmpty) {\n+            result.add(matchText);\n+        }\n+\n+        return result;\n+    }\n+\n     /**\n      * Shortens a given text to a maximum given number of characters. In case the text is too long it\n      * is shortened according to a given begin-end-distribution-value. Deleted text part is marked with '...'\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/utils/TextUtils.java b/main/src/cgeo/geocaching/utils/TextUtils.java\nindex 749c93ef9..43258a4bd 100644\n--- a/main/src/cgeo/geocaching/utils/TextUtils.java\n+++ b/main/src/cgeo/geocaching/utils/TextUtils.java\n", "chunk": "@@ -428,29 +429,6 @@ public final class TextUtils {\n         return result;\n     }\n \n-    @NonNull\n-    public static List<String> getAll(final String text, final char delimiter, final  Boolean ignoreEmpty) {\n-        final List<String> result = new ArrayList<>();\n-\n-        String matchText = text;\n-\n-        List<String> textMatches = TextUtils.getAll(matchText, \"\", \"\" + delimiter);\n-        while (1 == textMatches.size()) {\n-            final String matchedText = textMatches.iterator().next();\n-            if (!StringUtils.isBlank(matchedText) || ignoreEmpty) {\n-                result.add(matchedText);\n-            }\n-            matchText = TextUtils.replaceFirst(matchText, \"\", \"\" + delimiter, \"\");\n-            textMatches = TextUtils.getAll(matchText, \"\", \"\" + delimiter);\n-        }\n-\n-        if (!StringUtils.isBlank(matchText) || ignoreEmpty) {\n-            result.add(matchText);\n-        }\n-\n-        return result;\n-    }\n-\n     /**\n      * Shortens a given text to a maximum given number of characters. In case the text is too long it\n      * is shortened according to a given begin-end-distribution-value. Deleted text part is marked with '...'\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDk3Mw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554310973", "body": "An example formula in the class javadoc would be great", "bodyText": "An example formula in the class javadoc would be great", "bodyHTML": "<p dir=\"auto\">An example formula in the class javadoc would be great</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:40:18Z", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTYwOQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479609", "bodyText": "Done", "author": "murggel", "createdAt": "2021-01-09T22:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nindex 4b7ccd3d9..ed1b1d7e6 100644\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -20,10 +20,15 @@ import org.apache.commons.lang3.tuple.ImmutablePair;\n \n /**\n  * Parse coordinates with formulas.\n+ * For plain-format the keyword (FORMULA-PLAIN) has to be used. Use '|' to separate the variables and the user note.\n+ * example:\n+ * @name (x) (FORMULA-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5| user note\n  */\n public final class FormulaParser {\n \n     public  static final char WPC_DELIM = '|';\n+    public  static final String WPC_DELIM_STRING = \"|\";\n+    public  static final String WPC_DELIM_PATTERN_STRING = \"\\\\|\";\n \n     private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n     private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\ndeleted file mode 100644\nindex ed1b1d7e6..000000000\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ /dev/null\n", "chunk": "@@ -1,384 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-import cgeo.geocaching.R;\n-import cgeo.geocaching.location.Geopoint;\n-import cgeo.geocaching.settings.Settings;\n-import cgeo.geocaching.utils.CollectionStream;\n-import cgeo.geocaching.utils.MatcherWrapper;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n-\n-/**\n- * Parse coordinates with formulas.\n- * For plain-format the keyword (FORMULA-PLAIN) has to be used. Use '|' to separate the variables and the user note.\n- * example:\n- * @name (x) (FORMULA-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5| user note\n- */\n-public final class FormulaParser {\n-\n-    public  static final char WPC_DELIM = '|';\n-    public  static final String WPC_DELIM_STRING = \"|\";\n-    public  static final String WPC_DELIM_PATTERN_STRING = \"\\\\|\";\n-\n-    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n-    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n-\n-    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n-\n-    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n-\n-    public FormulaParser() {\n-    }\n-\n-    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n-        desiredFormulaFormat = formulaFormat;\n-    }\n-\n-    public static class ParseException extends IllegalArgumentException {\n-        private static final long serialVersionUID = 1L;\n-        public final int resource;\n-\n-        public ParseException(final String msg) {\n-            super(msg);\n-            resource = R.string.err_parse_lat_lon;\n-        }\n-\n-        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n-            super(msg);\n-            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n-        }\n-    }\n-\n-    private static class ResultWrapper {\n-        private final String result;\n-        private final int matcherLength;\n-\n-        ResultWrapper(final String result, final int stringLength) {\n-            this.result = result;\n-            this.matcherLength = stringLength;\n-        }\n-    }\n-\n-    /**\n-     * Abstract parser for coordinate formats.\n-     */\n-    private abstract static class AbstractFormulaParser {\n-        /**\n-         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n-         *\n-         * @param text the string to be parsed\n-         * @return an pair of strings with parsed formula for latitude and longitude\n-         */\n-        @Nullable\n-        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n-\n-        /**\n-         * Parses latitude or longitude out of the given string.\n-         *\n-         * @param text\n-         *            the string to be parsed\n-         * @param latlon\n-         *            whether to parse latitude or longitude\n-         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n-\n-        /**\n-         * Indicates which format is parsed\n-         * @return coordInputFormat which can be parsed\n-         */\n-        public abstract Settings.CoordInputFormatEnum formulaFormat();\n-    }\n-\n-    /**\n-     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n-     */\n-    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n-        private final Pattern latPattern;\n-        private final Pattern lonPattern;\n-        private final Pattern latLonPattern;\n-\n-        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n-            this.latPattern = latPattern;\n-            this.lonPattern = lonPattern;\n-            this.latLonPattern = latLonPattern;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude out of a given range of matched groups.\n-         *\n-         * @param matcher\n-         *            the matcher that holds the matches groups\n-         * @param first\n-         *            the first group to parse\n-         * @param last\n-         *            the last group to parse\n-         * @return the parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n-            final List<String> groups = new ArrayList<>(last - first + 1);\n-            for (int i = first; i <= last; i++) {\n-                groups.add(matcher.group(i));\n-            }\n-\n-            return parse(groups);\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String)\n-         */\n-        @Override\n-        @Nullable\n-        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n-            if (matcher.find()) {\n-                final int groupCount = matcher.groupCount();\n-                final int partCount = groupCount / 2;\n-\n-                final String lat = parseGroups(matcher, 1, partCount);\n-                if (lat == null || lat.isEmpty()) {\n-                    return null;\n-                }\n-\n-                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n-                if (lon == null || lon.isEmpty()) {\n-                    return null;\n-                }\n-\n-                return new ImmutablePair<>(lat, lon);\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n-         */\n-        @Override\n-        @Nullable\n-        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n-            if (matcher.find()) {\n-                final String res = parseGroups(matcher, 1, matcher.groupCount());\n-                if (res != null) {\n-                    return new ResultWrapper(res, matcher.group().length());\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude from matched groups of corresponding pattern.\n-         *\n-         * @param groups\n-         *            the groups matched by latitude/longitude pattern\n-         * @return parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract String parse(@NonNull List<String> groups);\n-    }\n-\n-\n-    /**\n-     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n-     */\n-    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n-\n-        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n-        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n-\n-        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n-        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n-\n-\n-\n-        //                                           (  1  )    (    2    )    (      3      )\n-        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n-\n-        //                                        (   1  )    (    2    )    (      3      )\n-        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n-        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n-        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n-\n-        MinDecFormulaParser() {\n-            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n-        }\n-\n-        /**\n-         * @see AbstractLatLonFormulaParser#parse(List)\n-         */\n-        @Override\n-        @Nullable\n-        public String parse(@NonNull final List<String> groups) {\n-            final String group1 = groups.get(0).trim();\n-            final String group2 = groups.get(1).trim();\n-            final String group3 = groups.get(2).trim();\n-\n-            // Handle empty degrees part (see #4620)\n-            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n-\n-            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n-            return result;\n-        }\n-\n-        public Settings.CoordInputFormatEnum formulaFormat() {\n-            return Settings.CoordInputFormatEnum.Plain;\n-        }\n-    }\n-\n-    /**\n-     * Returns a set of parser inputs for a given text\n-     *\n-     * The generated inputs use different delimiters for fractional numbers.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @return the set of parser inputs\n-     */\n-    @NonNull\n-    private static Set<String> getParseInputs(@NonNull final String text) {\n-        final String inputDot = removeSpaceAfterSeparators(text);\n-        return CollectionStream.of(new String[]{inputDot}).toSet();\n-    }\n-\n-    /**\n-     * Removes all single spaces after a comma (see #2404)\n-     *\n-     * @param text\n-     *            the string to substitute\n-     * @return the substituted string without the single spaces\n-     */\n-    @NonNull\n-    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n-        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n-        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n-    }\n-\n-    /**\n-     * Parses latitude/longitude from the given string.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @param latlon\n-     *            whether to parse latitude or longitude\n-     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n-     */\n-    @Nullable\n-    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-        final String input = removeSpaceAfterSeparators(text.trim());\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                final ResultWrapper wrapper = parser.parse(input, latlon);\n-                if (wrapper != null && wrapper.matcherLength == input.length()) {\n-                    return wrapper;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n-     *\n-     * Accepts following formats with formula:\n-     * - X DD\u00b0 MM.MMM\n-     *\n-     * variable count of spaces (also 0) are excepted\n-     *\n-     * @param text the string to be parsed\n-     * @return an pair of strings with parsed formula for latitude and longitude\n-     * @throws FormulaParser.ParseException\n-     *             if coordinates could not be parsed\n-     */\n-    @NonNull\n-    public ImmutablePair<String, String> parse(@NonNull final String text) {\n-        final Set<String> inputs = getParseInputs(text.trim());\n-        ImmutablePair<String, String> foundPair = null;\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                for (final String input : inputs) {\n-                    final ImmutablePair<String, String> coordinatePair = parser.parse(input);\n-                    if (coordinatePair == null) {\n-                        continue;\n-                    }\n-                    foundPair = coordinatePair;\n-                }\n-            }\n-        }\n-\n-        if (foundPair != null) {\n-            return foundPair;\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n-    }\n-\n-    /**\n-     * Parses latitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the latitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if latitude could not be parsed\n-     */\n-    public String parseLatitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n-    }\n-\n-    /**\n-     * Parses longitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the longitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if longitude could not be parsed\n-     */\n-    public String parseLongitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n-    }\n-\n-    private Boolean isValidParser(final AbstractFormulaParser parser) {\n-        if (null != desiredFormulaFormat) {\n-            return desiredFormulaFormat == parser.formulaFormat();\n-        }\n-        return true;\n-    }\n-}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nnew file mode 100644\nindex 000000000..4b7ccd3d9\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {\n+            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n+        }\n+\n+        /**\n+         * @see AbstractLatLonFormulaParser#parse(List)\n+         */\n+        @Override\n+        @Nullable\n+        public String parse(@NonNull final List<String> groups) {\n+            final String group1 = groups.get(0).trim();\n+            final String group2 = groups.get(1).trim();\n+            final String group3 = groups.get(2).trim();\n+\n+            // Handle empty degrees part (see #4620)\n+            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n+\n+            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n+            return result;\n+        }\n+\n+        public Settings.CoordInputFormatEnum formulaFormat() {\n+            return Settings.CoordInputFormatEnum.Plain;\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of parser inputs for a given text\n+     *\n+     * The generated inputs use different delimiters for fractional numbers.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @return the set of parser inputs\n+     */\n+    @NonNull\n+    private static Set<String> getParseInputs(@NonNull final String text) {\n+        final String inputDot = removeSpaceAfterSeparators(text);\n+        return CollectionStream.of(new String[]{inputDot}).toSet();\n+    }\n+\n+    /**\n+     * Removes all single spaces after a comma (see #2404)\n+     *\n+     * @param text\n+     *            the string to substitute\n+     * @return the substituted string without the single spaces\n+     */\n+    @NonNull\n+    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n+        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n+        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n+    }\n+\n+    /**\n+     * Parses latitude/longitude from the given string.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @param latlon\n+     *            whether to parse latitude or longitude\n+     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n+     */\n+    @Nullable\n+    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+        final String input = removeSpaceAfterSeparators(text.trim());\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                final ResultWrapper wrapper = parser.parse(input, latlon);\n+                if (wrapper != null && wrapper.matcherLength == input.length()) {\n+                    return wrapper;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n+     *\n+     * Accepts following formats with formula:\n+     * - X DD\u00b0 MM.MMM\n+     *\n+     * variable count of spaces (also 0) are excepted\n+     *\n+     * @param text the string to be parsed\n+     * @return an pair of strings with parsed formula for latitude and longitude\n+     * @throws FormulaParser.ParseException\n+     *             if coordinates could not be parsed\n+     */\n+    @NonNull\n+    public ImmutablePair<String, String> parse(@NonNull final String text) {\n+        final Set<String> inputs = getParseInputs(text.trim());\n+        ImmutablePair<String, String> foundPair = null;\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                for (final String input : inputs) {\n+                    final ImmutablePair<String, String> coordinatePair = parser.parse(input);\n+                    if (coordinatePair == null) {\n+                        continue;\n+                    }\n+                    foundPair = coordinatePair;\n+                }\n+            }\n+        }\n+\n+        if (foundPair != null) {\n+            return foundPair;\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n+    }\n+\n+    /**\n+     * Parses latitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the latitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if latitude could not be parsed\n+     */\n+    public String parseLatitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n+    }\n+\n+    /**\n+     * Parses longitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the longitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if longitude could not be parsed\n+     */\n+    public String parseLongitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n+    }\n+\n+    private Boolean isValidParser(final AbstractFormulaParser parser) {\n+        if (null != desiredFormulaFormat) {\n+            return desiredFormulaFormat == parser.formulaFormat();\n+        }\n+        return true;\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTEyMA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311120", "body": "Is MinDecFormulaParser the only subclass of AbstractLatLonFormulaParser? If yes, why do we need the subclass?", "bodyText": "Is MinDecFormulaParser the only subclass of AbstractLatLonFormulaParser? If yes, why do we need the subclass?", "bodyHTML": "<p dir=\"auto\">Is MinDecFormulaParser the only subclass of AbstractLatLonFormulaParser? If yes, why do we need the subclass?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:42:40Z", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ2ODkzNQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554468935", "bodyText": "No, there can / should be the others as well, but with your next comment, probably that will be done with reusing the other parser...", "author": "murggel", "createdAt": "2021-01-09T20:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nindex 4b7ccd3d9..4482f349b 100644\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -183,7 +189,7 @@ public final class FormulaParser {\n          * @return parsed latitude/longitude, or null if parsing failed\n          */\n         @Nullable\n-        public abstract String parse(@NonNull List<String> groups);\n+        public abstract String createCoordinate(@NonNull List<String> groups);\n     }\n \n \n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\ndeleted file mode 100644\nindex 4482f349b..000000000\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ /dev/null\n", "chunk": "@@ -1,382 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-import cgeo.geocaching.R;\n-import cgeo.geocaching.location.Geopoint;\n-import cgeo.geocaching.settings.Settings;\n-import cgeo.geocaching.utils.CollectionStream;\n-import cgeo.geocaching.utils.MatcherWrapper;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-\n-/**\n- * Parse coordinates with formulas.\n- * Similar to @see GeopointPareser, but there valid coordinates (double) are required, here a formula (string) is required.\n- *\n- * For plain-format the keyword (FORMULA-PLAIN) has to be used. Use '|' to separate the variables and the user note.\n- * example:\n- * @name (x) (FORMULA-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5| user note\n- */\n-public final class FormulaParser {\n-\n-    public  static final char WPC_DELIM = '|';\n-    public  static final String WPC_DELIM_STRING = \"|\";\n-    public  static final String WPC_DELIM_PATTERN_STRING = \"\\\\|\";\n-\n-    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n-    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n-\n-    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n-\n-    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n-\n-    public FormulaParser() {\n-    }\n-\n-    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n-        desiredFormulaFormat = formulaFormat;\n-    }\n-\n-    public static class ParseException extends IllegalArgumentException {\n-        private static final long serialVersionUID = 1L;\n-        public final int resource;\n-\n-        public ParseException(final String msg) {\n-            super(msg);\n-            resource = R.string.err_parse_lat_lon;\n-        }\n-\n-        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n-            super(msg);\n-            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n-        }\n-    }\n-\n-    private static class ResultWrapper {\n-        private final String result;\n-        private final int matcherLength;\n-\n-        ResultWrapper(final String result, final int stringLength) {\n-            this.result = result;\n-            this.matcherLength = stringLength;\n-        }\n-    }\n-\n-    /**\n-     * Abstract parser for coordinate formats.\n-     */\n-    private abstract static class AbstractFormulaParser {\n-        /**\n-         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n-         *\n-         * @param text the string to be parsed\n-         * @return an pair of strings with parsed formula for latitude and longitude\n-         */\n-        @Nullable\n-        public abstract FormulaWrapper parse(@NonNull String text);\n-\n-        /**\n-         * Parses latitude or longitude out of the given string.\n-         *\n-         * @param text\n-         *            the string to be parsed\n-         * @param latlon\n-         *            whether to parse latitude or longitude\n-         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n-\n-        /**\n-         * Indicates which format is parsed\n-         * @return coordInputFormat which can be parsed\n-         */\n-        public abstract Settings.CoordInputFormatEnum formulaFormat();\n-    }\n-\n-    /**\n-     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n-     */\n-    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n-        private final Pattern latPattern;\n-        private final Pattern lonPattern;\n-        private final Pattern latLonPattern;\n-\n-        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n-            this.latPattern = latPattern;\n-            this.lonPattern = lonPattern;\n-            this.latLonPattern = latLonPattern;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude out of a given range of matched groups.\n-         *\n-         * @param matcher\n-         *            the matcher that holds the matches groups\n-         * @param first\n-         *            the first group to parse\n-         * @param last\n-         *            the last group to parse\n-         * @return the parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n-            final List<String> groups = new ArrayList<>(last - first + 1);\n-            for (int i = first; i <= last; i++) {\n-                groups.add(matcher.group(i));\n-            }\n-\n-            return createCoordinate(groups);\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String)\n-         */\n-        @Override\n-        @Nullable\n-        public final FormulaWrapper parse(@NonNull final String text) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n-            if (matcher.find()) {\n-                final int groupCount = matcher.groupCount();\n-                final int partCount = groupCount / 2;\n-\n-                final String lat = parseGroups(matcher, 1, partCount);\n-                if (lat == null || lat.isEmpty()) {\n-                    return null;\n-                }\n-\n-                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n-                if (lon == null || lon.isEmpty()) {\n-                    return null;\n-                }\n-\n-                return new FormulaWrapper(lat, lon, matcher.start(), matcher.group().length(), text);\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n-         */\n-        @Override\n-        @Nullable\n-        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n-            if (matcher.find()) {\n-                final String res = parseGroups(matcher, 1, matcher.groupCount());\n-                if (res != null) {\n-                    return new ResultWrapper(res, matcher.group().length());\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude from matched groups of corresponding pattern.\n-         *\n-         * @param groups\n-         *            the groups matched by latitude/longitude pattern\n-         * @return parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract String createCoordinate(@NonNull List<String> groups);\n-    }\n-\n-\n-    /**\n-     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n-     */\n-    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n-\n-        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n-        //                                                        (    2    )                                      (      3      )\n-        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n-\n-        //                                           (  1  )    (    2    )    (      3      )\n-        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n-\n-        //                                        (   1  )    (    2    )    (      3      )\n-        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n-        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n-        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n-\n-        MinDecFormulaParser() {\n-            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n-        }\n-\n-        /**\n-         * @see AbstractLatLonFormulaParser#createCoordinate(List)\n-         */\n-        @Override\n-        @Nullable\n-        public String createCoordinate(@NonNull final List<String> groups) {\n-            final String group1 = groups.get(0).trim();\n-            final String group2 = groups.get(1).trim();\n-            final String group3 = groups.get(2).trim();\n-\n-            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n-\n-            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n-            return result;\n-        }\n-\n-        public Settings.CoordInputFormatEnum formulaFormat() {\n-            return Settings.CoordInputFormatEnum.Plain;\n-        }\n-    }\n-\n-    /**\n-     * Returns a set of parser inputs for a given text\n-     *\n-     * The generated inputs use different delimiters for fractional numbers.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @return the set of parser inputs\n-     */\n-    @NonNull\n-    private static Set<String> getParseInputs(@NonNull final String text) {\n-        final String inputDot = removeSpaceAfterSeparators(text);\n-        return CollectionStream.of(new String[]{inputDot}).toSet();\n-    }\n-\n-    /**\n-     * Removes all single spaces after a comma (see #2404)\n-     *\n-     * @param text\n-     *            the string to substitute\n-     * @return the substituted string without the single spaces\n-     */\n-    @NonNull\n-    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n-        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n-        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n-    }\n-\n-    /**\n-     * Parses latitude/longitude from the given string.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @param latlon\n-     *            whether to parse latitude or longitude\n-     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n-     */\n-    @Nullable\n-    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-        final String input = removeSpaceAfterSeparators(text.trim());\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                final ResultWrapper wrapper = parser.parse(input, latlon);\n-                if (wrapper != null && wrapper.matcherLength == input.length()) {\n-                    return wrapper;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n-     *\n-     * Accepts following formats with formula:\n-     * - X DD\u00b0 MM.MMM\n-     *\n-     * variable count of spaces (also 0) are excepted\n-     *\n-     * @param text the string to be parsed\n-     * @return an pair of strings with parsed formula for latitude and longitude\n-     * @throws FormulaParser.ParseException\n-     *             if coordinates could not be parsed\n-     */\n-    @NonNull\n-    public FormulaWrapper parse(@NonNull final String text) {\n-        final Set<String> inputs = getParseInputs(text.trim());\n-        FormulaWrapper best = null;\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                for (final String input : inputs) {\n-                    final FormulaWrapper formulaWrapper = parser.parse(input);\n-                    if (formulaWrapper == null) {\n-                        continue;\n-                    }\n-                    if (best == null || formulaWrapper.isBetterThan(best)) {\n-                        best = formulaWrapper;\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (best != null) {\n-            return best;\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n-    }\n-\n-    /**\n-     * Parses latitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the latitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if latitude could not be parsed\n-     */\n-    public String parseLatitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n-    }\n-\n-    /**\n-     * Parses longitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the longitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if longitude could not be parsed\n-     */\n-    public String parseLongitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n-    }\n-\n-    private Boolean isValidParser(final AbstractFormulaParser parser) {\n-        if (null != desiredFormulaFormat) {\n-            return desiredFormulaFormat == parser.formulaFormat();\n-        }\n-        return true;\n-    }\n-}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nnew file mode 100644\nindex 000000000..4b7ccd3d9\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {\n+            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n+        }\n+\n+        /**\n+         * @see AbstractLatLonFormulaParser#parse(List)\n+         */\n+        @Override\n+        @Nullable\n+        public String parse(@NonNull final List<String> groups) {\n+            final String group1 = groups.get(0).trim();\n+            final String group2 = groups.get(1).trim();\n+            final String group3 = groups.get(2).trim();\n+\n+            // Handle empty degrees part (see #4620)\n+            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n+\n+            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n+            return result;\n+        }\n+\n+        public Settings.CoordInputFormatEnum formulaFormat() {\n+            return Settings.CoordInputFormatEnum.Plain;\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of parser inputs for a given text\n+     *\n+     * The generated inputs use different delimiters for fractional numbers.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @return the set of parser inputs\n+     */\n+    @NonNull\n+    private static Set<String> getParseInputs(@NonNull final String text) {\n+        final String inputDot = removeSpaceAfterSeparators(text);\n+        return CollectionStream.of(new String[]{inputDot}).toSet();\n+    }\n+\n+    /**\n+     * Removes all single spaces after a comma (see #2404)\n+     *\n+     * @param text\n+     *            the string to substitute\n+     * @return the substituted string without the single spaces\n+     */\n+    @NonNull\n+    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n+        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n+        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n+    }\n+\n+    /**\n+     * Parses latitude/longitude from the given string.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @param latlon\n+     *            whether to parse latitude or longitude\n+     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n+     */\n+    @Nullable\n+    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+        final String input = removeSpaceAfterSeparators(text.trim());\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                final ResultWrapper wrapper = parser.parse(input, latlon);\n+                if (wrapper != null && wrapper.matcherLength == input.length()) {\n+                    return wrapper;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n+     *\n+     * Accepts following formats with formula:\n+     * - X DD\u00b0 MM.MMM\n+     *\n+     * variable count of spaces (also 0) are excepted\n+     *\n+     * @param text the string to be parsed\n+     * @return an pair of strings with parsed formula for latitude and longitude\n+     * @throws FormulaParser.ParseException\n+     *             if coordinates could not be parsed\n+     */\n+    @NonNull\n+    public ImmutablePair<String, String> parse(@NonNull final String text) {\n+        final Set<String> inputs = getParseInputs(text.trim());\n+        ImmutablePair<String, String> foundPair = null;\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                for (final String input : inputs) {\n+                    final ImmutablePair<String, String> coordinatePair = parser.parse(input);\n+                    if (coordinatePair == null) {\n+                        continue;\n+                    }\n+                    foundPair = coordinatePair;\n+                }\n+            }\n+        }\n+\n+        if (foundPair != null) {\n+            return foundPair;\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n+    }\n+\n+    /**\n+     * Parses latitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the latitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if latitude could not be parsed\n+     */\n+    public String parseLatitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n+    }\n+\n+    /**\n+     * Parses longitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the longitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if longitude could not be parsed\n+     */\n+    public String parseLongitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n+    }\n+\n+    private Boolean isValidParser(final AbstractFormulaParser parser) {\n+        if (null != desiredFormulaFormat) {\n+            return desiredFormulaFormat == parser.formulaFormat();\n+        }\n+        return true;\n+    }\n+}\n", "next_change": null}]}}]}}, {"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nindex 4b7ccd3d9..4482f349b 100644\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -193,13 +199,9 @@ public final class FormulaParser {\n     private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n \n         private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        //                                                        (    2    )                                      (      3      )\n         private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n \n-        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n-        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n-\n-\n-\n         //                                           (  1  )    (    2    )    (      3      )\n         private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n \n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\ndeleted file mode 100644\nindex 4482f349b..000000000\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ /dev/null\n", "chunk": "@@ -1,382 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-import cgeo.geocaching.R;\n-import cgeo.geocaching.location.Geopoint;\n-import cgeo.geocaching.settings.Settings;\n-import cgeo.geocaching.utils.CollectionStream;\n-import cgeo.geocaching.utils.MatcherWrapper;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-\n-/**\n- * Parse coordinates with formulas.\n- * Similar to @see GeopointPareser, but there valid coordinates (double) are required, here a formula (string) is required.\n- *\n- * For plain-format the keyword (FORMULA-PLAIN) has to be used. Use '|' to separate the variables and the user note.\n- * example:\n- * @name (x) (FORMULA-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5| user note\n- */\n-public final class FormulaParser {\n-\n-    public  static final char WPC_DELIM = '|';\n-    public  static final String WPC_DELIM_STRING = \"|\";\n-    public  static final String WPC_DELIM_PATTERN_STRING = \"\\\\|\";\n-\n-    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n-    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n-\n-    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n-\n-    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n-\n-    public FormulaParser() {\n-    }\n-\n-    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n-        desiredFormulaFormat = formulaFormat;\n-    }\n-\n-    public static class ParseException extends IllegalArgumentException {\n-        private static final long serialVersionUID = 1L;\n-        public final int resource;\n-\n-        public ParseException(final String msg) {\n-            super(msg);\n-            resource = R.string.err_parse_lat_lon;\n-        }\n-\n-        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n-            super(msg);\n-            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n-        }\n-    }\n-\n-    private static class ResultWrapper {\n-        private final String result;\n-        private final int matcherLength;\n-\n-        ResultWrapper(final String result, final int stringLength) {\n-            this.result = result;\n-            this.matcherLength = stringLength;\n-        }\n-    }\n-\n-    /**\n-     * Abstract parser for coordinate formats.\n-     */\n-    private abstract static class AbstractFormulaParser {\n-        /**\n-         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n-         *\n-         * @param text the string to be parsed\n-         * @return an pair of strings with parsed formula for latitude and longitude\n-         */\n-        @Nullable\n-        public abstract FormulaWrapper parse(@NonNull String text);\n-\n-        /**\n-         * Parses latitude or longitude out of the given string.\n-         *\n-         * @param text\n-         *            the string to be parsed\n-         * @param latlon\n-         *            whether to parse latitude or longitude\n-         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n-\n-        /**\n-         * Indicates which format is parsed\n-         * @return coordInputFormat which can be parsed\n-         */\n-        public abstract Settings.CoordInputFormatEnum formulaFormat();\n-    }\n-\n-    /**\n-     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n-     */\n-    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n-        private final Pattern latPattern;\n-        private final Pattern lonPattern;\n-        private final Pattern latLonPattern;\n-\n-        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n-            this.latPattern = latPattern;\n-            this.lonPattern = lonPattern;\n-            this.latLonPattern = latLonPattern;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude out of a given range of matched groups.\n-         *\n-         * @param matcher\n-         *            the matcher that holds the matches groups\n-         * @param first\n-         *            the first group to parse\n-         * @param last\n-         *            the last group to parse\n-         * @return the parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n-            final List<String> groups = new ArrayList<>(last - first + 1);\n-            for (int i = first; i <= last; i++) {\n-                groups.add(matcher.group(i));\n-            }\n-\n-            return createCoordinate(groups);\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String)\n-         */\n-        @Override\n-        @Nullable\n-        public final FormulaWrapper parse(@NonNull final String text) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n-            if (matcher.find()) {\n-                final int groupCount = matcher.groupCount();\n-                final int partCount = groupCount / 2;\n-\n-                final String lat = parseGroups(matcher, 1, partCount);\n-                if (lat == null || lat.isEmpty()) {\n-                    return null;\n-                }\n-\n-                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n-                if (lon == null || lon.isEmpty()) {\n-                    return null;\n-                }\n-\n-                return new FormulaWrapper(lat, lon, matcher.start(), matcher.group().length(), text);\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n-         */\n-        @Override\n-        @Nullable\n-        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n-            if (matcher.find()) {\n-                final String res = parseGroups(matcher, 1, matcher.groupCount());\n-                if (res != null) {\n-                    return new ResultWrapper(res, matcher.group().length());\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude from matched groups of corresponding pattern.\n-         *\n-         * @param groups\n-         *            the groups matched by latitude/longitude pattern\n-         * @return parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract String createCoordinate(@NonNull List<String> groups);\n-    }\n-\n-\n-    /**\n-     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n-     */\n-    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n-\n-        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n-        //                                                        (    2    )                                      (      3      )\n-        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n-\n-        //                                           (  1  )    (    2    )    (      3      )\n-        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n-\n-        //                                        (   1  )    (    2    )    (      3      )\n-        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n-        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n-        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n-\n-        MinDecFormulaParser() {\n-            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n-        }\n-\n-        /**\n-         * @see AbstractLatLonFormulaParser#createCoordinate(List)\n-         */\n-        @Override\n-        @Nullable\n-        public String createCoordinate(@NonNull final List<String> groups) {\n-            final String group1 = groups.get(0).trim();\n-            final String group2 = groups.get(1).trim();\n-            final String group3 = groups.get(2).trim();\n-\n-            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n-\n-            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n-            return result;\n-        }\n-\n-        public Settings.CoordInputFormatEnum formulaFormat() {\n-            return Settings.CoordInputFormatEnum.Plain;\n-        }\n-    }\n-\n-    /**\n-     * Returns a set of parser inputs for a given text\n-     *\n-     * The generated inputs use different delimiters for fractional numbers.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @return the set of parser inputs\n-     */\n-    @NonNull\n-    private static Set<String> getParseInputs(@NonNull final String text) {\n-        final String inputDot = removeSpaceAfterSeparators(text);\n-        return CollectionStream.of(new String[]{inputDot}).toSet();\n-    }\n-\n-    /**\n-     * Removes all single spaces after a comma (see #2404)\n-     *\n-     * @param text\n-     *            the string to substitute\n-     * @return the substituted string without the single spaces\n-     */\n-    @NonNull\n-    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n-        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n-        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n-    }\n-\n-    /**\n-     * Parses latitude/longitude from the given string.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @param latlon\n-     *            whether to parse latitude or longitude\n-     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n-     */\n-    @Nullable\n-    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-        final String input = removeSpaceAfterSeparators(text.trim());\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                final ResultWrapper wrapper = parser.parse(input, latlon);\n-                if (wrapper != null && wrapper.matcherLength == input.length()) {\n-                    return wrapper;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n-     *\n-     * Accepts following formats with formula:\n-     * - X DD\u00b0 MM.MMM\n-     *\n-     * variable count of spaces (also 0) are excepted\n-     *\n-     * @param text the string to be parsed\n-     * @return an pair of strings with parsed formula for latitude and longitude\n-     * @throws FormulaParser.ParseException\n-     *             if coordinates could not be parsed\n-     */\n-    @NonNull\n-    public FormulaWrapper parse(@NonNull final String text) {\n-        final Set<String> inputs = getParseInputs(text.trim());\n-        FormulaWrapper best = null;\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                for (final String input : inputs) {\n-                    final FormulaWrapper formulaWrapper = parser.parse(input);\n-                    if (formulaWrapper == null) {\n-                        continue;\n-                    }\n-                    if (best == null || formulaWrapper.isBetterThan(best)) {\n-                        best = formulaWrapper;\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (best != null) {\n-            return best;\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n-    }\n-\n-    /**\n-     * Parses latitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the latitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if latitude could not be parsed\n-     */\n-    public String parseLatitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n-    }\n-\n-    /**\n-     * Parses longitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the longitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if longitude could not be parsed\n-     */\n-    public String parseLongitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n-    }\n-\n-    private Boolean isValidParser(final AbstractFormulaParser parser) {\n-        if (null != desiredFormulaFormat) {\n-            return desiredFormulaFormat == parser.formulaFormat();\n-        }\n-        return true;\n-    }\n-}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nnew file mode 100644\nindex 000000000..4b7ccd3d9\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {\n+            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n+        }\n+\n+        /**\n+         * @see AbstractLatLonFormulaParser#parse(List)\n+         */\n+        @Override\n+        @Nullable\n+        public String parse(@NonNull final List<String> groups) {\n+            final String group1 = groups.get(0).trim();\n+            final String group2 = groups.get(1).trim();\n+            final String group3 = groups.get(2).trim();\n+\n+            // Handle empty degrees part (see #4620)\n+            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n+\n+            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n+            return result;\n+        }\n+\n+        public Settings.CoordInputFormatEnum formulaFormat() {\n+            return Settings.CoordInputFormatEnum.Plain;\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of parser inputs for a given text\n+     *\n+     * The generated inputs use different delimiters for fractional numbers.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @return the set of parser inputs\n+     */\n+    @NonNull\n+    private static Set<String> getParseInputs(@NonNull final String text) {\n+        final String inputDot = removeSpaceAfterSeparators(text);\n+        return CollectionStream.of(new String[]{inputDot}).toSet();\n+    }\n+\n+    /**\n+     * Removes all single spaces after a comma (see #2404)\n+     *\n+     * @param text\n+     *            the string to substitute\n+     * @return the substituted string without the single spaces\n+     */\n+    @NonNull\n+    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n+        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n+        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n+    }\n+\n+    /**\n+     * Parses latitude/longitude from the given string.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @param latlon\n+     *            whether to parse latitude or longitude\n+     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n+     */\n+    @Nullable\n+    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+        final String input = removeSpaceAfterSeparators(text.trim());\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                final ResultWrapper wrapper = parser.parse(input, latlon);\n+                if (wrapper != null && wrapper.matcherLength == input.length()) {\n+                    return wrapper;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n+     *\n+     * Accepts following formats with formula:\n+     * - X DD\u00b0 MM.MMM\n+     *\n+     * variable count of spaces (also 0) are excepted\n+     *\n+     * @param text the string to be parsed\n+     * @return an pair of strings with parsed formula for latitude and longitude\n+     * @throws FormulaParser.ParseException\n+     *             if coordinates could not be parsed\n+     */\n+    @NonNull\n+    public ImmutablePair<String, String> parse(@NonNull final String text) {\n+        final Set<String> inputs = getParseInputs(text.trim());\n+        ImmutablePair<String, String> foundPair = null;\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                for (final String input : inputs) {\n+                    final ImmutablePair<String, String> coordinatePair = parser.parse(input);\n+                    if (coordinatePair == null) {\n+                        continue;\n+                    }\n+                    foundPair = coordinatePair;\n+                }\n+            }\n+        }\n+\n+        if (foundPair != null) {\n+            return foundPair;\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n+    }\n+\n+    /**\n+     * Parses latitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the latitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if latitude could not be parsed\n+     */\n+    public String parseLatitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n+    }\n+\n+    /**\n+     * Parses longitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the longitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if longitude could not be parsed\n+     */\n+    public String parseLongitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n+    }\n+\n+    private Boolean isValidParser(final AbstractFormulaParser parser) {\n+        if (null != desiredFormulaFormat) {\n+            return desiredFormulaFormat == parser.formulaFormat();\n+        }\n+        return true;\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311279", "body": "There should be coordinate parsers for many coordinates formats in some other class available (alas, they don't parse for variable values inside of course). Can't they be reused somehow (parametereized to accept also letters instead of numbers)?", "bodyText": "There should be coordinate parsers for many coordinates formats in some other class available (alas, they don't parse for variable values inside of course). Can't they be reused somehow (parametereized to accept also letters instead of numbers)?", "bodyHTML": "<p dir=\"auto\">There should be coordinate parsers for many coordinates formats in some other class available (alas, they don't parse for variable values inside of course). Can't they be reused somehow (parametereized to accept also letters instead of numbers)?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:44:16Z", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ2ODg0OA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554468848", "bodyText": "Nice idea, didn't thougt about that. I will have a look into that...", "author": "murggel", "createdAt": "2021-01-09T20:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU0MDE2Mw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554540163", "bodyText": "I looked into it and remembered that I thought about it, but the other parser returns a Point /Double, whereas I need a string. So I just used it to copy and modify.\nBut I will think, if probably it can be reused somehow else, or just extend the classes with methods returning a string, which then can be converted to double ...", "author": "murggel", "createdAt": "2021-01-10T09:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1MDU1OQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554550559", "bodyText": "If its too complicated don't do it. I assume the formulas only work for MicDec-formatted coordinates anyway, do they?", "author": "eddiemuc", "createdAt": "2021-01-10T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1MTU1OA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554551558", "bodyText": "You are probably right, for the other formats only letters will be accepted instead of digits, but no formula.\nFormulas there only can appear in the variables.\nBut even then it makes probably more sense to reuse some logic...", "author": "murggel", "createdAt": "2021-01-10T11:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI1MDM3NQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559250375", "bodyText": "Did not manage yet to extract the logic.\nI will keep the AbstractParser for the other coordinate-formats, if there will be also parsers for it later", "author": "murggel", "createdAt": "2021-01-17T22:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nindex 4b7ccd3d9..4482f349b 100644\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -215,16 +217,15 @@ public final class FormulaParser {\n         }\n \n         /**\n-         * @see AbstractLatLonFormulaParser#parse(List)\n+         * @see AbstractLatLonFormulaParser#createCoordinate(List)\n          */\n         @Override\n         @Nullable\n-        public String parse(@NonNull final List<String> groups) {\n+        public String createCoordinate(@NonNull final List<String> groups) {\n             final String group1 = groups.get(0).trim();\n             final String group2 = groups.get(1).trim();\n             final String group3 = groups.get(2).trim();\n \n-            // Handle empty degrees part (see #4620)\n             final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n \n             final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\ndeleted file mode 100644\nindex 4482f349b..000000000\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ /dev/null\n", "chunk": "@@ -1,382 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-import cgeo.geocaching.R;\n-import cgeo.geocaching.location.Geopoint;\n-import cgeo.geocaching.settings.Settings;\n-import cgeo.geocaching.utils.CollectionStream;\n-import cgeo.geocaching.utils.MatcherWrapper;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-\n-/**\n- * Parse coordinates with formulas.\n- * Similar to @see GeopointPareser, but there valid coordinates (double) are required, here a formula (string) is required.\n- *\n- * For plain-format the keyword (FORMULA-PLAIN) has to be used. Use '|' to separate the variables and the user note.\n- * example:\n- * @name (x) (FORMULA-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5| user note\n- */\n-public final class FormulaParser {\n-\n-    public  static final char WPC_DELIM = '|';\n-    public  static final String WPC_DELIM_STRING = \"|\";\n-    public  static final String WPC_DELIM_PATTERN_STRING = \"\\\\|\";\n-\n-    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n-    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n-\n-    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n-\n-    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n-\n-    public FormulaParser() {\n-    }\n-\n-    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n-        desiredFormulaFormat = formulaFormat;\n-    }\n-\n-    public static class ParseException extends IllegalArgumentException {\n-        private static final long serialVersionUID = 1L;\n-        public final int resource;\n-\n-        public ParseException(final String msg) {\n-            super(msg);\n-            resource = R.string.err_parse_lat_lon;\n-        }\n-\n-        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n-            super(msg);\n-            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n-        }\n-    }\n-\n-    private static class ResultWrapper {\n-        private final String result;\n-        private final int matcherLength;\n-\n-        ResultWrapper(final String result, final int stringLength) {\n-            this.result = result;\n-            this.matcherLength = stringLength;\n-        }\n-    }\n-\n-    /**\n-     * Abstract parser for coordinate formats.\n-     */\n-    private abstract static class AbstractFormulaParser {\n-        /**\n-         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n-         *\n-         * @param text the string to be parsed\n-         * @return an pair of strings with parsed formula for latitude and longitude\n-         */\n-        @Nullable\n-        public abstract FormulaWrapper parse(@NonNull String text);\n-\n-        /**\n-         * Parses latitude or longitude out of the given string.\n-         *\n-         * @param text\n-         *            the string to be parsed\n-         * @param latlon\n-         *            whether to parse latitude or longitude\n-         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n-\n-        /**\n-         * Indicates which format is parsed\n-         * @return coordInputFormat which can be parsed\n-         */\n-        public abstract Settings.CoordInputFormatEnum formulaFormat();\n-    }\n-\n-    /**\n-     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n-     */\n-    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n-        private final Pattern latPattern;\n-        private final Pattern lonPattern;\n-        private final Pattern latLonPattern;\n-\n-        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n-            this.latPattern = latPattern;\n-            this.lonPattern = lonPattern;\n-            this.latLonPattern = latLonPattern;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude out of a given range of matched groups.\n-         *\n-         * @param matcher\n-         *            the matcher that holds the matches groups\n-         * @param first\n-         *            the first group to parse\n-         * @param last\n-         *            the last group to parse\n-         * @return the parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n-            final List<String> groups = new ArrayList<>(last - first + 1);\n-            for (int i = first; i <= last; i++) {\n-                groups.add(matcher.group(i));\n-            }\n-\n-            return createCoordinate(groups);\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String)\n-         */\n-        @Override\n-        @Nullable\n-        public final FormulaWrapper parse(@NonNull final String text) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n-            if (matcher.find()) {\n-                final int groupCount = matcher.groupCount();\n-                final int partCount = groupCount / 2;\n-\n-                final String lat = parseGroups(matcher, 1, partCount);\n-                if (lat == null || lat.isEmpty()) {\n-                    return null;\n-                }\n-\n-                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n-                if (lon == null || lon.isEmpty()) {\n-                    return null;\n-                }\n-\n-                return new FormulaWrapper(lat, lon, matcher.start(), matcher.group().length(), text);\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n-         */\n-        @Override\n-        @Nullable\n-        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n-            if (matcher.find()) {\n-                final String res = parseGroups(matcher, 1, matcher.groupCount());\n-                if (res != null) {\n-                    return new ResultWrapper(res, matcher.group().length());\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude from matched groups of corresponding pattern.\n-         *\n-         * @param groups\n-         *            the groups matched by latitude/longitude pattern\n-         * @return parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract String createCoordinate(@NonNull List<String> groups);\n-    }\n-\n-\n-    /**\n-     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n-     */\n-    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n-\n-        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n-        //                                                        (    2    )                                      (      3      )\n-        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n-\n-        //                                           (  1  )    (    2    )    (      3      )\n-        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n-\n-        //                                        (   1  )    (    2    )    (      3      )\n-        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n-        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n-        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n-\n-        MinDecFormulaParser() {\n-            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n-        }\n-\n-        /**\n-         * @see AbstractLatLonFormulaParser#createCoordinate(List)\n-         */\n-        @Override\n-        @Nullable\n-        public String createCoordinate(@NonNull final List<String> groups) {\n-            final String group1 = groups.get(0).trim();\n-            final String group2 = groups.get(1).trim();\n-            final String group3 = groups.get(2).trim();\n-\n-            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n-\n-            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n-            return result;\n-        }\n-\n-        public Settings.CoordInputFormatEnum formulaFormat() {\n-            return Settings.CoordInputFormatEnum.Plain;\n-        }\n-    }\n-\n-    /**\n-     * Returns a set of parser inputs for a given text\n-     *\n-     * The generated inputs use different delimiters for fractional numbers.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @return the set of parser inputs\n-     */\n-    @NonNull\n-    private static Set<String> getParseInputs(@NonNull final String text) {\n-        final String inputDot = removeSpaceAfterSeparators(text);\n-        return CollectionStream.of(new String[]{inputDot}).toSet();\n-    }\n-\n-    /**\n-     * Removes all single spaces after a comma (see #2404)\n-     *\n-     * @param text\n-     *            the string to substitute\n-     * @return the substituted string without the single spaces\n-     */\n-    @NonNull\n-    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n-        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n-        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n-    }\n-\n-    /**\n-     * Parses latitude/longitude from the given string.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @param latlon\n-     *            whether to parse latitude or longitude\n-     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n-     */\n-    @Nullable\n-    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-        final String input = removeSpaceAfterSeparators(text.trim());\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                final ResultWrapper wrapper = parser.parse(input, latlon);\n-                if (wrapper != null && wrapper.matcherLength == input.length()) {\n-                    return wrapper;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n-     *\n-     * Accepts following formats with formula:\n-     * - X DD\u00b0 MM.MMM\n-     *\n-     * variable count of spaces (also 0) are excepted\n-     *\n-     * @param text the string to be parsed\n-     * @return an pair of strings with parsed formula for latitude and longitude\n-     * @throws FormulaParser.ParseException\n-     *             if coordinates could not be parsed\n-     */\n-    @NonNull\n-    public FormulaWrapper parse(@NonNull final String text) {\n-        final Set<String> inputs = getParseInputs(text.trim());\n-        FormulaWrapper best = null;\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                for (final String input : inputs) {\n-                    final FormulaWrapper formulaWrapper = parser.parse(input);\n-                    if (formulaWrapper == null) {\n-                        continue;\n-                    }\n-                    if (best == null || formulaWrapper.isBetterThan(best)) {\n-                        best = formulaWrapper;\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (best != null) {\n-            return best;\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n-    }\n-\n-    /**\n-     * Parses latitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the latitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if latitude could not be parsed\n-     */\n-    public String parseLatitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n-    }\n-\n-    /**\n-     * Parses longitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the longitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if longitude could not be parsed\n-     */\n-    public String parseLongitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n-    }\n-\n-    private Boolean isValidParser(final AbstractFormulaParser parser) {\n-        if (null != desiredFormulaFormat) {\n-            return desiredFormulaFormat == parser.formulaFormat();\n-        }\n-        return true;\n-    }\n-}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nnew file mode 100644\nindex 000000000..4b7ccd3d9\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {\n+            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n+        }\n+\n+        /**\n+         * @see AbstractLatLonFormulaParser#parse(List)\n+         */\n+        @Override\n+        @Nullable\n+        public String parse(@NonNull final List<String> groups) {\n+            final String group1 = groups.get(0).trim();\n+            final String group2 = groups.get(1).trim();\n+            final String group3 = groups.get(2).trim();\n+\n+            // Handle empty degrees part (see #4620)\n+            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n+\n+            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n+            return result;\n+        }\n+\n+        public Settings.CoordInputFormatEnum formulaFormat() {\n+            return Settings.CoordInputFormatEnum.Plain;\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of parser inputs for a given text\n+     *\n+     * The generated inputs use different delimiters for fractional numbers.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @return the set of parser inputs\n+     */\n+    @NonNull\n+    private static Set<String> getParseInputs(@NonNull final String text) {\n+        final String inputDot = removeSpaceAfterSeparators(text);\n+        return CollectionStream.of(new String[]{inputDot}).toSet();\n+    }\n+\n+    /**\n+     * Removes all single spaces after a comma (see #2404)\n+     *\n+     * @param text\n+     *            the string to substitute\n+     * @return the substituted string without the single spaces\n+     */\n+    @NonNull\n+    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n+        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n+        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n+    }\n+\n+    /**\n+     * Parses latitude/longitude from the given string.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @param latlon\n+     *            whether to parse latitude or longitude\n+     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n+     */\n+    @Nullable\n+    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+        final String input = removeSpaceAfterSeparators(text.trim());\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                final ResultWrapper wrapper = parser.parse(input, latlon);\n+                if (wrapper != null && wrapper.matcherLength == input.length()) {\n+                    return wrapper;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n+     *\n+     * Accepts following formats with formula:\n+     * - X DD\u00b0 MM.MMM\n+     *\n+     * variable count of spaces (also 0) are excepted\n+     *\n+     * @param text the string to be parsed\n+     * @return an pair of strings with parsed formula for latitude and longitude\n+     * @throws FormulaParser.ParseException\n+     *             if coordinates could not be parsed\n+     */\n+    @NonNull\n+    public ImmutablePair<String, String> parse(@NonNull final String text) {\n+        final Set<String> inputs = getParseInputs(text.trim());\n+        ImmutablePair<String, String> foundPair = null;\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                for (final String input : inputs) {\n+                    final ImmutablePair<String, String> coordinatePair = parser.parse(input);\n+                    if (coordinatePair == null) {\n+                        continue;\n+                    }\n+                    foundPair = coordinatePair;\n+                }\n+            }\n+        }\n+\n+        if (foundPair != null) {\n+            return foundPair;\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n+    }\n+\n+    /**\n+     * Parses latitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the latitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if latitude could not be parsed\n+     */\n+    public String parseLatitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n+    }\n+\n+    /**\n+     * Parses longitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the longitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if longitude could not be parsed\n+     */\n+    public String parseLongitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n+    }\n+\n+    private Boolean isValidParser(final AbstractFormulaParser parser) {\n+        if (null != desiredFormulaFormat) {\n+            return desiredFormulaFormat == parser.formulaFormat();\n+        }\n+        return true;\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTMzNw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311337", "body": "Is AbstractLatLonFormulaParser the only subclass of AbstractFormularParser? If yes, why do we need the subclass?", "bodyText": "Is AbstractLatLonFormulaParser the only subclass of AbstractFormularParser? If yes, why do we need the subclass?", "bodyHTML": "<p dir=\"auto\">Is AbstractLatLonFormulaParser the only subclass of AbstractFormularParser? If yes, why do we need the subclass?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:44:59Z", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MjU0MQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554472541", "bodyText": "Probably yes,  but with your previous comment, probably that will be done with reusing the other parser...", "author": "murggel", "createdAt": "2021-01-09T21:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzA5MDMyOA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r567090328", "bodyText": "Did not manage yet to bring to a common base-class or logic...\nIf I have some more time, I will probably give it another try...", "author": "murggel", "createdAt": "2021-01-29T20:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTMzNw=="}], "type": "inlineReview", "revised_code": {"commit": "82c4d8e14cc013dac69f627891533b18bb2e6f86", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nindex 4b7ccd3d9..734df41c3 100644\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -87,19 +93,19 @@ public final class FormulaParser {\n          * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n          */\n         @Nullable\n-        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+        ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n \n         /**\n          * Indicates which format is parsed\n          * @return coordInputFormat which can be parsed\n          */\n-        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+        Settings.CoordInputFormatEnum formulaFormat();\n     }\n \n     /**\n      * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n      */\n-    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+    private abstract static class AbstractLatLonFormulaParser implements AbstractFormulaParser {\n         private final Pattern latPattern;\n         private final Pattern lonPattern;\n         private final Pattern latLonPattern;\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\ndeleted file mode 100644\nindex 734df41c3..000000000\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ /dev/null\n", "chunk": "@@ -1,382 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-import cgeo.geocaching.R;\n-import cgeo.geocaching.location.Geopoint;\n-import cgeo.geocaching.settings.Settings;\n-import cgeo.geocaching.utils.CollectionStream;\n-import cgeo.geocaching.utils.MatcherWrapper;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-\n-/**\n- * Parse coordinates with formulas.\n- * Similar to @see GeopointPareser, but there valid coordinates (double) are required, here a formula (string) is required.\n- *\n- * For plain-format the keyword (FORMULA-PLAIN) has to be used. Use '|' to separate the variables and the user note.\n- * example:\n- * @name (x) (FORMULA-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5| user note\n- */\n-public final class FormulaParser {\n-\n-    public  static final char WPC_DELIM = '|';\n-    public  static final String WPC_DELIM_STRING = \"|\";\n-    public  static final String WPC_DELIM_PATTERN_STRING = \"\\\\|\";\n-\n-    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n-    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n-\n-    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n-\n-    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n-\n-    public FormulaParser() {\n-    }\n-\n-    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n-        desiredFormulaFormat = formulaFormat;\n-    }\n-\n-    public static class ParseException extends IllegalArgumentException {\n-        private static final long serialVersionUID = 1L;\n-        public final int resource;\n-\n-        public ParseException(final String msg) {\n-            super(msg);\n-            resource = R.string.err_parse_lat_lon;\n-        }\n-\n-        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n-            super(msg);\n-            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n-        }\n-    }\n-\n-    private static class ResultWrapper {\n-        private final String result;\n-        private final int matcherLength;\n-\n-        ResultWrapper(final String result, final int stringLength) {\n-            this.result = result;\n-            this.matcherLength = stringLength;\n-        }\n-    }\n-\n-    /**\n-     * Abstract parser for coordinate formats.\n-     */\n-    private interface AbstractFormulaParser {\n-        /**\n-         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n-         *\n-         * @param text the string to be parsed\n-         * @return an pair of strings with parsed formula for latitude and longitude\n-         */\n-        @Nullable\n-        FormulaWrapper parse(@NonNull String text);\n-\n-        /**\n-         * Parses latitude or longitude out of the given string.\n-         *\n-         * @param text\n-         *            the string to be parsed\n-         * @param latlon\n-         *            whether to parse latitude or longitude\n-         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n-         */\n-        @Nullable\n-        ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n-\n-        /**\n-         * Indicates which format is parsed\n-         * @return coordInputFormat which can be parsed\n-         */\n-        Settings.CoordInputFormatEnum formulaFormat();\n-    }\n-\n-    /**\n-     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n-     */\n-    private abstract static class AbstractLatLonFormulaParser implements AbstractFormulaParser {\n-        private final Pattern latPattern;\n-        private final Pattern lonPattern;\n-        private final Pattern latLonPattern;\n-\n-        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n-            this.latPattern = latPattern;\n-            this.lonPattern = lonPattern;\n-            this.latLonPattern = latLonPattern;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude out of a given range of matched groups.\n-         *\n-         * @param matcher\n-         *            the matcher that holds the matches groups\n-         * @param first\n-         *            the first group to parse\n-         * @param last\n-         *            the last group to parse\n-         * @return the parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n-            final List<String> groups = new ArrayList<>(last - first + 1);\n-            for (int i = first; i <= last; i++) {\n-                groups.add(matcher.group(i));\n-            }\n-\n-            return createCoordinate(groups);\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String)\n-         */\n-        @Override\n-        @Nullable\n-        public final FormulaWrapper parse(@NonNull final String text) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n-            if (matcher.find()) {\n-                final int groupCount = matcher.groupCount();\n-                final int partCount = groupCount / 2;\n-\n-                final String lat = parseGroups(matcher, 1, partCount);\n-                if (lat == null || lat.isEmpty()) {\n-                    return null;\n-                }\n-\n-                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n-                if (lon == null || lon.isEmpty()) {\n-                    return null;\n-                }\n-\n-                return new FormulaWrapper(lat, lon, matcher.start(), matcher.group().length(), text);\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n-         */\n-        @Override\n-        @Nullable\n-        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n-            if (matcher.find()) {\n-                final String res = parseGroups(matcher, 1, matcher.groupCount());\n-                if (res != null) {\n-                    return new ResultWrapper(res, matcher.group().length());\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude from matched groups of corresponding pattern.\n-         *\n-         * @param groups\n-         *            the groups matched by latitude/longitude pattern\n-         * @return parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract String createCoordinate(@NonNull List<String> groups);\n-    }\n-\n-\n-    /**\n-     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n-     */\n-    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n-\n-        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n-        //                                                        (    2    )                                      (      3      )\n-        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n-\n-        //                                           (  1  )    (    2    )    (      3      )\n-        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n-\n-        //                                        (   1  )    (    2    )    (      3      )\n-        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n-        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n-        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n-\n-        MinDecFormulaParser() {\n-            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n-        }\n-\n-        /**\n-         * @see AbstractLatLonFormulaParser#createCoordinate(List)\n-         */\n-        @Override\n-        @Nullable\n-        public String createCoordinate(@NonNull final List<String> groups) {\n-            final String group1 = groups.get(0).trim();\n-            final String group2 = groups.get(1).trim();\n-            final String group3 = groups.get(2).trim();\n-\n-            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n-\n-            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n-            return result;\n-        }\n-\n-        public Settings.CoordInputFormatEnum formulaFormat() {\n-            return Settings.CoordInputFormatEnum.Plain;\n-        }\n-    }\n-\n-    /**\n-     * Returns a set of parser inputs for a given text\n-     *\n-     * The generated inputs use different delimiters for fractional numbers.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @return the set of parser inputs\n-     */\n-    @NonNull\n-    private static Set<String> getParseInputs(@NonNull final String text) {\n-        final String inputDot = removeSpaceAfterSeparators(text);\n-        return CollectionStream.of(new String[]{inputDot}).toSet();\n-    }\n-\n-    /**\n-     * Removes all single spaces after a comma (see #2404)\n-     *\n-     * @param text\n-     *            the string to substitute\n-     * @return the substituted string without the single spaces\n-     */\n-    @NonNull\n-    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n-        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n-        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n-    }\n-\n-    /**\n-     * Parses latitude/longitude from the given string.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @param latlon\n-     *            whether to parse latitude or longitude\n-     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n-     */\n-    @Nullable\n-    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-        final String input = removeSpaceAfterSeparators(text.trim());\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                final ResultWrapper wrapper = parser.parse(input, latlon);\n-                if (wrapper != null && wrapper.matcherLength == input.length()) {\n-                    return wrapper;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n-     *\n-     * Accepts following formats with formula:\n-     * - X DD\u00b0 MM.MMM\n-     *\n-     * variable count of spaces (also 0) are excepted\n-     *\n-     * @param text the string to be parsed\n-     * @return an pair of strings with parsed formula for latitude and longitude\n-     * @throws FormulaParser.ParseException\n-     *             if coordinates could not be parsed\n-     */\n-    @NonNull\n-    public FormulaWrapper parse(@NonNull final String text) {\n-        final Set<String> inputs = getParseInputs(text.trim());\n-        FormulaWrapper best = null;\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                for (final String input : inputs) {\n-                    final FormulaWrapper formulaWrapper = parser.parse(input);\n-                    if (formulaWrapper == null) {\n-                        continue;\n-                    }\n-                    if (best == null || formulaWrapper.isBetterThan(best)) {\n-                        best = formulaWrapper;\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (best != null) {\n-            return best;\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n-    }\n-\n-    /**\n-     * Parses latitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the latitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if latitude could not be parsed\n-     */\n-    public String parseLatitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n-    }\n-\n-    /**\n-     * Parses longitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the longitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if longitude could not be parsed\n-     */\n-    public String parseLongitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n-    }\n-\n-    private Boolean isValidParser(final AbstractFormulaParser parser) {\n-        if (null != desiredFormulaFormat) {\n-            return desiredFormulaFormat == parser.formulaFormat();\n-        }\n-        return true;\n-    }\n-}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nnew file mode 100644\nindex 000000000..4b7ccd3d9\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {\n+            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n+        }\n+\n+        /**\n+         * @see AbstractLatLonFormulaParser#parse(List)\n+         */\n+        @Override\n+        @Nullable\n+        public String parse(@NonNull final List<String> groups) {\n+            final String group1 = groups.get(0).trim();\n+            final String group2 = groups.get(1).trim();\n+            final String group3 = groups.get(2).trim();\n+\n+            // Handle empty degrees part (see #4620)\n+            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n+\n+            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n+            return result;\n+        }\n+\n+        public Settings.CoordInputFormatEnum formulaFormat() {\n+            return Settings.CoordInputFormatEnum.Plain;\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of parser inputs for a given text\n+     *\n+     * The generated inputs use different delimiters for fractional numbers.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @return the set of parser inputs\n+     */\n+    @NonNull\n+    private static Set<String> getParseInputs(@NonNull final String text) {\n+        final String inputDot = removeSpaceAfterSeparators(text);\n+        return CollectionStream.of(new String[]{inputDot}).toSet();\n+    }\n+\n+    /**\n+     * Removes all single spaces after a comma (see #2404)\n+     *\n+     * @param text\n+     *            the string to substitute\n+     * @return the substituted string without the single spaces\n+     */\n+    @NonNull\n+    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n+        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n+        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n+    }\n+\n+    /**\n+     * Parses latitude/longitude from the given string.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @param latlon\n+     *            whether to parse latitude or longitude\n+     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n+     */\n+    @Nullable\n+    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+        final String input = removeSpaceAfterSeparators(text.trim());\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                final ResultWrapper wrapper = parser.parse(input, latlon);\n+                if (wrapper != null && wrapper.matcherLength == input.length()) {\n+                    return wrapper;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n+     *\n+     * Accepts following formats with formula:\n+     * - X DD\u00b0 MM.MMM\n+     *\n+     * variable count of spaces (also 0) are excepted\n+     *\n+     * @param text the string to be parsed\n+     * @return an pair of strings with parsed formula for latitude and longitude\n+     * @throws FormulaParser.ParseException\n+     *             if coordinates could not be parsed\n+     */\n+    @NonNull\n+    public ImmutablePair<String, String> parse(@NonNull final String text) {\n+        final Set<String> inputs = getParseInputs(text.trim());\n+        ImmutablePair<String, String> foundPair = null;\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                for (final String input : inputs) {\n+                    final ImmutablePair<String, String> coordinatePair = parser.parse(input);\n+                    if (coordinatePair == null) {\n+                        continue;\n+                    }\n+                    foundPair = coordinatePair;\n+                }\n+            }\n+        }\n+\n+        if (foundPair != null) {\n+            return foundPair;\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n+    }\n+\n+    /**\n+     * Parses latitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the latitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if latitude could not be parsed\n+     */\n+    public String parseLatitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n+    }\n+\n+    /**\n+     * Parses longitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the longitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if longitude could not be parsed\n+     */\n+    public String parseLongitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n+    }\n+\n+    private Boolean isValidParser(final AbstractFormulaParser parser) {\n+        if (null != desiredFormulaFormat) {\n+            return desiredFormulaFormat == parser.formulaFormat();\n+        }\n+        return true;\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTM5NA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311394", "body": "I think this abstract class could be replaced by an interface?", "bodyText": "I think this abstract class could be replaced by an interface?", "bodyHTML": "<p dir=\"auto\">I think this abstract class could be replaced by an interface?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:45:37Z", "path": "main/src/cgeo/geocaching/calculator/FormulaParser.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MjU1OA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554472558", "bodyText": "Probably yes, but with your previous comment, probably that will be done with reusing the other parser...", "author": "murggel", "createdAt": "2021-01-09T21:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI1MzU4NA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559253584", "bodyText": "changed to interface", "author": "murggel", "createdAt": "2021-01-17T23:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "82c4d8e14cc013dac69f627891533b18bb2e6f86", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nindex 4b7ccd3d9..734df41c3 100644\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -67,7 +73,7 @@ public final class FormulaParser {\n     /**\n      * Abstract parser for coordinate formats.\n      */\n-    private abstract static class AbstractFormulaParser {\n+    private interface AbstractFormulaParser {\n         /**\n          * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n          *\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\ndeleted file mode 100644\nindex 734df41c3..000000000\n--- a/main/src/cgeo/geocaching/calculator/FormulaParser.java\n+++ /dev/null\n", "chunk": "@@ -1,382 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-import cgeo.geocaching.R;\n-import cgeo.geocaching.location.Geopoint;\n-import cgeo.geocaching.settings.Settings;\n-import cgeo.geocaching.utils.CollectionStream;\n-import cgeo.geocaching.utils.MatcherWrapper;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-\n-/**\n- * Parse coordinates with formulas.\n- * Similar to @see GeopointPareser, but there valid coordinates (double) are required, here a formula (string) is required.\n- *\n- * For plain-format the keyword (FORMULA-PLAIN) has to be used. Use '|' to separate the variables and the user note.\n- * example:\n- * @name (x) (FORMULA-PLAIN) N48 AB.(C*D/2) E 9 (C-D).(A+B) |A=a+b|a=5| user note\n- */\n-public final class FormulaParser {\n-\n-    public  static final char WPC_DELIM = '|';\n-    public  static final String WPC_DELIM_STRING = \"|\";\n-    public  static final String WPC_DELIM_PATTERN_STRING = \"\\\\|\";\n-\n-    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n-    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n-\n-    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n-\n-    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n-\n-    public FormulaParser() {\n-    }\n-\n-    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n-        desiredFormulaFormat = formulaFormat;\n-    }\n-\n-    public static class ParseException extends IllegalArgumentException {\n-        private static final long serialVersionUID = 1L;\n-        public final int resource;\n-\n-        public ParseException(final String msg) {\n-            super(msg);\n-            resource = R.string.err_parse_lat_lon;\n-        }\n-\n-        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n-            super(msg);\n-            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n-        }\n-    }\n-\n-    private static class ResultWrapper {\n-        private final String result;\n-        private final int matcherLength;\n-\n-        ResultWrapper(final String result, final int stringLength) {\n-            this.result = result;\n-            this.matcherLength = stringLength;\n-        }\n-    }\n-\n-    /**\n-     * Abstract parser for coordinate formats.\n-     */\n-    private interface AbstractFormulaParser {\n-        /**\n-         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n-         *\n-         * @param text the string to be parsed\n-         * @return an pair of strings with parsed formula for latitude and longitude\n-         */\n-        @Nullable\n-        FormulaWrapper parse(@NonNull String text);\n-\n-        /**\n-         * Parses latitude or longitude out of the given string.\n-         *\n-         * @param text\n-         *            the string to be parsed\n-         * @param latlon\n-         *            whether to parse latitude or longitude\n-         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n-         */\n-        @Nullable\n-        ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n-\n-        /**\n-         * Indicates which format is parsed\n-         * @return coordInputFormat which can be parsed\n-         */\n-        Settings.CoordInputFormatEnum formulaFormat();\n-    }\n-\n-    /**\n-     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n-     */\n-    private abstract static class AbstractLatLonFormulaParser implements AbstractFormulaParser {\n-        private final Pattern latPattern;\n-        private final Pattern lonPattern;\n-        private final Pattern latLonPattern;\n-\n-        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n-            this.latPattern = latPattern;\n-            this.lonPattern = lonPattern;\n-            this.latLonPattern = latLonPattern;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude out of a given range of matched groups.\n-         *\n-         * @param matcher\n-         *            the matcher that holds the matches groups\n-         * @param first\n-         *            the first group to parse\n-         * @param last\n-         *            the last group to parse\n-         * @return the parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n-            final List<String> groups = new ArrayList<>(last - first + 1);\n-            for (int i = first; i <= last; i++) {\n-                groups.add(matcher.group(i));\n-            }\n-\n-            return createCoordinate(groups);\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String)\n-         */\n-        @Override\n-        @Nullable\n-        public final FormulaWrapper parse(@NonNull final String text) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n-            if (matcher.find()) {\n-                final int groupCount = matcher.groupCount();\n-                final int partCount = groupCount / 2;\n-\n-                final String lat = parseGroups(matcher, 1, partCount);\n-                if (lat == null || lat.isEmpty()) {\n-                    return null;\n-                }\n-\n-                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n-                if (lon == null || lon.isEmpty()) {\n-                    return null;\n-                }\n-\n-                return new FormulaWrapper(lat, lon, matcher.start(), matcher.group().length(), text);\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n-         */\n-        @Override\n-        @Nullable\n-        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n-            if (matcher.find()) {\n-                final String res = parseGroups(matcher, 1, matcher.groupCount());\n-                if (res != null) {\n-                    return new ResultWrapper(res, matcher.group().length());\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        /**\n-         * Parses latitude or longitude from matched groups of corresponding pattern.\n-         *\n-         * @param groups\n-         *            the groups matched by latitude/longitude pattern\n-         * @return parsed latitude/longitude, or null if parsing failed\n-         */\n-        @Nullable\n-        public abstract String createCoordinate(@NonNull List<String> groups);\n-    }\n-\n-\n-    /**\n-     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n-     */\n-    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n-\n-        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n-        //                                                        (    2    )                                      (      3      )\n-        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n-\n-        //                                           (  1  )    (    2    )    (      3      )\n-        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n-\n-        //                                        (   1  )    (    2    )    (      3      )\n-        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n-        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n-        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n-        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n-\n-        MinDecFormulaParser() {\n-            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n-        }\n-\n-        /**\n-         * @see AbstractLatLonFormulaParser#createCoordinate(List)\n-         */\n-        @Override\n-        @Nullable\n-        public String createCoordinate(@NonNull final List<String> groups) {\n-            final String group1 = groups.get(0).trim();\n-            final String group2 = groups.get(1).trim();\n-            final String group3 = groups.get(2).trim();\n-\n-            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n-\n-            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n-            return result;\n-        }\n-\n-        public Settings.CoordInputFormatEnum formulaFormat() {\n-            return Settings.CoordInputFormatEnum.Plain;\n-        }\n-    }\n-\n-    /**\n-     * Returns a set of parser inputs for a given text\n-     *\n-     * The generated inputs use different delimiters for fractional numbers.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @return the set of parser inputs\n-     */\n-    @NonNull\n-    private static Set<String> getParseInputs(@NonNull final String text) {\n-        final String inputDot = removeSpaceAfterSeparators(text);\n-        return CollectionStream.of(new String[]{inputDot}).toSet();\n-    }\n-\n-    /**\n-     * Removes all single spaces after a comma (see #2404)\n-     *\n-     * @param text\n-     *            the string to substitute\n-     * @return the substituted string without the single spaces\n-     */\n-    @NonNull\n-    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n-        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n-        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n-    }\n-\n-    /**\n-     * Parses latitude/longitude from the given string.\n-     *\n-     * @param text\n-     *            the text to parse\n-     * @param latlon\n-     *            whether to parse latitude or longitude\n-     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n-     */\n-    @Nullable\n-    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n-        final String input = removeSpaceAfterSeparators(text.trim());\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                final ResultWrapper wrapper = parser.parse(input, latlon);\n-                if (wrapper != null && wrapper.matcherLength == input.length()) {\n-                    return wrapper;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n-     *\n-     * Accepts following formats with formula:\n-     * - X DD\u00b0 MM.MMM\n-     *\n-     * variable count of spaces (also 0) are excepted\n-     *\n-     * @param text the string to be parsed\n-     * @return an pair of strings with parsed formula for latitude and longitude\n-     * @throws FormulaParser.ParseException\n-     *             if coordinates could not be parsed\n-     */\n-    @NonNull\n-    public FormulaWrapper parse(@NonNull final String text) {\n-        final Set<String> inputs = getParseInputs(text.trim());\n-        FormulaWrapper best = null;\n-        for (final AbstractFormulaParser parser : parsers) {\n-            if (isValidParser(parser)) {\n-                for (final String input : inputs) {\n-                    final FormulaWrapper formulaWrapper = parser.parse(input);\n-                    if (formulaWrapper == null) {\n-                        continue;\n-                    }\n-                    if (best == null || formulaWrapper.isBetterThan(best)) {\n-                        best = formulaWrapper;\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (best != null) {\n-            return best;\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n-    }\n-\n-    /**\n-     * Parses latitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the latitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if latitude could not be parsed\n-     */\n-    public String parseLatitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n-    }\n-\n-    /**\n-     * Parses longitude out of the given string.\n-     *\n-     * The parsing fails if the string contains additional characters (except whitespaces).\n-     *\n-     * @see #parse(String)\n-     * @param text\n-     *            the string to be parsed\n-     * @return the longitude as decimal degrees\n-     * @throws FormulaParser.ParseException\n-     *             if longitude could not be parsed\n-     */\n-    public String parseLongitude(@Nullable final String text) {\n-        if (text != null) {\n-            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n-            if (wrapper != null) {\n-                return wrapper.result;\n-            }\n-        }\n-\n-        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n-    }\n-\n-    private Boolean isValidParser(final AbstractFormulaParser parser) {\n-        if (null != desiredFormulaFormat) {\n-            return desiredFormulaFormat == parser.formulaFormat();\n-        }\n-        return true;\n-    }\n-}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/FormulaParser.java b/main/src/cgeo/geocaching/calculator/FormulaParser.java\nnew file mode 100644\nindex 000000000..4b7ccd3d9\n--- /dev/null\n+++ b/main/src/cgeo/geocaching/calculator/FormulaParser.java\n", "chunk": "@@ -0,0 +1,379 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.location.Geopoint;\n+import cgeo.geocaching.settings.Settings;\n+import cgeo.geocaching.utils.CollectionStream;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+\n+/**\n+ * Parse coordinates with formulas.\n+ */\n+public final class FormulaParser {\n+\n+    public  static final char WPC_DELIM = '|';\n+\n+    private static final Pattern PATTERN_BAD_BLANK_COMMA = Pattern.compile(\"(\\\\d), (\\\\d{2,})\");\n+    private static final Pattern PATTERN_BAD_BLANK_DOT = Pattern.compile(\"(\\\\d)\\\\. (\\\\d{2,})\");\n+\n+    private static final List<AbstractFormulaParser> parsers = Arrays.asList(new MinDecFormulaParser());\n+\n+    private Settings.CoordInputFormatEnum desiredFormulaFormat = null;\n+\n+    public FormulaParser() {\n+    }\n+\n+    public FormulaParser(final Settings.CoordInputFormatEnum formulaFormat) {\n+        desiredFormulaFormat = formulaFormat;\n+    }\n+\n+    public static class ParseException extends IllegalArgumentException {\n+        private static final long serialVersionUID = 1L;\n+        public final int resource;\n+\n+        public ParseException(final String msg) {\n+            super(msg);\n+            resource = R.string.err_parse_lat_lon;\n+        }\n+\n+        public ParseException(final String msg, final Geopoint.LatLon faulty) {\n+            super(msg);\n+            resource = faulty == Geopoint.LatLon.LAT ? R.string.err_parse_lat : R.string.err_parse_lon;\n+        }\n+    }\n+\n+    private static class ResultWrapper {\n+        private final String result;\n+        private final int matcherLength;\n+\n+        ResultWrapper(final String result, final int stringLength) {\n+            this.result = result;\n+            this.matcherLength = stringLength;\n+        }\n+    }\n+\n+    /**\n+     * Abstract parser for coordinate formats.\n+     */\n+    private abstract static class AbstractFormulaParser {\n+        /**\n+         * Parses coordinates (with formula) out of the given string for a specific coordinate format.\n+         *\n+         * @param text the string to be parsed\n+         * @return an pair of strings with parsed formula for latitude and longitude\n+         */\n+        @Nullable\n+        public abstract ImmutablePair<String, String> parse(@NonNull String text);\n+\n+        /**\n+         * Parses latitude or longitude out of the given string.\n+         *\n+         * @param text\n+         *            the string to be parsed\n+         * @param latlon\n+         *            whether to parse latitude or longitude\n+         * @return a wrapper with the parsed latitude/longitude and the length of the match, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract ResultWrapper parse(@NonNull String text, @NonNull Geopoint.LatLon latlon);\n+\n+        /**\n+         * Indicates which format is parsed\n+         * @return coordInputFormat which can be parsed\n+         */\n+        public abstract Settings.CoordInputFormatEnum formulaFormat();\n+    }\n+\n+    /**\n+     * Abstract parser for coordinates that consist of two syntactic parts: latitude and longitude.\n+     */\n+    private abstract static class AbstractLatLonFormulaParser extends AbstractFormulaParser {\n+        private final Pattern latPattern;\n+        private final Pattern lonPattern;\n+        private final Pattern latLonPattern;\n+\n+        AbstractLatLonFormulaParser(@NonNull final Pattern latPattern, @NonNull final Pattern lonPattern, @NonNull final Pattern latLonPattern) {\n+            this.latPattern = latPattern;\n+            this.lonPattern = lonPattern;\n+            this.latLonPattern = latLonPattern;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude out of a given range of matched groups.\n+         *\n+         * @param matcher\n+         *            the matcher that holds the matches groups\n+         * @param first\n+         *            the first group to parse\n+         * @param last\n+         *            the last group to parse\n+         * @return the parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        private String parseGroups(@NonNull final MatcherWrapper matcher, final int first, final int last) {\n+            final List<String> groups = new ArrayList<>(last - first + 1);\n+            for (int i = first; i <= last; i++) {\n+                groups.add(matcher.group(i));\n+            }\n+\n+            return parse(groups);\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String)\n+         */\n+        @Override\n+        @Nullable\n+        public final ImmutablePair<String, String> parse(@NonNull final String text) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latLonPattern, text);\n+            if (matcher.find()) {\n+                final int groupCount = matcher.groupCount();\n+                final int partCount = groupCount / 2;\n+\n+                final String lat = parseGroups(matcher, 1, partCount);\n+                if (lat == null || lat.isEmpty()) {\n+                    return null;\n+                }\n+\n+                final String lon = parseGroups(matcher, partCount + 1, groupCount);\n+                if (lon == null || lon.isEmpty()) {\n+                    return null;\n+                }\n+\n+                return new ImmutablePair<>(lat, lon);\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * @see AbstractFormulaParser#parse(String, Geopoint.LatLon)\n+         */\n+        @Override\n+        @Nullable\n+        public final ResultWrapper parse(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+            final MatcherWrapper matcher = new MatcherWrapper(latlon == Geopoint.LatLon.LAT ? latPattern : lonPattern, text);\n+            if (matcher.find()) {\n+                final String res = parseGroups(matcher, 1, matcher.groupCount());\n+                if (res != null) {\n+                    return new ResultWrapper(res, matcher.group().length());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        /**\n+         * Parses latitude or longitude from matched groups of corresponding pattern.\n+         *\n+         * @param groups\n+         *            the groups matched by latitude/longitude pattern\n+         * @return parsed latitude/longitude, or null if parsing failed\n+         */\n+        @Nullable\n+        public abstract String parse(@NonNull List<String> groups);\n+    }\n+\n+\n+    /**\n+     * Parser for MinDec format: X DD\u00b0 MM.MMM'.\n+     */\n+    private static final class MinDecFormulaParser extends AbstractLatLonFormulaParser {\n+\n+        private static final String COORD_FORMULA_PATTERN_STRING = \"[\\\\[\\\\]\\\\(\\\\){}\" + CalculationUtils.VALID_OPERATOR_PATTERN + \"A-Za-z\\\\d]+\";\n+        private static final String STRING_MINDEC = \"\\\\s*(\" + COORD_FORMULA_PATTERN_STRING + \")[\u00b0\\\\s]+(\" + COORD_FORMULA_PATTERN_STRING + \"\\\\.\" + COORD_FORMULA_PATTERN_STRING + \")['\u2032\\\\s]?\";\n+\n+        // private static final String FORMULA_PATTERN_STRING = \"\\\\s*[NS]\" + COORD_FORMULA_PATTERN_STRING + \"\\\\s*[EW]\" + COORD_FORMULA_PATTERN_STRING ;\n+        // private static final Pattern FORMULA_PATTERN = Pattern.compile(FORMULA_PATTERN_STRING);\n+\n+\n+\n+        //                                           (  1  )    (    2    )    (      3      )\n+        private static final String STRING_LAT = \"([NS]?)\" + STRING_MINDEC;\n+\n+        //                                        (   1  )    (    2    )    (      3      )\n+        private static final String STRING_LON = \"([WEO]?)\" + STRING_MINDEC;\n+        private static final String STRING_SEPARATOR = \"[^\\\\w'\u2032\\\"\u2033\u00b0.\" + WPC_DELIM + \"]*\";\n+        private static final Pattern PATTERN_LAT = Pattern.compile(STRING_LAT, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LON = Pattern.compile(\"\\\\b\" + STRING_LON, Pattern.CASE_INSENSITIVE);\n+        private static final Pattern PATTERN_LATLON = Pattern.compile(STRING_LAT + STRING_SEPARATOR + STRING_LON, Pattern.CASE_INSENSITIVE);\n+\n+        MinDecFormulaParser() {\n+            super(PATTERN_LAT, PATTERN_LON, PATTERN_LATLON);\n+        }\n+\n+        /**\n+         * @see AbstractLatLonFormulaParser#parse(List)\n+         */\n+        @Override\n+        @Nullable\n+        public String parse(@NonNull final List<String> groups) {\n+            final String group1 = groups.get(0).trim();\n+            final String group2 = groups.get(1).trim();\n+            final String group3 = groups.get(2).trim();\n+\n+            // Handle empty degrees part (see #4620)\n+            final String strippedGroup2 = StringUtils.stripEnd(group2, \"\u00b0\").trim();\n+\n+            final String result = group1 + \" \" + strippedGroup2 + \"\u00b0 \" + group3 + \"'\";\n+            return result;\n+        }\n+\n+        public Settings.CoordInputFormatEnum formulaFormat() {\n+            return Settings.CoordInputFormatEnum.Plain;\n+        }\n+    }\n+\n+    /**\n+     * Returns a set of parser inputs for a given text\n+     *\n+     * The generated inputs use different delimiters for fractional numbers.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @return the set of parser inputs\n+     */\n+    @NonNull\n+    private static Set<String> getParseInputs(@NonNull final String text) {\n+        final String inputDot = removeSpaceAfterSeparators(text);\n+        return CollectionStream.of(new String[]{inputDot}).toSet();\n+    }\n+\n+    /**\n+     * Removes all single spaces after a comma (see #2404)\n+     *\n+     * @param text\n+     *            the string to substitute\n+     * @return the substituted string without the single spaces\n+     */\n+    @NonNull\n+    private static String removeSpaceAfterSeparators(@NonNull final String text) {\n+        final String replacedComma = new MatcherWrapper(PATTERN_BAD_BLANK_COMMA, text).replaceAll(\"$1,$2\");\n+        return new MatcherWrapper(PATTERN_BAD_BLANK_DOT, replacedComma).replaceAll(\"$1.$2\");\n+    }\n+\n+    /**\n+     * Parses latitude/longitude from the given string.\n+     *\n+     * @param text\n+     *            the text to parse\n+     * @param latlon\n+     *            whether to parse latitude or longitude\n+     * @return a wrapper with the best latitude/longitude and the length of the match, or null if parsing failed\n+     */\n+    @Nullable\n+    private ResultWrapper parseHelper(@NonNull final String text, @NonNull final Geopoint.LatLon latlon) {\n+        final String input = removeSpaceAfterSeparators(text.trim());\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                final ResultWrapper wrapper = parser.parse(input, latlon);\n+                if (wrapper != null && wrapper.matcherLength == input.length()) {\n+                    return wrapper;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Parses a pair of coordinates (latitude and longitude) with formula out of the given string.\n+     *\n+     * Accepts following formats with formula:\n+     * - X DD\u00b0 MM.MMM\n+     *\n+     * variable count of spaces (also 0) are excepted\n+     *\n+     * @param text the string to be parsed\n+     * @return an pair of strings with parsed formula for latitude and longitude\n+     * @throws FormulaParser.ParseException\n+     *             if coordinates could not be parsed\n+     */\n+    @NonNull\n+    public ImmutablePair<String, String> parse(@NonNull final String text) {\n+        final Set<String> inputs = getParseInputs(text.trim());\n+        ImmutablePair<String, String> foundPair = null;\n+        for (final AbstractFormulaParser parser : parsers) {\n+            if (isValidParser(parser)) {\n+                for (final String input : inputs) {\n+                    final ImmutablePair<String, String> coordinatePair = parser.parse(input);\n+                    if (coordinatePair == null) {\n+                        continue;\n+                    }\n+                    foundPair = coordinatePair;\n+                }\n+            }\n+        }\n+\n+        if (foundPair != null) {\n+            return foundPair;\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse coordinates with formula\");\n+    }\n+\n+    /**\n+     * Parses latitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the latitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if latitude could not be parsed\n+     */\n+    public String parseLatitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LAT);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse latitude\", Geopoint.LatLon.LAT);\n+    }\n+\n+    /**\n+     * Parses longitude out of the given string.\n+     *\n+     * The parsing fails if the string contains additional characters (except whitespaces).\n+     *\n+     * @see #parse(String)\n+     * @param text\n+     *            the string to be parsed\n+     * @return the longitude as decimal degrees\n+     * @throws FormulaParser.ParseException\n+     *             if longitude could not be parsed\n+     */\n+    public String parseLongitude(@Nullable final String text) {\n+        if (text != null) {\n+            final ResultWrapper wrapper = parseHelper(text, Geopoint.LatLon.LON);\n+            if (wrapper != null) {\n+                return wrapper.result;\n+            }\n+        }\n+\n+        throw new FormulaParser.ParseException(\"Cannot parse longitude\", Geopoint.LatLon.LON);\n+    }\n+\n+    private Boolean isValidParser(final AbstractFormulaParser parser) {\n+        if (null != desiredFormulaFormat) {\n+            return desiredFormulaFormat == parser.formulaFormat();\n+        }\n+        return true;\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTYyMg==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311622", "body": "This methods performance would profit from \"list\" being a map (char -> VariableData).  Would that be an adequate data structure for a collection of VariableData's?", "bodyText": "This methods performance would profit from \"list\" being a map (char -> VariableData).  Would that be an adequate data structure for a collection of VariableData's?", "bodyHTML": "<p dir=\"auto\">This methods performance would profit from \"list\" being a map (char -&gt; VariableData).  Would that be an adequate data structure for a collection of VariableData's?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:48:12Z", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -131,12 +149,9 @@ public final class CoordinatesCalculateUtils {\n      * @param list list of variables\n      * @return first occurrence of the variable if it can found, 'null' otherwise\n      */\n-    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+    private static VariableData findVariableData(final char name, final List<VariableData> list) {\n         for (final VariableData equ : list) {\n             if (equ.getName() == name) {\n-                if (remove) {\n-                    list.remove(equ);\n-                }\n                 return equ;\n             }\n         }\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 8dd7dcce1..cd6696ee1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -149,9 +32,12 @@ public final class CoordinatesCalculateUtils {\n      * @param list list of variables\n      * @return first occurrence of the variable if it can found, 'null' otherwise\n      */\n-    private static VariableData findVariableData(final char name, final List<VariableData> list) {\n+     private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n         for (final VariableData equ : list) {\n             if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n                 return equ;\n             }\n         }\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex cd6696ee1..0683cb822 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -25,43 +27,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Find if a variable exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @param list list of variables\n-     * @return first occurrence of the variable if it can found, 'null' otherwise\n-     */\n-     private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n-        for (final VariableData equ : list) {\n-            if (equ.getName() == name) {\n-                if (remove) {\n-                    list.remove(equ);\n-                }\n-                return equ;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Find if variable data exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @return first occurrence of the data if it can found, 'null' otherwise\n-     */\n-    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n-        for (final VariableData var : list) {\n-            if (var.getName() == name) {\n-                list.remove(var);\n-                return var;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n     public static List<VariableData> sortVariables(final List<VariableData> variables,\n                                                    final List<VariableData> varBank,\n                                                    final String variableNames,\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n-                if (getVariable(ch, returnList, false) != null) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                // equation for this variable?\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": null}]}}]}}, {"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 8dd7dcce1..cd6696ee1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -160,13 +46,12 @@ public final class CoordinatesCalculateUtils {\n     }\n \n     /**\n-     * Find if variable data exists in the supplied list with the given name and removes it from the list\n+     * Find if variable data exists in the supplied list with the given name\n      *\n      * @param name name to search for\n-     * @param list list of variables, variable will be removed from that list\n      * @return first occurrence of the data if it can found, 'null' otherwise\n      */\n-    private static VariableData findAndRemoveVariableData(final char name, final List<VariableData> list) {\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n         for (final VariableData var : list) {\n             if (var.getName() == name) {\n                 list.remove(var);\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex cd6696ee1..0683cb822 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -25,43 +27,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Find if a variable exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @param list list of variables\n-     * @return first occurrence of the variable if it can found, 'null' otherwise\n-     */\n-     private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n-        for (final VariableData equ : list) {\n-            if (equ.getName() == name) {\n-                if (remove) {\n-                    list.remove(equ);\n-                }\n-                return equ;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Find if variable data exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @return first occurrence of the data if it can found, 'null' otherwise\n-     */\n-    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n-        for (final VariableData var : list) {\n-            if (var.getName() == name) {\n-                list.remove(var);\n-                return var;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n     public static List<VariableData> sortVariables(final List<VariableData> variables,\n                                                    final List<VariableData> varBank,\n                                                    final String variableNames,\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n-                if (getVariable(ch, returnList, false) != null) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                // equation for this variable?\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311692", "body": "Isn't this the same as calling \"getVariable\" with \"remove=true\"?", "bodyText": "Isn't this the same as calling \"getVariable\" with \"remove=true\"?", "bodyHTML": "<p dir=\"auto\">Isn't this the same as calling \"getVariable\" with \"remove=true\"?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:48:52Z", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);\n+                if (thisEquation == null) {\n+                    thisEquation = findAndRemoveData(ch, varBank);\n+\n+                    if (thisEquation == null) {\n+                        thisEquation = new VariableData(ch);\n+                    }\n+                }\n+\n+                returnList.add(thisEquation);\n+            }\n+        }\n+\n+        // Add all the left over equations to the variable bank.\n+        for (final VariableData var : variables) {\n+            varBank.add(var);\n+        }\n+\n+        return returnList;\n+    }\n+\n+    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n+     *\n+     * @param latText formula / coordinates for latitude\n+     * @param lonText formula / coordinates for longitude\n+     * @param variableDataList list with already known variables / equations for formula\n+     *\n+     * @return calc state.\n+     * */\n+    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n+\n+        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n+\n+        char latHem = 'N';\n+        if (latText.length() > 0) {\n+            final char first = latText.charAt(0);\n+            if (first == 'N' || first == 'S') {\n+                latHem = first;\n+                coordinateChars = coordinateChars.concat(latText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(latText);\n+            }\n+        }\n+\n+        char lonHem = 'W';\n+        if (lonText.length() > 0) {\n+            final char first = lonText.charAt(0);\n+            if (first == 'E' || first == 'W' || first == 'O') {\n+                lonHem = first;\n+                coordinateChars = coordinateChars.concat(lonText.substring(1));\n+            } else {\n+                coordinateChars = coordinateChars.concat(lonText);\n+            }\n+        }\n+\n+        List<VariableData> equData = new ArrayList<>();\n+        equData = CoordinatesCalculateUtils.sortVariables(equData, variableDataList, coordinateChars, new CaseCheck(true));\n+\n+        String equationStrings = \"\";\n+        for (final VariableData equ : equData) {\n+            equationStrings = equationStrings.concat(equ.getExpression());\n+        }\n+\n+        // replace the old free variables list with a newly created ones.\n+        List<VariableData> freeVarData = new ArrayList<>();\n+        freeVarData = CoordinatesCalculateUtils.sortVariables(freeVarData, variableDataList, equationStrings, new CaseCheck(false));\n+\n+        final List<ButtonData> butData = new ArrayList<>();\n+\n+        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n+            latText,\n+            lonText,\n+            latHem,\n+            lonHem,\n+            butData,\n+            equData,\n+            freeVarData,\n+            variableDataList);\n+\n+        return calcState;\n+    }\n+\n+    /**\n+     * Find if a variable exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @param list list of variables\n+     * @return first occurrence of the variable if it can found, 'null' otherwise\n+     */\n+    private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n+        for (final VariableData equ : list) {\n+            if (equ.getName() == name) {\n+                if (remove) {\n+                    list.remove(equ);\n+                }\n+                return equ;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Find if variable data exists in the supplied list with the given name\n+     *\n+     * @param name name to search for\n+     * @return first occurrence of the data if it can found, 'null' otherwise\n+     */\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MzcxMw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554473713", "bodyText": "Seems so.\nI see 3 possibilities:\n\ncall getVariable(...false) in the method findAndRemoveData\nreplace the whole method findAndRemoveData with getVariable(...false)\nleave both methods and remove the parameter remove from getVariable and adapt all calls of getVariable(....true)  with findAndRemoveData\ncombination out of all having 3 functions:\n\n\nfindVariableData without boolean\nfindVariableDataAndRemove\nfindVariableData with boolean: the first two calls the third one\n\nI am not sure, which one I prefer, but variant 1 is the less preferred\nBTW isn't there any package in java which can handle that?", "author": "murggel", "createdAt": "2021-01-09T21:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3MzkwMQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554473901", "bodyText": "With your next comment, probably variant 3 or 4 will be best", "author": "murggel", "createdAt": "2021-01-09T21:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU1MDc5NA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554550794", "bodyText": "I like 3 best :-)", "author": "eddiemuc", "createdAt": "2021-01-10T11:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0OTYyMA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559249620", "bodyText": "Done", "author": "murggel", "createdAt": "2021-01-17T22:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -145,12 +160,13 @@ public final class CoordinatesCalculateUtils {\n     }\n \n     /**\n-     * Find if variable data exists in the supplied list with the given name\n+     * Find if variable data exists in the supplied list with the given name and removes it from the list\n      *\n      * @param name name to search for\n+     * @param list list of variables, variable will be removed from that list\n      * @return first occurrence of the data if it can found, 'null' otherwise\n      */\n-    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n+    private static VariableData findAndRemoveVariableData(final char name, final List<VariableData> list) {\n         for (final VariableData var : list) {\n             if (var.getName() == name) {\n                 list.remove(var);\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 8dd7dcce1..cd6696ee1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -160,13 +46,12 @@ public final class CoordinatesCalculateUtils {\n     }\n \n     /**\n-     * Find if variable data exists in the supplied list with the given name and removes it from the list\n+     * Find if variable data exists in the supplied list with the given name\n      *\n      * @param name name to search for\n-     * @param list list of variables, variable will be removed from that list\n      * @return first occurrence of the data if it can found, 'null' otherwise\n      */\n-    private static VariableData findAndRemoveVariableData(final char name, final List<VariableData> list) {\n+    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n         for (final VariableData var : list) {\n             if (var.getName() == name) {\n                 list.remove(var);\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex cd6696ee1..0683cb822 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -25,43 +27,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Find if a variable exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @param list list of variables\n-     * @return first occurrence of the variable if it can found, 'null' otherwise\n-     */\n-     private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n-        for (final VariableData equ : list) {\n-            if (equ.getName() == name) {\n-                if (remove) {\n-                    list.remove(equ);\n-                }\n-                return equ;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Find if variable data exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @return first occurrence of the data if it can found, 'null' otherwise\n-     */\n-    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n-        for (final VariableData var : list) {\n-            if (var.getName() == name) {\n-                list.remove(var);\n-                return var;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n     public static List<VariableData> sortVariables(final List<VariableData> variables,\n                                                    final List<VariableData> varBank,\n                                                    final String variableNames,\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n-                if (getVariable(ch, returnList, false) != null) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                // equation for this variable?\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTc1OQ==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311759", "body": "This method modifies the content of parameter \"variables\", which should not be done. At least there should be a comment on the method telling which params will be modified.", "bodyText": "This method modifies the content of parameter \"variables\", which should not be done. At least there should be a comment on the method telling which params will be modified.", "bodyHTML": "<p dir=\"auto\">This method modifies the content of parameter \"variables\", which should not be done. At least there should be a comment on the method telling which params will be modified.</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:49:59Z", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,\n+                                                   final CaseCheck theCase) {\n+        final List<VariableData> returnList = new ArrayList<>();\n+\n+        final char[] sortedVariables = variableNames.toCharArray();\n+        Arrays.sort(sortedVariables);\n+\n+        for (final char ch : sortedVariables) {\n+            if (theCase.check(ch)) {\n+                if (getVariable(ch, returnList, false) != null) {\n+                    continue;\n+                }\n+\n+                VariableData thisEquation = getVariable(ch, variables, true);", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0OTY3OA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r559249678", "bodyText": "Done", "author": "murggel", "createdAt": "2021-01-17T22:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTc1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..fb35ba663 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n                 if (getVariable(ch, returnList, false) != null) {\n                     continue;\n                 }\n \n+                // equation for this variable?\n                 VariableData thisEquation = getVariable(ch, variables, true);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex fb35ba663..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -52,15 +52,15 @@ public final class CoordinatesCalculateUtils {\n         for (final char ch : sortedVariables) {\n             if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n                 // already handled?\n-                if (getVariable(ch, returnList, false) != null) {\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n                 // equation for this variable?\n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n                     // saved equation for this variable?\n-                    thisEquation = findAndRemoveData(ch, variablesBank);\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n                         // create new equation\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 8dd7dcce1..cd6696ee1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -31,117 +25,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n-     * moves VariableData to the bank, if necessary\n-     * @param variables already defined VariableData and used\n-     * @param variablesBank already defined VariableData, but not used\n-     * @param variableNames names of currently used VariableData\n-     * @param upperCase sorting for upper-case variable\n-     * @return list of currently used VariableData\n-     */\n-    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n-                                                         final List<VariableData> variablesBank,\n-                                                         final String variableNames,\n-                                                         final Boolean upperCase) {\n-        final List<VariableData> returnList = new ArrayList<>();\n-\n-        final char[] sortedVariables = variableNames.toCharArray();\n-        Arrays.sort(sortedVariables);\n-\n-        for (final char ch : sortedVariables) {\n-            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n-                // already handled?\n-                if (findVariableData(ch, returnList) != null) {\n-                    continue;\n-                }\n-\n-                // equation for this variable?\n-                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n-                if (thisEquation == null) {\n-                    // saved equation for this variable?\n-                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n-\n-                    if (thisEquation == null) {\n-                        // create new equation\n-                        thisEquation = new VariableData(ch);\n-                    }\n-                }\n-\n-                returnList.add(thisEquation);\n-            }\n-        }\n-\n-        // Add all the left over equations to the variable bank.\n-        for (final VariableData var : variables) {\n-            variablesBank.add(var);\n-        }\n-\n-        // currently used equations\n-        return returnList;\n-    }\n-\n-    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n-     *\n-     * @param latText formula / coordinates for latitude\n-     * @param lonText formula / coordinates for longitude\n-     * @param variableDataList list with already known variables / equations for formula\n-     *\n-     * @return calc state.\n-     * */\n-    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n-\n-        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n-\n-        char latHem = 'N';\n-        if (latText.length() > 0) {\n-            final char first = latText.charAt(0);\n-            if (first == 'N' || first == 'S') {\n-                latHem = first;\n-                coordinateChars = coordinateChars.concat(latText.substring(1));\n-            } else {\n-                coordinateChars = coordinateChars.concat(latText);\n-            }\n-        }\n-\n-        char lonHem = 'W';\n-        if (lonText.length() > 0) {\n-            final char first = lonText.charAt(0);\n-            if (first == 'E' || first == 'W' || first == 'O') {\n-                lonHem = first;\n-                coordinateChars = coordinateChars.concat(lonText.substring(1));\n-            } else {\n-                coordinateChars = coordinateChars.concat(lonText);\n-            }\n-        }\n-\n-        List<VariableData> equData = new ArrayList<>();\n-        equData = CoordinatesCalculateUtils.updateVariablesList(equData, variableDataList, coordinateChars, true);\n-\n-        String equationStrings = \"\";\n-        for (final VariableData equ : equData) {\n-            equationStrings = equationStrings.concat(equ.getExpression());\n-        }\n-\n-        // replace the old free variables list with a newly created ones.\n-        List<VariableData> freeVarData = new ArrayList<>();\n-        freeVarData = CoordinatesCalculateUtils.updateVariablesList(freeVarData, variableDataList, equationStrings, false);\n-\n-        final List<ButtonData> butData = new ArrayList<>();\n-\n-        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n-            latText,\n-            lonText,\n-            latHem,\n-            lonHem,\n-            butData,\n-            equData,\n-            freeVarData,\n-            variableDataList);\n-\n-        return calcState;\n-    }\n-\n     /**\n      * Find if a variable exists in the supplied list with the given name\n      *\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex cd6696ee1..0683cb822 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -25,43 +27,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Find if a variable exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @param list list of variables\n-     * @return first occurrence of the variable if it can found, 'null' otherwise\n-     */\n-     private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n-        for (final VariableData equ : list) {\n-            if (equ.getName() == name) {\n-                if (remove) {\n-                    list.remove(equ);\n-                }\n-                return equ;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Find if variable data exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @return first occurrence of the data if it can found, 'null' otherwise\n-     */\n-    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n-        for (final VariableData var : list) {\n-            if (var.getName() == name) {\n-                list.remove(var);\n-                return var;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n     public static List<VariableData> sortVariables(final List<VariableData> variables,\n                                                    final List<VariableData> varBank,\n                                                    final String variableNames,\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n-                if (getVariable(ch, returnList, false) != null) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                // equation for this variable?\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTgyNA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311824", "body": "I dont understand difference between \"variables\" and \"varBank\". Maybe a short comment would help?", "bodyText": "I dont understand difference between \"variables\" and \"varBank\". Maybe a short comment would help?", "bodyHTML": "<p dir=\"auto\">I dont understand difference between \"variables\" and \"varBank\". Maybe a short comment would help?</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:51:01Z", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3OTY5MA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554479690", "bodyText": "Done", "author": "murggel", "createdAt": "2021-01-09T22:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..fb35ba663 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n                 if (getVariable(ch, returnList, false) != null) {\n                     continue;\n                 }\n \n+                // equation for this variable?\n                 VariableData thisEquation = getVariable(ch, variables, true);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex fb35ba663..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -52,15 +52,15 @@ public final class CoordinatesCalculateUtils {\n         for (final char ch : sortedVariables) {\n             if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n                 // already handled?\n-                if (getVariable(ch, returnList, false) != null) {\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n                 // equation for this variable?\n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n                     // saved equation for this variable?\n-                    thisEquation = findAndRemoveData(ch, variablesBank);\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n                         // create new equation\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 8dd7dcce1..cd6696ee1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -31,117 +25,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n-     * moves VariableData to the bank, if necessary\n-     * @param variables already defined VariableData and used\n-     * @param variablesBank already defined VariableData, but not used\n-     * @param variableNames names of currently used VariableData\n-     * @param upperCase sorting for upper-case variable\n-     * @return list of currently used VariableData\n-     */\n-    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n-                                                         final List<VariableData> variablesBank,\n-                                                         final String variableNames,\n-                                                         final Boolean upperCase) {\n-        final List<VariableData> returnList = new ArrayList<>();\n-\n-        final char[] sortedVariables = variableNames.toCharArray();\n-        Arrays.sort(sortedVariables);\n-\n-        for (final char ch : sortedVariables) {\n-            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n-                // already handled?\n-                if (findVariableData(ch, returnList) != null) {\n-                    continue;\n-                }\n-\n-                // equation for this variable?\n-                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n-                if (thisEquation == null) {\n-                    // saved equation for this variable?\n-                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n-\n-                    if (thisEquation == null) {\n-                        // create new equation\n-                        thisEquation = new VariableData(ch);\n-                    }\n-                }\n-\n-                returnList.add(thisEquation);\n-            }\n-        }\n-\n-        // Add all the left over equations to the variable bank.\n-        for (final VariableData var : variables) {\n-            variablesBank.add(var);\n-        }\n-\n-        // currently used equations\n-        return returnList;\n-    }\n-\n-    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n-     *\n-     * @param latText formula / coordinates for latitude\n-     * @param lonText formula / coordinates for longitude\n-     * @param variableDataList list with already known variables / equations for formula\n-     *\n-     * @return calc state.\n-     * */\n-    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n-\n-        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n-\n-        char latHem = 'N';\n-        if (latText.length() > 0) {\n-            final char first = latText.charAt(0);\n-            if (first == 'N' || first == 'S') {\n-                latHem = first;\n-                coordinateChars = coordinateChars.concat(latText.substring(1));\n-            } else {\n-                coordinateChars = coordinateChars.concat(latText);\n-            }\n-        }\n-\n-        char lonHem = 'W';\n-        if (lonText.length() > 0) {\n-            final char first = lonText.charAt(0);\n-            if (first == 'E' || first == 'W' || first == 'O') {\n-                lonHem = first;\n-                coordinateChars = coordinateChars.concat(lonText.substring(1));\n-            } else {\n-                coordinateChars = coordinateChars.concat(lonText);\n-            }\n-        }\n-\n-        List<VariableData> equData = new ArrayList<>();\n-        equData = CoordinatesCalculateUtils.updateVariablesList(equData, variableDataList, coordinateChars, true);\n-\n-        String equationStrings = \"\";\n-        for (final VariableData equ : equData) {\n-            equationStrings = equationStrings.concat(equ.getExpression());\n-        }\n-\n-        // replace the old free variables list with a newly created ones.\n-        List<VariableData> freeVarData = new ArrayList<>();\n-        freeVarData = CoordinatesCalculateUtils.updateVariablesList(freeVarData, variableDataList, equationStrings, false);\n-\n-        final List<ButtonData> butData = new ArrayList<>();\n-\n-        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n-            latText,\n-            lonText,\n-            latHem,\n-            lonHem,\n-            butData,\n-            equData,\n-            freeVarData,\n-            variableDataList);\n-\n-        return calcState;\n-    }\n-\n     /**\n      * Find if a variable exists in the supplied list with the given name\n      *\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex cd6696ee1..0683cb822 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -25,43 +27,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Find if a variable exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @param list list of variables\n-     * @return first occurrence of the variable if it can found, 'null' otherwise\n-     */\n-     private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n-        for (final VariableData equ : list) {\n-            if (equ.getName() == name) {\n-                if (remove) {\n-                    list.remove(equ);\n-                }\n-                return equ;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Find if variable data exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @return first occurrence of the data if it can found, 'null' otherwise\n-     */\n-    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n-        for (final VariableData var : list) {\n-            if (var.getName() == name) {\n-                list.remove(var);\n-                return var;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n     public static List<VariableData> sortVariables(final List<VariableData> variables,\n                                                    final List<VariableData> varBank,\n                                                    final String variableNames,\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n-                if (getVariable(ch, returnList, false) != null) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                // equation for this variable?\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTg4Mw==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554311883", "body": "If I understand the code correctly, then the value of \"variableNames\" could be extracted from list \"variables\". Is this correct? Then this parameter should be removed.", "bodyText": "If I understand the code correctly, then the value of \"variableNames\" could be extracted from list \"variables\". Is this correct? Then this parameter should be removed.", "bodyHTML": "<p dir=\"auto\">If I understand the code correctly, then the value of \"variableNames\" could be extracted from list \"variables\". Is this correct? Then this parameter should be removed.</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:51:53Z", "path": "main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.settings.Settings;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Through out this implementation:\n+ *\n+ * 'Equations' are used to represent 'Variables' that appear in the description of the cache coordinated themselves.\n+ *             As in \"N 42\u00b0 127.ABC\".  In this example 'A', 'B' and 'C' are all 'equations'.\n+ *             All 'equations' must have a CAPITAL-LETTER name.\n+ *\n+ * 'FreeVariables' are used to represent 'Variables' that appear in the 'expression' of an equation\n+ *                 As in \"X = a^2 + b^2\".  In this example 'a' and 'b' are both 'freeVariables'.\n+ *                 All 'freeVariables' must have a lower-case name.\n+ */\n+public final class CoordinatesCalculateUtils {\n+\n+    /** Flag values used to designate that no AutoChar has been set */\n+    public static final char EMPTY_CHAR = '-';\n+\n+    private CoordinatesCalculateUtils() {\n+        // Do not instantiate\n+    }\n+\n+    public static List<VariableData> sortVariables(final List<VariableData> variables,\n+                                                   final List<VariableData> varBank,\n+                                                   final String variableNames,", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3NDk4Ng==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554474986", "bodyText": "I will rename the function and add description", "author": "murggel", "createdAt": "2021-01-09T21:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMTg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..fb35ba663 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n                 if (getVariable(ch, returnList, false) != null) {\n                     continue;\n                 }\n \n+                // equation for this variable?\n                 VariableData thisEquation = getVariable(ch, variables, true);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex fb35ba663..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -52,15 +52,15 @@ public final class CoordinatesCalculateUtils {\n         for (final char ch : sortedVariables) {\n             if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n                 // already handled?\n-                if (getVariable(ch, returnList, false) != null) {\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n                 // equation for this variable?\n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n                     // saved equation for this variable?\n-                    thisEquation = findAndRemoveData(ch, variablesBank);\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n                         // create new equation\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 8dd7dcce1..cd6696ee1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -31,117 +25,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n-     * moves VariableData to the bank, if necessary\n-     * @param variables already defined VariableData and used\n-     * @param variablesBank already defined VariableData, but not used\n-     * @param variableNames names of currently used VariableData\n-     * @param upperCase sorting for upper-case variable\n-     * @return list of currently used VariableData\n-     */\n-    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n-                                                         final List<VariableData> variablesBank,\n-                                                         final String variableNames,\n-                                                         final Boolean upperCase) {\n-        final List<VariableData> returnList = new ArrayList<>();\n-\n-        final char[] sortedVariables = variableNames.toCharArray();\n-        Arrays.sort(sortedVariables);\n-\n-        for (final char ch : sortedVariables) {\n-            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n-                // already handled?\n-                if (findVariableData(ch, returnList) != null) {\n-                    continue;\n-                }\n-\n-                // equation for this variable?\n-                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n-                if (thisEquation == null) {\n-                    // saved equation for this variable?\n-                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n-\n-                    if (thisEquation == null) {\n-                        // create new equation\n-                        thisEquation = new VariableData(ch);\n-                    }\n-                }\n-\n-                returnList.add(thisEquation);\n-            }\n-        }\n-\n-        // Add all the left over equations to the variable bank.\n-        for (final VariableData var : variables) {\n-            variablesBank.add(var);\n-        }\n-\n-        // currently used equations\n-        return returnList;\n-    }\n-\n-    /** Creates a calc-state out of given lat- and lon-formula and list of variables\n-     *\n-     * @param latText formula / coordinates for latitude\n-     * @param lonText formula / coordinates for longitude\n-     * @param variableDataList list with already known variables / equations for formula\n-     *\n-     * @return calc state.\n-     * */\n-    public static CalcState createCalcState(final String latText, final String lonText, final List<VariableData> variableDataList) {\n-\n-        String coordinateChars = \"\"; // All the characters that appear in the coordinate representation.\n-\n-        char latHem = 'N';\n-        if (latText.length() > 0) {\n-            final char first = latText.charAt(0);\n-            if (first == 'N' || first == 'S') {\n-                latHem = first;\n-                coordinateChars = coordinateChars.concat(latText.substring(1));\n-            } else {\n-                coordinateChars = coordinateChars.concat(latText);\n-            }\n-        }\n-\n-        char lonHem = 'W';\n-        if (lonText.length() > 0) {\n-            final char first = lonText.charAt(0);\n-            if (first == 'E' || first == 'W' || first == 'O') {\n-                lonHem = first;\n-                coordinateChars = coordinateChars.concat(lonText.substring(1));\n-            } else {\n-                coordinateChars = coordinateChars.concat(lonText);\n-            }\n-        }\n-\n-        List<VariableData> equData = new ArrayList<>();\n-        equData = CoordinatesCalculateUtils.updateVariablesList(equData, variableDataList, coordinateChars, true);\n-\n-        String equationStrings = \"\";\n-        for (final VariableData equ : equData) {\n-            equationStrings = equationStrings.concat(equ.getExpression());\n-        }\n-\n-        // replace the old free variables list with a newly created ones.\n-        List<VariableData> freeVarData = new ArrayList<>();\n-        freeVarData = CoordinatesCalculateUtils.updateVariablesList(freeVarData, variableDataList, equationStrings, false);\n-\n-        final List<ButtonData> butData = new ArrayList<>();\n-\n-        final CalcState calcState = new CalcState(Settings.CoordInputFormatEnum.Plain,\n-            latText,\n-            lonText,\n-            latHem,\n-            lonHem,\n-            butData,\n-            equData,\n-            freeVarData,\n-            variableDataList);\n-\n-        return calcState;\n-    }\n-\n     /**\n      * Find if a variable exists in the supplied list with the given name\n      *\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex cd6696ee1..0683cb822 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -25,43 +27,6 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    /**\n-     * Find if a variable exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @param list list of variables\n-     * @return first occurrence of the variable if it can found, 'null' otherwise\n-     */\n-     private static VariableData getVariable(final char name, final List<VariableData> list, final boolean remove) {\n-        for (final VariableData equ : list) {\n-            if (equ.getName() == name) {\n-                if (remove) {\n-                    list.remove(equ);\n-                }\n-                return equ;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    /**\n-     * Find if variable data exists in the supplied list with the given name\n-     *\n-     * @param name name to search for\n-     * @return first occurrence of the data if it can found, 'null' otherwise\n-     */\n-    private static VariableData findAndRemoveData(final char name, final List<VariableData> list) {\n-        for (final VariableData var : list) {\n-            if (var.getName() == name) {\n-                list.remove(var);\n-                return var;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n     public static List<VariableData> sortVariables(final List<VariableData> variables,\n                                                    final List<VariableData> varBank,\n                                                    final String variableNames,\n", "next_change": {"commit": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "changed_code": [{"header": "diff --git a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\nindex 0683cb822..8dd7dcce1 100644\n--- a/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n+++ b/main/src/cgeo/geocaching/calculator/CoordinatesCalculateUtils.java\n", "chunk": "@@ -27,26 +31,39 @@ public final class CoordinatesCalculateUtils {\n         // Do not instantiate\n     }\n \n-    public static List<VariableData> sortVariables(final List<VariableData> variables,\n-                                                   final List<VariableData> varBank,\n-                                                   final String variableNames,\n-                                                   final CaseCheck theCase) {\n+    /**\n+     * Updates the list of currently used VariableData, creates new VariableData if necessary,\n+     * moves VariableData to the bank, if necessary\n+     * @param variables already defined VariableData and used\n+     * @param variablesBank already defined VariableData, but not used\n+     * @param variableNames names of currently used VariableData\n+     * @param upperCase sorting for upper-case variable\n+     * @return list of currently used VariableData\n+     */\n+    public static List<VariableData> updateVariablesList(final List<VariableData> variables,\n+                                                         final List<VariableData> variablesBank,\n+                                                         final String variableNames,\n+                                                         final Boolean upperCase) {\n         final List<VariableData> returnList = new ArrayList<>();\n \n         final char[] sortedVariables = variableNames.toCharArray();\n         Arrays.sort(sortedVariables);\n \n         for (final char ch : sortedVariables) {\n-            if (theCase.check(ch)) {\n-                if (getVariable(ch, returnList, false) != null) {\n+            if (TextUtils.isLetterOrDigit(ch, upperCase)) {\n+                // already handled?\n+                if (findVariableData(ch, returnList) != null) {\n                     continue;\n                 }\n \n-                VariableData thisEquation = getVariable(ch, variables, true);\n+                // equation for this variable?\n+                VariableData thisEquation = findAndRemoveVariableData(ch, variables);\n                 if (thisEquation == null) {\n-                    thisEquation = findAndRemoveData(ch, varBank);\n+                    // saved equation for this variable?\n+                    thisEquation = findAndRemoveVariableData(ch, variablesBank);\n \n                     if (thisEquation == null) {\n+                        // create new equation\n                         thisEquation = new VariableData(ch);\n                     }\n                 }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMjEyMA==", "url": "https://github.com/cgeo/cgeo/pull/9633#discussion_r554312120", "body": "Kudos for writing unit tests! :-)", "bodyText": "Kudos for writing unit tests! :-)", "bodyHTML": "<p dir=\"auto\">Kudos for writing unit tests! :-)</p>", "author": "eddiemuc", "createdAt": "2021-01-09T08:54:39Z", "path": "tests/src/cgeo/geocaching/calculator/FormulaParserTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.junit.Test;\n+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;\n+import static org.assertj.core.api.Java6Assertions.assertThat;\n+\n+public class FormulaParserTest {", "originalCommit": "a402ec75a5ddba61ae9d5ad9664c02a578275580", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "changed_code": [{"header": "diff --git a/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java b/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\nindex 4d21f29f8..f7c115b5b 100644\n--- a/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\n+++ b/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\n", "chunk": "@@ -5,7 +5,6 @@ import cgeo.geocaching.models.CalcState;\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.commons.lang3.tuple.ImmutablePair;\n import org.junit.Test;\n import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;\n import static org.assertj.core.api.Java6Assertions.assertThat;\n", "next_change": {"commit": "f70bd2ae6f7f28b857bc005ee787f438ffa42921", "changed_code": [{"header": "diff --git a/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java b/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\nindex f7c115b5b..f07421193 100644\n--- a/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\n+++ b/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\n", "chunk": "@@ -1,6 +1,7 @@\n package cgeo.geocaching.calculator;\n \n import cgeo.geocaching.models.CalcState;\n+import cgeo.geocaching.models.WaypointParser;\n \n import java.util.ArrayList;\n import java.util.List;\n", "next_change": {"commit": "743cc64fbd0ba41d94843aebb3929d5a25871608", "changed_code": [{"header": "diff --git a/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java b/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\ndeleted file mode 100644\nindex f07421193..000000000\n--- a/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\n+++ /dev/null\n", "chunk": "@@ -1,119 +0,0 @@\n-package cgeo.geocaching.calculator;\n-\n-import cgeo.geocaching.models.CalcState;\n-import cgeo.geocaching.models.WaypointParser;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import org.junit.Test;\n-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;\n-import static org.assertj.core.api.Java6Assertions.assertThat;\n-\n-public class FormulaParserTest {\n-\n-    @Test\n-    public void testParseLatitude() {\n-        final FormulaParser formulaParser = new FormulaParser();\n-        final String parsedLatitudeNorth = formulaParser.parseLatitude(\"N AB\u00b0 CD.EFG\");\n-        assertThat(parsedLatitudeNorth).isNotNull();\n-\n-        final String parsedLatitudeSouth = formulaParser.parseLatitude(\"S AB\u00b0 CD.EFG\");\n-        assertThat(parsedLatitudeSouth).isNotNull();\n-    }\n-\n-    @Test\n-    public void testParseLongitude() {\n-        final FormulaParser formulaParser = new FormulaParser();\n-        final String parsedLongitudeWest = formulaParser.parseLongitude(\"W A\u00b0 BC.DEF\");\n-        assertThat(parsedLongitudeWest).isNotNull();\n-\n-\n-        final String parsedLongitudeEast = formulaParser.parseLongitude(\"E A\u00b0 BC.DEF\");\n-        assertThat(parsedLongitudeEast).isNotNull();\n-\n-        final String parsedLongitudeOst = formulaParser.parseLongitude(\"O A\u00b0 BC.DEF\");\n-        assertThat(parsedLongitudeOst).isNotNull();\n-    }\n-\n-    @Test\n-    public void testParseFullCoordinatesDirections() {\n-        final FormulaParser formulaParser = new FormulaParser();\n-\n-        final FormulaWrapper parsedFullCoordinatesNorthEast = formulaParser.parse(\"N AB\u00b0 CD.EFG  E H\u00b0 IJ.KLM\");\n-        assertThat(parsedFullCoordinatesNorthEast).isNotNull();\n-\n-        final FormulaWrapper parsedFullCoordinatesSouthWest = formulaParser.parse(\"S AB\u00b0 CD.EFG  W H\u00b0 IJ.KLM\");\n-        assertThat(parsedFullCoordinatesSouthWest).isNotNull();\n-    }\n-\n-    @Test\n-    public void testParseFullCoordinates() {\n-        final FormulaParser formulaParser = new FormulaParser();\n-        final FormulaWrapper parsedFullCoordinates = formulaParser.parse(\"N 49\u00b0 AB.031  E 8\u00b0 38.DEF\");\n-        assertThat(parsedFullCoordinates).isNotNull();\n-        final String parsedLatitude = parsedFullCoordinates.getFormulaLat();\n-        final String parsedLongitude = parsedFullCoordinates.getFormulaLon();\n-        assertThat(parsedLatitude).isNotNull();\n-        assertThat(parsedLongitude).isNotNull();\n-\n-        final List<VariableData> variables = new ArrayList<>();\n-        final CalcState calcState = CoordinatesCalculateUtils.createCalcState(parsedLatitude, parsedLongitude, variables);\n-        assertThat(calcState.plainLat).isEqualTo(\"N 49\u00b0 AB.031'\");\n-        assertThat(calcState.plainLon).isEqualTo(\"E 8\u00b0 38.DEF'\");\n-    }\n-\n-    @Test\n-    public void testParseFullCoordinatesWithFormula() {\n-        final FormulaParser formulaParser = new FormulaParser();\n-        final FormulaWrapper parsedFullCoordinates = formulaParser.parse(WaypointParser.PARSING_COORD_FORMULA_PLAIN + \" N  AB\u00b0 48.[B+C-A]^2  E (B%C)\u00b0  38.(D+F)*2 | a = 2) test\");\n-        assertThat(parsedFullCoordinates).isNotNull();\n-        final String parsedLatitude = parsedFullCoordinates.getFormulaLat();\n-        final String parsedLongitude = parsedFullCoordinates.getFormulaLon();\n-        assertThat(parsedLatitude).isNotNull();\n-        assertThat(parsedLongitude).isNotNull();\n-\n-        final List<VariableData> variables = new ArrayList<>();\n-        final CalcState calcState = CoordinatesCalculateUtils.createCalcState(parsedLatitude, parsedLongitude, variables);\n-        assertThat(calcState.plainLat).isEqualTo(\"N AB\u00b0 48.[B+C-A]^2'\");\n-        assertThat(calcState.plainLon).isEqualTo(\"E (B%C)\u00b0 38.(D+F)*2'\");\n-    }\n-\n-    @Test\n-    public void testParseFullCoordinatesWithIncompleteFormula() {\n-        final FormulaParser formulaParser = new FormulaParser();\n-        final FormulaWrapper parsedFullCoordinates = formulaParser.parse(WaypointParser.PARSING_COORD_FORMULA_PLAIN  + \" N  AB\u00b0 48.B+C-A^2  E (B%C)\u00b0  38.(D+F)^2 | a = 2) test\");\n-        assertThat(parsedFullCoordinates).isNotNull();\n-        final String parsedLatitude = parsedFullCoordinates.getFormulaLat();\n-        final String parsedLongitude = parsedFullCoordinates.getFormulaLon();\n-        assertThat(parsedLatitude).isNotNull();\n-        assertThat(parsedLongitude).isNotNull();\n-\n-        final List<VariableData> variables = new ArrayList<>();\n-        final CalcState calcState = CoordinatesCalculateUtils.createCalcState(parsedLatitude, parsedLongitude, variables);\n-        assertThat(calcState.plainLat).isEqualTo(\"N AB\u00b0 48.B+C-A^2'\");\n-        assertThat(calcState.plainLon).isEqualTo(\"E (B%C)\u00b0 38.(D+F)^2'\");\n-    }\n-\n-    @Test\n-    public void testParseFullCoordinatesWithNoValidFormula() {\n-        try {\n-            final FormulaParser formulaParser = new FormulaParser();\n-            formulaParser.parse(WaypointParser.PARSING_COORD_FORMULA_PLAIN + \" N  AB\u00b0 48.[B+C-A^2  E (B%C)\u00b0  38!.(D+F)2 | a = 2) test\");\n-            failBecauseExceptionWasNotThrown(FormulaParser.ParseException.class);\n-        } catch (final FormulaParser.ParseException e) {\n-            // expected\n-        }\n-    }\n-\n-    @Test\n-    public void testParseFullCoordinatesException() {\n-        try {\n-            final FormulaParser formulaParser = new FormulaParser();\n-            formulaParser.parse(\"N 49\u00b0 AB.031 | E 8\u00b0 38.DEF\");\n-            failBecauseExceptionWasNotThrown(FormulaParser.ParseException.class);\n-        } catch (final FormulaParser.ParseException e) {\n-            // expected\n-        }\n-    }\n-}\n", "next_change": {"commit": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "changed_code": [{"header": "diff --git a/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java b/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\nnew file mode 100644\nindex 000000000..4d21f29f8\n--- /dev/null\n+++ b/tests/src/cgeo/geocaching/calculator/FormulaParserTest.java\n", "chunk": "@@ -0,0 +1,119 @@\n+package cgeo.geocaching.calculator;\n+\n+import cgeo.geocaching.models.CalcState;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.junit.Test;\n+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;\n+import static org.assertj.core.api.Java6Assertions.assertThat;\n+\n+public class FormulaParserTest {\n+\n+    @Test\n+    public void testParseLatitude() {\n+        final FormulaParser formulaParser = new FormulaParser();\n+        final String parsedLatitudeNorth = formulaParser.parseLatitude(\"N AB\u00b0 CD.EFG\");\n+        assertThat(parsedLatitudeNorth).isNotNull();\n+\n+        final String parsedLatitudeSouth = formulaParser.parseLatitude(\"S AB\u00b0 CD.EFG\");\n+        assertThat(parsedLatitudeSouth).isNotNull();\n+    }\n+\n+    @Test\n+    public void testParseLongitude() {\n+        final FormulaParser formulaParser = new FormulaParser();\n+        final String parsedLongitudeWest = formulaParser.parseLongitude(\"W A\u00b0 BC.DEF\");\n+        assertThat(parsedLongitudeWest).isNotNull();\n+\n+\n+        final String parsedLongitudeEast = formulaParser.parseLongitude(\"E A\u00b0 BC.DEF\");\n+        assertThat(parsedLongitudeEast).isNotNull();\n+\n+        final String parsedLongitudeOst = formulaParser.parseLongitude(\"O A\u00b0 BC.DEF\");\n+        assertThat(parsedLongitudeOst).isNotNull();\n+    }\n+\n+    @Test\n+    public void testParseFullCoordinatesDirections() {\n+        final FormulaParser formulaParser = new FormulaParser();\n+\n+        final ImmutablePair<String, String> parsedFullCoordinatesNorthEast = formulaParser.parse(\"N AB\u00b0 CD.EFG  E H\u00b0 IJ.KLM\");\n+        assertThat(parsedFullCoordinatesNorthEast).isNotNull();\n+\n+        final ImmutablePair<String, String> parsedFullCoordinatesSouthWest = formulaParser.parse(\"S AB\u00b0 CD.EFG  W H\u00b0 IJ.KLM\");\n+        assertThat(parsedFullCoordinatesSouthWest).isNotNull();\n+    }\n+\n+    @Test\n+    public void testParseFullCoordinates() {\n+        final FormulaParser formulaParser = new FormulaParser();\n+        final ImmutablePair<String, String> parsedFullCoordinates = formulaParser.parse(\"N 49\u00b0 AB.031  E 8\u00b0 38.DEF\");\n+        assertThat(parsedFullCoordinates).isNotNull();\n+        final String parsedLatitude = parsedFullCoordinates.left;\n+        final String parsedLongitude = parsedFullCoordinates.right;\n+        assertThat(parsedLatitude).isNotNull();\n+        assertThat(parsedLongitude).isNotNull();\n+\n+        final List<VariableData> variables = new ArrayList<>();\n+        final CalcState calcState = CoordinatesCalculateUtils.createCalcState(parsedLatitude, parsedLongitude, variables);\n+        assertThat(calcState.plainLat).isEqualTo(\"N 49\u00b0 AB.031'\");\n+        assertThat(calcState.plainLon).isEqualTo(\"E 8\u00b0 38.DEF'\");\n+    }\n+\n+    @Test\n+    public void testParseFullCoordinatesWithFormula() {\n+        final FormulaParser formulaParser = new FormulaParser();\n+        final ImmutablePair<String, String> parsedFullCoordinates = formulaParser.parse(\"(FORMULA-PLAIN) N  AB\u00b0 48.[B+C-A]^2  E (B%C)\u00b0  38.(D+F)*2 | a = 2) test\");\n+        assertThat(parsedFullCoordinates).isNotNull();\n+        final String parsedLatitude = parsedFullCoordinates.left;\n+        final String parsedLongitude = parsedFullCoordinates.right;\n+        assertThat(parsedLatitude).isNotNull();\n+        assertThat(parsedLongitude).isNotNull();\n+\n+        final List<VariableData> variables = new ArrayList<>();\n+        final CalcState calcState = CoordinatesCalculateUtils.createCalcState(parsedLatitude, parsedLongitude, variables);\n+        assertThat(calcState.plainLat).isEqualTo(\"N AB\u00b0 48.[B+C-A]^2'\");\n+        assertThat(calcState.plainLon).isEqualTo(\"E (B%C)\u00b0 38.(D+F)*2'\");\n+    }\n+\n+    @Test\n+    public void testParseFullCoordinatesWithIncompleteFormula() {\n+        final FormulaParser formulaParser = new FormulaParser();\n+        final ImmutablePair<String, String> parsedFullCoordinates = formulaParser.parse(\"(FORMULA-PLAIN) N  AB\u00b0 48.B+C-A^2  E (B%C)\u00b0  38.(D+F)^2 | a = 2) test\");\n+        assertThat(parsedFullCoordinates).isNotNull();\n+        final String parsedLatitude = parsedFullCoordinates.left;\n+        final String parsedLongitude = parsedFullCoordinates.right;\n+        assertThat(parsedLatitude).isNotNull();\n+        assertThat(parsedLongitude).isNotNull();\n+\n+        final List<VariableData> variables = new ArrayList<>();\n+        final CalcState calcState = CoordinatesCalculateUtils.createCalcState(parsedLatitude, parsedLongitude, variables);\n+        assertThat(calcState.plainLat).isEqualTo(\"N AB\u00b0 48.B+C-A^2'\");\n+        assertThat(calcState.plainLon).isEqualTo(\"E (B%C)\u00b0 38.(D+F)^2'\");\n+    }\n+\n+    @Test\n+    public void testParseFullCoordinatesWithNoValidFormula() {\n+        try {\n+            final FormulaParser formulaParser = new FormulaParser();\n+            formulaParser.parse(\"(FORMULA-PLAIN) N  AB\u00b0 48.[B+C-A^2  E (B%C)\u00b0  38!.(D+F)2 | a = 2) test\");\n+            failBecauseExceptionWasNotThrown(FormulaParser.ParseException.class);\n+        } catch (final FormulaParser.ParseException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testParseFullCoordinatesException() {\n+        try {\n+            final FormulaParser formulaParser = new FormulaParser();\n+            formulaParser.parse(\"N 49\u00b0 AB.031 | E 8\u00b0 38.DEF\");\n+            failBecauseExceptionWasNotThrown(FormulaParser.ParseException.class);\n+        } catch (final FormulaParser.ParseException e) {\n+            // expected\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}]}}]}}, {"oid": "4751dd40eeffee2cf381a313443308e52b2e7ff1", "url": "https://github.com/cgeo/cgeo/commit/4751dd40eeffee2cf381a313443308e52b2e7ff1", "message": "incorporate review comments", "committedDate": "2021-01-09T23:47:57Z", "type": "forcePushed"}, {"oid": "66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "url": "https://github.com/cgeo/cgeo/commit/66e0f4a14897b958d9a7bb5f67b5d4e075f6cb1f", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers.", "committedDate": "2021-01-17T22:34:19Z", "type": "forcePushed"}, {"oid": "c6d040552255b39e72ce189c47a941fead596eb4", "url": "https://github.com/cgeo/cgeo/commit/c6d040552255b39e72ce189c47a941fead596eb4", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers.", "committedDate": "2021-01-17T22:58:40Z", "type": "forcePushed"}, {"oid": "82c4d8e14cc013dac69f627891533b18bb2e6f86", "url": "https://github.com/cgeo/cgeo/commit/82c4d8e14cc013dac69f627891533b18bb2e6f86", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers.", "committedDate": "2021-01-17T23:10:56Z", "type": "forcePushed"}, {"oid": "0bcbe1ee454e764b731c2fbb0f8aa1c96248302d", "url": "https://github.com/cgeo/cgeo/commit/0bcbe1ee454e764b731c2fbb0f8aa1c96248302d", "message": "merge with master", "committedDate": "2021-01-17T23:47:07Z", "type": "forcePushed"}, {"oid": "52fab4e01cb4f05fb7293b6be4e7d1972b4130a6", "url": "https://github.com/cgeo/cgeo/commit/52fab4e01cb4f05fb7293b6be4e7d1972b4130a6", "message": "evaluate formula after parsing", "committedDate": "2021-01-26T11:16:51Z", "type": "forcePushed"}, {"oid": "365d08526d66552c6d13481824c59c71ef1d7ece", "url": "https://github.com/cgeo/cgeo/commit/365d08526d66552c6d13481824c59c71ef1d7ece", "message": "evaluate formula after parsing (moving evaluate-methods from CoordinatesCalculateDialog to CalcStateEvaluator)", "committedDate": "2021-01-26T12:12:56Z", "type": "forcePushed"}, {"oid": "f70bd2ae6f7f28b857bc005ee787f438ffa42921", "url": "https://github.com/cgeo/cgeo/commit/f70bd2ae6f7f28b857bc005ee787f438ffa42921", "message": "merge from master", "committedDate": "2021-02-15T01:01:13Z", "type": "forcePushed"}, {"oid": "5847e78465043096aa941fdf6fb1ab3199ae8e19", "url": "https://github.com/cgeo/cgeo/commit/5847e78465043096aa941fdf6fb1ab3199ae8e19", "message": "waypoint with formula is userModified", "committedDate": "2021-03-31T15:26:10Z", "type": "forcePushed"}, {"oid": "743cc64fbd0ba41d94843aebb3929d5a25871608", "url": "https://github.com/cgeo/cgeo/commit/743cc64fbd0ba41d94843aebb3929d5a25871608", "message": "move / split classes to calculator package", "committedDate": "2021-04-15T20:44:17Z", "type": "commit"}, {"oid": "857908a08c9b5652a36600c7c081d46dbdf33803", "url": "https://github.com/cgeo/cgeo/commit/857908a08c9b5652a36600c7c081d46dbdf33803", "message": "move methods to parse waypoint to WaypointParser\nsuppress NPath-complexity warning with remark for \"parseWaypointType\"", "committedDate": "2021-04-15T20:47:09Z", "type": "commit"}, {"oid": "167826d3ae8b30dcdeea3206217079af9b92d9a0", "url": "https://github.com/cgeo/cgeo/commit/167826d3ae8b30dcdeea3206217079af9b92d9a0", "message": "move methods to combine user note to WaypointUserNoteCombiner", "committedDate": "2021-04-15T20:47:11Z", "type": "commit"}, {"oid": "552ffe707ac5f49f517d31b062ad620c6ad499c2", "url": "https://github.com/cgeo/cgeo/commit/552ffe707ac5f49f517d31b062ad620c6ad499c2", "message": "add Formula-Parser to parse coordinates with formula,\nquery valid formula-operators from CalculationUtils", "committedDate": "2021-04-15T20:47:13Z", "type": "commit"}, {"oid": "694006d08fd3c96e34033e9d1a1cf3e7e588f231", "url": "https://github.com/cgeo/cgeo/commit/694006d08fd3c96e34033e9d1a1cf3e7e588f231", "message": "incorporate review comments", "committedDate": "2021-04-15T20:47:14Z", "type": "commit"}, {"oid": "af91323ed99f67b76dc4479a659b5a48bae865a9", "url": "https://github.com/cgeo/cgeo/commit/af91323ed99f67b76dc4479a659b5a48bae865a9", "message": "GeopointParser / GeopointWrapper has different return value (double / string).\nSo I am currently not able to reuse logic, but prepared with siimilar wrappers and parsers.", "committedDate": "2021-04-15T20:47:14Z", "type": "commit"}, {"oid": "b52db28b4adec1c159f70541c5a8f6e356e2db41", "url": "https://github.com/cgeo/cgeo/commit/b52db28b4adec1c159f70541c5a8f6e356e2db41", "message": "merge with master", "committedDate": "2021-04-15T20:47:14Z", "type": "commit"}, {"oid": "d39ad6788a90131633bb01a21efce68305693c10", "url": "https://github.com/cgeo/cgeo/commit/d39ad6788a90131633bb01a21efce68305693c10", "message": "evaluate formula after parsing (moving evaluate-methods from CoordinatesCalculateDialog to CalcStateEvaluator)", "committedDate": "2021-04-15T20:47:15Z", "type": "commit"}, {"oid": "aa5c260276b7f4b0b263ccdd08dbbe547b6c6003", "url": "https://github.com/cgeo/cgeo/commit/aa5c260276b7f4b0b263ccdd08dbbe547b6c6003", "message": "set calcState from parsed text if calcState from existing waypoint is empty", "committedDate": "2021-04-15T20:47:18Z", "type": "commit"}, {"oid": "a7ee0274f0755464b07dc04b1ac5cb0022ed8a88", "url": "https://github.com/cgeo/cgeo/commit/a7ee0274f0755464b07dc04b1ac5cb0022ed8a88", "message": "make formula-string configurable in test", "committedDate": "2021-04-15T20:47:20Z", "type": "commit"}, {"oid": "3b5d5c850fbafb306a351212d5d9a739214ca9e0", "url": "https://github.com/cgeo/cgeo/commit/3b5d5c850fbafb306a351212d5d9a739214ca9e0", "message": "merge from master", "committedDate": "2021-04-15T20:47:20Z", "type": "commit"}, {"oid": "df9f801ead62a0a66becce0b81ccda079d309e3d", "url": "https://github.com/cgeo/cgeo/commit/df9f801ead62a0a66becce0b81ccda079d309e3d", "message": "return variable-name in string, if value can not be evaluated", "committedDate": "2021-04-15T20:47:21Z", "type": "commit"}, {"oid": "aa9ac17ff25e856cd8e710440197dc5af58cf08d", "url": "https://github.com/cgeo/cgeo/commit/aa9ac17ff25e856cd8e710440197dc5af58cf08d", "message": "waypoint with formula is userModified", "committedDate": "2021-04-15T20:47:21Z", "type": "commit"}, {"oid": "79ff3adfccbd43c56f156dd3b096fe32b9759144", "url": "https://github.com/cgeo/cgeo/commit/79ff3adfccbd43c56f156dd3b096fe32b9759144", "message": "convert lower case letter in formula into upper case", "committedDate": "2021-04-15T20:47:22Z", "type": "commit"}, {"oid": "30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "url": "https://github.com/cgeo/cgeo/commit/30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "message": "split function getParseableFormula into formulaString (different for the various formula-types) and variablesString", "committedDate": "2021-04-15T20:47:22Z", "type": "commit"}, {"oid": "30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "url": "https://github.com/cgeo/cgeo/commit/30b5d7cce3f71cd46cce7a3049d4646cecd123ed", "message": "split function getParseableFormula into formulaString (different for the various formula-types) and variablesString", "committedDate": "2021-04-15T20:47:22Z", "type": "forcePushed"}, {"oid": "a9a330f6b98562a60837896bf1ff89634923dcaa", "url": "https://github.com/cgeo/cgeo/commit/a9a330f6b98562a60837896bf1ff89634923dcaa", "message": "resolve conflicts due to rebase to master", "committedDate": "2021-04-15T22:32:44Z", "type": "commit"}, {"oid": "a9a330f6b98562a60837896bf1ff89634923dcaa", "url": "https://github.com/cgeo/cgeo/commit/a9a330f6b98562a60837896bf1ff89634923dcaa", "message": "resolve conflicts due to rebase to master", "committedDate": "2021-04-15T22:32:44Z", "type": "forcePushed"}]}