{"pr_number": 432, "pr_title": "Add spawner module", "pr_author": "EricZeiberg", "pr_createdAt": "2020-04-27T01:47:14Z", "pr_url": "https://github.com/PGMDev/PGM/pull/432", "timeline": [{"oid": "797b8a7b2e9526312a0fc186c68c46ec3a2bf271", "url": "https://github.com/PGMDev/PGM/commit/797b8a7b2e9526312a0fc186c68c46ec3a2bf271", "message": "Initial module structure and parsing\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T03:48:07Z", "type": "commit"}, {"oid": "469dd2d125d7579c5ba9d482e1a313f0a1596adc", "url": "https://github.com/PGMDev/PGM/commit/469dd2d125d7579c5ba9d482e1a313f0a1596adc", "message": "Add object structure\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T04:43:28Z", "type": "commit"}, {"oid": "9e535bc713b2edb995065e744e28f659faea7c5c", "url": "https://github.com/PGMDev/PGM/commit/9e535bc713b2edb995065e744e28f659faea7c5c", "message": "Initial spawning behavior\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T19:30:58Z", "type": "commit"}, {"oid": "7d50ac1a4e9d7bb9819cb17afae8187ae4270bd7", "url": "https://github.com/PGMDev/PGM/commit/7d50ac1a4e9d7bb9819cb17afae8187ae4270bd7", "message": "Merge branch 'master' of https://github.com/Electroid/PGM into spawner-module", "committedDate": "2020-04-26T19:47:15Z", "type": "commit"}, {"oid": "6e110f08e6ab7c3f2522dc6ba7855ac4f8d98fab", "url": "https://github.com/PGMDev/PGM/commit/6e110f08e6ab7c3f2522dc6ba7855ac4f8d98fab", "message": "Finish mob spawning\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T21:01:34Z", "type": "commit"}, {"oid": "0d31d99600a0437047a421cbcfc606643093e644", "url": "https://github.com/PGMDev/PGM/commit/0d31d99600a0437047a421cbcfc606643093e644", "message": "Add TNT and Potions\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T22:20:25Z", "type": "commit"}, {"oid": "20423df11258ba8d6869b5495511111506a98925", "url": "https://github.com/PGMDev/PGM/commit/20423df11258ba8d6869b5495511111506a98925", "message": "Add item object\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T23:18:15Z", "type": "commit"}, {"oid": "c975bf9c4bb2e782659e58fbf34dcbb5b0482972", "url": "https://github.com/PGMDev/PGM/commit/c975bf9c4bb2e782659e58fbf34dcbb5b0482972", "message": "Fix extra stack spawning\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T23:25:20Z", "type": "commit"}, {"oid": "e78c890977a634d9b185a24456b2c40ec3014d68", "url": "https://github.com/PGMDev/PGM/commit/e78c890977a634d9b185a24456b2c40ec3014d68", "message": "Format code\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T23:52:21Z", "type": "commit"}, {"oid": "f0d602128e794468325ada8bef767d5bce0dbb4f", "url": "https://github.com/PGMDev/PGM/commit/f0d602128e794468325ada8bef767d5bce0dbb4f", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:16:43Z", "type": "forcePushed"}, {"oid": "60a68714d335acf085d63a837b51ce467dea497c", "url": "https://github.com/PGMDev/PGM/commit/60a68714d335acf085d63a837b51ce467dea497c", "message": "Add filter support", "committedDate": "2020-04-28T00:14:37Z", "type": "forcePushed"}, {"oid": "3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "url": "https://github.com/PGMDev/PGM/commit/3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "message": "Add filter support\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:26:27Z", "type": "commit"}, {"oid": "3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "url": "https://github.com/PGMDev/PGM/commit/3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "message": "Add filter support\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:26:27Z", "type": "forcePushed"}, {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "url": "https://github.com/PGMDev/PGM/commit/ff23cb29ee991482a9b3789ab7ec9f831223cd59", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:29:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxODEwMw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416918103", "body": "See `Feature` and other examples of it, you'll want `Spawner implements Feature`. ", "bodyText": "See Feature and other examples of it, you'll want Spawner implements Feature.", "bodyHTML": "<p dir=\"auto\">See <code>Feature</code> and other examples of it, you'll want <code>Spawner implements Feature</code>.</p>", "author": "Electroid", "createdAt": "2020-04-28T20:58:39Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxODM3Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416918376", "body": "Is this nessecary, looks unused?", "bodyText": "Is this nessecary, looks unused?", "bodyHTML": "<p dir=\"auto\">Is this nessecary, looks unused?</p>", "author": "Electroid", "createdAt": "2020-04-28T20:59:07Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMzMyMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416923322", "body": "Instead of storing a static variable, just use `Match#getRandom` when you need it.", "bodyText": "Instead of storing a static variable, just use Match#getRandom when you need it.", "bodyHTML": "<p dir=\"auto\">Instead of storing a static variable, just use <code>Match#getRandom</code> when you need it.</p>", "author": "Electroid", "createdAt": "2020-04-28T21:07:51Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDU2Mg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416924562", "body": "We should avoid at all costs having any `Collection` with a hard reference to a `Player` or `MatchPlayer`, it's essentially a trouble maker for memory leaks. Try using `OnlinePlayerMapAdapter` ", "bodyText": "We should avoid at all costs having any Collection with a hard reference to a Player or MatchPlayer, it's essentially a trouble maker for memory leaks. Try using OnlinePlayerMapAdapter", "bodyHTML": "<p dir=\"auto\">We should avoid at all costs having any <code>Collection</code> with a hard reference to a <code>Player</code> or <code>MatchPlayer</code>, it's essentially a trouble maker for memory leaks. Try using <code>OnlinePlayerMapAdapter</code></p>", "author": "Electroid", "createdAt": "2020-04-28T21:10:02Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTI2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416925267", "body": "Is this a filter on the players or the spawner location? If it's players, you'll want to name is `playerFilter`.", "bodyText": "Is this a filter on the players or the spawner location? If it's players, you'll want to name is playerFilter.", "bodyHTML": "<p dir=\"auto\">Is this a filter on the players or the spawner location? If it's players, you'll want to name is <code>playerFilter</code>.</p>", "author": "Electroid", "createdAt": "2020-04-28T21:11:23Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;\n+  public Region playerRegion;\n+  public int maxEntities;\n+  public Duration minDelay, maxDelay, delay;\n+  public List<SpawnerObject> objects;\n+  public Filter filter;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTY2Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416925666", "body": "Be more specific than `count`, what does this mean?", "bodyText": "Be more specific than count, what does this mean?", "bodyHTML": "<p dir=\"auto\">Be more specific than <code>count</code>, what does this mean?</p>", "author": "Electroid", "createdAt": "2020-04-28T21:12:02Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjgwNw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416926807", "body": "Other than augmenting vanilla, what's the use-case for varied delays?", "bodyText": "Other than augmenting vanilla, what's the use-case for varied delays?", "bodyHTML": "<p dir=\"auto\">Other than augmenting vanilla, what's the use-case for varied delays?</p>", "author": "Electroid", "createdAt": "2020-04-28T21:14:01Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;\n+  public Region playerRegion;\n+  public int maxEntities;\n+  public Duration minDelay, maxDelay, delay;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzYzMA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417007630", "bodyText": "The idea was to have the ability to create randomized delays between two values", "author": "EricZeiberg", "createdAt": "2020-04-29T00:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzIzNg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416927236", "body": "This should not be in a `MapModule` class.", "bodyText": "This should not be in a MapModule class.", "bodyHTML": "<p dir=\"auto\">This should not be in a <code>MapModule</code> class.</p>", "author": "Electroid", "createdAt": "2020-04-28T21:14:52Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTgwNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416929804", "body": "Be careful, can't use `static`, since each `MapContext` will have it's own `MapModule`.\r\n\r\nAs of right now, all maps will share the same spawners!", "bodyText": "Be careful, can't use static, since each MapContext will have it's own MapModule.\nAs of right now, all maps will share the same spawners!", "bodyHTML": "<p dir=\"auto\">Be careful, can't use <code>static</code>, since each <code>MapContext</code> will have it's own <code>MapModule</code>.</p>\n<p dir=\"auto\">As of right now, all maps will share the same spawners!</p>", "author": "Electroid", "createdAt": "2020-04-28T21:19:58Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwODQzMA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417008430", "bodyText": "Ooh good catch! I was getting some weird behavior when testing this feature, now I know why.", "author": "EricZeiberg", "createdAt": "2020-04-29T00:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDQyOQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416930429", "body": "`TimeUtils` has helpful methods for comparing durations.", "bodyText": "TimeUtils has helpful methods for comparing durations.", "bodyHTML": "<p dir=\"auto\"><code>TimeUtils</code> has helpful methods for comparing durations.</p>", "author": "Electroid", "createdAt": "2020-04-28T21:21:08Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzOTkxOA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416939918", "body": "One of the more difficult parts of contributing to PGM modules is finding the right balance between features and abstraction. While I think these are all cool features, we don't have the proper abstractions to support them yet.\r\n\r\nWhile PGM has a comprehensive system for parsing items, it does not have an approach for parsing entities (such as tnt, potions, or projectiles). For instance, `<projectiles>` has its own syntax for spawning projectile entities.\r\n\r\nBefore introducing these features, I think we will need to brainstorm a way to create entity \"templates\" similar to how we create item \"templates\" whenever you parse a kit.\r\n\r\nSince that will take a lot of work, I would suggest changing the MVP of this module to just be items.", "bodyText": "One of the more difficult parts of contributing to PGM modules is finding the right balance between features and abstraction. While I think these are all cool features, we don't have the proper abstractions to support them yet.\nWhile PGM has a comprehensive system for parsing items, it does not have an approach for parsing entities (such as tnt, potions, or projectiles). For instance, <projectiles> has its own syntax for spawning projectile entities.\nBefore introducing these features, I think we will need to brainstorm a way to create entity \"templates\" similar to how we create item \"templates\" whenever you parse a kit.\nSince that will take a lot of work, I would suggest changing the MVP of this module to just be items.", "bodyHTML": "<p dir=\"auto\">One of the more difficult parts of contributing to PGM modules is finding the right balance between features and abstraction. While I think these are all cool features, we don't have the proper abstractions to support them yet.</p>\n<p dir=\"auto\">While PGM has a comprehensive system for parsing items, it does not have an approach for parsing entities (such as tnt, potions, or projectiles). For instance, <code>&lt;projectiles&gt;</code> has its own syntax for spawning projectile entities.</p>\n<p dir=\"auto\">Before introducing these features, I think we will need to brainstorm a way to create entity \"templates\" similar to how we create item \"templates\" whenever you parse a kit.</p>\n<p dir=\"auto\">Since that will take a lot of work, I would suggest changing the MVP of this module to just be items.</p>", "author": "Electroid", "createdAt": "2020-04-28T21:38:54Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {\n+          throw new InvalidXMLException(\"Max delay cannot be smaller than min delay\", element);\n+        }\n+\n+        spawnerDefinition.maxEntities =\n+            XMLUtils.parseNumber(\n+                element.getAttribute(\"max-entities\"), Integer.class, Integer.MAX_VALUE);\n+        spawnerDefinition.filter =\n+            filterParser.parseFilterProperty(element, \"filter\", StaticFilter.ALLOW);\n+\n+        List<SpawnerObject> objects = new ArrayList<>();\n+        for (Element object : XMLUtils.getChildren(element, \"entity\", \"item\", \"tnt\", \"effect\")) {\n+          int count;\n+          switch (object.getName()) {\n+            case \"entity\":\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectEntity entity =\n+                  new SpawnerObjectEntity(XMLUtils.parseEntityType(object), count);\n+              objects.add(entity);\n+              break;\n+            case \"tnt\":\n+              Duration fuse = XMLUtils.parseDuration(object.getAttribute(\"fuse\"));\n+              float power = XMLUtils.parseNumber(object.getAttribute(\"power\"), Float.class);\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectTNT tnt =\n+                  new SpawnerObjectTNT(power, (int) TimeUtils.toTicks(fuse), count);\n+              objects.add(tnt);\n+              break;\n+            case \"effect\":\n+              PotionEffect effect = XMLUtils.parsePotionEffect(object);\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectPotion potion = new SpawnerObjectPotion(count, effect);\n+              objects.add(potion);\n+              break;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDY2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940667", "body": "This doesn't seem necessary, because you could just have non-trackable entities return `0` on `spawnCount`", "bodyText": "This doesn't seem necessary, because you could just have non-trackable entities return 0 on spawnCount", "bodyHTML": "<p dir=\"auto\">This doesn't seem necessary, because you could just have non-trackable entities return <code>0</code> on <code>spawnCount</code></p>", "author": "Electroid", "createdAt": "2020-04-28T21:40:20Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {\n+\n+  void spawn(Location location);\n+\n+  /**\n+   * Some objects are tracked and added to the max entities count (Mobs, items) while others\n+   * (ThrownPotions, TNT) are not.\n+   *\n+   * @return whether the object affects the entity count.\n+   */\n+  boolean isTracked();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTMzNg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417009336", "bodyText": "That seems a bit confusing, as the spawnCount getter is expected to return how many of the object was spawned, not if they contribute to the entity cap.", "author": "EricZeiberg", "createdAt": "2020-04-29T00:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDc2NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940765", "body": "`getSpawnCount`", "bodyText": "getSpawnCount", "bodyHTML": "<p dir=\"auto\"><code>getSpawnCount</code></p>", "author": "Electroid", "createdAt": "2020-04-28T21:40:30Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {\n+\n+  void spawn(Location location);\n+\n+  /**\n+   * Some objects are tracked and added to the max entities count (Mobs, items) while others\n+   * (ThrownPotions, TNT) are not.\n+   *\n+   * @return whether the object affects the entity count.\n+   */\n+  boolean isTracked();\n+\n+  int spawnCount();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDk2MQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940961", "body": "`Spawnable`", "bodyText": "Spawnable", "bodyHTML": "<p dir=\"auto\"><code>Spawnable</code></p>", "author": "Electroid", "createdAt": "2020-04-28T21:40:57Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjA3MA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416942070", "body": "I think you'll need to clamp this value so map makers can't spawn 10k entities.", "bodyText": "I think you'll need to clamp this value so map makers can't spawn 10k entities.", "bodyHTML": "<p dir=\"auto\">I think you'll need to clamp this value so map makers can't spawn 10k entities.</p>", "author": "Electroid", "createdAt": "2020-04-28T21:43:11Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {\n+          throw new InvalidXMLException(\"Max delay cannot be smaller than min delay\", element);\n+        }\n+\n+        spawnerDefinition.maxEntities =\n+            XMLUtils.parseNumber(\n+                element.getAttribute(\"max-entities\"), Integer.class, Integer.MAX_VALUE);\n+        spawnerDefinition.filter =\n+            filterParser.parseFilterProperty(element, \"filter\", StaticFilter.ALLOW);\n+\n+        List<SpawnerObject> objects = new ArrayList<>();\n+        for (Element object : XMLUtils.getChildren(element, \"entity\", \"item\", \"tnt\", \"effect\")) {\n+          int count;\n+          switch (object.getName()) {\n+            case \"entity\":\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjMxMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416946312", "body": "Make a helper method for that `if` check.", "bodyText": "Make a helper method for that if check.", "bodyHTML": "<p dir=\"auto\">Make a helper method for that <code>if</code> check.</p>", "author": "Electroid", "createdAt": "2020-04-28T21:52:25Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match, Logger logger) {\n+    this.definition = definition;\n+    this.match = match;\n+    this.logger = logger;\n+\n+    this.lastTick = match.getTick().tick;\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (SpawnerObject object : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(RANDOM);\n+        object.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()));\n+        if (object.isTracked()) {\n+          spawnedEntities = spawnedEntities + object.spawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (RANDOM.nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {\n+      for (Player p : trackedPlayers) {\n+        if (definition.filter.query(match.getPlayer(p).getQuery()).isAllowed()) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+    return false;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (event.getEntity().getMetadata(SpawnerModule.METADATA_KEY, PGM.get()) != null) {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NzM2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416947367", "body": "```suggestion\r\n   if (spawnedEntities  > definition.maxEntities || trackedPlayers.isEmpty()) return false;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {\n          \n          \n            \n               if (spawnedEntities  > definition.maxEntities || trackedPlayers.isEmpty()) return false;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"x x-first x-last\"> </span><span class=\"pl-k\">if</span> (spawnedEntities <span class=\"pl-k x x-first\">&lt;</span><span class=\"x x-last\"> </span>definition<span class=\"pl-k\">.</span>maxEntities <span class=\"pl-k x x-first x-last\">&amp;&amp;</span> trackedPlayers<span class=\"pl-k\">.</span><span class=\"x x-first\">size() </span><span class=\"pl-k x\">!=</span><span class=\"x\"> </span><span class=\"pl-c1 x\">0</span><span class=\"x x-last\">) {</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">if</span> (spawnedEntities <span class=\"x x-first\"> </span><span class=\"pl-k x\">&gt;</span><span class=\"x x-last\"> </span>definition<span class=\"pl-k\">.</span>maxEntities <span class=\"pl-k x x-first x-last\">||</span> trackedPlayers<span class=\"pl-k\">.</span><span class=\"x x-first\">isEmpty()) </span><span class=\"pl-k x\">return</span><span class=\"x\"> </span><span class=\"pl-c1 x\">false</span><span class=\"x x-last\">;</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "Electroid", "createdAt": "2020-04-28T21:54:48Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match, Logger logger) {\n+    this.definition = definition;\n+    this.match = match;\n+    this.logger = logger;\n+\n+    this.lastTick = match.getTick().tick;\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (SpawnerObject object : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(RANDOM);\n+        object.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()));\n+        if (object.isTracked()) {\n+          spawnedEntities = spawnedEntities + object.spawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (RANDOM.nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75d0e3c087261fd7eec035462609ad66caddf167", "url": "https://github.com/PGMDev/PGM/commit/75d0e3c087261fd7eec035462609ad66caddf167", "message": "Make Spawner implement Feature and refactor some stuff\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-29T00:52:21Z", "type": "commit"}, {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "url": "https://github.com/PGMDev/PGM/commit/dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "message": "Add particles and remove non-item spawnables\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-29T19:13:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NDU4MQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417654581", "body": "So typically the best way to sort variables in a class is (at least in this project)\r\n\r\n```java\r\n// static variables\r\n//\r\n// final variables\r\n//\r\n// other variables\r\n\r\nprotected final static String METADATA_KEY = \"spawner\";\r\n\r\nprivate final Match match;\r\nprivate final SpawnerDefinition definition;\r\nprivate final OnlinePlayerMapAdapter<MatchPlayer> players;\r\n\r\nprivate long lastTick;\r\nprivate long currentDelay;\r\nprivate long spawnedEntities;\r\n```", "bodyText": "So typically the best way to sort variables in a class is (at least in this project)\n// static variables\n//\n// final variables\n//\n// other variables\n\nprotected final static String METADATA_KEY = \"spawner\";\n\nprivate final Match match;\nprivate final SpawnerDefinition definition;\nprivate final OnlinePlayerMapAdapter<MatchPlayer> players;\n\nprivate long lastTick;\nprivate long currentDelay;\nprivate long spawnedEntities;", "bodyHTML": "<p dir=\"auto\">So typically the best way to sort variables in a class is (at least in this project)</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// static variables\n//\n// final variables\n//\n// other variables\n\nprotected final static String METADATA_KEY = &quot;spawner&quot;;\n\nprivate final Match match;\nprivate final SpawnerDefinition definition;\nprivate final OnlinePlayerMapAdapter&lt;MatchPlayer&gt; players;\n\nprivate long lastTick;\nprivate long currentDelay;\nprivate long spawnedEntities;\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> static variables</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> final variables</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> other variables</span>\n\n<span class=\"pl-k\">protected</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">String</span> <span class=\"pl-c1\">METADATA_KEY</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>spawner<span class=\"pl-pds\">\"</span></span>;\n\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Match</span> match;\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">SpawnerDefinition</span> definition;\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">OnlinePlayerMapAdapter&lt;<span class=\"pl-smi\">MatchPlayer</span>&gt;</span> players;\n\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">long</span> lastTick;\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">long</span> currentDelay;\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">long</span> spawnedEntities;</pre></div>", "author": "Electroid", "createdAt": "2020-04-29T22:41:00Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NjEwOQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417656109", "body": "Small `if` guards can be collapsed.\r\n\r\n```java\r\nif (!canSpawn()) return;\r\n```\r\n\r\nCould also change this to be:\r\n\r\n```java\r\nif (!canSpawn() || match.getTick().tick - lastTick < generatedDelay) return;\r\n```", "bodyText": "Small if guards can be collapsed.\nif (!canSpawn()) return;\nCould also change this to be:\nif (!canSpawn() || match.getTick().tick - lastTick < generatedDelay) return;", "bodyHTML": "<p dir=\"auto\">Small <code>if</code> guards can be collapsed.</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (!canSpawn()) return;\"><pre><span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>canSpawn()) <span class=\"pl-k\">return</span>;</pre></div>\n<p dir=\"auto\">Could also change this to be:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (!canSpawn() || match.getTick().tick - lastTick &lt; generatedDelay) return;\"><pre><span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>canSpawn() <span class=\"pl-k\">||</span> match<span class=\"pl-k\">.</span>getTick()<span class=\"pl-k\">.</span>tick <span class=\"pl-k\">-</span> lastTick <span class=\"pl-k\">&lt;</span> generatedDelay) <span class=\"pl-k\">return</span>;</pre></div>", "author": "Electroid", "createdAt": "2020-04-29T22:45:09Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTYyNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417659624", "body": "Use `final` whenever you can.", "bodyText": "Use final whenever you can.", "bodyHTML": "<p dir=\"auto\">Use <code>final</code> whenever you can.</p>", "author": "Electroid", "createdAt": "2020-04-29T22:55:17Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTcwNw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417659707", "bodyText": "Also this variable name can just be location", "author": "Electroid", "createdAt": "2020-04-29T22:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDA3NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660075", "body": "Use `player` instead of `p`, 1 letter arguments are usually only okay for `Exception e` in `try/catch` blocks.", "bodyText": "Use player instead of p, 1 letter arguments are usually only okay for Exception e in try/catch blocks.", "bodyHTML": "<p dir=\"auto\">Use <code>player</code> instead of <code>p</code>, 1 letter arguments are usually only okay for <code>Exception e</code> in <code>try/catch</code> blocks.</p>", "author": "Electroid", "createdAt": "2020-04-29T22:56:29Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDE3Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660176", "body": "`isTracked`", "bodyText": "isTracked", "bodyHTML": "<p dir=\"auto\"><code>isTracked</code></p>", "author": "Electroid", "createdAt": "2020-04-29T22:56:45Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDM1NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660355", "body": "`spawnedEntities -= event.getEntity().getItemStack().getAmount()`", "bodyText": "spawnedEntities -= event.getEntity().getItemStack().getAmount()", "bodyHTML": "<p dir=\"auto\"><code>spawnedEntities -= event.getEntity().getItemStack().getAmount()</code></p>", "author": "Electroid", "createdAt": "2020-04-29T22:57:16Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MTYzMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417661632", "body": "```java\r\nfinal MatchPlayer player = match.getParticipant(event.getPlayer());\r\nif (player == null) return;\r\n// ...\r\n```", "bodyText": "final MatchPlayer player = match.getParticipant(event.getPlayer());\nif (player == null) return;\n// ...", "bodyHTML": "<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"final MatchPlayer player = match.getParticipant(event.getPlayer());\nif (player == null) return;\n// ...\"><pre><span class=\"pl-k\">final</span> <span class=\"pl-smi\">MatchPlayer</span> player <span class=\"pl-k\">=</span> match<span class=\"pl-k\">.</span>getParticipant(event<span class=\"pl-k\">.</span>getPlayer());\n<span class=\"pl-k\">if</span> (player <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) <span class=\"pl-k\">return</span>;\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> ...</span></pre></div>", "author": "Electroid", "createdAt": "2020-04-29T23:01:10Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjA0Mg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662042", "body": "```suggestion\r\n    if (definition.playerRegion.contains(event.getPlayer())) {\r\n      trackedPlayers.putIfAbsent(player, match.getPlayer(player));\r\n    } else {\r\n      trackedPlayers.remove(player);\r\n    }\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n          \n          \n            \n                  trackedPlayers.put(player, match.getPlayer(player));\n          \n          \n            \n                } else if (!definition.playerRegion.contains(event.getPlayer())) {\n          \n          \n            \n                  trackedPlayers.remove(player);\n          \n          \n            \n                }\n          \n          \n            \n                if (definition.playerRegion.contains(event.getPlayer())) {\n          \n          \n            \n                  trackedPlayers.putIfAbsent(player, match.getPlayer(player));\n          \n          \n            \n                } else {\n          \n          \n            \n                  trackedPlayers.remove(player);\n          \n          \n            \n                }", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"123\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">if</span> (definition<span class=\"pl-k\">.</span>playerRegion<span class=\"pl-k\">.</span>contains(event<span class=\"pl-k\">.</span>getPlayer())<span class=\"x x-first\"> </span><span class=\"pl-k x\">&amp;&amp;</span><span class=\"x\"> trackedPlayers</span><span class=\"pl-k x\">.</span><span class=\"x\">get(player) </span><span class=\"pl-k x\">==</span><span class=\"x\"> </span><span class=\"pl-c1 x x-last\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"124\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      trackedPlayers<span class=\"pl-k\">.</span><span class=\"x x-first x-last\">put</span>(player, match<span class=\"pl-k\">.</span>getPlayer(player));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"125\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    } <span class=\"pl-k\">else</span> <span class=\"pl-k x x-first\">if</span><span class=\"x\"> (</span><span class=\"pl-k x\">!</span><span class=\"x\">definition</span><span class=\"pl-k x\">.</span><span class=\"x\">playerRegion</span><span class=\"pl-k x\">.</span><span class=\"x\">contains(event</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getPlayer())) </span>{</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"126\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      trackedPlayers<span class=\"pl-k\">.</span>remove(player);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"127\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"123\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">if</span> (definition<span class=\"pl-k\">.</span>playerRegion<span class=\"pl-k\">.</span>contains(event<span class=\"pl-k\">.</span>getPlayer())) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"124\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      trackedPlayers<span class=\"pl-k\">.</span><span class=\"x x-first x-last\">putIfAbsent</span>(player, match<span class=\"pl-k\">.</span>getPlayer(player));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"125\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"126\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      trackedPlayers<span class=\"pl-k\">.</span>remove(player);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"127\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "Electroid", "createdAt": "2020-04-29T23:02:26Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }\n+    if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n+      trackedPlayers.put(player, match.getPlayer(player));\n+    } else if (!definition.playerRegion.contains(event.getPlayer())) {\n+      trackedPlayers.remove(player);\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjI1NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662255", "body": "Since you're using `OnlinePlayerMapAdapter` players are automatically removed on quit, so you can remove this.", "bodyText": "Since you're using OnlinePlayerMapAdapter players are automatically removed on quit, so you can remove this.", "bodyHTML": "<p dir=\"auto\">Since you're using <code>OnlinePlayerMapAdapter</code> players are automatically removed on quit, so you can remove this.</p>", "author": "Electroid", "createdAt": "2020-04-29T23:03:08Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }\n+    if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n+      trackedPlayers.put(player, match.getPlayer(player));\n+    } else if (!definition.playerRegion.contains(event.getPlayer())) {\n+      trackedPlayers.remove(player);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerQuit(PlayerQuitEvent event) {\n+    trackedPlayers.remove(event.getPlayer());\n+  }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjkxMA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662910", "body": "You'll want to clear this when the match ends. `MatchFinishEvent`", "bodyText": "You'll want to clear this when the match ends. MatchFinishEvent", "bodyHTML": "<p dir=\"auto\">You'll want to clear this when the match ends. <code>MatchFinishEvent</code></p>", "author": "Electroid", "createdAt": "2020-04-29T23:05:03Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2Mzc1Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417663756", "body": "I'd make a constructor for this and use it. Make all these variables final.", "bodyText": "I'd make a constructor for this and use it. Make all these variables final.", "bodyHTML": "<p dir=\"auto\">I'd make a constructor for this and use it. Make all these variables final.</p>", "author": "Electroid", "createdAt": "2020-04-29T23:07:39Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.feature.FeatureDefinition;\n+import tc.oc.pgm.api.feature.FeatureInfo;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+@FeatureInfo(name = \"spawner\")\n+public class SpawnerDefinition implements FeatureDefinition {", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTIzNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665234", "body": "`final`", "bodyText": "final", "bodyHTML": "<p dir=\"auto\"><code>final</code></p>", "author": "Electroid", "createdAt": "2020-04-29T23:11:57Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerMatchModule.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.List;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+\n+public class SpawnerMatchModule implements MatchModule {\n+\n+  private Match match;\n+  private List<SpawnerDefinition> definitions;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTYwMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665602", "body": "Make this a private static final, change to `spawner-item`", "bodyText": "Make this a private static final, change to spawner-item", "bodyHTML": "<p dir=\"auto\">Make this a private static final, change to <code>spawner-item</code></p>", "author": "Electroid", "createdAt": "2020-04-29T23:13:04Z", "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;\n+  private String metadataValue = \"Spawner Item\";", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTc2NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665765", "body": "Can't you set the count in `ItemStack#setAmount` ? And not need to store count?", "bodyText": "Can't you set the count in ItemStack#setAmount ? And not need to store count?", "bodyHTML": "<p dir=\"auto\">Can't you set the count in <code>ItemStack#setAmount</code> ? And not need to store count?</p>", "author": "Electroid", "createdAt": "2020-04-29T23:13:30Z", "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NjA5NA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417666094", "body": "Don't use `NMSHacks` it will soon be totally gone. For that API you can use `World#spigot#playParticle` (I think that's what it is)", "bodyText": "Don't use NMSHacks it will soon be totally gone. For that API you can use World#spigot#playParticle (I think that's what it is)", "bodyHTML": "<p dir=\"auto\">Don't use <code>NMSHacks</code> it will soon be totally gone. For that API you can use <code>World#spigot#playParticle</code> (I think that's what it is)</p>", "author": "Electroid", "createdAt": "2020-04-29T23:14:26Z", "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;\n+  private String metadataValue = \"Spawner Item\";\n+\n+  public SpawnableItem(ItemStack stack) {\n+    this.count = stack.getAmount();\n+    this.stack = stack;\n+  }\n+\n+  @Override\n+  public void spawn(Location location, Match match) {\n+    Item item = location.getWorld().dropItem(location.add(0, 1, 0), stack);\n+    item.setMetadata(Spawner.METADATA_KEY, new FixedMetadataValue(PGM.get(), metadataValue));\n+\n+    Object particle =\n+        NMSHacks.particlesPacket(\n+            \"FLAME\", true, location.toVector(), new Vector(0.15, 0.15, 0.15), 0, 40);\n+    for (MatchPlayer player : match.getPlayers()) {\n+      NMSHacks.sendPacket(player.getBukkit(), particle);\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDc1Mg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418500752", "body": "Can be one line\r\n`if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) return false;`", "bodyText": "Can be one line\nif (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) return false;", "bodyHTML": "<p dir=\"auto\">Can be one line<br>\n<code>if (spawnedEntities &gt;= definition.maxEntities || trackedPlayers.isEmpty()) return false;</code></p>", "author": "KingOfSquares", "createdAt": "2020-05-01T11:02:58Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDg0OQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418500849", "body": "Can also be one line:\r\n`if (definition.playerFilter.query(p.getQuery()).isAllowed()) return true;`", "bodyText": "Can also be one line:\nif (definition.playerFilter.query(p.getQuery()).isAllowed()) return true;", "bodyHTML": "<p dir=\"auto\">Can also be one line:<br>\n<code>if (definition.playerFilter.query(p.getQuery()).isAllowed()) return true;</code></p>", "author": "KingOfSquares", "createdAt": "2020-05-01T11:03:30Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTA2MA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501060", "body": "`final long`", "bodyText": "final long", "bodyHTML": "<p dir=\"auto\"><code>final long</code></p>", "author": "KingOfSquares", "createdAt": "2020-05-01T11:04:19Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTQzMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501432", "body": "`if (isTrackedEntity(event.getEntity())) spawnedEntities--;`", "bodyText": "if (isTrackedEntity(event.getEntity())) spawnedEntities--;", "bodyHTML": "<p dir=\"auto\"><code>if (isTrackedEntity(event.getEntity())) spawnedEntities--;</code></p>", "author": "KingOfSquares", "createdAt": "2020-05-01T11:05:42Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTcyNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501724", "body": "`if (match.getPlayer(player).isObserving()) return;`", "bodyText": "if (match.getPlayer(player).isObserving()) return;", "bodyHTML": "<p dir=\"auto\"><code>if (match.getPlayer(player).isObserving()) return;</code></p>", "author": "KingOfSquares", "createdAt": "2020-05-01T11:06:34Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8943829d855b3a2b65dad079e1b2ff69e64814af", "url": "https://github.com/PGMDev/PGM/commit/8943829d855b3a2b65dad079e1b2ff69e64814af", "message": "Merge branch 'master' into spawner-module", "committedDate": "2020-05-01T23:43:52Z", "type": "commit"}, {"oid": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "url": "https://github.com/PGMDev/PGM/commit/4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "message": "More code style changes, use #playEffect\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-05-02T00:30:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzUxNQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973515", "body": "Since you do `toLocation` twice below. Just have `location` be a `Location`.", "bodyText": "Since you do toLocation twice below. Just have location be a Location.", "bodyHTML": "<p dir=\"auto\">Since you do <code>toLocation</code> twice below. Just have <code>location</code> be a <code>Location</code>.</p>", "author": "Electroid", "createdAt": "2020-05-02T15:44:56Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());", "originalCommit": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzU2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973567", "body": "I think this should be handled in `generateDelay`. Maybe rename the method `calculateDelay`", "bodyText": "I think this should be handled in generateDelay. Maybe rename the method calculateDelay", "bodyHTML": "<p dir=\"auto\">I think this should be handled in <code>generateDelay</code>. Maybe rename the method <code>calculateDelay</code></p>", "author": "Electroid", "createdAt": "2020-05-02T15:45:36Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(location.toLocation(match.getWorld()), match);\n+        match\n+            .getWorld()\n+            .spigot()\n+            .playEffect(\n+                location.toLocation(match.getWorld()), Effect.FLAME, 0, 0, 0, 0.15f, 0, 0, 40, 64);\n+\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;", "originalCommit": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzYwNQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973605", "body": "```suggestion\r\n      spawnedEntities -= event.getItem().getItemStack().getAmount();\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n          \n          \n            \n                  spawnedEntities -= event.getItem().getItemStack().getAmount();", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      spawnedEntities <span class=\"pl-k x x-first\">=</span><span class=\"x\"> spawnedEntities </span><span class=\"pl-k x x-last\">-</span> event<span class=\"pl-k\">.</span>getItem()<span class=\"pl-k\">.</span>getItemStack()<span class=\"pl-k\">.</span>getAmount();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      spawnedEntities <span class=\"pl-k x x-first x-last\">-=</span> event<span class=\"pl-k\">.</span>getItem()<span class=\"pl-k\">.</span>getItemStack()<span class=\"pl-k\">.</span>getAmount();</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "Electroid", "createdAt": "2020-05-02T15:45:58Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(location.toLocation(match.getWorld()), match);\n+        match\n+            .getWorld()\n+            .spigot()\n+            .playEffect(\n+                location.toLocation(match.getWorld()), Effect.FLAME, 0, 0, 0, 0.15f, 0, 0, 40, 64);\n+\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      currentDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      currentDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || players.isEmpty()) return false;\n+    for (MatchPlayer player : players.values()) {\n+      if (definition.playerFilter.query(player.getQuery()).isAllowed()) return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTracked(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTracked(event.getEntity())) spawnedEntities--;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTracked(event.getEntity()))\n+      spawnedEntities -= event.getEntity().getItemStack().getAmount();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTracked(event.getItem()))\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();", "originalCommit": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24760b150d33fef1d757cc8a398f4169d4d19f68", "url": "https://github.com/PGMDev/PGM/commit/24760b150d33fef1d757cc8a398f4169d4d19f68", "message": "Merge branch 'master' into spawner-module", "committedDate": "2020-05-02T15:48:24Z", "type": "commit"}, {"oid": "5c3b1f945cf605802246f444a9e74b8a59b781ab", "url": "https://github.com/PGMDev/PGM/commit/5c3b1f945cf605802246f444a9e74b8a59b781ab", "message": "More small code style changes\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-05-02T15:54:27Z", "type": "commit"}, {"oid": "0ccb62b0842a7c131b6cc352232116f0f0616f28", "url": "https://github.com/PGMDev/PGM/commit/0ccb62b0842a7c131b6cc352232116f0f0616f28", "message": "Merge branch 'spawner-module' of https://github.com/EricZeiberg/PGM into spawner-module", "committedDate": "2020-05-02T15:54:44Z", "type": "commit"}]}