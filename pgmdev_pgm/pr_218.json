{"pr_number": 218, "pr_title": "Map, MapModule, and MatchModule refactors", "pr_author": "Electroid", "pr_createdAt": "2020-01-10T17:44:40Z", "pr_url": "https://github.com/PGMDev/PGM/pull/218", "timeline": [{"oid": "4fd9be07ae445ef7d73d0e0b5a66f3de7ed4e8c4", "url": "https://github.com/PGMDev/PGM/commit/4fd9be07ae445ef7d73d0e0b5a66f3de7ed4e8c4", "message": "WIP: Remove various debug statements\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-20T05:16:33Z", "type": "forcePushed"}, {"oid": "6bf2ebfbf1a364e1148883316ad1fe097182b5e6", "url": "https://github.com/PGMDev/PGM/commit/6bf2ebfbf1a364e1148883316ad1fe097182b5e6", "message": "WIP: End of WIP\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-23T08:23:17Z", "type": "forcePushed"}, {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "url": "https://github.com/PGMDev/PGM/commit/88e7cfe63ec24b171c800f60f5aecff4f7faee60", "message": "Fix various CME/NPE exceptions\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-23T09:01:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912144", "body": "Why is this an int instead of `Difficulty`?", "bodyText": "Why is this an int instead of Difficulty?", "bodyHTML": "<p dir=\"auto\">Why is this an int instead of <code>Difficulty</code>?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T03:59:56Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA0NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944045", "bodyText": "Moving away from having Bukkit literals in the api.", "author": "Electroid", "createdAt": "2020-01-25T17:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjE5OQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946199", "bodyText": "why?", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 656c205f..7fd2eb84 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -55,59 +72,50 @@ public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n   Collection<Contributor> getAuthors();\n \n   /**\n-   * Get all {@link Contributor}s that helped contribute to the map.\n+   * Get the {@link Contributor}s that helped contribute to the map.\n    *\n    * @return The contributors.\n    */\n   Collection<Contributor> getContributors();\n \n   /**\n-   * Get any special rules that players must follow for the map.\n+   * Get any special rules that participants must follow for the map.\n    *\n-   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   * <p>As a rule of thumb, try to keep extra rules to a minimum. From experience, it is often\n+   * difficult to enforce these rules.\n    *\n-   * @return A collection of rules.\n+   * @return A collection of human-readable rules.\n    */\n   Collection<String> getRules();\n \n   /**\n-   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   * Get the {@link Difficulty} level that should be set for the map.\n    *\n-   * @return The difficulty level.\n-   */\n-  int getDifficulty();\n-\n-  /**\n-   * Get a collection of \"hash tags\" used to describe the map.\n+   * <p>If not set, should default to the {@link org.bukkit.World#getDifficulty()} of the first\n+   * loaded world on the server.\n    *\n-   * @return A collection of tags.\n+   * @return The difficulty, or {@code null} for auto-detect.\n    */\n-  Collection<MapTag> getTags();\n+  @Nullable\n+  Difficulty getDifficulty();\n \n   /**\n    * Get the maximum number of players that can participate on each team.\n    *\n-   * @return Maximum number of players on each team.\n+   * <p>For free-for-all matches, this should be left empty.\n+   *\n+   * <p>Sum of all the limits should equal {@link #getPlayerLimit()}.\n+   *\n+   * @return Maximum number of participants on each team.\n    */\n-  Collection<Integer> getMaxPlayers();\n+  Collection<Integer> getTeamLimits();\n \n   /**\n-   * Create an immutable copy of this info.\n+   * Get the maximum number of players that can participate in the map.\n    *\n-   * @return A cloned {@link MapInfo}.\n+   * <p>Should be capped at {@link org.bukkit.Bukkit#getMaxPlayers()}.\n+   *\n+   * @return Maximum number of participants.\n    */\n-  MapInfo clone();\n-\n-  @Override\n-  default int compareTo(MapInfo o) {\n-    return getId().compareTo(o.getId());\n-  }\n-\n-  static String normalizeName(@Nullable String idOrName) {\n-    return idOrName == null\n-        ? \"\"\n-        : Normalizer.normalize(idOrName, Normalizer.Form.NFD)\n-            .replaceAll(\"[^A-Za-z0-9]\", \"\")\n-            .toLowerCase();\n-  }\n+  int getPlayerLimit();\n }\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 7fd2eb84..87c65687 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -96,26 +86,5 @@ public interface MapInfo extends Comparable<MapInfo> {\n    *\n    * @return The difficulty, or {@code null} for auto-detect.\n    */\n-  @Nullable\n   Difficulty getDifficulty();\n-\n-  /**\n-   * Get the maximum number of players that can participate on each team.\n-   *\n-   * <p>For free-for-all matches, this should be left empty.\n-   *\n-   * <p>Sum of all the limits should equal {@link #getPlayerLimit()}.\n-   *\n-   * @return Maximum number of participants on each team.\n-   */\n-  Collection<Integer> getTeamLimits();\n-\n-  /**\n-   * Get the maximum number of players that can participate in the map.\n-   *\n-   * <p>Should be capped at {@link org.bukkit.Bukkit#getMaxPlayers()}.\n-   *\n-   * @return Maximum number of participants.\n-   */\n-  int getPlayerLimit();\n }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 87c65687..a4e9633b 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -87,4 +78,9 @@ public interface MapInfo {\n    * @return The difficulty, or {@code null} for auto-detect.\n    */\n   Difficulty getDifficulty();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n }\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex a4e9633b..d1dd7972 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -53,34 +54,63 @@ public interface MapInfo extends Comparable<MapInfo> {\n   Collection<Contributor> getAuthors();\n \n   /**\n-   * Get the {@link Contributor}s that helped contribute to the map.\n+   * Get all {@link Contributor}s that helped contribute to the map.\n    *\n    * @return The contributors.\n    */\n   Collection<Contributor> getContributors();\n \n   /**\n-   * Get any special rules that participants must follow for the map.\n+   * Get any special rules that players must follow for the map.\n    *\n-   * <p>As a rule of thumb, try to keep extra rules to a minimum. From experience, it is often\n-   * difficult to enforce these rules.\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n    *\n-   * @return A collection of human-readable rules.\n+   * @return A collection of rules.\n    */\n   Collection<String> getRules();\n \n   /**\n-   * Get the {@link Difficulty} level that should be set for the map.\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get the genre or \"game mode\" for the map.\n+   *\n+   * <p>Used to override the default sidebar title.\n+   *\n+   * @return The genre.\n+   */\n+  String getGenre();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.\n    *\n-   * <p>If not set, should default to the {@link org.bukkit.World#getDifficulty()} of the first\n-   * loaded world on the server.\n+   * @return A collection of tags.\n+   */\n+  Collection<String> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n    *\n-   * @return The difficulty, or {@code null} for auto-detect.\n+   * @return Maximum number of players on each team.\n    */\n-  Difficulty getDifficulty();\n+  Collection<Integer> getMaxPlayers();\n+\n+  MapInfo clone();\n \n   @Override\n   default int compareTo(MapInfo o) {\n     return getId().compareTo(o.getId());\n   }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"\n+        : Normalizer.normalize(idOrName, Normalizer.Form.NFD)\n+            .replaceAll(\"[^A-Za-z0-9]\", \"\")\n+            .toLowerCase();\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjIwMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912200", "body": "What about a BaseComponent?", "bodyText": "What about a BaseComponent?", "bodyHTML": "<p dir=\"auto\">What about a BaseComponent?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:01:30Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA4NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944084", "bodyText": "Components are rendering level stuff, this interface is just descriptive.", "author": "Electroid", "createdAt": "2020-01-25T17:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 656c205f..7fd2eb84 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -1,52 +1,69 @@\n package tc.oc.pgm.api.map;\n \n-import java.text.Normalizer;\n import java.util.Collection;\n import javax.annotation.Nullable;\n-import tc.oc.named.Named;\n-import tc.oc.util.Version;\n-\n-/** Essential information about a map. */\n-public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+import org.bukkit.Difficulty;\n+import tc.oc.util.SemanticVersion;\n+\n+/**\n+ * Essential information about a map.\n+ *\n+ * <p>Unlike {@link MapContext} that should be garbage-collected after match load, {@link MapInfo}\n+ * should stay in-memory after loading so players can easily list or search for maps they wish to\n+ * play.\n+ */\n+public interface MapInfo extends Comparable<MapInfo> {\n \n   /**\n-   * Get a unique id for the map.\n+   * Get the unique id of the map.\n+   *\n+   * <p>When another {@link MapInfo} shares the same id, only the most recent {@link #getVersion()}\n+   * should be shown.\n    *\n    * @return A unique id.\n    */\n   String getId();\n \n   /**\n-   * Get the proto of the map's {@link org.jdom2.Document}.\n+   * Get the proto of the map {@link org.jdom2.Document}.\n    *\n-   * @see MapProtos\n    * @return The proto.\n    */\n-  Version getProto();\n+  SemanticVersion getProto();\n \n   /**\n    * Get the version of the map.\n    *\n    * @return The version.\n    */\n-  Version getVersion();\n+  SemanticVersion getVersion();\n \n   /**\n-   * Get a unique, human-readable name for the map.\n+   * Get a unique, human-readable name of the map.\n    *\n    * @return A name, alphanumeric with spaces are allowed.\n    */\n   String getName();\n \n   /**\n-   * Get a short, human-readable description of the map's objective.\n+   * Get the genre of \"game mode\" of the map.\n+   *\n+   * <p>Used to override the default sidebar title.\n+   *\n+   * @return The genre, or {@code null} to auto-detect.\n+   */\n+  @Nullable\n+  String getGenre();\n+\n+  /**\n+   * Get a short human-readable description of the map's objective.\n    *\n    * @return A description.\n    */\n   String getDescription();\n \n   /**\n-   * Get all {@link Contributor}s that contributed significantly to the map.\n+   * Get the {@link Contributor}s that contributed significantly to the map.\n    *\n    * <p>There must be at least 1 author.\n    *\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 7fd2eb84..d1dd7972 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -1,69 +1,51 @@\n package tc.oc.pgm.api.map;\n \n+import java.text.Normalizer;\n import java.util.Collection;\n import javax.annotation.Nullable;\n-import org.bukkit.Difficulty;\n-import tc.oc.util.SemanticVersion;\n-\n-/**\n- * Essential information about a map.\n- *\n- * <p>Unlike {@link MapContext} that should be garbage-collected after match load, {@link MapInfo}\n- * should stay in-memory after loading so players can easily list or search for maps they wish to\n- * play.\n- */\n-public interface MapInfo extends Comparable<MapInfo> {\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Comparable<MapInfo>, Cloneable {\n \n   /**\n-   * Get the unique id of the map.\n-   *\n-   * <p>When another {@link MapInfo} shares the same id, only the most recent {@link #getVersion()}\n-   * should be shown.\n+   * Get a unique id for the map.\n    *\n    * @return A unique id.\n    */\n   String getId();\n \n   /**\n-   * Get the proto of the map {@link org.jdom2.Document}.\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n    *\n+   * @see MapProtos\n    * @return The proto.\n    */\n-  SemanticVersion getProto();\n+  Version getProto();\n \n   /**\n    * Get the version of the map.\n    *\n    * @return The version.\n    */\n-  SemanticVersion getVersion();\n+  Version getVersion();\n \n   /**\n-   * Get a unique, human-readable name of the map.\n+   * Get a unique, human-readable name for the map.\n    *\n    * @return A name, alphanumeric with spaces are allowed.\n    */\n   String getName();\n \n   /**\n-   * Get the genre of \"game mode\" of the map.\n-   *\n-   * <p>Used to override the default sidebar title.\n-   *\n-   * @return The genre, or {@code null} to auto-detect.\n-   */\n-  @Nullable\n-  String getGenre();\n-\n-  /**\n-   * Get a short human-readable description of the map's objective.\n+   * Get a short, human-readable description of the map's objective.\n    *\n    * @return A description.\n    */\n   String getDescription();\n \n   /**\n-   * Get the {@link Contributor}s that contributed significantly to the map.\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n    *\n    * <p>There must be at least 1 author.\n    *\n", "next_change": null}, {"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 7fd2eb84..d1dd7972 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -72,50 +54,63 @@ public interface MapInfo extends Comparable<MapInfo> {\n   Collection<Contributor> getAuthors();\n \n   /**\n-   * Get the {@link Contributor}s that helped contribute to the map.\n+   * Get all {@link Contributor}s that helped contribute to the map.\n    *\n    * @return The contributors.\n    */\n   Collection<Contributor> getContributors();\n \n   /**\n-   * Get any special rules that participants must follow for the map.\n+   * Get any special rules that players must follow for the map.\n    *\n-   * <p>As a rule of thumb, try to keep extra rules to a minimum. From experience, it is often\n-   * difficult to enforce these rules.\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n    *\n-   * @return A collection of human-readable rules.\n+   * @return A collection of rules.\n    */\n   Collection<String> getRules();\n \n   /**\n-   * Get the {@link Difficulty} level that should be set for the map.\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n    *\n-   * <p>If not set, should default to the {@link org.bukkit.World#getDifficulty()} of the first\n-   * loaded world on the server.\n-   *\n-   * @return The difficulty, or {@code null} for auto-detect.\n+   * @return The difficulty level.\n    */\n-  @Nullable\n-  Difficulty getDifficulty();\n+  int getDifficulty();\n \n   /**\n-   * Get the maximum number of players that can participate on each team.\n+   * Get the genre or \"game mode\" for the map.\n    *\n-   * <p>For free-for-all matches, this should be left empty.\n-   *\n-   * <p>Sum of all the limits should equal {@link #getPlayerLimit()}.\n+   * <p>Used to override the default sidebar title.\n    *\n-   * @return Maximum number of participants on each team.\n+   * @return The genre.\n    */\n-  Collection<Integer> getTeamLimits();\n+  String getGenre();\n \n   /**\n-   * Get the maximum number of players that can participate in the map.\n+   * Get a collection of \"hash tags\" used to describe the map.\n    *\n-   * <p>Should be capped at {@link org.bukkit.Bukkit#getMaxPlayers()}.\n+   * @return A collection of tags.\n+   */\n+  Collection<String> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n    *\n-   * @return Maximum number of participants.\n+   * @return Maximum number of players on each team.\n    */\n-  int getPlayerLimit();\n+  Collection<Integer> getMaxPlayers();\n+\n+  MapInfo clone();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"\n+        : Normalizer.normalize(idOrName, Normalizer.Form.NFD)\n+            .replaceAll(\"[^A-Za-z0-9]\", \"\")\n+            .toLowerCase();\n+  }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjI3Nw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912277", "body": "The documentation should say if these are all maptags (with automatic maptags) or just XML defined.", "bodyText": "The documentation should say if these are all maptags (with automatic maptags) or just XML defined.", "bodyHTML": "<p dir=\"auto\">The documentation should say if these are all maptags (with automatic maptags) or just XML defined.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:03:25Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 656c205f..7fd2eb84 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -55,59 +72,50 @@ public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n   Collection<Contributor> getAuthors();\n \n   /**\n-   * Get all {@link Contributor}s that helped contribute to the map.\n+   * Get the {@link Contributor}s that helped contribute to the map.\n    *\n    * @return The contributors.\n    */\n   Collection<Contributor> getContributors();\n \n   /**\n-   * Get any special rules that players must follow for the map.\n+   * Get any special rules that participants must follow for the map.\n    *\n-   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   * <p>As a rule of thumb, try to keep extra rules to a minimum. From experience, it is often\n+   * difficult to enforce these rules.\n    *\n-   * @return A collection of rules.\n+   * @return A collection of human-readable rules.\n    */\n   Collection<String> getRules();\n \n   /**\n-   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   * Get the {@link Difficulty} level that should be set for the map.\n    *\n-   * @return The difficulty level.\n-   */\n-  int getDifficulty();\n-\n-  /**\n-   * Get a collection of \"hash tags\" used to describe the map.\n+   * <p>If not set, should default to the {@link org.bukkit.World#getDifficulty()} of the first\n+   * loaded world on the server.\n    *\n-   * @return A collection of tags.\n+   * @return The difficulty, or {@code null} for auto-detect.\n    */\n-  Collection<MapTag> getTags();\n+  @Nullable\n+  Difficulty getDifficulty();\n \n   /**\n    * Get the maximum number of players that can participate on each team.\n    *\n-   * @return Maximum number of players on each team.\n+   * <p>For free-for-all matches, this should be left empty.\n+   *\n+   * <p>Sum of all the limits should equal {@link #getPlayerLimit()}.\n+   *\n+   * @return Maximum number of participants on each team.\n    */\n-  Collection<Integer> getMaxPlayers();\n+  Collection<Integer> getTeamLimits();\n \n   /**\n-   * Create an immutable copy of this info.\n+   * Get the maximum number of players that can participate in the map.\n    *\n-   * @return A cloned {@link MapInfo}.\n+   * <p>Should be capped at {@link org.bukkit.Bukkit#getMaxPlayers()}.\n+   *\n+   * @return Maximum number of participants.\n    */\n-  MapInfo clone();\n-\n-  @Override\n-  default int compareTo(MapInfo o) {\n-    return getId().compareTo(o.getId());\n-  }\n-\n-  static String normalizeName(@Nullable String idOrName) {\n-    return idOrName == null\n-        ? \"\"\n-        : Normalizer.normalize(idOrName, Normalizer.Form.NFD)\n-            .replaceAll(\"[^A-Za-z0-9]\", \"\")\n-            .toLowerCase();\n-  }\n+  int getPlayerLimit();\n }\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 7fd2eb84..87c65687 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -96,26 +86,5 @@ public interface MapInfo extends Comparable<MapInfo> {\n    *\n    * @return The difficulty, or {@code null} for auto-detect.\n    */\n-  @Nullable\n   Difficulty getDifficulty();\n-\n-  /**\n-   * Get the maximum number of players that can participate on each team.\n-   *\n-   * <p>For free-for-all matches, this should be left empty.\n-   *\n-   * <p>Sum of all the limits should equal {@link #getPlayerLimit()}.\n-   *\n-   * @return Maximum number of participants on each team.\n-   */\n-  Collection<Integer> getTeamLimits();\n-\n-  /**\n-   * Get the maximum number of players that can participate in the map.\n-   *\n-   * <p>Should be capped at {@link org.bukkit.Bukkit#getMaxPlayers()}.\n-   *\n-   * @return Maximum number of participants.\n-   */\n-  int getPlayerLimit();\n }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 87c65687..a4e9633b 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -87,4 +78,9 @@ public interface MapInfo {\n    * @return The difficulty, or {@code null} for auto-detect.\n    */\n   Difficulty getDifficulty();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n }\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex a4e9633b..d1dd7972 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -53,34 +54,63 @@ public interface MapInfo extends Comparable<MapInfo> {\n   Collection<Contributor> getAuthors();\n \n   /**\n-   * Get the {@link Contributor}s that helped contribute to the map.\n+   * Get all {@link Contributor}s that helped contribute to the map.\n    *\n    * @return The contributors.\n    */\n   Collection<Contributor> getContributors();\n \n   /**\n-   * Get any special rules that participants must follow for the map.\n+   * Get any special rules that players must follow for the map.\n    *\n-   * <p>As a rule of thumb, try to keep extra rules to a minimum. From experience, it is often\n-   * difficult to enforce these rules.\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n    *\n-   * @return A collection of human-readable rules.\n+   * @return A collection of rules.\n    */\n   Collection<String> getRules();\n \n   /**\n-   * Get the {@link Difficulty} level that should be set for the map.\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get the genre or \"game mode\" for the map.\n+   *\n+   * <p>Used to override the default sidebar title.\n+   *\n+   * @return The genre.\n+   */\n+  String getGenre();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.\n    *\n-   * <p>If not set, should default to the {@link org.bukkit.World#getDifficulty()} of the first\n-   * loaded world on the server.\n+   * @return A collection of tags.\n+   */\n+  Collection<String> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n    *\n-   * @return The difficulty, or {@code null} for auto-detect.\n+   * @return Maximum number of players on each team.\n    */\n-  Difficulty getDifficulty();\n+  Collection<Integer> getMaxPlayers();\n+\n+  MapInfo clone();\n \n   @Override\n   default int compareTo(MapInfo o) {\n     return getId().compareTo(o.getId());\n   }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"\n+        : Normalizer.normalize(idOrName, Normalizer.Form.NFD)\n+            .replaceAll(\"[^A-Za-z0-9]\", \"\")\n+            .toLowerCase();\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjMzMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912330", "body": "If it's null why should throw NPE to find bugs easier.", "bodyText": "If it's null why should throw NPE to find bugs easier.", "bodyHTML": "<p dir=\"auto\">If it's null why should throw NPE to find bugs easier.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:04:54Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.\n+   *\n+   * @return A collection of tags.\n+   */\n+  Collection<MapTag> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n+   *\n+   * @return Maximum number of players on each team.\n+   */\n+  Collection<Integer> getMaxPlayers();\n+\n+  /**\n+   * Create an immutable copy of this info.\n+   *\n+   * @return A cloned {@link MapInfo}.\n+   */\n+  MapInfo clone();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkzMTAzMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370931030", "bodyText": "Since it's @Nullable, i assume if you use the /map without map argument it will get thru this and then if the result is an empty string will get replaced with the current map.", "author": "Pablete1234", "createdAt": "2020-01-25T12:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 656c205f..7fd2eb84 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -55,59 +72,50 @@ public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n   Collection<Contributor> getAuthors();\n \n   /**\n-   * Get all {@link Contributor}s that helped contribute to the map.\n+   * Get the {@link Contributor}s that helped contribute to the map.\n    *\n    * @return The contributors.\n    */\n   Collection<Contributor> getContributors();\n \n   /**\n-   * Get any special rules that players must follow for the map.\n+   * Get any special rules that participants must follow for the map.\n    *\n-   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   * <p>As a rule of thumb, try to keep extra rules to a minimum. From experience, it is often\n+   * difficult to enforce these rules.\n    *\n-   * @return A collection of rules.\n+   * @return A collection of human-readable rules.\n    */\n   Collection<String> getRules();\n \n   /**\n-   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   * Get the {@link Difficulty} level that should be set for the map.\n    *\n-   * @return The difficulty level.\n-   */\n-  int getDifficulty();\n-\n-  /**\n-   * Get a collection of \"hash tags\" used to describe the map.\n+   * <p>If not set, should default to the {@link org.bukkit.World#getDifficulty()} of the first\n+   * loaded world on the server.\n    *\n-   * @return A collection of tags.\n+   * @return The difficulty, or {@code null} for auto-detect.\n    */\n-  Collection<MapTag> getTags();\n+  @Nullable\n+  Difficulty getDifficulty();\n \n   /**\n    * Get the maximum number of players that can participate on each team.\n    *\n-   * @return Maximum number of players on each team.\n+   * <p>For free-for-all matches, this should be left empty.\n+   *\n+   * <p>Sum of all the limits should equal {@link #getPlayerLimit()}.\n+   *\n+   * @return Maximum number of participants on each team.\n    */\n-  Collection<Integer> getMaxPlayers();\n+  Collection<Integer> getTeamLimits();\n \n   /**\n-   * Create an immutable copy of this info.\n+   * Get the maximum number of players that can participate in the map.\n    *\n-   * @return A cloned {@link MapInfo}.\n+   * <p>Should be capped at {@link org.bukkit.Bukkit#getMaxPlayers()}.\n+   *\n+   * @return Maximum number of participants.\n    */\n-  MapInfo clone();\n-\n-  @Override\n-  default int compareTo(MapInfo o) {\n-    return getId().compareTo(o.getId());\n-  }\n-\n-  static String normalizeName(@Nullable String idOrName) {\n-    return idOrName == null\n-        ? \"\"\n-        : Normalizer.normalize(idOrName, Normalizer.Form.NFD)\n-            .replaceAll(\"[^A-Za-z0-9]\", \"\")\n-            .toLowerCase();\n-  }\n+  int getPlayerLimit();\n }\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 7fd2eb84..87c65687 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -96,26 +86,5 @@ public interface MapInfo extends Comparable<MapInfo> {\n    *\n    * @return The difficulty, or {@code null} for auto-detect.\n    */\n-  @Nullable\n   Difficulty getDifficulty();\n-\n-  /**\n-   * Get the maximum number of players that can participate on each team.\n-   *\n-   * <p>For free-for-all matches, this should be left empty.\n-   *\n-   * <p>Sum of all the limits should equal {@link #getPlayerLimit()}.\n-   *\n-   * @return Maximum number of participants on each team.\n-   */\n-  Collection<Integer> getTeamLimits();\n-\n-  /**\n-   * Get the maximum number of players that can participate in the map.\n-   *\n-   * <p>Should be capped at {@link org.bukkit.Bukkit#getMaxPlayers()}.\n-   *\n-   * @return Maximum number of participants.\n-   */\n-  int getPlayerLimit();\n }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex 87c65687..a4e9633b 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -87,4 +78,9 @@ public interface MapInfo {\n    * @return The difficulty, or {@code null} for auto-detect.\n    */\n   Difficulty getDifficulty();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n }\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapInfo.java b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\nindex a4e9633b..d1dd7972 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapInfo.java\n", "chunk": "@@ -53,34 +54,63 @@ public interface MapInfo extends Comparable<MapInfo> {\n   Collection<Contributor> getAuthors();\n \n   /**\n-   * Get the {@link Contributor}s that helped contribute to the map.\n+   * Get all {@link Contributor}s that helped contribute to the map.\n    *\n    * @return The contributors.\n    */\n   Collection<Contributor> getContributors();\n \n   /**\n-   * Get any special rules that participants must follow for the map.\n+   * Get any special rules that players must follow for the map.\n    *\n-   * <p>As a rule of thumb, try to keep extra rules to a minimum. From experience, it is often\n-   * difficult to enforce these rules.\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n    *\n-   * @return A collection of human-readable rules.\n+   * @return A collection of rules.\n    */\n   Collection<String> getRules();\n \n   /**\n-   * Get the {@link Difficulty} level that should be set for the map.\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get the genre or \"game mode\" for the map.\n+   *\n+   * <p>Used to override the default sidebar title.\n+   *\n+   * @return The genre.\n+   */\n+  String getGenre();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.\n    *\n-   * <p>If not set, should default to the {@link org.bukkit.World#getDifficulty()} of the first\n-   * loaded world on the server.\n+   * @return A collection of tags.\n+   */\n+  Collection<String> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n    *\n-   * @return The difficulty, or {@code null} for auto-detect.\n+   * @return Maximum number of players on each team.\n    */\n-  Difficulty getDifficulty();\n+  Collection<Integer> getMaxPlayers();\n+\n+  MapInfo clone();\n \n   @Override\n   default int compareTo(MapInfo o) {\n     return getId().compareTo(o.getId());\n   }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"\n+        : Normalizer.normalize(idOrName, Normalizer.Form.NFD)\n+            .replaceAll(\"[^A-Za-z0-9]\", \"\")\n+            .toLowerCase();\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjQ4NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912485", "body": "We should deprecate these three parsers and explain why they shouldn't be here imho.", "bodyText": "We should deprecate these three parsers and explain why they shouldn't be here imho.", "bodyHTML": "<p dir=\"auto\">We should deprecate these three parsers and explain why they shouldn't be here imho.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:09:51Z", "path": "src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package tc.oc.pgm.api.map.factory;\n+\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.exception.MapException;\n+import tc.oc.pgm.api.module.ModuleContext;\n+import tc.oc.pgm.features.FeatureDefinitionContext;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.util.Version;\n+\n+/** A factory for creating {@link MapInfo}s and {@link MapContext}s. */\n+public interface MapFactory extends ModuleContext<MapModule>, AutoCloseable {\n+\n+  RegionParser getRegions();\n+\n+  FilterParser getFilters();\n+\n+  KitParser getKits();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzk2Mw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943963", "bodyText": "It's too widely used at this point. But I'll add some descriptions.", "author": "Electroid", "createdAt": "2020-01-25T17:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\ndeleted file mode 100644\nindex c5db0072..00000000\n--- a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n+++ /dev/null\n", "chunk": "@@ -1,28 +0,0 @@\n-package tc.oc.pgm.api.map.factory;\n-\n-import tc.oc.pgm.api.map.MapContext;\n-import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapModule;\n-import tc.oc.pgm.api.map.exception.MapException;\n-import tc.oc.pgm.api.module.ModuleContext;\n-import tc.oc.pgm.features.FeatureDefinitionContext;\n-import tc.oc.pgm.filters.FilterParser;\n-import tc.oc.pgm.kits.KitParser;\n-import tc.oc.pgm.regions.RegionParser;\n-import tc.oc.util.Version;\n-\n-/** A factory for creating {@link MapInfo}s and {@link MapContext}s. */\n-public interface MapFactory extends ModuleContext<MapModule>, AutoCloseable {\n-\n-  RegionParser getRegions();\n-\n-  FilterParser getFilters();\n-\n-  KitParser getKits();\n-\n-  FeatureDefinitionContext getFeatures();\n-\n-  Version getProto();\n-\n-  MapContext load() throws MapException;\n-}\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\nnew file mode 100644\nindex 00000000..9eef9f72\n--- /dev/null\n+++ b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n", "chunk": "@@ -0,0 +1,33 @@\n+package tc.oc.pgm.api.map.factory;\n+\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.exception.MapNotFoundException;\n+import tc.oc.pgm.api.module.ModuleContext;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.features.FeatureDefinitionContext;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.util.SemanticVersion;\n+\n+/**\n+ * A shared map state used during {@link MapModule} loading.\n+ */\n+public interface MapFactory extends ModuleContext<MapModule> {\n+\n+    RegionParser getRegions();\n+\n+    FilterParser getFilters();\n+\n+    KitParser getKits();\n+\n+    FeatureDefinitionContext getFeatures();\n+\n+    SemanticVersion getProto();\n+\n+    MapInfo getInfo();\n+\n+    void load() throws MapNotFoundException, ModuleLoadException;\n+\n+}\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\nindex 9eef9f72..c072f10e 100644\n--- a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n+++ b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n", "chunk": "@@ -12,22 +13,21 @@ import tc.oc.pgm.regions.RegionParser;\n import tc.oc.util.SemanticVersion;\n \n /**\n- * A shared map state used during {@link MapModule} loading.\n+ * A factory for creating {@link MapInfo}s and {@link MapContext}s.\n  */\n public interface MapFactory extends ModuleContext<MapModule> {\n \n-    RegionParser getRegions();\n+  RegionParser getRegions();\n \n-    FilterParser getFilters();\n+  FilterParser getFilters();\n \n-    KitParser getKits();\n+  KitParser getKits();\n \n-    FeatureDefinitionContext getFeatures();\n+  FeatureDefinitionContext getFeatures();\n \n-    SemanticVersion getProto();\n+  SemanticVersion getProto();\n \n-    MapInfo getInfo();\n-\n-    void load() throws MapNotFoundException, ModuleLoadException;\n+  MapInfo buildInfo() throws MapNotFoundException, ModuleLoadException;\n \n+  MapContext buildContext() throws MapNotFoundException, ModuleLoadException;\n }\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\nindex c072f10e..9c2da4bc 100644\n--- a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n+++ b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n", "chunk": "@@ -25,9 +23,7 @@ public interface MapFactory extends ModuleContext<MapModule> {\n \n   FeatureDefinitionContext getFeatures();\n \n-  SemanticVersion getProto();\n+  Version getProto();\n \n-  MapInfo buildInfo() throws MapNotFoundException, ModuleLoadException;\n-\n-  MapContext buildContext() throws MapNotFoundException, ModuleLoadException;\n+  MapContext load() throws MapNotFoundException, ModuleLoadException;\n }\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\nindex 9c2da4bc..c5db0072 100644\n--- a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n+++ b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n", "chunk": "@@ -25,5 +24,5 @@ public interface MapFactory extends ModuleContext<MapModule> {\n \n   Version getProto();\n \n-  MapContext load() throws MapNotFoundException, ModuleLoadException;\n+  MapContext load() throws MapException;\n }\n", "next_change": {"commit": "c02af41697dbe0326b0e03435ce31be894676c31", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\nindex c5db0072..b92af76e 100644\n--- a/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n+++ b/src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java\n", "chunk": "@@ -14,15 +14,47 @@ import tc.oc.util.Version;\n /** A factory for creating {@link MapInfo}s and {@link MapContext}s. */\n public interface MapFactory extends ModuleContext<MapModule>, AutoCloseable {\n \n+  /**\n+   * Get the {@link RegionParser} for parsing region references.\n+   *\n+   * @return A {@link RegionParser}.\n+   */\n   RegionParser getRegions();\n \n+  /**\n+   * Get the {@link FilterParser} for parsing filter references.\n+   *\n+   * @return A {@link FilterParser}.\n+   */\n   FilterParser getFilters();\n \n+  /**\n+   * Get the {@link KitParser} for parsing filter references.\n+   *\n+   * @return A {@link KitParser}.\n+   */\n   KitParser getKits();\n \n+  /**\n+   * Get the {@link FeatureDefinitionContext} for registering feature references.\n+   *\n+   * @return A {@link FeatureDefinitionContext}.\n+   */\n   FeatureDefinitionContext getFeatures();\n \n+  /**\n+   * Get the effective {@link Version} for the map syntax.\n+   *\n+   * @see tc.oc.pgm.api.map.MapProtos\n+   * @return A {@link Version}.\n+   */\n   Version getProto();\n \n+  /**\n+   * Load each {@link MapModule} and create a persistent context.\n+   *\n+   * @return A {@link MapContext}.\n+   * @throws MapException If there was an error loading the context.\n+   */\n   MapContext load() throws MapException;\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjgxMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912810", "body": "This `match` field will now pop up in each `MatchModule` implementation. We should have `MatchModule.Impl` with this to keep it DRY.", "bodyText": "This match field will now pop up in each MatchModule implementation. We should have MatchModule.Impl with this to keep it DRY.", "bodyHTML": "<p dir=\"auto\">This <code>match</code> field will now pop up in each <code>MatchModule</code> implementation. We should have <code>MatchModule.Impl</code> with this to keep it DRY.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:18:37Z", "path": "src/main/java/tc/oc/pgm/blockdrops/BlockDropsMatchModule.java", "diffHunk": "@@ -52,9 +52,10 @@\n   // die that do not fire an event e.g. the tick age limit, but this should be\n   // rare and they will only leak until the end of the match.\n   private final Set<FallingBlock> fallingBlocksThatWillNotLand = new HashSet<>();\n+  private final Match match;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzk0NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943945", "bodyText": "There are some MatchModules that don't even need a Match reference. They just use event listeners. Not really nessecary.", "author": "Electroid", "createdAt": "2020-01-25T17:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjgxMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzAyNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913026", "body": "Keep that * import :P", "bodyText": "Keep that * import :P", "bodyHTML": "<p dir=\"auto\">Keep that * import :P</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:23:50Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -1,16 +1,15 @@\n package tc.oc.pgm.commands;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzkwMQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943901", "bodyText": "? It's just the google syntax cleaner.", "author": "Electroid", "createdAt": "2020-01-25T17:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzAyNg=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -1,23 +1,13 @@\n package tc.oc.pgm.commands;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n import app.ashcon.intake.Command;\n import app.ashcon.intake.CommandException;\n-import app.ashcon.intake.bukkit.parametric.Type;\n-import app.ashcon.intake.bukkit.parametric.annotation.Fallback;\n-import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Default;\n import com.google.common.collect.ImmutableSortedSet;\n-import com.google.common.collect.Sets;\n import java.util.Collection;\n import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n import javax.annotation.Nullable;\n import net.md_5.bungee.api.ChatColor;\n-import net.md_5.bungee.api.chat.ClickEvent;\n-import net.md_5.bungee.api.chat.HoverEvent;\n import org.bukkit.command.CommandSender;\n import tc.oc.component.Component;\n import tc.oc.component.types.PersonalizedText;\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..69503185 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -4,9 +4,6 @@ import app.ashcon.intake.Command;\n import app.ashcon.intake.CommandException;\n import app.ashcon.intake.parametric.annotation.Default;\n import com.google.common.collect.ImmutableSortedSet;\n-import java.util.Collection;\n-import java.util.Set;\n-import javax.annotation.Nullable;\n import net.md_5.bungee.api.ChatColor;\n import org.bukkit.command.CommandSender;\n import tc.oc.component.Component;\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 69503185..15598937 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -4,6 +4,9 @@ import app.ashcon.intake.Command;\n import app.ashcon.intake.CommandException;\n import app.ashcon.intake.parametric.annotation.Default;\n import com.google.common.collect.ImmutableSortedSet;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n import net.md_5.bungee.api.ChatColor;\n import org.bukkit.command.CommandSender;\n import tc.oc.component.Component;\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 15598937..fccfc940 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -3,6 +3,7 @@ package tc.oc.pgm.commands;\n import app.ashcon.intake.Command;\n import app.ashcon.intake.CommandException;\n import app.ashcon.intake.parametric.annotation.Default;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableSortedSet;\n import java.util.Collection;\n import java.util.Set;\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex fccfc940..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -1,14 +1,23 @@\n package tc.oc.pgm.commands;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n import app.ashcon.intake.Command;\n import app.ashcon.intake.CommandException;\n-import app.ashcon.intake.parametric.annotation.Default;\n-import com.google.common.base.Joiner;\n+import app.ashcon.intake.bukkit.parametric.Type;\n+import app.ashcon.intake.bukkit.parametric.annotation.Fallback;\n+import app.ashcon.intake.parametric.annotation.Switch;\n import com.google.common.collect.ImmutableSortedSet;\n+import com.google.common.collect.Sets;\n import java.util.Collection;\n import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.annotation.Nullable;\n import net.md_5.bungee.api.ChatColor;\n+import net.md_5.bungee.api.chat.ClickEvent;\n+import net.md_5.bungee.api.chat.HoverEvent;\n import org.bukkit.command.CommandSender;\n import tc.oc.component.Component;\n import tc.oc.component.types.PersonalizedText;\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzExOA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913118", "body": "The previous syntax was way easier imo. Just `/maps #many #tags` instead of commas, dashes and other difficult combinations you need to do to put multiple maptags.", "bodyText": "The previous syntax was way easier imo. Just /maps #many #tags instead of commas, dashes and other difficult combinations you need to do to put multiple maptags.", "bodyHTML": "<p dir=\"auto\">The previous syntax was way easier imo. Just <code>/maps #many #tags</code> instead of commas, dashes and other difficult combinations you need to do to put multiple maptags.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:26:31Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..acb4f59b 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -48,23 +49,24 @@ public class MapCommands {\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n+      usage = \"[-a <author>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n+      @Default(\"1\") Integer page,\n       @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author,\n-      @Fallback(Type.NULL) @Switch('p') Integer page)\n+      @Fallback(Type.NULL) @Switch('a') String author)\n       throws CommandException {\n-    if (page == null) page = 1;\n-\n     Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n     if (tags != null) {\n       final Set<String> tagSet =\n-          Stream.of(tags.split(\",\")).map(String::trim).collect(Collectors.toSet());\n+          Stream.of(tags.split(\",\"))\n+              .map(String::toLowerCase)\n+              .map(String::trim)\n+              .collect(Collectors.toSet());\n       search = search.filter(map -> matchesTags(map, tagSet));\n     }\n \n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex acb4f59b..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -28,90 +17,57 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n import tc.oc.pgm.api.map.MapLibrary;\n-import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n-  @Command(\n-      aliases = {\"loadnewmaps\"},\n-      desc = \"Loads new maps and outputs any errors\")\n-  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n-    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n-  }\n-\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-# <tag1>,<tag2>]\",\n+      usage = \"[page]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience,\n-      CommandSender sender,\n-      MapLibrary library,\n-      @Default(\"1\") Integer page,\n-      @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author)\n+      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n       throws CommandException {\n-    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n-    if (tags != null) {\n-      final Set<String> tagSet =\n-          Stream.of(tags.split(\",\"))\n-              .map(String::toLowerCase)\n-              .map(String::trim)\n-              .collect(Collectors.toSet());\n-      search = search.filter(map -> matchesTags(map, tagSet));\n-    }\n+    final Set<MapContext> maps = ImmutableSortedSet.copyOf(library.getMaps());\n \n-    if (author != null) {\n-      search = search.filter(map -> matchesAuthor(map, author));\n-    }\n-\n-    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n-    int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n+    int pages = (library.getMaps().size() + resultsPerPage - 1) / resultsPerPage;\n \n-    String title =\n-        ComponentUtils.paginate(\n-            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n-\n-    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n+        ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \"---------------\"\n+            + ChatColor.RESET\n+            + \" \"\n+            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n+            + ChatColor.DARK_AQUA\n+            + \" (\"\n+            + ChatColor.AQUA\n+            + page\n+            + ChatColor.DARK_AQUA\n+            + \" of \"\n+            + ChatColor.AQUA\n+            + pages\n+            + ChatColor.DARK_AQUA\n+            + \") \"\n+            + ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \" ---------------\"\n+            + ChatColor.RESET;\n+\n+    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapInfo map, int index) {\n-        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n-      }\n-    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n-  }\n-\n-  private static boolean matchesTags(MapInfo map, Set<String> tags) {\n-    if (checkNotNull(tags).isEmpty()) return true;\n-    for (MapTag tag : checkNotNull(map).getTags()) {\n-      if (tags.contains(tag.getId())) {\n-        return true;\n+      public String format(MapContext map, int index) {\n+        return (index + 1) + \". \" + map.getInfo().getDescription();\n       }\n-    }\n-    return false;\n-  }\n-\n-  private static boolean matchesAuthor(MapInfo map, String query) {\n-    checkNotNull(map);\n-    query = checkNotNull(query).toLowerCase();\n-\n-    for (Contributor contributor : map.getAuthors()) {\n-      if (contributor.getName().toLowerCase().contains(query)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    }.display(audience, maps, page);\n   }\n \n   @Command(\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..ecd202ed 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -65,7 +66,7 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getDescription();\n+        return (index + 1) + \". \" + map.getDescription();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex ecd202ed..69503185 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -63,10 +65,11 @@ public class MapCommands {\n             + \" ---------------\"\n             + ChatColor.RESET;\n \n-    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getDescription();\n+      public String format(MapInfo map, int index) {\n+        // TODO: fix misc.authorship\n+        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 69503185..15598937 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -69,7 +68,15 @@ public class MapCommands {\n       @Override\n       public String format(MapInfo map, int index) {\n         // TODO: fix misc.authorship\n-        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n+        return (index + 1)\n+            + \". \"\n+            + ChatColor.RED\n+            + map.getName()\n+            + \" \"\n+            + ChatColor.DARK_PURPLE\n+            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                .render(sender)\n+                .toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 15598937..3ce76bfc 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -67,16 +67,17 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        // TODO: fix misc.authorship\n         return (index + 1)\n             + \". \"\n-            + ChatColor.RED\n-            + map.getName()\n-            + \" \"\n-            + ChatColor.DARK_PURPLE\n-            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                .render(sender)\n-                .toLegacyText();\n+            + AllTranslations.get()\n+                .translate(\n+                    \"misc.authorship\",\n+                    sender,\n+                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n+                    ChatColor.DARK_PURPLE\n+                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                            .render(sender)\n+                            .toLegacyText());\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 3ce76bfc..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -17,69 +27,67 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapInfoExtra;\n import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[page]\",\n+      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n+      Audience audience,\n+      CommandSender sender,\n+      MapLibrary library,\n+      @Fallback(Type.NULL) @Switch('a') String author,\n+      @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n-    final Set<MapInfo> maps = ImmutableSortedSet.copyOf(library.getMaps());\n+    if (page == null) page = 1;\n+\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    // FIXME: Add tag support again\n+    if (author != null) {\n+      search = search.filter(map -> matchesAuthor(map, author));\n+    }\n \n+    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n     int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n \n+    String title =\n+        ComponentUtils.paginate(\n+            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \"---------------\"\n-            + ChatColor.RESET\n-            + \" \"\n-            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n-            + ChatColor.DARK_AQUA\n-            + \" (\"\n-            + ChatColor.AQUA\n-            + page\n-            + ChatColor.DARK_AQUA\n-            + \" of \"\n-            + ChatColor.AQUA\n-            + pages\n-            + ChatColor.DARK_AQUA\n-            + \") \"\n-            + ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \" ---------------\"\n-            + ChatColor.RESET;\n+        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        return (index + 1)\n-            + \". \"\n-            + AllTranslations.get()\n-                .translate(\n-                    \"misc.authorship\",\n-                    sender,\n-                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n-                    ChatColor.DARK_PURPLE\n-                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                            .render(sender)\n-                            .toLegacyText());\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n+      }\n+    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n+  }\n+\n+  private static boolean matchesAuthor(MapInfo map, String query) {\n+    checkNotNull(map);\n+    query = checkNotNull(query).toLowerCase();\n+\n+    for (Contributor contributor : map.getAuthors()) {\n+      if (contributor.getName().toLowerCase().contains(query)) {\n+        return true;\n       }\n-    }.display(audience, maps, page);\n+    }\n+    return false;\n   }\n \n   @Command(\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzIxMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913213", "body": "This should fix the page number input I think? Also doing flags for maptags which always start with `#` isn't obvious to end-user.", "bodyText": "This should fix the page number input I think? Also doing flags for maptags which always start with # isn't obvious to end-user.", "bodyHTML": "<p dir=\"auto\">This should fix the page number input I think? Also doing flags for maptags which always start with <code>#</code> isn't obvious to end-user.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:30:02Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n-      MapTagsCondition mapTags,\n+      @Fallback(Type.NULL) @Switch('t') String tags,", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDExNQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944115", "bodyText": "Yea, will remove the -p, because everyone was just using /maps N", "author": "Electroid", "createdAt": "2020-01-25T17:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..acb4f59b 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -48,23 +49,24 @@ public class MapCommands {\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n+      usage = \"[-a <author>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n+      @Default(\"1\") Integer page,\n       @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author,\n-      @Fallback(Type.NULL) @Switch('p') Integer page)\n+      @Fallback(Type.NULL) @Switch('a') String author)\n       throws CommandException {\n-    if (page == null) page = 1;\n-\n     Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n     if (tags != null) {\n       final Set<String> tagSet =\n-          Stream.of(tags.split(\",\")).map(String::trim).collect(Collectors.toSet());\n+          Stream.of(tags.split(\",\"))\n+              .map(String::toLowerCase)\n+              .map(String::trim)\n+              .collect(Collectors.toSet());\n       search = search.filter(map -> matchesTags(map, tagSet));\n     }\n \n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex acb4f59b..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -28,90 +17,57 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n import tc.oc.pgm.api.map.MapLibrary;\n-import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n-  @Command(\n-      aliases = {\"loadnewmaps\"},\n-      desc = \"Loads new maps and outputs any errors\")\n-  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n-    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n-  }\n-\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-# <tag1>,<tag2>]\",\n+      usage = \"[page]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience,\n-      CommandSender sender,\n-      MapLibrary library,\n-      @Default(\"1\") Integer page,\n-      @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author)\n+      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n       throws CommandException {\n-    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n-    if (tags != null) {\n-      final Set<String> tagSet =\n-          Stream.of(tags.split(\",\"))\n-              .map(String::toLowerCase)\n-              .map(String::trim)\n-              .collect(Collectors.toSet());\n-      search = search.filter(map -> matchesTags(map, tagSet));\n-    }\n+    final Set<MapContext> maps = ImmutableSortedSet.copyOf(library.getMaps());\n \n-    if (author != null) {\n-      search = search.filter(map -> matchesAuthor(map, author));\n-    }\n-\n-    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n-    int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n+    int pages = (library.getMaps().size() + resultsPerPage - 1) / resultsPerPage;\n \n-    String title =\n-        ComponentUtils.paginate(\n-            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n-\n-    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n+        ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \"---------------\"\n+            + ChatColor.RESET\n+            + \" \"\n+            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n+            + ChatColor.DARK_AQUA\n+            + \" (\"\n+            + ChatColor.AQUA\n+            + page\n+            + ChatColor.DARK_AQUA\n+            + \" of \"\n+            + ChatColor.AQUA\n+            + pages\n+            + ChatColor.DARK_AQUA\n+            + \") \"\n+            + ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \" ---------------\"\n+            + ChatColor.RESET;\n+\n+    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapInfo map, int index) {\n-        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n-      }\n-    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n-  }\n-\n-  private static boolean matchesTags(MapInfo map, Set<String> tags) {\n-    if (checkNotNull(tags).isEmpty()) return true;\n-    for (MapTag tag : checkNotNull(map).getTags()) {\n-      if (tags.contains(tag.getId())) {\n-        return true;\n+      public String format(MapContext map, int index) {\n+        return (index + 1) + \". \" + map.getInfo().getDescription();\n       }\n-    }\n-    return false;\n-  }\n-\n-  private static boolean matchesAuthor(MapInfo map, String query) {\n-    checkNotNull(map);\n-    query = checkNotNull(query).toLowerCase();\n-\n-    for (Contributor contributor : map.getAuthors()) {\n-      if (contributor.getName().toLowerCase().contains(query)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    }.display(audience, maps, page);\n   }\n \n   @Command(\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..ecd202ed 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -65,7 +66,7 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getDescription();\n+        return (index + 1) + \". \" + map.getDescription();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex ecd202ed..69503185 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -63,10 +65,11 @@ public class MapCommands {\n             + \" ---------------\"\n             + ChatColor.RESET;\n \n-    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getDescription();\n+      public String format(MapInfo map, int index) {\n+        // TODO: fix misc.authorship\n+        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 69503185..15598937 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -69,7 +68,15 @@ public class MapCommands {\n       @Override\n       public String format(MapInfo map, int index) {\n         // TODO: fix misc.authorship\n-        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n+        return (index + 1)\n+            + \". \"\n+            + ChatColor.RED\n+            + map.getName()\n+            + \" \"\n+            + ChatColor.DARK_PURPLE\n+            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                .render(sender)\n+                .toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 15598937..3ce76bfc 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -67,16 +67,17 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        // TODO: fix misc.authorship\n         return (index + 1)\n             + \". \"\n-            + ChatColor.RED\n-            + map.getName()\n-            + \" \"\n-            + ChatColor.DARK_PURPLE\n-            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                .render(sender)\n-                .toLegacyText();\n+            + AllTranslations.get()\n+                .translate(\n+                    \"misc.authorship\",\n+                    sender,\n+                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n+                    ChatColor.DARK_PURPLE\n+                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                            .render(sender)\n+                            .toLegacyText());\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 3ce76bfc..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -17,69 +27,67 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapInfoExtra;\n import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[page]\",\n+      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n+      Audience audience,\n+      CommandSender sender,\n+      MapLibrary library,\n+      @Fallback(Type.NULL) @Switch('a') String author,\n+      @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n-    final Set<MapInfo> maps = ImmutableSortedSet.copyOf(library.getMaps());\n+    if (page == null) page = 1;\n+\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    // FIXME: Add tag support again\n+    if (author != null) {\n+      search = search.filter(map -> matchesAuthor(map, author));\n+    }\n \n+    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n     int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n \n+    String title =\n+        ComponentUtils.paginate(\n+            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \"---------------\"\n-            + ChatColor.RESET\n-            + \" \"\n-            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n-            + ChatColor.DARK_AQUA\n-            + \" (\"\n-            + ChatColor.AQUA\n-            + page\n-            + ChatColor.DARK_AQUA\n-            + \" of \"\n-            + ChatColor.AQUA\n-            + pages\n-            + ChatColor.DARK_AQUA\n-            + \") \"\n-            + ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \" ---------------\"\n-            + ChatColor.RESET;\n+        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        return (index + 1)\n-            + \". \"\n-            + AllTranslations.get()\n-                .translate(\n-                    \"misc.authorship\",\n-                    sender,\n-                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n-                    ChatColor.DARK_PURPLE\n-                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                            .render(sender)\n-                            .toLegacyText());\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n+      }\n+    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n+  }\n+\n+  private static boolean matchesAuthor(MapInfo map, String query) {\n+    checkNotNull(map);\n+    query = checkNotNull(query).toLowerCase();\n+\n+    for (Contributor contributor : map.getAuthors()) {\n+      if (contributor.getName().toLowerCase().contains(query)) {\n+        return true;\n       }\n-    }.display(audience, maps, page);\n+    }\n+    return false;\n   }\n \n   @Command(\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzM2Mw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913363", "body": "People can no longer negate maptags as @Pablete1234 suggested me to do. Let's say if people would want to search for all DTM maps except the ones mixed with cores (SSB) - `/maps #monument !#core`", "bodyText": "People can no longer negate maptags as @Pablete1234 suggested me to do. Let's say if people would want to search for all DTM maps except the ones mixed with cores (SSB) - /maps #monument !#core", "bodyHTML": "<p dir=\"auto\">People can no longer negate maptags as <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Pablete1234/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Pablete1234\">@Pablete1234</a> suggested me to do. Let's say if people would want to search for all DTM maps except the ones mixed with cores (SSB) - <code>/maps #monument !#core</code></p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:33:15Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n-      MapTagsCondition mapTags,\n+      @Fallback(Type.NULL) @Switch('t') String tags,\n       @Fallback(Type.NULL) @Switch('a') String author,\n       @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n     if (page == null) page = 1;\n \n-    Stream<PGMMap> search = library.getMaps().stream().filter(mapTags);\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    if (tags != null) {\n+      final Set<String> tagSet =\n+          Stream.of(tags.split(\",\")).map(String::trim).collect(Collectors.toSet());\n+      search = search.filter(map -> matchesTags(map, tagSet));", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..acb4f59b 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -48,23 +49,24 @@ public class MapCommands {\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n+      usage = \"[-a <author>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n+      @Default(\"1\") Integer page,\n       @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author,\n-      @Fallback(Type.NULL) @Switch('p') Integer page)\n+      @Fallback(Type.NULL) @Switch('a') String author)\n       throws CommandException {\n-    if (page == null) page = 1;\n-\n     Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n     if (tags != null) {\n       final Set<String> tagSet =\n-          Stream.of(tags.split(\",\")).map(String::trim).collect(Collectors.toSet());\n+          Stream.of(tags.split(\",\"))\n+              .map(String::toLowerCase)\n+              .map(String::trim)\n+              .collect(Collectors.toSet());\n       search = search.filter(map -> matchesTags(map, tagSet));\n     }\n \n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex acb4f59b..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -28,90 +17,57 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n import tc.oc.pgm.api.map.MapLibrary;\n-import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n-  @Command(\n-      aliases = {\"loadnewmaps\"},\n-      desc = \"Loads new maps and outputs any errors\")\n-  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n-    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n-  }\n-\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-# <tag1>,<tag2>]\",\n+      usage = \"[page]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience,\n-      CommandSender sender,\n-      MapLibrary library,\n-      @Default(\"1\") Integer page,\n-      @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author)\n+      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n       throws CommandException {\n-    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n-    if (tags != null) {\n-      final Set<String> tagSet =\n-          Stream.of(tags.split(\",\"))\n-              .map(String::toLowerCase)\n-              .map(String::trim)\n-              .collect(Collectors.toSet());\n-      search = search.filter(map -> matchesTags(map, tagSet));\n-    }\n+    final Set<MapContext> maps = ImmutableSortedSet.copyOf(library.getMaps());\n \n-    if (author != null) {\n-      search = search.filter(map -> matchesAuthor(map, author));\n-    }\n-\n-    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n-    int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n+    int pages = (library.getMaps().size() + resultsPerPage - 1) / resultsPerPage;\n \n-    String title =\n-        ComponentUtils.paginate(\n-            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n-\n-    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n+        ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \"---------------\"\n+            + ChatColor.RESET\n+            + \" \"\n+            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n+            + ChatColor.DARK_AQUA\n+            + \" (\"\n+            + ChatColor.AQUA\n+            + page\n+            + ChatColor.DARK_AQUA\n+            + \" of \"\n+            + ChatColor.AQUA\n+            + pages\n+            + ChatColor.DARK_AQUA\n+            + \") \"\n+            + ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \" ---------------\"\n+            + ChatColor.RESET;\n+\n+    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapInfo map, int index) {\n-        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n-      }\n-    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n-  }\n-\n-  private static boolean matchesTags(MapInfo map, Set<String> tags) {\n-    if (checkNotNull(tags).isEmpty()) return true;\n-    for (MapTag tag : checkNotNull(map).getTags()) {\n-      if (tags.contains(tag.getId())) {\n-        return true;\n+      public String format(MapContext map, int index) {\n+        return (index + 1) + \". \" + map.getInfo().getDescription();\n       }\n-    }\n-    return false;\n-  }\n-\n-  private static boolean matchesAuthor(MapInfo map, String query) {\n-    checkNotNull(map);\n-    query = checkNotNull(query).toLowerCase();\n-\n-    for (Contributor contributor : map.getAuthors()) {\n-      if (contributor.getName().toLowerCase().contains(query)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    }.display(audience, maps, page);\n   }\n \n   @Command(\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..ecd202ed 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -65,7 +66,7 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getDescription();\n+        return (index + 1) + \". \" + map.getDescription();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex ecd202ed..69503185 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -63,10 +65,11 @@ public class MapCommands {\n             + \" ---------------\"\n             + ChatColor.RESET;\n \n-    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getDescription();\n+      public String format(MapInfo map, int index) {\n+        // TODO: fix misc.authorship\n+        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 69503185..15598937 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -69,7 +68,15 @@ public class MapCommands {\n       @Override\n       public String format(MapInfo map, int index) {\n         // TODO: fix misc.authorship\n-        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n+        return (index + 1)\n+            + \". \"\n+            + ChatColor.RED\n+            + map.getName()\n+            + \" \"\n+            + ChatColor.DARK_PURPLE\n+            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                .render(sender)\n+                .toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 15598937..3ce76bfc 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -67,16 +67,17 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        // TODO: fix misc.authorship\n         return (index + 1)\n             + \". \"\n-            + ChatColor.RED\n-            + map.getName()\n-            + \" \"\n-            + ChatColor.DARK_PURPLE\n-            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                .render(sender)\n-                .toLegacyText();\n+            + AllTranslations.get()\n+                .translate(\n+                    \"misc.authorship\",\n+                    sender,\n+                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n+                    ChatColor.DARK_PURPLE\n+                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                            .render(sender)\n+                            .toLegacyText());\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 3ce76bfc..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -17,69 +27,67 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapInfoExtra;\n import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[page]\",\n+      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n+      Audience audience,\n+      CommandSender sender,\n+      MapLibrary library,\n+      @Fallback(Type.NULL) @Switch('a') String author,\n+      @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n-    final Set<MapInfo> maps = ImmutableSortedSet.copyOf(library.getMaps());\n+    if (page == null) page = 1;\n+\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    // FIXME: Add tag support again\n+    if (author != null) {\n+      search = search.filter(map -> matchesAuthor(map, author));\n+    }\n \n+    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n     int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n \n+    String title =\n+        ComponentUtils.paginate(\n+            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \"---------------\"\n-            + ChatColor.RESET\n-            + \" \"\n-            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n-            + ChatColor.DARK_AQUA\n-            + \" (\"\n-            + ChatColor.AQUA\n-            + page\n-            + ChatColor.DARK_AQUA\n-            + \" of \"\n-            + ChatColor.AQUA\n-            + pages\n-            + ChatColor.DARK_AQUA\n-            + \") \"\n-            + ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \" ---------------\"\n-            + ChatColor.RESET;\n+        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        return (index + 1)\n-            + \". \"\n-            + AllTranslations.get()\n-                .translate(\n-                    \"misc.authorship\",\n-                    sender,\n-                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n-                    ChatColor.DARK_PURPLE\n-                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                            .render(sender)\n-                            .toLegacyText());\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n+      }\n+    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n+  }\n+\n+  private static boolean matchesAuthor(MapInfo map, String query) {\n+    checkNotNull(map);\n+    query = checkNotNull(query).toLowerCase();\n+\n+    for (Contributor contributor : map.getAuthors()) {\n+      if (contributor.getName().toLowerCase().contains(query)) {\n+        return true;\n       }\n-    }.display(audience, maps, page);\n+    }\n+    return false;\n   }\n \n   @Command(\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzQyMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913420", "body": "`tags` aren't always lower case, `getId()` is.", "bodyText": "tags aren't always lower case, getId() is.", "bodyHTML": "<p dir=\"auto\"><code>tags</code> aren't always lower case, <code>getId()</code> is.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:35:26Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -73,20 +82,30 @@ public static void maplist(\n     String listHeader =\n         ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n-    new PrettyPaginatedResult<PGMMap>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(PGMMap map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getShortDescription(sender);\n+      public String format(MapInfo map, int index) {\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n       }\n     }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n   }\n \n-  private static boolean matchesAuthor(PGMMap map, String query) {\n+  private static boolean matchesTags(MapInfo map, Set<String> tags) {\n+    if (checkNotNull(tags).isEmpty()) return true;\n+    for (MapTag tag : checkNotNull(map).getTags()) {\n+      if (tags.contains(tag.getId())) {", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -27,89 +17,57 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n import tc.oc.pgm.api.map.MapLibrary;\n-import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n-  @Command(\n-      aliases = {\"loadnewmaps\"},\n-      desc = \"Loads new maps and outputs any errors\")\n-  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n-    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n-  }\n-\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n+      usage = \"[page]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience,\n-      CommandSender sender,\n-      MapLibrary library,\n-      @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author,\n-      @Fallback(Type.NULL) @Switch('p') Integer page)\n+      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n       throws CommandException {\n-    if (page == null) page = 1;\n+    final Set<MapContext> maps = ImmutableSortedSet.copyOf(library.getMaps());\n \n-    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n-    if (tags != null) {\n-      final Set<String> tagSet =\n-          Stream.of(tags.split(\",\")).map(String::trim).collect(Collectors.toSet());\n-      search = search.filter(map -> matchesTags(map, tagSet));\n-    }\n-\n-    if (author != null) {\n-      search = search.filter(map -> matchesAuthor(map, author));\n-    }\n-\n-    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n-    int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n+    int pages = (library.getMaps().size() + resultsPerPage - 1) / resultsPerPage;\n \n-    String title =\n-        ComponentUtils.paginate(\n-            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n-\n-    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n+        ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \"---------------\"\n+            + ChatColor.RESET\n+            + \" \"\n+            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n+            + ChatColor.DARK_AQUA\n+            + \" (\"\n+            + ChatColor.AQUA\n+            + page\n+            + ChatColor.DARK_AQUA\n+            + \" of \"\n+            + ChatColor.AQUA\n+            + pages\n+            + ChatColor.DARK_AQUA\n+            + \") \"\n+            + ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \" ---------------\"\n+            + ChatColor.RESET;\n+\n+    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapInfo map, int index) {\n-        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n+      public String format(MapContext map, int index) {\n+        return (index + 1) + \". \" + map.getInfo().getDescription();\n       }\n-    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n-  }\n-\n-  private static boolean matchesTags(MapInfo map, Set<String> tags) {\n-    if (checkNotNull(tags).isEmpty()) return true;\n-    for (MapTag tag : checkNotNull(map).getTags()) {\n-      if (tags.contains(tag.getId())) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  private static boolean matchesAuthor(MapInfo map, String query) {\n-    checkNotNull(map);\n-    query = checkNotNull(query).toLowerCase();\n-\n-    for (Contributor contributor : map.getAuthors()) {\n-      if (contributor.getName().toLowerCase().contains(query)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    }.display(audience, maps, page);\n   }\n \n   @Command(\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..ecd202ed 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -65,7 +66,7 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getDescription();\n+        return (index + 1) + \". \" + map.getDescription();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex ecd202ed..69503185 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -63,10 +65,11 @@ public class MapCommands {\n             + \" ---------------\"\n             + ChatColor.RESET;\n \n-    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getDescription();\n+      public String format(MapInfo map, int index) {\n+        // TODO: fix misc.authorship\n+        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 69503185..15598937 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -69,7 +68,15 @@ public class MapCommands {\n       @Override\n       public String format(MapInfo map, int index) {\n         // TODO: fix misc.authorship\n-        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n+        return (index + 1)\n+            + \". \"\n+            + ChatColor.RED\n+            + map.getName()\n+            + \" \"\n+            + ChatColor.DARK_PURPLE\n+            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                .render(sender)\n+                .toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 15598937..3ce76bfc 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -67,16 +67,17 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        // TODO: fix misc.authorship\n         return (index + 1)\n             + \". \"\n-            + ChatColor.RED\n-            + map.getName()\n-            + \" \"\n-            + ChatColor.DARK_PURPLE\n-            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                .render(sender)\n-                .toLegacyText();\n+            + AllTranslations.get()\n+                .translate(\n+                    \"misc.authorship\",\n+                    sender,\n+                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n+                    ChatColor.DARK_PURPLE\n+                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                            .render(sender)\n+                            .toLegacyText());\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 3ce76bfc..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -17,69 +27,67 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapInfoExtra;\n import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[page]\",\n+      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n+      Audience audience,\n+      CommandSender sender,\n+      MapLibrary library,\n+      @Fallback(Type.NULL) @Switch('a') String author,\n+      @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n-    final Set<MapInfo> maps = ImmutableSortedSet.copyOf(library.getMaps());\n+    if (page == null) page = 1;\n+\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    // FIXME: Add tag support again\n+    if (author != null) {\n+      search = search.filter(map -> matchesAuthor(map, author));\n+    }\n \n+    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n     int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n \n+    String title =\n+        ComponentUtils.paginate(\n+            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \"---------------\"\n-            + ChatColor.RESET\n-            + \" \"\n-            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n-            + ChatColor.DARK_AQUA\n-            + \" (\"\n-            + ChatColor.AQUA\n-            + page\n-            + ChatColor.DARK_AQUA\n-            + \" of \"\n-            + ChatColor.AQUA\n-            + pages\n-            + ChatColor.DARK_AQUA\n-            + \") \"\n-            + ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \" ---------------\"\n-            + ChatColor.RESET;\n+        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        return (index + 1)\n-            + \". \"\n-            + AllTranslations.get()\n-                .translate(\n-                    \"misc.authorship\",\n-                    sender,\n-                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n-                    ChatColor.DARK_PURPLE\n-                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                            .render(sender)\n-                            .toLegacyText());\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n+      }\n+    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n+  }\n+\n+  private static boolean matchesAuthor(MapInfo map, String query) {\n+    checkNotNull(map);\n+    query = checkNotNull(query).toLowerCase();\n+\n+    for (Contributor contributor : map.getAuthors()) {\n+      if (contributor.getName().toLowerCase().contains(query)) {\n+        return true;\n       }\n-    }.display(audience, maps, page);\n+    }\n+    return false;\n   }\n \n   @Command(\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913506", "body": "I think this should be translatable? I guess in Arabic you should have `v1.0 Airship Battle` since they read right-to-left.", "bodyText": "I think this should be translatable? I guess in Arabic you should have v1.0 Airship Battle since they read right-to-left.", "bodyHTML": "<p dir=\"auto\">I think this should be translatable? I guess in Arabic you should have <code>v1.0 Airship Battle</code> since they read right-to-left.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:37:42Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE3Mw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944173", "bodyText": "Sure, but not a high priority.", "author": "Electroid", "createdAt": "2020-01-25T17:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjI3MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946271", "bodyText": "Leave a todo there so we don't forget it when we migrate to text library.", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -117,14 +75,7 @@ public class MapCommands {\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n   public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n-    audience.sendMessage(\n-        ComponentUtils.horizontalLineHeading(\n-            ChatColor.DARK_AQUA\n-                + map.getName()\n-                + \" \"\n-                + ChatColor.GRAY\n-                + map.getVersion().toString(),\n-            ChatColor.RED));\n+    audience.sendMessage(map.getName()); // TODO: formatted title?\n \n     audience.sendMessage(\n         new PersonalizedText(\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..69503185 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -75,7 +79,7 @@ public class MapCommands {\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n   public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n-    audience.sendMessage(map.getName()); // TODO: formatted title?\n+    audience.sendMessage(ComponentUtils.horizontalLineHeading(map.getName(), ChatColor.RED, 200));\n \n     audience.sendMessage(\n         new PersonalizedText(\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 69503185..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -79,7 +95,14 @@ public class MapCommands {\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n   public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n-    audience.sendMessage(ComponentUtils.horizontalLineHeading(map.getName(), ChatColor.RED, 200));\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913613", "body": "Instead of putting `#` here we should call `toString()` instead.", "bodyText": "Instead of putting # here we should call toString() instead.", "bodyHTML": "<p dir=\"auto\">Instead of putting <code>#</code> here we should call <code>toString()</code> instead.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:40:15Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzY2MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913661", "bodyText": "BTW, maptags in voting books are yellow so I would keep them yellow here too for consistency.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDIyOQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944229", "bodyText": "I made them gold to keep the output consistent in /map. So might look at the voting book too.", "author": "Electroid", "createdAt": "2020-01-25T17:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -167,68 +118,18 @@ public class MapCommands {\n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, map)));\n+            new PersonalizedText(String.valueOf(map.getPlayerLimit()), ChatColor.GOLD)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n+      audience.sendMessage(\n+          new PersonalizedText(\n+              mapInfoLabel(\"command.map.mapInfo.genre\"),\n+              new PersonalizedText(map.getGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n               new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n-\n-    audience.sendMessage(createTagsComponent(map.getTags()));\n-  }\n-\n-  private Component createTagsComponent(Collection<MapTag> tags) {\n-    checkNotNull(tags);\n-\n-    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n-    MapTag[] mapTags = tags.toArray(new MapTag[0]);\n-    for (int i = 0; i < mapTags.length; i++) {\n-      if (i != 0) {\n-        result.extra(Components.space());\n-      }\n-\n-      String mapTag = mapTags[i].getId();\n-      Component component =\n-          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)\n-              .bold(false)\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps -t \" + mapTag)\n-              .hoverEvent(\n-                  HoverEvent.Action.SHOW_TEXT,\n-                  new PersonalizedTranslatable(\"command.map.mapTag.hover\", mapTag).render());\n-      result.extra(component);\n-    }\n-    return result;\n-  }\n-\n-  private static Component createPlayerLimitComponent(CommandSender sender, MapInfo map) {\n-    checkNotNull(sender);\n-    checkNotNull(map);\n-\n-    Collection<Integer> maxPlayers = map.getMaxPlayers();\n-    if (maxPlayers.isEmpty()) {\n-      return Components.blank();\n-    } else if (maxPlayers.size() == 1) {\n-      return new PersonalizedText(maxPlayers.iterator().next().toString(), ChatColor.GOLD);\n-    }\n-\n-    int totalPlayers = maxPlayers.stream().mapToInt(i -> i).sum();\n-    Component total = new PersonalizedText(Integer.toString(totalPlayers), ChatColor.GOLD);\n-\n-    String verboseVs =\n-        \" \" + AllTranslations.get().translate(\"command.map.mapInfo.playerLimit.vs\", sender) + \" \";\n-    Component verbose =\n-        new PersonalizedText(\n-            new PersonalizedText(\"(\")\n-                .extra(\n-                    maxPlayers.stream()\n-                        .map(Object::toString)\n-                        .collect(Collectors.joining(verboseVs)))\n-                .extra(\")\"),\n-            ChatColor.GRAY);\n-\n-    return total.extra(\" \").extra(verbose);\n   }\n \n   @Command(\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -118,18 +145,75 @@ public class MapCommands {\n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            new PersonalizedText(String.valueOf(map.getPlayerLimit()), ChatColor.GOLD)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(map.getGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n               new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n+\n+      if (map instanceof MapContext) {\n+        audience.sendMessage(\n+            new PersonalizedText(\n+                mapInfoLabel(\"command.map.mapInfo.source\"),\n+                new PersonalizedText(((MapContext) map).getSource().getId(), ChatColor.GOLD)));\n+      }\n+    }\n+\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n+  }\n+\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n+    checkNotNull(tags);\n+\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n+    MapTag[] mapTags = tags.toArray(new MapTag[0]);\n+    for (int i = 0; i < mapTags.length; i++) {\n+      if (i != 0) {\n+        result.extra(Components.space());\n+      }\n+\n+      String mapTag = mapTags[i].toString();\n+      Component component =\n+          new PersonalizedText(mapTag, ChatColor.GOLD)\n+              .bold(false)\n+              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps \" + mapTag)\n+              .hoverEvent(\n+                  HoverEvent.Action.SHOW_TEXT,\n+                  new PersonalizedTranslatable(\"command.map.mapTag.hover\", mapTag).render());\n+      result.extra(component);\n     }\n+    return result;\n+  }\n+\n+  private static Component createPlayerLimitComponent(CommandSender sender, MapInfo map) {\n+    checkNotNull(sender);\n+    checkNotNull(map);\n+\n+    Collection<Integer> maxPlayers = map.getMaxPlayers();\n+    if (maxPlayers.isEmpty()) {\n+      return Components.blank();\n+    } else if (maxPlayers.size() == 1) {\n+      return new PersonalizedText(maxPlayers.iterator().next().toString(), ChatColor.GOLD);\n+    }\n+\n+    int totalPlayers = maxPlayers.stream().mapToInt(i -> i).sum();\n+    Component total = new PersonalizedText(Integer.toString(totalPlayers), ChatColor.GOLD);\n+\n+    String verboseVs =\n+        \" \" + AllTranslations.get().translate(\"command.map.mapInfo.playerLimit.vs\", sender) + \" \";\n+    Component verbose =\n+        new PersonalizedText(\n+            new PersonalizedText(\"(\")\n+                .extra(\n+                    maxPlayers.stream()\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(verboseVs)))\n+                .extra(\")\"),\n+            ChatColor.GRAY);\n+\n+    return total.extra(\" \").extra(verbose);\n   }\n \n   @Command(\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzc0OQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913749", "body": "`/maps` is an alias to `/maplist` so I would keep `/maplist` here. :P", "bodyText": "/maps is an alias to /maplist so I would keep /maplist here. :P", "bodyHTML": "<p dir=\"auto\"><code>/maps</code> is an alias to <code>/maplist</code> so I would keep <code>/maplist</code> here. :P</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:44:13Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)\n+              .bold(false)\n+              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps -t \" + mapTag)", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI0Nw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944247", "bodyText": "/maps is the main command.", "author": "Electroid", "createdAt": "2020-01-25T17:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 00360dfb..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -167,68 +118,18 @@ public class MapCommands {\n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, map)));\n+            new PersonalizedText(String.valueOf(map.getPlayerLimit()), ChatColor.GOLD)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n+      audience.sendMessage(\n+          new PersonalizedText(\n+              mapInfoLabel(\"command.map.mapInfo.genre\"),\n+              new PersonalizedText(map.getGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n               new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n-\n-    audience.sendMessage(createTagsComponent(map.getTags()));\n-  }\n-\n-  private Component createTagsComponent(Collection<MapTag> tags) {\n-    checkNotNull(tags);\n-\n-    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n-    MapTag[] mapTags = tags.toArray(new MapTag[0]);\n-    for (int i = 0; i < mapTags.length; i++) {\n-      if (i != 0) {\n-        result.extra(Components.space());\n-      }\n-\n-      String mapTag = mapTags[i].getId();\n-      Component component =\n-          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)\n-              .bold(false)\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps -t \" + mapTag)\n-              .hoverEvent(\n-                  HoverEvent.Action.SHOW_TEXT,\n-                  new PersonalizedTranslatable(\"command.map.mapTag.hover\", mapTag).render());\n-      result.extra(component);\n-    }\n-    return result;\n-  }\n-\n-  private static Component createPlayerLimitComponent(CommandSender sender, MapInfo map) {\n-    checkNotNull(sender);\n-    checkNotNull(map);\n-\n-    Collection<Integer> maxPlayers = map.getMaxPlayers();\n-    if (maxPlayers.isEmpty()) {\n-      return Components.blank();\n-    } else if (maxPlayers.size() == 1) {\n-      return new PersonalizedText(maxPlayers.iterator().next().toString(), ChatColor.GOLD);\n-    }\n-\n-    int totalPlayers = maxPlayers.stream().mapToInt(i -> i).sum();\n-    Component total = new PersonalizedText(Integer.toString(totalPlayers), ChatColor.GOLD);\n-\n-    String verboseVs =\n-        \" \" + AllTranslations.get().translate(\"command.map.mapInfo.playerLimit.vs\", sender) + \" \";\n-    Component verbose =\n-        new PersonalizedText(\n-            new PersonalizedText(\"(\")\n-                .extra(\n-                    maxPlayers.stream()\n-                        .map(Object::toString)\n-                        .collect(Collectors.joining(verboseVs)))\n-                .extra(\")\"),\n-            ChatColor.GRAY);\n-\n-    return total.extra(\" \").extra(verbose);\n   }\n \n   @Command(\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -118,18 +145,75 @@ public class MapCommands {\n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            new PersonalizedText(String.valueOf(map.getPlayerLimit()), ChatColor.GOLD)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(map.getGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n               new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n+\n+      if (map instanceof MapContext) {\n+        audience.sendMessage(\n+            new PersonalizedText(\n+                mapInfoLabel(\"command.map.mapInfo.source\"),\n+                new PersonalizedText(((MapContext) map).getSource().getId(), ChatColor.GOLD)));\n+      }\n+    }\n+\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n+  }\n+\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n+    checkNotNull(tags);\n+\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n+    MapTag[] mapTags = tags.toArray(new MapTag[0]);\n+    for (int i = 0; i < mapTags.length; i++) {\n+      if (i != 0) {\n+        result.extra(Components.space());\n+      }\n+\n+      String mapTag = mapTags[i].toString();\n+      Component component =\n+          new PersonalizedText(mapTag, ChatColor.GOLD)\n+              .bold(false)\n+              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps \" + mapTag)\n+              .hoverEvent(\n+                  HoverEvent.Action.SHOW_TEXT,\n+                  new PersonalizedTranslatable(\"command.map.mapTag.hover\", mapTag).render());\n+      result.extra(component);\n     }\n+    return result;\n+  }\n+\n+  private static Component createPlayerLimitComponent(CommandSender sender, MapInfo map) {\n+    checkNotNull(sender);\n+    checkNotNull(map);\n+\n+    Collection<Integer> maxPlayers = map.getMaxPlayers();\n+    if (maxPlayers.isEmpty()) {\n+      return Components.blank();\n+    } else if (maxPlayers.size() == 1) {\n+      return new PersonalizedText(maxPlayers.iterator().next().toString(), ChatColor.GOLD);\n+    }\n+\n+    int totalPlayers = maxPlayers.stream().mapToInt(i -> i).sum();\n+    Component total = new PersonalizedText(Integer.toString(totalPlayers), ChatColor.GOLD);\n+\n+    String verboseVs =\n+        \" \" + AllTranslations.get().translate(\"command.map.mapInfo.playerLimit.vs\", sender) + \" \";\n+    Component verbose =\n+        new PersonalizedText(\n+            new PersonalizedText(\"(\")\n+                .extra(\n+                    maxPlayers.stream()\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(verboseVs)))\n+                .extra(\")\"),\n+            ChatColor.GRAY);\n+\n+    return total.extra(\" \").extra(verbose);\n   }\n \n   @Command(\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzkyMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913920", "body": "We completly have lost tab suggestion for maptags :(", "bodyText": "We completly have lost tab suggestion for maptags :(", "bodyHTML": "<p dir=\"auto\">We completly have lost tab suggestion for maptags :(</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:49:22Z", "path": "src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java", "diffHunk": "@@ -1,108 +0,0 @@\n-package tc.oc.pgm.commands.provider;\n-\n-import static com.google.common.base.Preconditions.*;\n-\n-import app.ashcon.intake.argument.ArgumentException;\n-import app.ashcon.intake.argument.CommandArgs;\n-import app.ashcon.intake.argument.Namespace;\n-import app.ashcon.intake.parametric.Provider;\n-import app.ashcon.intake.parametric.ProvisionException;\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import javax.annotation.Nullable;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n-import tc.oc.util.Pair;\n-\n-public class MapTagsConditionProvider implements Provider<MapTagsCondition> {\n-\n-  private static final String PREFIX = Character.toString(MapTag.SYMBOL);\n-  private static final String NEGATION = \"!\";\n-\n-  private final MapLibrary mapLibrary;\n-\n-  public MapTagsConditionProvider(MapLibrary mapLibrary) {\n-    this.mapLibrary = checkNotNull(mapLibrary);\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return \"maptags\";\n-  }\n-\n-  @Nullable\n-  @Override\n-  public MapTagsCondition get(CommandArgs args, List<? extends Annotation> list)\n-      throws ArgumentException, ProvisionException {\n-    Map<MapTag, Boolean> mapTags = new HashMap<>();\n-    while (args.hasNext()) {\n-      parseMapTag(args.next())\n-          .ifPresent(\n-              pair -> {\n-                if (!pair.first.isEmpty()) {\n-                  mapTags.put(MapTag.forName(pair.first), pair.second);\n-                }\n-              });\n-    }\n-\n-    return new MapTagsCondition(mapTags);\n-  }\n-\n-  @Override\n-  public List<String> getSuggestions(\n-      String prefix, Namespace namespace, List<? extends Annotation> modifiers) {\n-    return parseMapTag(prefix)\n-        .map(\n-            pair -> {\n-              Set<String> mapTags = new TreeSet<>(Comparator.naturalOrder());\n-              for (PGMMap map : mapLibrary.getMaps()) {\n-                for (MapTag mapTag : map.getPersistentContext().getMapTags()) {\n-                  if (mapTag.getName().startsWith(pair.first)) {\n-                    mapTags.add(mapTagToString(mapTag, pair.second));\n-                  }\n-                }\n-              }\n-\n-              return (List<String>) new ArrayList<>(mapTags);\n-            })\n-        .orElse(Collections.emptyList());\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java b/src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java\nnew file mode 100644\nindex 00000000..89441ad2\n--- /dev/null\n+++ b/src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java\n", "chunk": "@@ -0,0 +1,108 @@\n+package tc.oc.pgm.commands.provider;\n+\n+import static com.google.common.base.Preconditions.*;\n+\n+import app.ashcon.intake.argument.ArgumentException;\n+import app.ashcon.intake.argument.CommandArgs;\n+import app.ashcon.intake.argument.Namespace;\n+import app.ashcon.intake.parametric.Provider;\n+import app.ashcon.intake.parametric.ProvisionException;\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.Nullable;\n+import tc.oc.pgm.map.MapLibrary;\n+import tc.oc.pgm.map.PGMMap;\n+import tc.oc.pgm.maptag.MapTag;\n+import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.util.Pair;\n+\n+public class MapTagsConditionProvider implements Provider<MapTagsCondition> {\n+\n+  private static final String PREFIX = Character.toString(MapTag.SYMBOL);\n+  private static final String NEGATION = \"!\";\n+\n+  private final MapLibrary mapLibrary;\n+\n+  public MapTagsConditionProvider(MapLibrary mapLibrary) {\n+    this.mapLibrary = checkNotNull(mapLibrary);\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return \"maptags\";\n+  }\n+\n+  @Nullable\n+  @Override\n+  public MapTagsCondition get(CommandArgs args, List<? extends Annotation> list)\n+      throws ArgumentException, ProvisionException {\n+    Map<MapTag, Boolean> mapTags = new HashMap<>();\n+    while (args.hasNext()) {\n+      parseMapTag(args.next())\n+          .ifPresent(\n+              pair -> {\n+                if (!pair.first.isEmpty()) {\n+                  mapTags.put(MapTag.forName(pair.first), pair.second);\n+                }\n+              });\n+    }\n+\n+    return new MapTagsCondition(mapTags);\n+  }\n+\n+  @Override\n+  public List<String> getSuggestions(\n+      String prefix, Namespace namespace, List<? extends Annotation> modifiers) {\n+    return parseMapTag(prefix)\n+        .map(\n+            pair -> {\n+              Set<String> mapTags = new TreeSet<>(Comparator.naturalOrder());\n+              for (PGMMap map : mapLibrary.getMaps()) {\n+                for (MapTag mapTag : map.getPersistentContext().getMapTags()) {\n+                  if (mapTag.getName().startsWith(pair.first)) {\n+                    mapTags.add(mapTagToString(mapTag, pair.second));\n+                  }\n+                }\n+              }\n+\n+              return (List<String>) new ArrayList<>(mapTags);\n+            })\n+        .orElse(Collections.emptyList());\n+  }\n+\n+  private Optional<Pair<String, Boolean>> parseMapTag(String query) {\n+    checkNotNull(query);\n+    query = query.toLowerCase(Locale.ROOT);\n+    boolean allow = true;\n+\n+    if (query.startsWith(NEGATION)) {\n+      query = query.substring(NEGATION.length());\n+      allow = false;\n+    }\n+\n+    if (!query.startsWith(PREFIX)) {\n+      return Optional.empty();\n+    }\n+\n+    query = query.substring(PREFIX.length());\n+    return Optional.of(Pair.create(query, allow));\n+  }\n+\n+  private String mapTagToString(MapTag mapTag, boolean allow) {\n+    StringBuilder toString = new StringBuilder();\n+    if (!allow) {\n+      toString.append(NEGATION);\n+    }\n+    toString.append(mapTag.toString());\n+    return toString.toString();\n+  }\n+}\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java b/src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java\ndeleted file mode 100644\nindex 89441ad2..00000000\n--- a/src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java\n+++ /dev/null\n", "chunk": "@@ -1,108 +0,0 @@\n-package tc.oc.pgm.commands.provider;\n-\n-import static com.google.common.base.Preconditions.*;\n-\n-import app.ashcon.intake.argument.ArgumentException;\n-import app.ashcon.intake.argument.CommandArgs;\n-import app.ashcon.intake.argument.Namespace;\n-import app.ashcon.intake.parametric.Provider;\n-import app.ashcon.intake.parametric.ProvisionException;\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import javax.annotation.Nullable;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n-import tc.oc.util.Pair;\n-\n-public class MapTagsConditionProvider implements Provider<MapTagsCondition> {\n-\n-  private static final String PREFIX = Character.toString(MapTag.SYMBOL);\n-  private static final String NEGATION = \"!\";\n-\n-  private final MapLibrary mapLibrary;\n-\n-  public MapTagsConditionProvider(MapLibrary mapLibrary) {\n-    this.mapLibrary = checkNotNull(mapLibrary);\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return \"maptags\";\n-  }\n-\n-  @Nullable\n-  @Override\n-  public MapTagsCondition get(CommandArgs args, List<? extends Annotation> list)\n-      throws ArgumentException, ProvisionException {\n-    Map<MapTag, Boolean> mapTags = new HashMap<>();\n-    while (args.hasNext()) {\n-      parseMapTag(args.next())\n-          .ifPresent(\n-              pair -> {\n-                if (!pair.first.isEmpty()) {\n-                  mapTags.put(MapTag.forName(pair.first), pair.second);\n-                }\n-              });\n-    }\n-\n-    return new MapTagsCondition(mapTags);\n-  }\n-\n-  @Override\n-  public List<String> getSuggestions(\n-      String prefix, Namespace namespace, List<? extends Annotation> modifiers) {\n-    return parseMapTag(prefix)\n-        .map(\n-            pair -> {\n-              Set<String> mapTags = new TreeSet<>(Comparator.naturalOrder());\n-              for (PGMMap map : mapLibrary.getMaps()) {\n-                for (MapTag mapTag : map.getPersistentContext().getMapTags()) {\n-                  if (mapTag.getName().startsWith(pair.first)) {\n-                    mapTags.add(mapTagToString(mapTag, pair.second));\n-                  }\n-                }\n-              }\n-\n-              return (List<String>) new ArrayList<>(mapTags);\n-            })\n-        .orElse(Collections.emptyList());\n-  }\n-\n-  private Optional<Pair<String, Boolean>> parseMapTag(String query) {\n-    checkNotNull(query);\n-    query = query.toLowerCase(Locale.ROOT);\n-    boolean allow = true;\n-\n-    if (query.startsWith(NEGATION)) {\n-      query = query.substring(NEGATION.length());\n-      allow = false;\n-    }\n-\n-    if (!query.startsWith(PREFIX)) {\n-      return Optional.empty();\n-    }\n-\n-    query = query.substring(PREFIX.length());\n-    return Optional.of(Pair.create(query, allow));\n-  }\n-\n-  private String mapTagToString(MapTag mapTag, boolean allow) {\n-    StringBuilder toString = new StringBuilder();\n-    if (!allow) {\n-      toString.append(NEGATION);\n-    }\n-    toString.append(mapTag.toString());\n-    return toString.toString();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDAxMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914013", "body": "I feel that we should make the description a BaseComponent too. `Control The Point` should be translatable.", "bodyText": "I feel that we should make the description a BaseComponent too. Control The Point should be translatable.", "bodyHTML": "<p dir=\"auto\">I feel that we should make the description a BaseComponent too. <code>Control The Point</code> should be translatable.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:51:58Z", "path": "src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java", "diffHunk": "@@ -2,81 +2,92 @@\n \n import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n import java.util.logging.Logger;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.filters.FilterModule;\n import tc.oc.pgm.goals.GoalMatchModule;\n-import tc.oc.pgm.goals.GoalModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n import tc.oc.pgm.regions.RegionModule;\n import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Control Points\",\n-    depends = {TeamModule.class, GoalModule.class, RegionModule.class, FilterModule.class})\n-public class ControlPointModule extends MapModule<ControlPointMatchModule> {\n-\n-  private static final MapTag CONTROLPOINT_TAG = MapTag.forName(\"controlpoint\");\n+public class ControlPointModule implements MapModule<ControlPointMatchModule> {\n \n+  private static final Collection<MapTag> TAGS =\n+      ImmutableList.of(MapTag.create(\"controlpoint\", \"Control the Point\", true, false));", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI1OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944258", "bodyText": "In the future, not today.", "author": "Electroid", "createdAt": "2020-01-25T17:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\nindex 76572fc7..cfd4194a 100644\n--- a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n+++ b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n", "chunk": "@@ -21,10 +19,8 @@ import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-public class ControlPointModule implements MapModule<ControlPointMatchModule> {\n+public class ControlPointModule implements MapModule {\n \n-  private static final Collection<MapTag> TAGS =\n-      ImmutableList.of(MapTag.create(\"controlpoint\", \"Control the Point\", true, false));\n   private final List<ControlPointDefinition> definitions;\n \n   public ControlPointModule(List<ControlPointDefinition> definitions) {\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\nindex cfd4194a..f24cd796 100644\n--- a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n+++ b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n", "chunk": "@@ -19,6 +15,11 @@ import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n public class ControlPointModule implements MapModule {\n \n   private final List<ControlPointDefinition> definitions;\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\nindex f24cd796..8cadb47c 100644\n--- a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n+++ b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n", "chunk": "@@ -15,11 +19,6 @@ import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.logging.Logger;\n-\n public class ControlPointModule implements MapModule {\n \n   private final List<ControlPointDefinition> definitions;\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\nindex 8cadb47c..6b527746 100644\n--- a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n+++ b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n", "chunk": "@@ -19,17 +21,27 @@ import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-public class ControlPointModule implements MapModule {\n+public class ControlPointModule implements MapModule, MapInfoExtra {\n \n   private final List<ControlPointDefinition> definitions;\n+  private final boolean mostlyPermanent;\n \n   public ControlPointModule(List<ControlPointDefinition> definitions) {\n     this.definitions = definitions;\n+    this.mostlyPermanent =\n+        definitions.stream().filter(ControlPointDefinition::isPermanent).count()\n+                / Math.max(definitions.size(), 1)\n+            >= 0.5;\n+  }\n+\n+  @Override\n+  public String getGenre() {\n+    return mostlyPermanent ? \"Capture the Point\" : \"Control the Point\";\n   }\n \n   @Override\n   public MatchModule createMatchModule(Match match) {\n-    ImmutableList.Builder<ControlPoint> controlPoints = new ImmutableList.Builder<>();\n+    List<ControlPoint> controlPoints = new LinkedList<>();\n \n     for (ControlPointDefinition definition : this.definitions) {\n       ControlPoint controlPoint = new ControlPoint(match, definition);\n", "next_change": {"commit": "f048768e4874fe36201ab51542a5b15b4a9bc9f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\nindex 6b527746..76572fc7 100644\n--- a/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n+++ b/src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java\n", "chunk": "@@ -21,26 +21,23 @@ import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-public class ControlPointModule implements MapModule, MapInfoExtra {\n+public class ControlPointModule implements MapModule<ControlPointMatchModule> {\n \n+  private static final Collection<MapTag> TAGS =\n+      ImmutableList.of(MapTag.create(\"controlpoint\", \"Control the Point\", true, false));\n   private final List<ControlPointDefinition> definitions;\n-  private final boolean mostlyPermanent;\n \n   public ControlPointModule(List<ControlPointDefinition> definitions) {\n     this.definitions = definitions;\n-    this.mostlyPermanent =\n-        definitions.stream().filter(ControlPointDefinition::isPermanent).count()\n-                / Math.max(definitions.size(), 1)\n-            >= 0.5;\n   }\n \n   @Override\n-  public String getGenre() {\n-    return mostlyPermanent ? \"Capture the Point\" : \"Control the Point\";\n+  public Collection<Class<? extends MatchModule>> getSoftDependencies() {\n+    return ImmutableList.of(GoalMatchModule.class);\n   }\n \n   @Override\n-  public MatchModule createMatchModule(Match match) {\n+  public ControlPointMatchModule createMatchModule(Match match) {\n     List<ControlPoint> controlPoints = new LinkedList<>();\n \n     for (ControlPointDefinition definition : this.definitions) {\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDE2NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914164", "body": "Why complete removal?", "bodyText": "Why complete removal?", "bodyHTML": "<p dir=\"auto\">Why complete removal?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:56:10Z", "path": "src/main/java/tc/oc/pgm/damage/DisableDamageModule.java", "diffHunk": "@@ -2,73 +2,63 @@\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.SetMultimap;\n-import java.util.Set;\n import java.util.logging.Logger;\n import org.bukkit.event.entity.EntityDamageEvent.DamageCause;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.api.player.PlayerRelation;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n-@ModuleDescription(name = \"DisableDamage\")\n-public class DisableDamageModule extends MapModule<DisableDamageMatchModule> {\n-\n-  private static final MapTag NOFALLDAMAGE_TAG = MapTag.forName(\"nofalldamage\");\n-\n+public class DisableDamageModule implements MapModule {\n   protected final SetMultimap<DamageCause, PlayerRelation> causes;\n \n   public DisableDamageModule(SetMultimap<DamageCause, PlayerRelation> causes) {\n     this.causes = causes;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (causes.containsKey(DamageCause.FALL)) tags.add(NOFALLDAMAGE_TAG);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDUxMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914510", "body": "Fix the * import, please.", "bodyText": "Fix the * import, please.", "bodyHTML": "<p dir=\"auto\">Fix the * import, please.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:05:38Z", "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "diffHunk": "@@ -1,14 +1,13 @@\n package tc.oc.pgm.listeners;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\nindex d4eb0bb9..0d1c5b7b 100644\n--- a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n+++ b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n", "chunk": "@@ -1,6 +1,6 @@\n package tc.oc.pgm.listeners;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.*;\n \n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\nindex 0d1c5b7b..66d7ff14 100644\n--- a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n+++ b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n", "chunk": "@@ -1,14 +1,12 @@\n package tc.oc.pgm.listeners;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n import com.google.gson.JsonArray;\n import com.google.gson.JsonObject;\n-import com.google.gson.JsonPrimitive;\n-import java.util.UUID;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n", "next_change": {"commit": "880a7bc94df17b2871006fd79dac1877f7df3886", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\nindex 66d7ff14..d4eb0bb9 100644\n--- a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n+++ b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n", "chunk": "@@ -7,6 +7,7 @@ import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n import com.google.gson.JsonArray;\n import com.google.gson.JsonObject;\n+import com.google.gson.JsonPrimitive;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDY1MA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914650", "body": "This is going to break at least OCC website. The slug is used to locate map icons afaik. Can we leave `slug` here, please?", "bodyText": "This is going to break at least OCC website. The slug is used to locate map icons afaik. Can we leave slug here, please?", "bodyHTML": "<p dir=\"auto\">This is going to break at least OCC website. The slug is used to locate map icons afaik. Can we leave <code>slug</code> here, please?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:08:57Z", "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "diffHunk": "@@ -101,40 +101,34 @@ private void serializeMatch(Match match, JsonObject jsonObject) {\n   private void appendNextMap(JsonObject jsonObject) {\n     checkNotNull(jsonObject);\n \n-    PGMMapOrder mapOrder = this.matchManager.getMapOrder();\n-    if (mapOrder != null) {\n-      PGMMap nextMap = mapOrder.getNextMap();\n+    MapInfo nextMap = mapOrder.getNextMap();\n \n-      if (nextMap != null) {\n-        JsonObject nextMapObject = new JsonObject();\n-        this.serializeMap(nextMap, nextMapObject);\n-        jsonObject.add(\"next_map\", nextMapObject);\n-      }\n+    if (nextMap != null) {\n+      JsonObject nextMapObject = new JsonObject();\n+      this.serializeMap(nextMap, nextMapObject);\n+      jsonObject.add(\"next_map\", nextMapObject);\n     }\n   }\n \n-  private void serializeMap(PGMMap map, JsonObject jsonObject) {\n+  private void serializeMap(MapInfo map, JsonObject jsonObject) {\n     checkNotNull(map);\n     checkNotNull(jsonObject);\n \n-    MapInfo mapInfo = map.getInfo();\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    jsonObject.addProperty(\"slug\", mapInfo.slug());\n-    jsonObject.addProperty(\"name\", mapInfo.name);\n-    jsonObject.addProperty(\"version\", mapInfo.version.toString());\n-    jsonObject.addProperty(\"objective\", mapInfo.objective);\n+    jsonObject.addProperty(\"id\", map.getId());", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NzIwOQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370947209", "bodyText": "<slug> is becoming <id> so I think we'll have to accept this breaking change.", "author": "Electroid", "createdAt": "2020-01-25T18:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\nindex d4eb0bb9..0d1c5b7b 100644\n--- a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n+++ b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n", "chunk": "@@ -101,34 +101,40 @@ public class ServerPingDataListener implements Listener {\n   private void appendNextMap(JsonObject jsonObject) {\n     checkNotNull(jsonObject);\n \n-    MapInfo nextMap = mapOrder.getNextMap();\n+    PGMMapOrder mapOrder = this.matchManager.getMapOrder();\n+    if (mapOrder != null) {\n+      PGMMap nextMap = mapOrder.getNextMap();\n \n-    if (nextMap != null) {\n-      JsonObject nextMapObject = new JsonObject();\n-      this.serializeMap(nextMap, nextMapObject);\n-      jsonObject.add(\"next_map\", nextMapObject);\n+      if (nextMap != null) {\n+        JsonObject nextMapObject = new JsonObject();\n+        this.serializeMap(nextMap, nextMapObject);\n+        jsonObject.add(\"next_map\", nextMapObject);\n+      }\n     }\n   }\n \n-  private void serializeMap(MapInfo map, JsonObject jsonObject) {\n+  private void serializeMap(PGMMap map, JsonObject jsonObject) {\n     checkNotNull(map);\n     checkNotNull(jsonObject);\n \n-    jsonObject.addProperty(\"id\", map.getId());\n-    jsonObject.addProperty(\"name\", map.getName());\n-    jsonObject.addProperty(\"version\", map.getVersion().toString());\n-    jsonObject.addProperty(\"objective\", map.getDescription());\n+    MapInfo mapInfo = map.getInfo();\n+    MapPersistentContext persistentContext = map.getPersistentContext();\n+\n+    jsonObject.addProperty(\"slug\", mapInfo.slug());\n+    jsonObject.addProperty(\"name\", mapInfo.name);\n+    jsonObject.addProperty(\"version\", mapInfo.version.toString());\n+    jsonObject.addProperty(\"objective\", mapInfo.objective);\n \n     JsonArray tags = new JsonArray();\n-    for (MapTag mapTag : map.getTags()) {\n-      tags.add(new JsonPrimitive(mapTag.getId()));\n+    for (MapTag mapTag : persistentContext.getMapTags()) {\n+      tags.add(new JsonPrimitive(mapTag.getName()));\n     }\n     if (tags.iterator().hasNext()) {\n       jsonObject.add(\"tags\", tags);\n     }\n \n     JsonArray authors = new JsonArray();\n-    for (Contributor author : map.getAuthors()) {\n+    for (Contributor author : mapInfo.authors) {\n       JsonObject authorObject = new JsonObject();\n       this.serializeContributor(author, authorObject);\n       authors.add(authorObject);\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\nindex 0d1c5b7b..66d7ff14 100644\n--- a/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n+++ b/src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java\n", "chunk": "@@ -101,40 +99,35 @@ public class ServerPingDataListener implements Listener {\n   private void appendNextMap(JsonObject jsonObject) {\n     checkNotNull(jsonObject);\n \n-    PGMMapOrder mapOrder = this.matchManager.getMapOrder();\n-    if (mapOrder != null) {\n-      PGMMap nextMap = mapOrder.getNextMap();\n+    MapInfo nextMap = mapOrder.getNextMap();\n \n-      if (nextMap != null) {\n-        JsonObject nextMapObject = new JsonObject();\n-        this.serializeMap(nextMap, nextMapObject);\n-        jsonObject.add(\"next_map\", nextMapObject);\n-      }\n+    if (nextMap != null) {\n+      JsonObject nextMapObject = new JsonObject();\n+      this.serializeMap(nextMap, nextMapObject);\n+      jsonObject.add(\"next_map\", nextMapObject);\n     }\n   }\n \n-  private void serializeMap(PGMMap map, JsonObject jsonObject) {\n+  private void serializeMap(MapInfo map, JsonObject jsonObject) {\n     checkNotNull(map);\n     checkNotNull(jsonObject);\n \n-    MapInfo mapInfo = map.getInfo();\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    jsonObject.addProperty(\"slug\", mapInfo.slug());\n-    jsonObject.addProperty(\"name\", mapInfo.name);\n-    jsonObject.addProperty(\"version\", mapInfo.version.toString());\n-    jsonObject.addProperty(\"objective\", mapInfo.objective);\n+    jsonObject.addProperty(\"slug\", map.getId());\n+    jsonObject.addProperty(\"name\", map.getName());\n+    jsonObject.addProperty(\"version\", map.getVersion().toString());\n+    jsonObject.addProperty(\"objective\", map.getDescription());\n \n     JsonArray tags = new JsonArray();\n-    for (MapTag mapTag : persistentContext.getMapTags()) {\n+    // FIXME: map tags\n+    /*for (MapTag mapTag : persistentContext.getMapTags()) {\n       tags.add(new JsonPrimitive(mapTag.getName()));\n-    }\n+    }*/\n     if (tags.iterator().hasNext()) {\n       jsonObject.add(\"tags\", tags);\n     }\n \n     JsonArray authors = new JsonArray();\n-    for (Contributor author : mapInfo.authors) {\n+    for (Contributor author : map.getAuthors()) {\n       JsonObject authorObject = new JsonObject();\n       this.serializeContributor(author, authorObject);\n       authors.add(authorObject);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDc5MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914791", "body": "Why is this an integer instead of a Difficulty?", "bodyText": "Why is this an integer instead of a Difficulty?", "bodyHTML": "<p dir=\"auto\">Why is this an integer instead of a Difficulty?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:13:23Z", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI4MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944281", "bodyText": "See other comment.", "author": "Electroid", "createdAt": "2020-01-25T17:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDc5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 41e694ca..1284ad74 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -55,7 +56,8 @@ public class MapInfoImpl implements MapInfo {\n       @Nullable Collection<String> rules,\n       @Nullable Integer difficulty,\n       @Nullable Collection<MapTag> tags,\n-      @Nullable Collection<Integer> players) {\n+      @Nullable Collection<Integer> players,\n+      @Nullable WorldInfo world) {\n     this.name = checkNotNull(name);\n     this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n     this.proto = checkNotNull(proto);\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 1284ad74..b992f453 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -2,111 +2,76 @@ package tc.oc.pgm.map;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import com.google.common.collect.ImmutableList;\n+import java.text.Normalizer;\n import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n-import java.util.TreeSet;\n import java.util.UUID;\n-import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n-import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.CompareToBuilder;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Bukkit;\n import org.bukkit.Difficulty;\n+import org.jdom2.Document;\n import org.jdom2.Element;\n import tc.oc.component.Component;\n import tc.oc.component.types.PersonalizedText;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.AllTranslations;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.map.Contributor;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapTag;\n-import tc.oc.pgm.api.map.WorldInfo;\n+import tc.oc.pgm.api.map.ProtoVersions;\n import tc.oc.pgm.map.contrib.PlayerContributor;\n import tc.oc.pgm.map.contrib.PseudonymContributor;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.server.NullCommandSender;\n-import tc.oc.util.Version;\n+import tc.oc.util.SemanticVersion;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n public class MapInfoImpl implements MapInfo {\n+\n   private final String id;\n-  private final Version proto;\n-  private final Version version;\n+  private final SemanticVersion proto;\n+  private final SemanticVersion version;\n   private final String name;\n+  private final String genre;\n   private final String description;\n   private final Collection<Contributor> authors;\n   private final Collection<Contributor> contributors;\n   private final Collection<String> rules;\n-  private final int difficulty;\n-  private final WorldInfo world;\n-\n-  protected final Collection<MapTag> tags;\n-  protected final Collection<Integer> players;\n+  private final Difficulty difficulty;\n+  private final Collection<Integer> teamLimits;\n+  private final int playerLimit;\n \n   public MapInfoImpl(\n       @Nullable String id,\n-      Version proto,\n-      Version version,\n+      SemanticVersion proto,\n+      SemanticVersion version,\n       String name,\n+      String genre,\n       String description,\n-      @Nullable Collection<Contributor> authors,\n-      @Nullable Collection<Contributor> contributors,\n-      @Nullable Collection<String> rules,\n-      @Nullable Integer difficulty,\n-      @Nullable Collection<MapTag> tags,\n-      @Nullable Collection<Integer> players,\n-      @Nullable WorldInfo world) {\n-    this.name = checkNotNull(name);\n-    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+      Collection<Contributor> authors,\n+      Collection<Contributor> contributors,\n+      Collection<String> rules,\n+      Difficulty difficulty,\n+      Collection<Integer> teamLimits,\n+      int playerLimit) {\n     this.proto = checkNotNull(proto);\n     this.version = checkNotNull(version);\n+    this.name = checkNotNull(name);\n+    this.genre = checkNotNull(genre);\n     this.description = checkNotNull(description);\n-    this.authors = authors == null ? new LinkedList<>() : authors;\n-    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n-    this.rules = rules == null ? new LinkedList<>() : rules;\n-    this.difficulty = difficulty == null ? Difficulty.NORMAL.ordinal() : difficulty;\n-    this.tags = tags == null ? new TreeSet<>() : tags;\n-    this.players = players == null ? new LinkedList<>() : players;\n-    this.world = world == null ? new WorldInfoImpl() : world;\n-  }\n-\n-  public MapInfoImpl(MapInfo info) {\n-    this(\n-        checkNotNull(info).getId(),\n-        info.getProto(),\n-        info.getVersion(),\n-        info.getName(),\n-        info.getDescription(),\n-        info.getAuthors(),\n-        info.getContributors(),\n-        info.getRules(),\n-        info.getDifficulty(),\n-        info.getTags(),\n-        info.getMaxPlayers(),\n-        info.getWorld());\n-  }\n-\n-  public MapInfoImpl(Element root) throws InvalidXMLException {\n-    this(\n-        checkNotNull(root).getChildTextNormalize(\"slug\"),\n-        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n-        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n-        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n-        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n-        parseContributors(root, \"author\"),\n-        parseContributors(root, \"contributor\"),\n-        parseRules(root),\n-        XMLUtils.parseEnum(\n-                Node.fromLastChildOrAttr(root, \"difficulty\"),\n-                Difficulty.class,\n-                \"difficulty\",\n-                Difficulty.NORMAL)\n-            .ordinal(),\n-        null,\n-        null,\n-        parseWorld(root));\n+    this.authors = ImmutableList.copyOf(checkNotNull(authors));\n+    this.contributors = ImmutableList.copyOf(checkNotNull(contributors));\n+    this.rules = ImmutableList.copyOf(checkNotNull(rules));\n+    this.difficulty = checkNotNull(difficulty);\n+    this.teamLimits = ImmutableList.copyOf(checkNotNull(teamLimits));\n+    this.playerLimit = Math.max(1, playerLimit);\n+    this.id = checkNotNull(normalizeName(id == null ? this.name : id));\n   }\n \n   @Override\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex b992f453..79735e2c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -1,77 +1,86 @@\n package tc.oc.pgm.map;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n import com.google.common.collect.ImmutableList;\n-import java.text.Normalizer;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.UUID;\n-import javax.annotation.Nullable;\n-import org.apache.commons.lang3.builder.CompareToBuilder;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ToStringBuilder;\n-import org.bukkit.Bukkit;\n import org.bukkit.Difficulty;\n-import org.jdom2.Document;\n import org.jdom2.Element;\n-import tc.oc.component.Component;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.map.Contributor;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.ProtoVersions;\n import tc.oc.pgm.map.contrib.PlayerContributor;\n import tc.oc.pgm.map.contrib.PseudonymContributor;\n import tc.oc.pgm.util.XMLUtils;\n-import tc.oc.server.NullCommandSender;\n import tc.oc.util.SemanticVersion;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n+import javax.annotation.Nullable;\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n public class MapInfoImpl implements MapInfo {\n \n   private final String id;\n   private final SemanticVersion proto;\n   private final SemanticVersion version;\n   private final String name;\n-  private final String genre;\n   private final String description;\n   private final Collection<Contributor> authors;\n   private final Collection<Contributor> contributors;\n   private final Collection<String> rules;\n   private final Difficulty difficulty;\n-  private final Collection<Integer> teamLimits;\n-  private final int playerLimit;\n \n   public MapInfoImpl(\n       @Nullable String id,\n       SemanticVersion proto,\n       SemanticVersion version,\n       String name,\n-      String genre,\n       String description,\n-      Collection<Contributor> authors,\n-      Collection<Contributor> contributors,\n-      Collection<String> rules,\n-      Difficulty difficulty,\n-      Collection<Integer> teamLimits,\n-      int playerLimit) {\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Difficulty difficulty) {\n     this.proto = checkNotNull(proto);\n     this.version = checkNotNull(version);\n     this.name = checkNotNull(name);\n-    this.genre = checkNotNull(genre);\n     this.description = checkNotNull(description);\n-    this.authors = ImmutableList.copyOf(checkNotNull(authors));\n-    this.contributors = ImmutableList.copyOf(checkNotNull(contributors));\n-    this.rules = ImmutableList.copyOf(checkNotNull(rules));\n-    this.difficulty = checkNotNull(difficulty);\n-    this.teamLimits = ImmutableList.copyOf(checkNotNull(teamLimits));\n-    this.playerLimit = Math.max(1, playerLimit);\n-    this.id = checkNotNull(normalizeName(id == null ? this.name : id));\n+    this.authors =\n+        authors == null || authors.isEmpty()\n+            ? Collections.emptyList()\n+            : ImmutableList.copyOf(authors);\n+    this.contributors =\n+        contributors == null || contributors.isEmpty()\n+            ? Collections.emptyList()\n+            : ImmutableList.copyOf(contributors);\n+    this.rules =\n+        rules == null || rules.isEmpty() ? Collections.emptyList() : ImmutableList.copyOf(rules);\n+    this.difficulty = difficulty == null ? Difficulty.NORMAL : difficulty;\n+    this.id = checkNotNull(normalizeName(id == null ? name : id));\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(checkNotNull(info).getId(), info.getProto(), info.getVersion(), info.getName(), info.getDescription(), info.getAuthors(), info.getContributors(), info.getRules(), info.getDifficulty());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {\n+    this(\n+        checkNotNull(root).getChildTextNormalize(\"slug\"),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n+        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n+        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n+        parseContributors(root, \"author\"),\n+        parseContributors(root, \"contributor\"),\n+        parseRules(root),\n+        XMLUtils.parseEnum(\n+            Node.fromLastChildOrAttr(root, \"difficulty\"), Difficulty.class, \"difficulty\"));\n   }\n \n   @Override\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 79735e2c..aea10612 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -80,7 +88,14 @@ public class MapInfoImpl implements MapInfo {\n         parseContributors(root, \"contributor\"),\n         parseRules(root),\n         XMLUtils.parseEnum(\n-            Node.fromLastChildOrAttr(root, \"difficulty\"), Difficulty.class, \"difficulty\"));\n+                Node.fromLastChildOrAttr(root, \"difficulty\"),\n+                Difficulty.class,\n+                \"difficulty\",\n+                Difficulty.NORMAL)\n+            .ordinal(),\n+        null,\n+        null,\n+        null);\n   }\n \n   @Override\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex aea10612..41e694ca 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -94,7 +101,6 @@ public class MapInfoImpl implements MapInfo {\n                 Difficulty.NORMAL)\n             .ordinal(),\n         null,\n-        null,\n         null);\n   }\n \n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 41e694ca..1284ad74 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -101,7 +105,8 @@ public class MapInfoImpl implements MapInfo {\n                 Difficulty.NORMAL)\n             .ordinal(),\n         null,\n-        null);\n+        null,\n+        parseWorld(root));\n   }\n \n   @Override\n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 79735e2c..aea10612 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -89,12 +104,12 @@ public class MapInfoImpl implements MapInfo {\n   }\n \n   @Override\n-  public SemanticVersion getProto() {\n+  public Version getProto() {\n     return proto;\n   }\n \n   @Override\n-  public SemanticVersion getVersion() {\n+  public Version getVersion() {\n     return version;\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDg1NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914855", "body": "I think we should make a public static factory method to parse the XML and return a new instance of this class.", "bodyText": "I think we should make a public static factory method to parse the XML and return a new instance of this class.", "bodyHTML": "<p dir=\"auto\">I think we should make a public static factory method to parse the XML and return a new instance of this class.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:15:29Z", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,\n+      @Nullable Collection<MapTag> tags,\n+      @Nullable Collection<Integer> players) {\n+    this.name = checkNotNull(name);\n+    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+    this.proto = checkNotNull(proto);\n+    this.version = checkNotNull(version);\n+    this.description = checkNotNull(description);\n+    this.authors = authors == null ? new LinkedList<>() : authors;\n+    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n+    this.rules = rules == null ? new LinkedList<>() : rules;\n+    this.difficulty = difficulty == null ? DEFAULT_DIFFICULTY : difficulty;\n+    this.tags = tags == null ? new TreeSet<>() : tags;\n+    this.players = players == null ? new LinkedList<>() : players;\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(\n+        checkNotNull(info).getId(),\n+        info.getProto(),\n+        info.getVersion(),\n+        info.getName(),\n+        info.getDescription(),\n+        info.getAuthors(),\n+        info.getContributors(),\n+        info.getRules(),\n+        info.getDifficulty(),\n+        info.getTags(),\n+        info.getMaxPlayers());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 41e694ca..1284ad74 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -81,7 +84,8 @@ public class MapInfoImpl implements MapInfo {\n         info.getRules(),\n         info.getDifficulty(),\n         info.getTags(),\n-        info.getMaxPlayers());\n+        info.getMaxPlayers(),\n+        info.getWorld());\n   }\n \n   public MapInfoImpl(Element root) throws InvalidXMLException {\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 1284ad74..b992f453 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -2,111 +2,76 @@ package tc.oc.pgm.map;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import com.google.common.collect.ImmutableList;\n+import java.text.Normalizer;\n import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n-import java.util.TreeSet;\n import java.util.UUID;\n-import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n-import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.CompareToBuilder;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Bukkit;\n import org.bukkit.Difficulty;\n+import org.jdom2.Document;\n import org.jdom2.Element;\n import tc.oc.component.Component;\n import tc.oc.component.types.PersonalizedText;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.AllTranslations;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.map.Contributor;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapTag;\n-import tc.oc.pgm.api.map.WorldInfo;\n+import tc.oc.pgm.api.map.ProtoVersions;\n import tc.oc.pgm.map.contrib.PlayerContributor;\n import tc.oc.pgm.map.contrib.PseudonymContributor;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.server.NullCommandSender;\n-import tc.oc.util.Version;\n+import tc.oc.util.SemanticVersion;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n public class MapInfoImpl implements MapInfo {\n+\n   private final String id;\n-  private final Version proto;\n-  private final Version version;\n+  private final SemanticVersion proto;\n+  private final SemanticVersion version;\n   private final String name;\n+  private final String genre;\n   private final String description;\n   private final Collection<Contributor> authors;\n   private final Collection<Contributor> contributors;\n   private final Collection<String> rules;\n-  private final int difficulty;\n-  private final WorldInfo world;\n-\n-  protected final Collection<MapTag> tags;\n-  protected final Collection<Integer> players;\n+  private final Difficulty difficulty;\n+  private final Collection<Integer> teamLimits;\n+  private final int playerLimit;\n \n   public MapInfoImpl(\n       @Nullable String id,\n-      Version proto,\n-      Version version,\n+      SemanticVersion proto,\n+      SemanticVersion version,\n       String name,\n+      String genre,\n       String description,\n-      @Nullable Collection<Contributor> authors,\n-      @Nullable Collection<Contributor> contributors,\n-      @Nullable Collection<String> rules,\n-      @Nullable Integer difficulty,\n-      @Nullable Collection<MapTag> tags,\n-      @Nullable Collection<Integer> players,\n-      @Nullable WorldInfo world) {\n-    this.name = checkNotNull(name);\n-    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+      Collection<Contributor> authors,\n+      Collection<Contributor> contributors,\n+      Collection<String> rules,\n+      Difficulty difficulty,\n+      Collection<Integer> teamLimits,\n+      int playerLimit) {\n     this.proto = checkNotNull(proto);\n     this.version = checkNotNull(version);\n+    this.name = checkNotNull(name);\n+    this.genre = checkNotNull(genre);\n     this.description = checkNotNull(description);\n-    this.authors = authors == null ? new LinkedList<>() : authors;\n-    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n-    this.rules = rules == null ? new LinkedList<>() : rules;\n-    this.difficulty = difficulty == null ? Difficulty.NORMAL.ordinal() : difficulty;\n-    this.tags = tags == null ? new TreeSet<>() : tags;\n-    this.players = players == null ? new LinkedList<>() : players;\n-    this.world = world == null ? new WorldInfoImpl() : world;\n-  }\n-\n-  public MapInfoImpl(MapInfo info) {\n-    this(\n-        checkNotNull(info).getId(),\n-        info.getProto(),\n-        info.getVersion(),\n-        info.getName(),\n-        info.getDescription(),\n-        info.getAuthors(),\n-        info.getContributors(),\n-        info.getRules(),\n-        info.getDifficulty(),\n-        info.getTags(),\n-        info.getMaxPlayers(),\n-        info.getWorld());\n-  }\n-\n-  public MapInfoImpl(Element root) throws InvalidXMLException {\n-    this(\n-        checkNotNull(root).getChildTextNormalize(\"slug\"),\n-        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n-        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n-        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n-        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n-        parseContributors(root, \"author\"),\n-        parseContributors(root, \"contributor\"),\n-        parseRules(root),\n-        XMLUtils.parseEnum(\n-                Node.fromLastChildOrAttr(root, \"difficulty\"),\n-                Difficulty.class,\n-                \"difficulty\",\n-                Difficulty.NORMAL)\n-            .ordinal(),\n-        null,\n-        null,\n-        parseWorld(root));\n+    this.authors = ImmutableList.copyOf(checkNotNull(authors));\n+    this.contributors = ImmutableList.copyOf(checkNotNull(contributors));\n+    this.rules = ImmutableList.copyOf(checkNotNull(rules));\n+    this.difficulty = checkNotNull(difficulty);\n+    this.teamLimits = ImmutableList.copyOf(checkNotNull(teamLimits));\n+    this.playerLimit = Math.max(1, playerLimit);\n+    this.id = checkNotNull(normalizeName(id == null ? this.name : id));\n   }\n \n   @Override\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex b992f453..79735e2c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -1,77 +1,86 @@\n package tc.oc.pgm.map;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n import com.google.common.collect.ImmutableList;\n-import java.text.Normalizer;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.UUID;\n-import javax.annotation.Nullable;\n-import org.apache.commons.lang3.builder.CompareToBuilder;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ToStringBuilder;\n-import org.bukkit.Bukkit;\n import org.bukkit.Difficulty;\n-import org.jdom2.Document;\n import org.jdom2.Element;\n-import tc.oc.component.Component;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.map.Contributor;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.ProtoVersions;\n import tc.oc.pgm.map.contrib.PlayerContributor;\n import tc.oc.pgm.map.contrib.PseudonymContributor;\n import tc.oc.pgm.util.XMLUtils;\n-import tc.oc.server.NullCommandSender;\n import tc.oc.util.SemanticVersion;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n+import javax.annotation.Nullable;\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n public class MapInfoImpl implements MapInfo {\n \n   private final String id;\n   private final SemanticVersion proto;\n   private final SemanticVersion version;\n   private final String name;\n-  private final String genre;\n   private final String description;\n   private final Collection<Contributor> authors;\n   private final Collection<Contributor> contributors;\n   private final Collection<String> rules;\n   private final Difficulty difficulty;\n-  private final Collection<Integer> teamLimits;\n-  private final int playerLimit;\n \n   public MapInfoImpl(\n       @Nullable String id,\n       SemanticVersion proto,\n       SemanticVersion version,\n       String name,\n-      String genre,\n       String description,\n-      Collection<Contributor> authors,\n-      Collection<Contributor> contributors,\n-      Collection<String> rules,\n-      Difficulty difficulty,\n-      Collection<Integer> teamLimits,\n-      int playerLimit) {\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Difficulty difficulty) {\n     this.proto = checkNotNull(proto);\n     this.version = checkNotNull(version);\n     this.name = checkNotNull(name);\n-    this.genre = checkNotNull(genre);\n     this.description = checkNotNull(description);\n-    this.authors = ImmutableList.copyOf(checkNotNull(authors));\n-    this.contributors = ImmutableList.copyOf(checkNotNull(contributors));\n-    this.rules = ImmutableList.copyOf(checkNotNull(rules));\n-    this.difficulty = checkNotNull(difficulty);\n-    this.teamLimits = ImmutableList.copyOf(checkNotNull(teamLimits));\n-    this.playerLimit = Math.max(1, playerLimit);\n-    this.id = checkNotNull(normalizeName(id == null ? this.name : id));\n+    this.authors =\n+        authors == null || authors.isEmpty()\n+            ? Collections.emptyList()\n+            : ImmutableList.copyOf(authors);\n+    this.contributors =\n+        contributors == null || contributors.isEmpty()\n+            ? Collections.emptyList()\n+            : ImmutableList.copyOf(contributors);\n+    this.rules =\n+        rules == null || rules.isEmpty() ? Collections.emptyList() : ImmutableList.copyOf(rules);\n+    this.difficulty = difficulty == null ? Difficulty.NORMAL : difficulty;\n+    this.id = checkNotNull(normalizeName(id == null ? name : id));\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(checkNotNull(info).getId(), info.getProto(), info.getVersion(), info.getName(), info.getDescription(), info.getAuthors(), info.getContributors(), info.getRules(), info.getDifficulty());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {\n+    this(\n+        checkNotNull(root).getChildTextNormalize(\"slug\"),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n+        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n+        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n+        parseContributors(root, \"author\"),\n+        parseContributors(root, \"contributor\"),\n+        parseRules(root),\n+        XMLUtils.parseEnum(\n+            Node.fromLastChildOrAttr(root, \"difficulty\"), Difficulty.class, \"difficulty\"));\n   }\n \n   @Override\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 79735e2c..aea10612 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -80,7 +88,14 @@ public class MapInfoImpl implements MapInfo {\n         parseContributors(root, \"contributor\"),\n         parseRules(root),\n         XMLUtils.parseEnum(\n-            Node.fromLastChildOrAttr(root, \"difficulty\"), Difficulty.class, \"difficulty\"));\n+                Node.fromLastChildOrAttr(root, \"difficulty\"),\n+                Difficulty.class,\n+                \"difficulty\",\n+                Difficulty.NORMAL)\n+            .ordinal(),\n+        null,\n+        null,\n+        null);\n   }\n \n   @Override\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex aea10612..41e694ca 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -94,7 +101,6 @@ public class MapInfoImpl implements MapInfo {\n                 Difficulty.NORMAL)\n             .ordinal(),\n         null,\n-        null,\n         null);\n   }\n \n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 41e694ca..1284ad74 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -101,7 +105,8 @@ public class MapInfoImpl implements MapInfo {\n                 Difficulty.NORMAL)\n             .ordinal(),\n         null,\n-        null);\n+        null,\n+        parseWorld(root));\n   }\n \n   @Override\n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 79735e2c..aea10612 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -89,12 +104,12 @@ public class MapInfoImpl implements MapInfo {\n   }\n \n   @Override\n-  public SemanticVersion getProto() {\n+  public Version getProto() {\n     return proto;\n   }\n \n   @Override\n-  public SemanticVersion getVersion() {\n+  public Version getVersion() {\n     return version;\n   }\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTMxOQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915319", "body": "I called this `SYMBOL` originally because all these different special characters (mainly on scoreboard) were called `SYMBOL`s.", "bodyText": "I called this SYMBOL originally because all these different special characters (mainly on scoreboard) were called SYMBOLs.", "bodyHTML": "<p dir=\"auto\">I called this <code>SYMBOL</code> originally because all these different special characters (mainly on scoreboard) were called <code>SYMBOL</code>s.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:29:23Z", "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\nindex fdce4258..847dbd7c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n", "chunk": "@@ -1,19 +1,25 @@\n package tc.oc.pgm.map;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import java.util.regex.Pattern;\n import tc.oc.pgm.api.map.MapTag;\n \n public class MapTagImpl implements MapTag {\n \n-  private static final String HASHTAG = \"#\";\n+  private static final Pattern PATTERN = Pattern.compile(\"^[a-z0-9_-]+$\");\n+  private static final String SYMBOL = \"#\";\n+\n   private final String id;\n   private final String name;\n   private final boolean gamemode;\n   private final boolean auxiliary;\n \n   public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n-    this.id = checkNotNull(id);\n+    checkArgument(\n+        PATTERN.matcher(checkNotNull(id)).matches(), name + \" must match \" + PATTERN.pattern());\n+    this.id = id;\n     this.name = checkNotNull(name);\n     this.gamemode = gamemode;\n     this.auxiliary = auxiliary;\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\ndeleted file mode 100644\nindex 847dbd7c..00000000\n--- a/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,63 +0,0 @@\n-package tc.oc.pgm.map;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-import java.util.regex.Pattern;\n-import tc.oc.pgm.api.map.MapTag;\n-\n-public class MapTagImpl implements MapTag {\n-\n-  private static final Pattern PATTERN = Pattern.compile(\"^[a-z0-9_-]+$\");\n-  private static final String SYMBOL = \"#\";\n-\n-  private final String id;\n-  private final String name;\n-  private final boolean gamemode;\n-  private final boolean auxiliary;\n-\n-  public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n-    checkArgument(\n-        PATTERN.matcher(checkNotNull(id)).matches(), name + \" must match \" + PATTERN.pattern());\n-    this.id = id;\n-    this.name = checkNotNull(name);\n-    this.gamemode = gamemode;\n-    this.auxiliary = auxiliary;\n-  }\n-\n-  @Override\n-  public String getId() {\n-    return id;\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return name;\n-  }\n-\n-  @Override\n-  public boolean isGamemode() {\n-    return gamemode;\n-  }\n-\n-  @Override\n-  public boolean isAuxiliary() {\n-    return auxiliary;\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    return getId().hashCode();\n-  }\n-\n-  @Override\n-  public boolean equals(Object obj) {\n-    if (!(obj instanceof MapTag)) return false;\n-    return getId().equalsIgnoreCase(((MapTag) obj).getId());\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return SYMBOL + getId();\n-  }\n-}\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\nnew file mode 100644\nindex 00000000..fdce4258\n--- /dev/null\n+++ b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n", "chunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";\n+  private final String id;\n+  private final String name;\n+  private final boolean gamemode;\n+  private final boolean auxiliary;\n+\n+  public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n+    this.id = checkNotNull(id);\n+    this.name = checkNotNull(name);\n+    this.gamemode = gamemode;\n+    this.auxiliary = auxiliary;\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return id;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return name;\n+  }\n+\n+  @Override\n+  public boolean isGamemode() {\n+    return gamemode;\n+  }\n+\n+  @Override\n+  public boolean isAuxiliary() {\n+    return auxiliary;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return getId().hashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (!(obj instanceof MapTag)) return false;\n+    return getId().equalsIgnoreCase(((MapTag) obj).getId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return HASHTAG + getId();\n+  }\n+}\n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\nindex fdce4258..847dbd7c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n", "chunk": "@@ -52,6 +58,6 @@ public class MapTagImpl implements MapTag {\n \n   @Override\n   public String toString() {\n-    return HASHTAG + getId();\n+    return SYMBOL + getId();\n   }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTQ0OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915448", "body": "We lost the regex pattern to validate if the maptag was in lower case, between a-z, 0-9, with - or _. This is public and people from outside can create new instances of this class with illegal characters which will potentially lead to bugs.", "bodyText": "We lost the regex pattern to validate if the maptag was in lower case, between a-z, 0-9, with - or _. This is public and people from outside can create new instances of this class with illegal characters which will potentially lead to bugs.", "bodyHTML": "<p dir=\"auto\">We lost the regex pattern to validate if the maptag was in lower case, between a-z, 0-9, with - or _. This is public and people from outside can create new instances of this class with illegal characters which will potentially lead to bugs.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:32:42Z", "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";\n+  private final String id;\n+  private final String name;\n+  private final boolean gamemode;\n+  private final boolean auxiliary;\n+\n+  public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n+    this.id = checkNotNull(id);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\nindex fdce4258..847dbd7c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n", "chunk": "@@ -1,19 +1,25 @@\n package tc.oc.pgm.map;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import java.util.regex.Pattern;\n import tc.oc.pgm.api.map.MapTag;\n \n public class MapTagImpl implements MapTag {\n \n-  private static final String HASHTAG = \"#\";\n+  private static final Pattern PATTERN = Pattern.compile(\"^[a-z0-9_-]+$\");\n+  private static final String SYMBOL = \"#\";\n+\n   private final String id;\n   private final String name;\n   private final boolean gamemode;\n   private final boolean auxiliary;\n \n   public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n-    this.id = checkNotNull(id);\n+    checkArgument(\n+        PATTERN.matcher(checkNotNull(id)).matches(), name + \" must match \" + PATTERN.pattern());\n+    this.id = id;\n     this.name = checkNotNull(name);\n     this.gamemode = gamemode;\n     this.auxiliary = auxiliary;\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\ndeleted file mode 100644\nindex 847dbd7c..00000000\n--- a/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,63 +0,0 @@\n-package tc.oc.pgm.map;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-import java.util.regex.Pattern;\n-import tc.oc.pgm.api.map.MapTag;\n-\n-public class MapTagImpl implements MapTag {\n-\n-  private static final Pattern PATTERN = Pattern.compile(\"^[a-z0-9_-]+$\");\n-  private static final String SYMBOL = \"#\";\n-\n-  private final String id;\n-  private final String name;\n-  private final boolean gamemode;\n-  private final boolean auxiliary;\n-\n-  public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n-    checkArgument(\n-        PATTERN.matcher(checkNotNull(id)).matches(), name + \" must match \" + PATTERN.pattern());\n-    this.id = id;\n-    this.name = checkNotNull(name);\n-    this.gamemode = gamemode;\n-    this.auxiliary = auxiliary;\n-  }\n-\n-  @Override\n-  public String getId() {\n-    return id;\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return name;\n-  }\n-\n-  @Override\n-  public boolean isGamemode() {\n-    return gamemode;\n-  }\n-\n-  @Override\n-  public boolean isAuxiliary() {\n-    return auxiliary;\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    return getId().hashCode();\n-  }\n-\n-  @Override\n-  public boolean equals(Object obj) {\n-    if (!(obj instanceof MapTag)) return false;\n-    return getId().equalsIgnoreCase(((MapTag) obj).getId());\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return SYMBOL + getId();\n-  }\n-}\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\nnew file mode 100644\nindex 00000000..fdce4258\n--- /dev/null\n+++ b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n", "chunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";\n+  private final String id;\n+  private final String name;\n+  private final boolean gamemode;\n+  private final boolean auxiliary;\n+\n+  public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n+    this.id = checkNotNull(id);\n+    this.name = checkNotNull(name);\n+    this.gamemode = gamemode;\n+    this.auxiliary = auxiliary;\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return id;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return name;\n+  }\n+\n+  @Override\n+  public boolean isGamemode() {\n+    return gamemode;\n+  }\n+\n+  @Override\n+  public boolean isAuxiliary() {\n+    return auxiliary;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return getId().hashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (!(obj instanceof MapTag)) return false;\n+    return getId().equalsIgnoreCase(((MapTag) obj).getId());\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return HASHTAG + getId();\n+  }\n+}\n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapTagImpl.java b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\nindex fdce4258..847dbd7c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapTagImpl.java\n", "chunk": "@@ -52,6 +58,6 @@ public class MapTagImpl implements MapTag {\n \n   @Override\n   public String toString() {\n-    return HASHTAG + getId();\n+    return SYMBOL + getId();\n   }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTU3NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915574", "body": "`getName()` and `getDescription()` maybe?", "bodyText": "getName() and getDescription() maybe?", "bodyHTML": "<p dir=\"auto\"><code>getName()</code> and <code>getDescription()</code> maybe?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:36:26Z", "path": "src/main/java/tc/oc/pgm/api/map/MapTag.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package tc.oc.pgm.api.map;\n+\n+import tc.oc.pgm.map.MapTagImpl;\n+\n+/** A \"#hashtag\" that describes a {@link MapInfo} feature. */\n+public interface MapTag extends Comparable<MapTag> {\n+\n+  /**\n+   * Get a short id for the tag.\n+   *\n+   * @return A short, lowercase id without the \"#\".\n+   */\n+  String getId();\n+\n+  /**\n+   * Get a full name for the tag.\n+   *\n+   * @return A full name.\n+   */\n+  String getName();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapTag.java b/src/main/java/tc/oc/pgm/api/map/MapTag.java\ndeleted file mode 100644\nindex 26513899..00000000\n--- a/src/main/java/tc/oc/pgm/api/map/MapTag.java\n+++ /dev/null\n", "chunk": "@@ -1,44 +0,0 @@\n-package tc.oc.pgm.api.map;\n-\n-import tc.oc.pgm.map.MapTagImpl;\n-\n-/** A \"#hashtag\" that describes a {@link MapInfo} feature. */\n-public interface MapTag extends Comparable<MapTag> {\n-\n-  /**\n-   * Get a short id for the tag.\n-   *\n-   * @return A short, lowercase id without the \"#\".\n-   */\n-  String getId();\n-\n-  /**\n-   * Get a full name for the tag.\n-   *\n-   * @return A full name.\n-   */\n-  String getName();\n-\n-  /**\n-   * Get whether this tag represents a \"gamemode.\"\n-   *\n-   * @return If a gamemode.\n-   */\n-  boolean isGamemode();\n-\n-  /**\n-   * Get whether this tag is an auxiliary feature.\n-   *\n-   * @return If an auxiliary feature.\n-   */\n-  boolean isAuxiliary();\n-\n-  @Override\n-  default int compareTo(MapTag o) {\n-    return getId().compareTo(o.getId());\n-  }\n-\n-  static MapTag create(String id, String name, boolean gamemode, boolean auxiliary) {\n-    return new MapTagImpl(id, name, gamemode, auxiliary);\n-  }\n-}\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapTag.java b/src/main/java/tc/oc/pgm/api/map/MapTag.java\nnew file mode 100644\nindex 00000000..26513899\n--- /dev/null\n+++ b/src/main/java/tc/oc/pgm/api/map/MapTag.java\n", "chunk": "@@ -0,0 +1,44 @@\n+package tc.oc.pgm.api.map;\n+\n+import tc.oc.pgm.map.MapTagImpl;\n+\n+/** A \"#hashtag\" that describes a {@link MapInfo} feature. */\n+public interface MapTag extends Comparable<MapTag> {\n+\n+  /**\n+   * Get a short id for the tag.\n+   *\n+   * @return A short, lowercase id without the \"#\".\n+   */\n+  String getId();\n+\n+  /**\n+   * Get a full name for the tag.\n+   *\n+   * @return A full name.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get whether this tag represents a \"gamemode.\"\n+   *\n+   * @return If a gamemode.\n+   */\n+  boolean isGamemode();\n+\n+  /**\n+   * Get whether this tag is an auxiliary feature.\n+   *\n+   * @return If an auxiliary feature.\n+   */\n+  boolean isAuxiliary();\n+\n+  @Override\n+  default int compareTo(MapTag o) {\n+    return getId().compareTo(o.getId());\n+  }\n+\n+  static MapTag create(String id, String name, boolean gamemode, boolean auxiliary) {\n+    return new MapTagImpl(id, name, gamemode, auxiliary);\n+  }\n+}\n", "next_change": {"commit": "459c36b117ef8f6a377836da5cc44a4be4e00b66", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/api/map/MapTag.java b/src/main/java/tc/oc/pgm/api/map/MapTag.java\nindex 26513899..520309c0 100644\n--- a/src/main/java/tc/oc/pgm/api/map/MapTag.java\n+++ b/src/main/java/tc/oc/pgm/api/map/MapTag.java\n", "chunk": "@@ -35,7 +36,11 @@ public interface MapTag extends Comparable<MapTag> {\n \n   @Override\n   default int compareTo(MapTag o) {\n-    return getId().compareTo(o.getId());\n+    return new CompareToBuilder()\n+        .append(isGamemode(), o.isGamemode())\n+        .append(isAuxiliary(), o.isAuxiliary())\n+        .append(getId(), o.getId())\n+        .build();\n   }\n \n   static MapTag create(String id, String name, boolean gamemode, boolean auxiliary) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTY2MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915661", "body": "`Bukkit.getDifficulty()`?", "bodyText": "Bukkit.getDifficulty()?", "bodyHTML": "<p dir=\"auto\"><code>Bukkit.getDifficulty()</code>?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:39:09Z", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,\n+      @Nullable Collection<MapTag> tags,\n+      @Nullable Collection<Integer> players) {\n+    this.name = checkNotNull(name);\n+    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+    this.proto = checkNotNull(proto);\n+    this.version = checkNotNull(version);\n+    this.description = checkNotNull(description);\n+    this.authors = authors == null ? new LinkedList<>() : authors;\n+    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n+    this.rules = rules == null ? new LinkedList<>() : rules;\n+    this.difficulty = difficulty == null ? DEFAULT_DIFFICULTY : difficulty;\n+    this.tags = tags == null ? new TreeSet<>() : tags;\n+    this.players = players == null ? new LinkedList<>() : players;\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(\n+        checkNotNull(info).getId(),\n+        info.getProto(),\n+        info.getVersion(),\n+        info.getName(),\n+        info.getDescription(),\n+        info.getAuthors(),\n+        info.getContributors(),\n+        info.getRules(),\n+        info.getDifficulty(),\n+        info.getTags(),\n+        info.getMaxPlayers());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {\n+    this(\n+        checkNotNull(root).getChildTextNormalize(\"slug\"),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n+        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n+        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n+        parseContributors(root, \"author\"),\n+        parseContributors(root, \"contributor\"),\n+        parseRules(root),\n+        XMLUtils.parseEnum(\n+                Node.fromLastChildOrAttr(root, \"difficulty\"),\n+                Difficulty.class,\n+                \"difficulty\",\n+                Difficulty.NORMAL)", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 41e694ca..1284ad74 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -101,7 +105,8 @@ public class MapInfoImpl implements MapInfo {\n                 Difficulty.NORMAL)\n             .ordinal(),\n         null,\n-        null);\n+        null,\n+        parseWorld(root));\n   }\n \n   @Override\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 1284ad74..b992f453 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -2,111 +2,76 @@ package tc.oc.pgm.map;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n+import com.google.common.collect.ImmutableList;\n+import java.text.Normalizer;\n import java.util.Collection;\n import java.util.LinkedList;\n import java.util.List;\n-import java.util.TreeSet;\n import java.util.UUID;\n-import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n-import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.CompareToBuilder;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Bukkit;\n import org.bukkit.Difficulty;\n+import org.jdom2.Document;\n import org.jdom2.Element;\n import tc.oc.component.Component;\n import tc.oc.component.types.PersonalizedText;\n-import tc.oc.named.NameStyle;\n-import tc.oc.pgm.AllTranslations;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.map.Contributor;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapTag;\n-import tc.oc.pgm.api.map.WorldInfo;\n+import tc.oc.pgm.api.map.ProtoVersions;\n import tc.oc.pgm.map.contrib.PlayerContributor;\n import tc.oc.pgm.map.contrib.PseudonymContributor;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.server.NullCommandSender;\n-import tc.oc.util.Version;\n+import tc.oc.util.SemanticVersion;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n public class MapInfoImpl implements MapInfo {\n+\n   private final String id;\n-  private final Version proto;\n-  private final Version version;\n+  private final SemanticVersion proto;\n+  private final SemanticVersion version;\n   private final String name;\n+  private final String genre;\n   private final String description;\n   private final Collection<Contributor> authors;\n   private final Collection<Contributor> contributors;\n   private final Collection<String> rules;\n-  private final int difficulty;\n-  private final WorldInfo world;\n-\n-  protected final Collection<MapTag> tags;\n-  protected final Collection<Integer> players;\n+  private final Difficulty difficulty;\n+  private final Collection<Integer> teamLimits;\n+  private final int playerLimit;\n \n   public MapInfoImpl(\n       @Nullable String id,\n-      Version proto,\n-      Version version,\n+      SemanticVersion proto,\n+      SemanticVersion version,\n       String name,\n+      String genre,\n       String description,\n-      @Nullable Collection<Contributor> authors,\n-      @Nullable Collection<Contributor> contributors,\n-      @Nullable Collection<String> rules,\n-      @Nullable Integer difficulty,\n-      @Nullable Collection<MapTag> tags,\n-      @Nullable Collection<Integer> players,\n-      @Nullable WorldInfo world) {\n-    this.name = checkNotNull(name);\n-    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+      Collection<Contributor> authors,\n+      Collection<Contributor> contributors,\n+      Collection<String> rules,\n+      Difficulty difficulty,\n+      Collection<Integer> teamLimits,\n+      int playerLimit) {\n     this.proto = checkNotNull(proto);\n     this.version = checkNotNull(version);\n+    this.name = checkNotNull(name);\n+    this.genre = checkNotNull(genre);\n     this.description = checkNotNull(description);\n-    this.authors = authors == null ? new LinkedList<>() : authors;\n-    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n-    this.rules = rules == null ? new LinkedList<>() : rules;\n-    this.difficulty = difficulty == null ? Difficulty.NORMAL.ordinal() : difficulty;\n-    this.tags = tags == null ? new TreeSet<>() : tags;\n-    this.players = players == null ? new LinkedList<>() : players;\n-    this.world = world == null ? new WorldInfoImpl() : world;\n-  }\n-\n-  public MapInfoImpl(MapInfo info) {\n-    this(\n-        checkNotNull(info).getId(),\n-        info.getProto(),\n-        info.getVersion(),\n-        info.getName(),\n-        info.getDescription(),\n-        info.getAuthors(),\n-        info.getContributors(),\n-        info.getRules(),\n-        info.getDifficulty(),\n-        info.getTags(),\n-        info.getMaxPlayers(),\n-        info.getWorld());\n-  }\n-\n-  public MapInfoImpl(Element root) throws InvalidXMLException {\n-    this(\n-        checkNotNull(root).getChildTextNormalize(\"slug\"),\n-        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n-        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n-        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n-        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n-        parseContributors(root, \"author\"),\n-        parseContributors(root, \"contributor\"),\n-        parseRules(root),\n-        XMLUtils.parseEnum(\n-                Node.fromLastChildOrAttr(root, \"difficulty\"),\n-                Difficulty.class,\n-                \"difficulty\",\n-                Difficulty.NORMAL)\n-            .ordinal(),\n-        null,\n-        null,\n-        parseWorld(root));\n+    this.authors = ImmutableList.copyOf(checkNotNull(authors));\n+    this.contributors = ImmutableList.copyOf(checkNotNull(contributors));\n+    this.rules = ImmutableList.copyOf(checkNotNull(rules));\n+    this.difficulty = checkNotNull(difficulty);\n+    this.teamLimits = ImmutableList.copyOf(checkNotNull(teamLimits));\n+    this.playerLimit = Math.max(1, playerLimit);\n+    this.id = checkNotNull(normalizeName(id == null ? this.name : id));\n   }\n \n   @Override\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex b992f453..79735e2c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -1,77 +1,86 @@\n package tc.oc.pgm.map;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n import com.google.common.collect.ImmutableList;\n-import java.text.Normalizer;\n-import java.util.Collection;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.UUID;\n-import javax.annotation.Nullable;\n-import org.apache.commons.lang3.builder.CompareToBuilder;\n import org.apache.commons.lang3.builder.EqualsBuilder;\n import org.apache.commons.lang3.builder.HashCodeBuilder;\n import org.apache.commons.lang3.builder.ToStringBuilder;\n-import org.bukkit.Bukkit;\n import org.bukkit.Difficulty;\n-import org.jdom2.Document;\n import org.jdom2.Element;\n-import tc.oc.component.Component;\n-import tc.oc.component.types.PersonalizedText;\n-import tc.oc.component.types.PersonalizedTranslatable;\n-import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.map.Contributor;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.ProtoVersions;\n import tc.oc.pgm.map.contrib.PlayerContributor;\n import tc.oc.pgm.map.contrib.PseudonymContributor;\n import tc.oc.pgm.util.XMLUtils;\n-import tc.oc.server.NullCommandSender;\n import tc.oc.util.SemanticVersion;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n+import javax.annotation.Nullable;\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n public class MapInfoImpl implements MapInfo {\n \n   private final String id;\n   private final SemanticVersion proto;\n   private final SemanticVersion version;\n   private final String name;\n-  private final String genre;\n   private final String description;\n   private final Collection<Contributor> authors;\n   private final Collection<Contributor> contributors;\n   private final Collection<String> rules;\n   private final Difficulty difficulty;\n-  private final Collection<Integer> teamLimits;\n-  private final int playerLimit;\n \n   public MapInfoImpl(\n       @Nullable String id,\n       SemanticVersion proto,\n       SemanticVersion version,\n       String name,\n-      String genre,\n       String description,\n-      Collection<Contributor> authors,\n-      Collection<Contributor> contributors,\n-      Collection<String> rules,\n-      Difficulty difficulty,\n-      Collection<Integer> teamLimits,\n-      int playerLimit) {\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Difficulty difficulty) {\n     this.proto = checkNotNull(proto);\n     this.version = checkNotNull(version);\n     this.name = checkNotNull(name);\n-    this.genre = checkNotNull(genre);\n     this.description = checkNotNull(description);\n-    this.authors = ImmutableList.copyOf(checkNotNull(authors));\n-    this.contributors = ImmutableList.copyOf(checkNotNull(contributors));\n-    this.rules = ImmutableList.copyOf(checkNotNull(rules));\n-    this.difficulty = checkNotNull(difficulty);\n-    this.teamLimits = ImmutableList.copyOf(checkNotNull(teamLimits));\n-    this.playerLimit = Math.max(1, playerLimit);\n-    this.id = checkNotNull(normalizeName(id == null ? this.name : id));\n+    this.authors =\n+        authors == null || authors.isEmpty()\n+            ? Collections.emptyList()\n+            : ImmutableList.copyOf(authors);\n+    this.contributors =\n+        contributors == null || contributors.isEmpty()\n+            ? Collections.emptyList()\n+            : ImmutableList.copyOf(contributors);\n+    this.rules =\n+        rules == null || rules.isEmpty() ? Collections.emptyList() : ImmutableList.copyOf(rules);\n+    this.difficulty = difficulty == null ? Difficulty.NORMAL : difficulty;\n+    this.id = checkNotNull(normalizeName(id == null ? name : id));\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(checkNotNull(info).getId(), info.getProto(), info.getVersion(), info.getName(), info.getDescription(), info.getAuthors(), info.getContributors(), info.getRules(), info.getDifficulty());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {\n+    this(\n+        checkNotNull(root).getChildTextNormalize(\"slug\"),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n+        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n+        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n+        parseContributors(root, \"author\"),\n+        parseContributors(root, \"contributor\"),\n+        parseRules(root),\n+        XMLUtils.parseEnum(\n+            Node.fromLastChildOrAttr(root, \"difficulty\"), Difficulty.class, \"difficulty\"));\n   }\n \n   @Override\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 79735e2c..aea10612 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -80,7 +88,14 @@ public class MapInfoImpl implements MapInfo {\n         parseContributors(root, \"contributor\"),\n         parseRules(root),\n         XMLUtils.parseEnum(\n-            Node.fromLastChildOrAttr(root, \"difficulty\"), Difficulty.class, \"difficulty\"));\n+                Node.fromLastChildOrAttr(root, \"difficulty\"),\n+                Difficulty.class,\n+                \"difficulty\",\n+                Difficulty.NORMAL)\n+            .ordinal(),\n+        null,\n+        null,\n+        null);\n   }\n \n   @Override\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex aea10612..41e694ca 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -94,7 +101,6 @@ public class MapInfoImpl implements MapInfo {\n                 Difficulty.NORMAL)\n             .ordinal(),\n         null,\n-        null,\n         null);\n   }\n \n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 41e694ca..1284ad74 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -101,7 +105,8 @@ public class MapInfoImpl implements MapInfo {\n                 Difficulty.NORMAL)\n             .ordinal(),\n         null,\n-        null);\n+        null,\n+        parseWorld(root));\n   }\n \n   @Override\n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 79735e2c..aea10612 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -89,12 +104,12 @@ public class MapInfoImpl implements MapInfo {\n   }\n \n   @Override\n-  public SemanticVersion getProto() {\n+  public Version getProto() {\n     return proto;\n   }\n \n   @Override\n-  public SemanticVersion getVersion() {\n+  public Version getVersion() {\n     return version;\n   }\n \n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex 1284ad74..b992f453 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -115,12 +80,12 @@ public class MapInfoImpl implements MapInfo {\n   }\n \n   @Override\n-  public Version getProto() {\n+  public SemanticVersion getProto() {\n     return proto;\n   }\n \n   @Override\n-  public Version getVersion() {\n+  public SemanticVersion getVersion() {\n     return version;\n   }\n \n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\nindex b992f453..79735e2c 100644\n--- a/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n+++ b/src/main/java/tc/oc/pgm/map/MapInfoImpl.java\n", "chunk": "@@ -94,11 +103,6 @@ public class MapInfoImpl implements MapInfo {\n     return name;\n   }\n \n-  @Override\n-  public String getGenre() {\n-    return genre;\n-  }\n-\n   @Override\n   public String getDescription() {\n     return description;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjg4MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370942881", "body": "I think this should count `sum()`?", "bodyText": "I think this should count sum()?", "bodyHTML": "<p dir=\"auto\">I think this should count <code>sum()</code>?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:41:05Z", "path": "src/main/java/tc/oc/pgm/match/MatchImpl.java", "diffHunk": "@@ -131,7 +134,8 @@ protected MatchImpl(String id, PGMMap map, World world) {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity = new AtomicInteger(map.getPersistentContext().getTotalMaxPlayers());\n+    this.capacity =\n+        new AtomicInteger(map.getMaxPlayers().stream().findFirst().orElse(Bukkit.getMaxPlayers()));", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDM0OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944348", "bodyText": "Ah yes, nice catch.", "author": "Electroid", "createdAt": "2020-01-25T17:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjg4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchImpl.java b/src/main/java/tc/oc/pgm/match/MatchImpl.java\nindex cfdd1a8a..ef0d52d5 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchImpl.java\n", "chunk": "@@ -134,8 +134,7 @@ public class MatchImpl implements Match {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity =\n-        new AtomicInteger(map.getMaxPlayers().stream().findFirst().orElse(Bukkit.getMaxPlayers()));\n+    this.capacity = new AtomicInteger(map.getMaxPlayers().stream().mapToInt(i -> i).sum());\n     this.schedulers = new EnumMap<>(MatchScope.class);\n     this.listeners = new EnumMap<>(MatchScope.class);\n     this.tickables = new EnumMap<>(MatchScope.class);\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchImpl.java b/src/main/java/tc/oc/pgm/match/MatchImpl.java\nindex ef0d52d5..8bb319b1 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchImpl.java\n", "chunk": "@@ -134,7 +134,7 @@ public class MatchImpl implements Match {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity = new AtomicInteger(map.getMaxPlayers().stream().mapToInt(i -> i).sum());\n+    this.capacity = new AtomicInteger(map.getInfo().getPlayerLimit());\n     this.schedulers = new EnumMap<>(MatchScope.class);\n     this.listeners = new EnumMap<>(MatchScope.class);\n     this.tickables = new EnumMap<>(MatchScope.class);\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchImpl.java b/src/main/java/tc/oc/pgm/match/MatchImpl.java\nindex 8bb319b1..fe07308c 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchImpl.java\n", "chunk": "@@ -134,7 +134,7 @@ public class MatchImpl implements Match {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity = new AtomicInteger(map.getInfo().getPlayerLimit());\n+    this.capacity = new AtomicInteger(map.getPlayerLimit());\n     this.schedulers = new EnumMap<>(MatchScope.class);\n     this.listeners = new EnumMap<>(MatchScope.class);\n     this.tickables = new EnumMap<>(MatchScope.class);\n", "next_change": {"commit": "54ea8df0c1b17aa541250d525a715b016f946ca0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchImpl.java b/src/main/java/tc/oc/pgm/match/MatchImpl.java\nindex fe07308c..3ec9d672 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchImpl.java\n", "chunk": "@@ -134,7 +133,8 @@ public class MatchImpl implements Match {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity = new AtomicInteger(map.getPlayerLimit());\n+    this.capacity =\n+        new AtomicInteger(map.getMaxPlayers().stream().findFirst().orElse(Bukkit.getMaxPlayers()));\n     this.schedulers = new EnumMap<>(MatchScope.class);\n     this.listeners = new EnumMap<>(MatchScope.class);\n     this.tickables = new EnumMap<>(MatchScope.class);\n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchImpl.java b/src/main/java/tc/oc/pgm/match/MatchImpl.java\nindex 3ec9d672..ef0d52d5 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchImpl.java\n", "chunk": "@@ -133,8 +134,7 @@ public class MatchImpl implements Match {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity =\n-        new AtomicInteger(map.getMaxPlayers().stream().findFirst().orElse(Bukkit.getMaxPlayers()));\n+    this.capacity = new AtomicInteger(map.getMaxPlayers().stream().mapToInt(i -> i).sum());\n     this.schedulers = new EnumMap<>(MatchScope.class);\n     this.listeners = new EnumMap<>(MatchScope.class);\n     this.tickables = new EnumMap<>(MatchScope.class);\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjk2MA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370942960", "body": "If the `world` is null throw NPE for finding bugs easier?", "bodyText": "If the world is null throw NPE for finding bugs easier?", "bodyHTML": "<p dir=\"auto\">If the <code>world</code> is null throw NPE for finding bugs easier?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:42:37Z", "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "diffHunk": "@@ -1,433 +1,206 @@\n package tc.oc.pgm.match;\n \n-import com.google.common.cache.*;\n-import com.google.common.collect.ImmutableSet;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.collect.Iterables;\n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import org.bukkit.*;\n+import org.bukkit.Difficulty;\n+import org.bukkit.Server;\n+import org.bukkit.World;\n+import org.bukkit.WorldCreator;\n import org.bukkit.entity.Player;\n-import tc.oc.pgm.Config;\n+import org.joda.time.Duration;\n+import tc.oc.chunk.NullChunkGenerator;\n import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.chat.MultiAudience;\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.exception.MapMissingException;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.match.factory.MatchFactory;\n import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.map.*;\n-import tc.oc.pgm.module.ModuleLoadException;\n-import tc.oc.pgm.rotation.PGMMapOrder;\n-import tc.oc.pgm.terrain.TerrainModule;\n+import tc.oc.server.Scheduler;\n+import tc.oc.util.ClassLogger;\n import tc.oc.util.FileUtils;\n-import tc.oc.util.logging.ClassLogger;\n-import tc.oc.world.NMSHacks;\n \n-@SuppressWarnings(\"UnstableApiUsage\")\n-public class MatchManagerImpl implements MatchManager, MultiAudience {\n+public class MatchManagerImpl implements MatchFactory, MatchManager {\n+\n+  private static final Duration TIMEOUT = Duration.standardSeconds(30);\n \n   private final Logger logger;\n   private final Server server;\n-  private final MapLibrary library;\n-  private final MapLoader loader;\n-\n-  private final Map<String, Match> matchById = new ConcurrentHashMap<>();\n-  private final Map<String, String> matchIdByWorldName = new HashMap<>();\n-  private final LoadingCache<PGMMap, String> preMatch =\n-      CacheBuilder.newBuilder()\n-          .expireAfterWrite(10, TimeUnit.SECONDS)\n-          // If after 10 secs of writing the match it hasn't been loaded, unload & destroy it\n-          .removalListener(\n-              (RemovalNotification<PGMMap, String> r) -> {\n-                if (!matchById.get(r.getValue()).isLoaded()) unloadMatch(r.getValue());\n-              })\n-          .concurrencyLevel(1)\n-          .build(\n-              new CacheLoader<PGMMap, String>() {\n-                @Override\n-                public String load(@Nonnull PGMMap pgmMap) throws Exception {\n-                  return createPreMatch(pgmMap).getId();\n-                }\n-              });\n-  private final AtomicInteger count;\n-\n-  private PGMMapOrder pgmMapOrder;\n-\n-  public MatchManagerImpl(Server server, MapLibrary library, MapLoader loader)\n-      throws MapNotFoundException {\n-    this.logger = ClassLogger.get(PGM.get().getLogger(), getClass());\n-    this.server = server;\n-    this.library = library;\n-    this.loader = loader;\n-    this.count = new AtomicInteger(0);\n-\n-    loadNewMaps();\n-  }\n-\n-  public void createPreMatchAsync(final PGMMap map) {\n-    logger.fine(\"Creating pre-match for \" + map.getName() + \" async\");\n-    PGM.get()\n-        .getServer()\n-        .getScheduler()\n-        .runTaskAsynchronously(\n-            PGM.get(),\n-            () -> {\n-              try {\n-                preMatch.get(map);\n-                PGM.get()\n-                    .getLogger()\n-                    .fine(\"Done creating pre-match for \" + map.getName() + \" async\");\n-              } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-              }\n-            });\n-  }\n-\n-  /**\n-   * Pre-creates a match, without loading it. Can and should be done async unless a /cycle 0 is\n-   * done.\n-   *\n-   * @param map The map to generate a pre-match for\n-   * @return The created pre-match\n-   * @throws Exception If the match fails to be generated\n-   */\n-  private Match createPreMatch(PGMMap map) throws Exception {\n-    logger.fine(\"Creating pre-match for \" + map.getName());\n-    String id = Integer.toString(count.getAndIncrement());\n-\n-    if (!map.getContext().isPresent()) {\n-      map.reload(true);\n-    }\n-\n-    final TerrainModule terrain = map.getContext().get().needModule(TerrainModule.class);\n-    final File src = terrain.getWorldFolder();\n+  private final Scheduler scheduler;\n \n-    final String worldName = createMatchFolder(id, src);\n-    final World world = createMatchWorld(worldName, map.getInfo(), terrain);\n+  private final AtomicLong matches;\n+  private final Map<String, Match> matchById;\n+  private final Map<String, Match> matchByWorld;\n \n-    final Match match = new MatchImpl(id, map, world);\n-\n-    matchById.put(match.getId(), match);\n-    matchIdByWorldName.put(match.getWorld().getName(), match.getId());\n-\n-    logger.fine(\"Done creating pre-match for \" + map.getName());\n-    return match;\n+  public MatchManagerImpl(Logger logger, Server server) {\n+    this.logger = ClassLogger.get(checkNotNull(logger), getClass());\n+    this.server = checkNotNull(server);\n+    this.scheduler = new Scheduler(PGM.get());\n+    this.matches = new AtomicLong(0);\n+    this.matchById = new ConcurrentHashMap<>();\n+    this.matchByWorld = new ConcurrentHashMap<>();\n   }\n \n   @Override\n-  public Match createMatch(PGMMap map) throws Throwable {\n-    final Match match = matchById.get(preMatch.get(map));\n-\n-    try {\n-      match.load();\n-    } catch (Throwable t) {\n-      unloadMatch(match.getId());\n-      throw t;\n-    } finally {\n-      // Remove all preMatches, since we already loaded one\n-      preMatch.invalidateAll();\n-    }\n-\n-    return match;\n-  }\n-\n-  private String createMatchFolder(String id, File src) throws IOException {\n-    final String worldName = getWorldName(id);\n-    final File dest = new File(server.getWorldContainer(), worldName);\n-\n-    if (dest.exists()) FileUtils.delete(dest);\n-\n-    if (!dest.mkdir()) {\n-      throw new IOException(\"Failed to create temporary world folder \" + dest);\n-    }\n-\n-    FileUtils.copy(new File(src, \"level.dat\"), new File(dest, \"level.dat\"));\n-\n-    File region = new File(src, \"region\");\n-    if (region.isDirectory()) {\n-      FileUtils.copy(region, new File(dest, \"region\"));\n-    }\n-\n-    File data = new File(src, \"data\");\n-    if (data.isDirectory()) {\n-      FileUtils.copy(data, new File(dest, \"data\"));\n-    }\n-\n-    return worldName;\n-  }\n-\n-  private World createMatchWorld(String worldName, MapInfo info, TerrainModule terrain) {\n-    WorldCreator creator = server.detectWorld(worldName);\n-    if (creator == null) creator = new WorldCreator(worldName);\n-    creator\n-        .environment(info.dimension)\n-        .generator(terrain.getChunkGenerator())\n-        .seed(terrain.getSeed());\n-\n-    final World world = createWorld(creator);\n-    if (world == null) {\n-      throw new IllegalStateException(\"Failed to create world, createWorld returned null\");\n-    }\n-\n-    world.setPVP(true);\n-    world.setSpawnFlags(false, false);\n-    world.setAutoSave(false);\n-\n-    if (info.difficulty != null) {\n-      world.setDifficulty(info.difficulty);\n-    } else {\n-      world.setDifficulty(server.getWorlds().get(0).getDifficulty());\n-    }\n-\n-    return world;\n+  public Match getMatch(@Nullable World world) {", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex 32abd67a..d411bacc 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -1,60 +1,71 @@\n package tc.oc.pgm.match;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n-import com.google.common.collect.Iterables;\n-import java.io.File;\n-import java.io.IOException;\n+import java.util.Collections;\n import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.logging.Level;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n-import org.bukkit.Difficulty;\n-import org.bukkit.Server;\n import org.bukkit.World;\n-import org.bukkit.WorldCreator;\n import org.bukkit.entity.Player;\n-import org.joda.time.Duration;\n-import tc.oc.chunk.NullChunkGenerator;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.Config;\n import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.map.MapContext;\n-import tc.oc.pgm.api.map.exception.MapMissingException;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.match.event.MatchLoadEvent;\n+import tc.oc.pgm.api.match.event.MatchUnloadEvent;\n import tc.oc.pgm.api.match.factory.MatchFactory;\n import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.server.Scheduler;\n import tc.oc.util.ClassLogger;\n-import tc.oc.util.FileUtils;\n \n-public class MatchManagerImpl implements MatchFactory, MatchManager {\n-\n-  private static final Duration TIMEOUT = Duration.standardSeconds(30);\n+public class MatchManagerImpl implements MatchManager, Listener {\n \n   private final Logger logger;\n-  private final Server server;\n-  private final Scheduler scheduler;\n-\n-  private final AtomicLong matches;\n   private final Map<String, Match> matchById;\n   private final Map<String, Match> matchByWorld;\n \n-  public MatchManagerImpl(Logger logger, Server server) {\n+  public MatchManagerImpl(Logger logger) {\n     this.logger = ClassLogger.get(checkNotNull(logger), getClass());\n-    this.server = checkNotNull(server);\n-    this.scheduler = new Scheduler(PGM.get());\n-    this.matches = new AtomicLong(0);\n     this.matchById = new ConcurrentHashMap<>();\n     this.matchByWorld = new ConcurrentHashMap<>();\n   }\n \n+  @EventHandler\n+  public void onMatchLoad(MatchLoadEvent event) {\n+    final Match match = event.getMatch();\n+\n+    matchById.put(checkNotNull(match).getId(), match);\n+    matchByWorld.put(checkNotNull(match.getWorld()).getName(), match);\n+\n+    logger.info(\"Loaded match-\" + match.getId() + \" (\" + match.getMap().getId() + \")\");\n+  }\n+\n+  @EventHandler\n+  public void onMatchUnload(MatchUnloadEvent event) {\n+    final Match match = event.getMatch();\n+\n+    matchById.remove(checkNotNull(match).getId());\n+    matchByWorld.remove(checkNotNull(match.getWorld()).getName());\n+    PGM.get()\n+        .getServer()\n+        .getScheduler()\n+        .runTaskLaterAsynchronously(\n+            PGM.get(), match::destroy, Config.Experiments.get().getMatchDestroySeconds() * 20);\n+\n+    logger.info(\"Unloaded match-\" + match.getId() + \" (\" + match.getMap().getId() + \")\");\n+  }\n+\n+  @Override\n+  public MatchFactory createMatch(@Nullable String mapId) {\n+    // FIXME: \"infinite\" retry if a Match fails to load\n+    if (mapId == null) mapId = PGM.get().getMapOrder().popNextMap().getId();\n+    return new MatchFactoryImpl(mapId);\n+  }\n+\n   @Override\n   public Match getMatch(@Nullable World world) {\n     return matchByWorld.get(world == null ? null : world.getName());\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex d411bacc..cd2524f6 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -2,68 +2,27 @@ package tc.oc.pgm.match;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n-import java.util.Collections;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.bukkit.World;\n import org.bukkit.entity.Player;\n-import org.bukkit.event.EventHandler;\n-import org.bukkit.event.Listener;\n-import tc.oc.pgm.Config;\n import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchManager;\n-import tc.oc.pgm.api.match.event.MatchLoadEvent;\n-import tc.oc.pgm.api.match.event.MatchUnloadEvent;\n-import tc.oc.pgm.api.match.factory.MatchFactory;\n import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.util.ClassLogger;\n \n-public class MatchManagerImpl implements MatchManager, Listener {\n+public class MatchManagerImpl implements MatchManager {\n \n-  private final Logger logger;\n   private final Map<String, Match> matchById;\n   private final Map<String, Match> matchByWorld;\n \n-  public MatchManagerImpl(Logger logger) {\n-    this.logger = ClassLogger.get(checkNotNull(logger), getClass());\n-    this.matchById = new ConcurrentHashMap<>();\n-    this.matchByWorld = new ConcurrentHashMap<>();\n-  }\n-\n-  @EventHandler\n-  public void onMatchLoad(MatchLoadEvent event) {\n-    final Match match = event.getMatch();\n-\n-    matchById.put(checkNotNull(match).getId(), match);\n-    matchByWorld.put(checkNotNull(match.getWorld()).getName(), match);\n-\n-    logger.info(\"Loaded match-\" + match.getId() + \" (\" + match.getMap().getId() + \")\");\n-  }\n-\n-  @EventHandler\n-  public void onMatchUnload(MatchUnloadEvent event) {\n-    final Match match = event.getMatch();\n-\n-    matchById.remove(checkNotNull(match).getId());\n-    matchByWorld.remove(checkNotNull(match.getWorld()).getName());\n-    PGM.get()\n-        .getServer()\n-        .getScheduler()\n-        .runTaskLaterAsynchronously(\n-            PGM.get(), match::destroy, Config.Experiments.get().getMatchDestroySeconds() * 20);\n-\n-    logger.info(\"Unloaded match-\" + match.getId() + \" (\" + match.getMap().getId() + \")\");\n-  }\n-\n-  @Override\n-  public MatchFactory createMatch(@Nullable String mapId) {\n-    // FIXME: \"infinite\" retry if a Match fails to load\n-    if (mapId == null) mapId = PGM.get().getMapOrder().popNextMap().getId();\n-    return new MatchFactoryImpl(mapId);\n+  public MatchManagerImpl() {\n+    this.matchById = new HashMap<>();\n+    this.matchByWorld = new HashMap<>();\n   }\n \n   @Override\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex cd2524f6..7df9d207 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -1,28 +1,59 @@\n package tc.oc.pgm.match;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import java.util.HashMap;\n+import java.io.File;\n+import java.io.IOException;\n import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n import javax.annotation.Nullable;\n+import org.bukkit.Server;\n import org.bukkit.World;\n+import org.bukkit.WorldCreator;\n import org.bukkit.entity.Player;\n+import org.joda.time.Duration;\n+import tc.oc.chunk.NullChunkGenerator;\n import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.chat.Audience;\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.exception.MapNotFoundException;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.match.factory.MatchFactory;\n import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.terrain.TerrainModule;\n+import tc.oc.server.Scheduler;\n+import tc.oc.util.FileUtils;\n+import tc.oc.util.logging.ClassLogger;\n \n-public class MatchManagerImpl implements MatchManager {\n+public class MatchManagerImpl implements MatchFactory, MatchManager {\n \n+  private static final Duration TIMEOUT = Duration.standardSeconds(30);\n+\n+  private final Logger logger;\n+  private final Server server;\n+  private final Scheduler scheduler;\n+\n+  private final AtomicLong matches;\n   private final Map<String, Match> matchById;\n   private final Map<String, Match> matchByWorld;\n \n-  public MatchManagerImpl() {\n-    this.matchById = new HashMap<>();\n-    this.matchByWorld = new HashMap<>();\n+  public MatchManagerImpl(Logger logger, Server server) {\n+    this.logger = ClassLogger.get(checkNotNull(logger), getClass());\n+    this.server = checkNotNull(server);\n+    this.scheduler = new Scheduler(PGM.get());\n+    this.matches = new AtomicLong(0);\n+    this.matchById = new ConcurrentHashMap<>();\n+    this.matchByWorld = new ConcurrentHashMap<>();\n   }\n \n   @Override\n", "next_change": {"commit": "5e311631c9253e7b9e8c9961850da792089034ec", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex 7df9d207..fd5208aa 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -1,61 +1,48 @@\n package tc.oc.pgm.match;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.collect.Iterables;\n-import java.io.File;\n-import java.io.IOException;\n import java.util.Map;\n-import java.util.Random;\n-import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n import javax.annotation.Nullable;\n-import org.bukkit.Server;\n import org.bukkit.World;\n-import org.bukkit.WorldCreator;\n import org.bukkit.entity.Player;\n-import org.joda.time.Duration;\n-import tc.oc.chunk.NullChunkGenerator;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.map.MapContext;\n-import tc.oc.pgm.api.map.exception.MapNotFoundException;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.match.event.MatchLoadEvent;\n import tc.oc.pgm.api.match.factory.MatchFactory;\n import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.terrain.TerrainModule;\n-import tc.oc.server.Scheduler;\n-import tc.oc.util.FileUtils;\n-import tc.oc.util.logging.ClassLogger;\n \n-public class MatchManagerImpl implements MatchFactory, MatchManager {\n+public class MatchManagerImpl implements MatchManager, Listener {\n \n-  private static final Duration TIMEOUT = Duration.standardSeconds(30);\n-\n-  private final Logger logger;\n-  private final Server server;\n-  private final Scheduler scheduler;\n-\n-  private final AtomicLong matches;\n   private final Map<String, Match> matchById;\n   private final Map<String, Match> matchByWorld;\n \n-  public MatchManagerImpl(Logger logger, Server server) {\n-    this.logger = ClassLogger.get(checkNotNull(logger), getClass());\n-    this.server = checkNotNull(server);\n-    this.scheduler = new Scheduler(PGM.get());\n-    this.matches = new AtomicLong(0);\n+  public MatchManagerImpl() {\n     this.matchById = new ConcurrentHashMap<>();\n     this.matchByWorld = new ConcurrentHashMap<>();\n   }\n \n+  @EventHandler\n+  public void onMatchLoad(MatchLoadEvent event) {\n+    final Match match = event.getMatch();\n+\n+    matchById.put(checkNotNull(match).getId(), match);\n+    matchByWorld.put(checkNotNull(match.getWorld()).getName(), match);\n+  }\n+\n+  @Override\n+  public MatchFactory createMatch(@Nullable String mapId) {\n+    // FIXME: \"infinite\" retry if a Match fails to load\n+    if (mapId == null) mapId = PGM.get().getMapOrder().popNextMap().getId();\n+    return new MatchFactoryImpl(mapId);\n+  }\n+\n   @Override\n   public Match getMatch(@Nullable World world) {\n     return matchByWorld.get(world == null ? null : world.getName());\n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex fd5208aa..d411bacc 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -50,7 +73,7 @@ public class MatchManagerImpl implements MatchManager, Listener {\n \n   @Override\n   public Iterable<Match> getMatches() {\n-    return Iterables.filter(matchById.values(), Match::isLoaded);\n+    return Collections.unmodifiableCollection(matchById.values());\n   }\n \n   @Override\n", "next_change": {"commit": "1f9a27591228c799422d015f0dac33add052180b", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex d411bacc..07198176 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -72,24 +76,20 @@ public class MatchManagerImpl implements MatchManager, Listener {\n   }\n \n   @Override\n-  public Iterable<Match> getMatches() {\n-    return Collections.unmodifiableCollection(matchById.values());\n+  public Iterator<Match> getMatches() {\n+    return Iterators.unmodifiableIterator(matchById.values().iterator());\n   }\n \n   @Override\n   public Iterable<? extends Audience> getAudiences() {\n-    return getMatches();\n+    return Iterables.unmodifiableIterable(matchById.values());\n   }\n \n   @Override\n   public MatchPlayer getPlayer(@Nullable Player bukkit) {\n-    // FIXME: determine if this needs to be more efficient with N matches\n-    for (Match match : getMatches()) {\n-      final MatchPlayer player = match.getPlayer(bukkit);\n-      if (player != null) {\n-        return player;\n-      }\n-    }\n-    return null;\n+    if (bukkit == null) return null;\n+    final Match match = getMatch(bukkit.getWorld());\n+    if (match == null) return null;\n+    return match.getPlayer(bukkit);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex d411bacc..cd2524f6 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -73,7 +32,18 @@ public class MatchManagerImpl implements MatchManager, Listener {\n \n   @Override\n   public Iterable<Match> getMatches() {\n-    return Collections.unmodifiableCollection(matchById.values());\n+    return Iterables.filter(matchById.values(), Match::isLoaded);\n+  }\n+\n+  @Override\n+  public void addMatch(Match match) {\n+    matchById.put(checkNotNull(match).getId(), match);\n+    matchByWorld.put(match.getWorld().getName(), match);\n+\n+    PGM.get()\n+        .getServer()\n+        .getScheduler()\n+        .runTaskLaterAsynchronously(PGM.get(), this::cleanUp, 20 * 10);\n   }\n \n   @Override\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex cd2524f6..4c5f57e9 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -43,7 +44,7 @@ public class MatchManagerImpl implements MatchManager {\n     PGM.get()\n         .getServer()\n         .getScheduler()\n-        .runTaskLaterAsynchronously(PGM.get(), this::cleanUp, 20 * 10);\n+        .runTaskLaterAsynchronously(PGM.get(), this::cleanUp, 20 * 10 /* 10 seconds later */);\n   }\n \n   @Override\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex 4c5f57e9..7df9d207 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -36,17 +66,6 @@ public class MatchManagerImpl implements MatchManager {\n     return Iterables.filter(matchById.values(), Match::isLoaded);\n   }\n \n-  @Override\n-  public void addMatch(Match match) {\n-    matchById.put(checkNotNull(match).getId(), match);\n-    matchByWorld.put(match.getWorld().getName(), match);\n-\n-    PGM.get()\n-        .getServer()\n-        .getScheduler()\n-        .runTaskLaterAsynchronously(PGM.get(), this::cleanUp, 20 * 10 /* 10 seconds later */);\n-  }\n-\n   @Override\n   public Iterable<? extends Audience> getAudiences() {\n     return getMatches();\n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex 7df9d207..d411bacc 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -63,7 +73,7 @@ public class MatchManagerImpl implements MatchFactory, MatchManager {\n \n   @Override\n   public Iterable<Match> getMatches() {\n-    return Iterables.filter(matchById.values(), Match::isLoaded);\n+    return Collections.unmodifiableCollection(matchById.values());\n   }\n \n   @Override\n", "next_change": {"commit": "1f9a27591228c799422d015f0dac33add052180b", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\nindex d411bacc..07198176 100644\n--- a/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n+++ b/src/main/java/tc/oc/pgm/match/MatchManagerImpl.java\n", "chunk": "@@ -72,24 +76,20 @@ public class MatchManagerImpl implements MatchManager, Listener {\n   }\n \n   @Override\n-  public Iterable<Match> getMatches() {\n-    return Collections.unmodifiableCollection(matchById.values());\n+  public Iterator<Match> getMatches() {\n+    return Iterators.unmodifiableIterator(matchById.values().iterator());\n   }\n \n   @Override\n   public Iterable<? extends Audience> getAudiences() {\n-    return getMatches();\n+    return Iterables.unmodifiableIterable(matchById.values());\n   }\n \n   @Override\n   public MatchPlayer getPlayer(@Nullable Player bukkit) {\n-    // FIXME: determine if this needs to be more efficient with N matches\n-    for (Match match : getMatches()) {\n-      final MatchPlayer player = match.getPlayer(bukkit);\n-      if (player != null) {\n-        return player;\n-      }\n-    }\n-    return null;\n+    if (bukkit == null) return null;\n+    final Match match = getMatch(bukkit.getWorld());\n+    if (match == null) return null;\n+    return match.getPlayer(bukkit);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzA4NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943084", "body": "I think we should keep the `*` import?", "bodyText": "I think we should keep the * import?", "bodyHTML": "<p dir=\"auto\">I think we should keep the <code>*</code> import?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:44:29Z", "path": "src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java", "diffHunk": "@@ -1,95 +1,102 @@\n package tc.oc.pgm.modes;\n \n-import static tc.oc.pgm.map.ProtoVersions.*;\n+import static tc.oc.pgm.api.map.MapProtos.MODES_IMPLEMENTATION_VERSION;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java b/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\nindex 98f29a8c..bfbd0a06 100644\n--- a/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\n+++ b/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\n", "chunk": "@@ -1,10 +1,8 @@\n package tc.oc.pgm.modes;\n \n-import static tc.oc.pgm.api.map.MapProtos.MODES_IMPLEMENTATION_VERSION;\n+import static tc.oc.pgm.api.map.ProtoVersions.MODES_IMPLEMENTATION_VERSION;\n \n-import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.List;\n import java.util.logging.Logger;\n import org.bukkit.ChatColor;\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java b/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\nindex bfbd0a06..bc8d3405 100644\n--- a/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\n+++ b/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\n", "chunk": "@@ -10,8 +10,8 @@ import org.bukkit.material.MaterialData;\n import org.jdom2.Document;\n import org.jdom2.Element;\n import org.joda.time.Duration;\n-import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchModule;\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java b/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\nindex bc8d3405..98f29a8c 100644\n--- a/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\n+++ b/src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java\n", "chunk": "@@ -15,6 +17,7 @@ import tc.oc.pgm.api.map.factory.MapFactory;\n import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.goals.GoalMatchModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzE2Mg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943162", "body": "Modules should have their own loggers if possible.", "bodyText": "Modules should have their own loggers if possible.", "bodyHTML": "<p dir=\"auto\">Modules should have their own loggers if possible.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:45:48Z", "path": "src/main/java/tc/oc/pgm/modules/EventFilterMatchModule.java", "diffHunk": "@@ -39,14 +55,16 @@\n  * kept simple.\n  */\n @ListenerScope(MatchScope.LOADED)\n-public class EventFilterMatchModule extends MatchModule implements Listener {\n+public class EventFilterMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n \n   public EventFilterMatchModule(Match match) {\n-    super(match);\n+    this.match = match;\n   }\n \n   boolean cancel(Cancellable event, @Nullable MatchPlayer actor, @Nullable Component message) {\n-    logger.fine(\"Cancel \" + event + \" actor=\" + actor);\n+    match.getLogger().fine(\"Cancel \" + event + \" actor=\" + actor);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzc4Mg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943782", "body": "Unnecessary newline", "bodyText": "Unnecessary newline", "bodyHTML": "<p dir=\"auto\">Unnecessary newline</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:57:43Z", "path": "src/main/java/tc/oc/pgm/score/ScoreModule.java", "diffHunk": "@@ -80,69 +71,78 @@ public ScoreConfig getConfig() {\n     return config;\n   }\n \n-  // ---------------------\n-  // ---- XML Parsing ----\n-  // ---------------------\n-\n-  public static ScoreModule parse(MapModuleContext context, Logger logger, Document doc)\n-      throws InvalidXMLException {\n-    SemanticVersion proto = context.getProto();\n+  public static class Factory implements MapModuleFactory<ScoreModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getSoftDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n \n-    List<Element> scoreElements = doc.getRootElement().getChildren(\"score\");\n-    if (scoreElements.size() == 0) {\n-      return null;\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(BlitzModule.class);\n     }\n \n-    RegionParser regionParser = context.getRegionParser();\n-    ScoreConfig config = new ScoreConfig();\n-    ImmutableSet.Builder<ScoreBoxFactory> scoreBoxFactories = ImmutableSet.builder();\n-\n-    for (Element scoreEl : scoreElements) {\n-      config.scoreLimit = XMLUtils.parseNumber(scoreEl.getChild(\"limit\"), Integer.class, -1);\n-\n-      // For backwards compatibility, default kill/death points to 1 if proto is old and <king/> tag\n-      // is not present\n-      boolean scoreKillsByDefault =\n-          proto.isOlderThan(ProtoVersions.DEFAULT_SCORES_TO_ZERO)\n-              && scoreEl.getChild(\"king\") == null;\n-      config.deathScore =\n-          XMLUtils.parseNumber(\n-              scoreEl.getChild(\"deaths\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n-      config.killScore =\n-          XMLUtils.parseNumber(\n-              scoreEl.getChild(\"kills\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n-\n-      for (Element scoreBoxEl : scoreEl.getChildren(\"box\")) {\n-        int points =\n+    @Override\n+    public ScoreModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      Version proto = factory.getProto();\n+\n+      List<Element> scoreElements = doc.getRootElement().getChildren(\"score\");\n+      if (scoreElements.size() == 0) {\n+        return null;\n+      }\n+\n+      RegionParser regionParser = factory.getRegions();\n+      ScoreConfig config = new ScoreConfig();\n+      ImmutableSet.Builder<ScoreBoxFactory> scoreBoxFactories = ImmutableSet.builder();\n+\n+      for (Element scoreEl : scoreElements) {\n+        config.scoreLimit = XMLUtils.parseNumber(scoreEl.getChild(\"limit\"), Integer.class, -1);\n+\n+        // For backwards compatibility, default kill/death points to 1 if proto is old and <king/>\n+        // tag\n+        // is not present", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/score/ScoreModule.java b/src/main/java/tc/oc/pgm/score/ScoreModule.java\nindex 943bae50..335254ac 100644\n--- a/src/main/java/tc/oc/pgm/score/ScoreModule.java\n+++ b/src/main/java/tc/oc/pgm/score/ScoreModule.java\n", "chunk": "@@ -103,7 +95,8 @@ public class ScoreModule implements MapModule {\n         // tag\n         // is not present\n         boolean scoreKillsByDefault =\n-            proto.isOlderThan(MapProtos.DEFAULT_SCORES_TO_ZERO) && scoreEl.getChild(\"king\") == null;\n+            proto.isOlderThan(ProtoVersions.DEFAULT_SCORES_TO_ZERO)\n+                && scoreEl.getChild(\"king\") == null;\n         config.deathScore =\n             XMLUtils.parseNumber(\n                 scoreEl.getChild(\"deaths\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/score/ScoreModule.java b/src/main/java/tc/oc/pgm/score/ScoreModule.java\nindex 335254ac..a14ab21f 100644\n--- a/src/main/java/tc/oc/pgm/score/ScoreModule.java\n+++ b/src/main/java/tc/oc/pgm/score/ScoreModule.java\n", "chunk": "@@ -95,7 +95,7 @@ public class ScoreModule implements MapModule {\n         // tag\n         // is not present\n         boolean scoreKillsByDefault =\n-            proto.isOlderThan(ProtoVersions.DEFAULT_SCORES_TO_ZERO)\n+            proto.isOlderThan(MapProtos.DEFAULT_SCORES_TO_ZERO)\n                 && scoreEl.getChild(\"king\") == null;\n         config.deathScore =\n             XMLUtils.parseNumber(\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/score/ScoreModule.java b/src/main/java/tc/oc/pgm/score/ScoreModule.java\nindex a14ab21f..509d280b 100644\n--- a/src/main/java/tc/oc/pgm/score/ScoreModule.java\n+++ b/src/main/java/tc/oc/pgm/score/ScoreModule.java\n", "chunk": "@@ -95,8 +95,7 @@ public class ScoreModule implements MapModule {\n         // tag\n         // is not present\n         boolean scoreKillsByDefault =\n-            proto.isOlderThan(MapProtos.DEFAULT_SCORES_TO_ZERO)\n-                && scoreEl.getChild(\"king\") == null;\n+            proto.isOlderThan(MapProtos.DEFAULT_SCORES_TO_ZERO) && scoreEl.getChild(\"king\") == null;\n         config.deathScore =\n             XMLUtils.parseNumber(\n                 scoreEl.getChild(\"deaths\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzgzNA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943834", "body": "Should be translatable.", "bodyText": "Should be translatable.", "bodyHTML": "<p dir=\"auto\">Should be translatable.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:58:48Z", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\nindex 4c03b1c6..f33c1e89 100644\n--- a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n+++ b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n", "chunk": "@@ -88,37 +70,6 @@ public class SidebarMatchModule implements MatchModule, Listener {\n \n   protected @Nullable BukkitTask renderTask;\n \n-  private static String renderSidebarTitle(Collection<MapTag> tags) {\n-    final List<String> gamemode =\n-        tags.stream()\n-            .filter(MapTag::isGamemode)\n-            .filter(tag -> !tag.isAuxiliary())\n-            .map(MapTag::getName)\n-            .collect(Collectors.toList());\n-    final List<String> auxiliary =\n-        tags.stream()\n-            .filter(MapTag::isGamemode)\n-            .filter(MapTag::isAuxiliary)\n-            .map(MapTag::getName)\n-            .collect(Collectors.toList());\n-\n-    String title = \"\";\n-\n-    if (gamemode.size() == 1) {\n-      title = gamemode.get(0);\n-    } else if (gamemode.size() >= 2) {\n-      title = \"Objectives\";\n-    }\n-\n-    if (auxiliary.size() == 1) {\n-      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n-    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n-      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n-    }\n-\n-    return title.isEmpty() ? \"Match\" : title;\n-  }\n-\n   private class Sidebar {\n \n     private static final String IDENTIFIER = \"pgm\";\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\nindex f33c1e89..3a3a75f6 100644\n--- a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n+++ b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n", "chunk": "@@ -70,6 +88,37 @@ public class SidebarMatchModule implements MatchModule, Listener {\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \"& \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n+    }\n+\n+    return title.isEmpty() ? \"Match\" : title;\n+  }\n+\n   private class Sidebar {\n \n     private static final String IDENTIFIER = \"pgm\";\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzg3MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943871", "body": "`&` should also be translatable.", "bodyText": "& should also be translatable.", "bodyHTML": "<p dir=\"auto\"><code>&amp;</code> should also be translatable.</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:59:24Z", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\nindex 4c03b1c6..f33c1e89 100644\n--- a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n+++ b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n", "chunk": "@@ -88,37 +70,6 @@ public class SidebarMatchModule implements MatchModule, Listener {\n \n   protected @Nullable BukkitTask renderTask;\n \n-  private static String renderSidebarTitle(Collection<MapTag> tags) {\n-    final List<String> gamemode =\n-        tags.stream()\n-            .filter(MapTag::isGamemode)\n-            .filter(tag -> !tag.isAuxiliary())\n-            .map(MapTag::getName)\n-            .collect(Collectors.toList());\n-    final List<String> auxiliary =\n-        tags.stream()\n-            .filter(MapTag::isGamemode)\n-            .filter(MapTag::isAuxiliary)\n-            .map(MapTag::getName)\n-            .collect(Collectors.toList());\n-\n-    String title = \"\";\n-\n-    if (gamemode.size() == 1) {\n-      title = gamemode.get(0);\n-    } else if (gamemode.size() >= 2) {\n-      title = \"Objectives\";\n-    }\n-\n-    if (auxiliary.size() == 1) {\n-      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n-    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n-      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n-    }\n-\n-    return title.isEmpty() ? \"Match\" : title;\n-  }\n-\n   private class Sidebar {\n \n     private static final String IDENTIFIER = \"pgm\";\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\nindex f33c1e89..3a3a75f6 100644\n--- a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n+++ b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n", "chunk": "@@ -70,6 +88,37 @@ public class SidebarMatchModule implements MatchModule, Listener {\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \"& \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n+    }\n+\n+    return title.isEmpty() ? \"Match\" : title;\n+  }\n+\n   private class Sidebar {\n \n     private static final String IDENTIFIER = \"pgm\";\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzg3Nw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943877", "body": "This too", "bodyText": "This too", "bodyHTML": "<p dir=\"auto\">This too</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:59:31Z", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n+    }\n+\n+    return title.isEmpty() ? \"Match\" : title;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\nindex 4c03b1c6..f33c1e89 100644\n--- a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n+++ b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n", "chunk": "@@ -88,37 +70,6 @@ public class SidebarMatchModule implements MatchModule, Listener {\n \n   protected @Nullable BukkitTask renderTask;\n \n-  private static String renderSidebarTitle(Collection<MapTag> tags) {\n-    final List<String> gamemode =\n-        tags.stream()\n-            .filter(MapTag::isGamemode)\n-            .filter(tag -> !tag.isAuxiliary())\n-            .map(MapTag::getName)\n-            .collect(Collectors.toList());\n-    final List<String> auxiliary =\n-        tags.stream()\n-            .filter(MapTag::isGamemode)\n-            .filter(MapTag::isAuxiliary)\n-            .map(MapTag::getName)\n-            .collect(Collectors.toList());\n-\n-    String title = \"\";\n-\n-    if (gamemode.size() == 1) {\n-      title = gamemode.get(0);\n-    } else if (gamemode.size() >= 2) {\n-      title = \"Objectives\";\n-    }\n-\n-    if (auxiliary.size() == 1) {\n-      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n-    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n-      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n-    }\n-\n-    return title.isEmpty() ? \"Match\" : title;\n-  }\n-\n   private class Sidebar {\n \n     private static final String IDENTIFIER = \"pgm\";\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\nindex f33c1e89..3a3a75f6 100644\n--- a/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n+++ b/src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java\n", "chunk": "@@ -70,6 +88,37 @@ public class SidebarMatchModule implements MatchModule, Listener {\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \"& \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n+    }\n+\n+    return title.isEmpty() ? \"Match\" : title;\n+  }\n+\n   private class Sidebar {\n \n     private static final String IDENTIFIER = \"pgm\";\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDAyNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944026", "body": "`amount`?", "bodyText": "amount?", "bodyHTML": "<p dir=\"auto\"><code>amount</code>?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:02:41Z", "path": "src/main/java/tc/oc/pgm/teams/TeamModule.java", "diffHunk": "@@ -40,15 +39,44 @@ public TeamModule(Set<TeamFactory> teams, @Nullable Boolean requireEven) {\n   }\n \n   @Override\n-  public String toString() {\n-    return getClass().getSimpleName() + \"{teams=[\" + Joiner.on(\", \").join(teams) + \"]}\";\n+  public Collection<MapTag> getTags() {\n+    final int id = teams.size();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/teams/TeamModule.java b/src/main/java/tc/oc/pgm/teams/TeamModule.java\nindex a6d2fa78..fd161efb 100644\n--- a/src/main/java/tc/oc/pgm/teams/TeamModule.java\n+++ b/src/main/java/tc/oc/pgm/teams/TeamModule.java\n", "chunk": "@@ -38,31 +29,9 @@ public class TeamModule implements MapModule<TeamMatchModule> {\n     this.requireEven = requireEven;\n   }\n \n-  @Override\n-  public Collection<MapTag> getTags() {\n-    final int id = teams.size();\n-    Collection<MapTag> tags = TAGS.get(id);\n-    if (tags == null) {\n-      tags =\n-          ImmutableList.of(\n-              MapTag.create(\n-                  id + \"team\" + (id == 1 ? \"\" : \"s\"),\n-                  id + \" Team\" + (id == 1 ? \"\" : \"s\"),\n-                  false,\n-                  true));\n-      TAGS.put(id, tags);\n-    }\n-    return tags;\n-  }\n-\n-  @Override\n-  public Collection<Class<? extends MatchModule>> getHardDependencies() {\n-    return ImmutableList.of(JoinMatchModule.class, StartMatchModule.class);\n-  }\n-\n   public static class Factory implements MapModuleFactory<TeamModule> {\n     @Override\n-    public TeamModule parse(MapFactory factory, Logger logger, Document doc)\n+    public TeamModule parse(MapContext context, Logger logger, Document doc)\n         throws InvalidXMLException {\n       Set<TeamFactory> teamFactories = Sets.newLinkedHashSet();\n       Boolean requireEven = null;\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/teams/TeamModule.java b/src/main/java/tc/oc/pgm/teams/TeamModule.java\nindex fd161efb..a172e58b 100644\n--- a/src/main/java/tc/oc/pgm/teams/TeamModule.java\n+++ b/src/main/java/tc/oc/pgm/teams/TeamModule.java\n", "chunk": "@@ -20,18 +19,28 @@ import tc.oc.util.StringUtils;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n-public class TeamModule implements MapModule<TeamMatchModule> {\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+public class TeamModule implements MapModule<TeamMatchModule>, MapInfoExtra {\n+\n   private final Set<TeamFactory> teams;\n   private final @Nullable Boolean requireEven;\n+  private final Collection<Integer> teamLimits;\n+  private final int playerLimit;\n \n   public TeamModule(Set<TeamFactory> teams, @Nullable Boolean requireEven) {\n     this.teams = teams;\n     this.requireEven = requireEven;\n+    this.teamLimits = Collections2.transform(teams, TeamFactory::getMaxPlayers);\n+    this.playerLimit = teams.stream().mapToInt(TeamFactory::getMaxPlayers).sum();\n   }\n \n   public static class Factory implements MapModuleFactory<TeamModule> {\n     @Override\n-    public TeamModule parse(MapContext context, Logger logger, Document doc)\n+    public TeamModule parse(MapFactory factory, Logger logger, Document doc)\n         throws InvalidXMLException {\n       Set<TeamFactory> teamFactories = Sets.newLinkedHashSet();\n       Boolean requireEven = null;\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/teams/TeamModule.java b/src/main/java/tc/oc/pgm/teams/TeamModule.java\nindex a172e58b..cc01d8ad 100644\n--- a/src/main/java/tc/oc/pgm/teams/TeamModule.java\n+++ b/src/main/java/tc/oc/pgm/teams/TeamModule.java\n", "chunk": "@@ -38,6 +41,11 @@ public class TeamModule implements MapModule<TeamMatchModule>, MapInfoExtra {\n     this.playerLimit = teams.stream().mapToInt(TeamFactory::getMaxPlayers).sum();\n   }\n \n+  @Override\n+  public Collection<Class<? extends MatchModule>> getHardDependencies() {\n+    return ImmutableList.of(JoinMatchModule.class, StartMatchModule.class);\n+  }\n+\n   public static class Factory implements MapModuleFactory<TeamModule> {\n     @Override\n     public TeamModule parse(MapFactory factory, Logger logger, Document doc)\n", "next_change": null}]}}, {"header": "diff --git a/src/main/java/tc/oc/pgm/teams/TeamModule.java b/src/main/java/tc/oc/pgm/teams/TeamModule.java\nindex fd161efb..a172e58b 100644\n--- a/src/main/java/tc/oc/pgm/teams/TeamModule.java\n+++ b/src/main/java/tc/oc/pgm/teams/TeamModule.java\n", "chunk": "@@ -40,7 +49,7 @@ public class TeamModule implements MapModule<TeamMatchModule> {\n         requireEven = XMLUtils.parseBoolean(teamRootElement.getAttribute(\"even\"), requireEven);\n \n         for (Element teamElement : teamRootElement.getChildren(\"team\")) {\n-          teamFactories.add(parseTeamDefinition(teamElement, context));\n+          teamFactories.add(parseTeamDefinition(teamElement, factory));\n         }\n       }\n \n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/teams/TeamModule.java b/src/main/java/tc/oc/pgm/teams/TeamModule.java\nindex a172e58b..a6d2fa78 100644\n--- a/src/main/java/tc/oc/pgm/teams/TeamModule.java\n+++ b/src/main/java/tc/oc/pgm/teams/TeamModule.java\n", "chunk": "@@ -57,27 +79,12 @@ public class TeamModule implements MapModule<TeamMatchModule>, MapInfoExtra {\n     }\n   }\n \n-  @Override\n-  public String toString() {\n-    return getClass().getSimpleName() + \"{teams=[\" + Joiner.on(\", \").join(teams) + \"]}\";\n-  }\n-\n   @Override\n   public TeamMatchModule createMatchModule(Match match) {\n     return new TeamMatchModule(\n         match, teams, requireEven != null ? requireEven : Config.Teams.requireEven());\n   }\n \n-  @Override\n-  public int getPlayerLimit() {\n-    return playerLimit;\n-  }\n-\n-  @Override\n-  public Collection<Integer> getTeamLimits() {\n-    return teamLimits;\n-  }\n-\n   /**\n    * Gets the set of TeamInfo instances this map provides.\n    *\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA4OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944088", "body": "Why complete removal?", "bodyText": "Why complete removal?", "bodyHTML": "<p dir=\"auto\">Why complete removal?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:03:56Z", "path": "src/main/java/tc/oc/pgm/terrain/TerrainModule.java", "diffHunk": "@@ -1,40 +1,28 @@\n package tc.oc.pgm.terrain;\n \n-import java.io.File;\n import java.util.Random;\n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.bukkit.generator.ChunkGenerator;\n import org.jdom2.Document;\n import org.jdom2.Element;\n import tc.oc.chunk.NullChunkGenerator;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.MapModuleFactory;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.match.MatchModule;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n-import tc.oc.xml.Node;\n \n-@ModuleDescription(name = \"Terrain\")\n-public class TerrainModule extends MapModule<MatchModule> {\n-\n-  private static final MapTag VANILLAWORLDGEN_TAG = MapTag.forName(\"vanillaworldgen\");\n+public class TerrainModule implements MapModule {\n \n   private final TerrainOptions options;\n \n   public TerrainModule(TerrainOptions options) {\n     this.options = options;\n   }\n \n-  @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (options.vanilla) tags.add(VANILLAWORLDGEN_TAG);\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/terrain/TerrainModule.java b/src/main/java/tc/oc/pgm/terrain/TerrainModule.java\ndeleted file mode 100644\nindex 2745899e..00000000\n--- a/src/main/java/tc/oc/pgm/terrain/TerrainModule.java\n+++ /dev/null\n", "chunk": "@@ -1,65 +0,0 @@\n-package tc.oc.pgm.terrain;\n-\n-import java.util.Random;\n-import java.util.logging.Logger;\n-import javax.annotation.Nullable;\n-import org.bukkit.generator.ChunkGenerator;\n-import org.jdom2.Document;\n-import org.jdom2.Element;\n-import tc.oc.chunk.NullChunkGenerator;\n-import tc.oc.pgm.api.map.MapModule;\n-import tc.oc.pgm.api.map.factory.MapFactory;\n-import tc.oc.pgm.api.map.factory.MapModuleFactory;\n-import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.api.match.MatchModule;\n-import tc.oc.pgm.util.XMLUtils;\n-import tc.oc.xml.InvalidXMLException;\n-\n-public class TerrainModule implements MapModule {\n-\n-  private final TerrainOptions options;\n-\n-  public TerrainModule(TerrainOptions options) {\n-    this.options = options;\n-  }\n-\n-  public @Nullable ChunkGenerator getChunkGenerator() {\n-    return options.vanilla ? null : new NullChunkGenerator();\n-  }\n-\n-  public long getSeed() {\n-    if (options.seed == null) {\n-      return new Random().nextLong();\n-    } else {\n-      return options.seed;\n-    }\n-  }\n-\n-  @Override\n-  public MatchModule createMatchModule(Match match) {\n-    return null;\n-  }\n-\n-  public static class Factory implements MapModuleFactory<TerrainModule> {\n-    @Override\n-    public TerrainModule parse(MapFactory factory, Logger logger, Document doc)\n-        throws InvalidXMLException {\n-      boolean vanilla = false;\n-      Long seed = null;\n-\n-      for (Element elTerrain : doc.getRootElement().getChildren(\"terrain\")) {\n-        vanilla = XMLUtils.parseBoolean(elTerrain.getAttribute(\"vanilla\"), vanilla);\n-        String seedText = elTerrain.getAttributeValue(\"seed\");\n-        if (seedText != null) {\n-          try {\n-            seed = Long.parseLong(seedText);\n-          } catch (NumberFormatException e) {\n-            seed = (long) seedText.hashCode();\n-          }\n-        }\n-      }\n-\n-      return new TerrainModule(new TerrainOptions(vanilla, seed));\n-    }\n-  }\n-}\n", "next_change": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/terrain/TerrainModule.java b/src/main/java/tc/oc/pgm/terrain/TerrainModule.java\nnew file mode 100644\nindex 00000000..744d99d5\n--- /dev/null\n+++ b/src/main/java/tc/oc/pgm/terrain/TerrainModule.java\n", "chunk": "@@ -0,0 +1,65 @@\n+package tc.oc.pgm.terrain;\n+\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import org.bukkit.generator.ChunkGenerator;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.chunk.NullChunkGenerator;\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.xml.InvalidXMLException;\n+\n+public class TerrainModule implements MapModule {\n+\n+  private final TerrainOptions options;\n+\n+  public TerrainModule(TerrainOptions options) {\n+    this.options = options;\n+  }\n+\n+  public @Nullable ChunkGenerator getChunkGenerator() {\n+    return options.vanilla ? null : new NullChunkGenerator();\n+  }\n+\n+  public long getSeed() {\n+    if (options.seed == null) {\n+      return new Random().nextLong();\n+    } else {\n+      return options.seed;\n+    }\n+  }\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return null;\n+  }\n+\n+  public static class Factory implements MapModuleFactory<TerrainModule> {\n+    @Override\n+    public TerrainModule parse(MapContext context, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      boolean vanilla = false;\n+      Long seed = null;\n+\n+      for (Element elTerrain : doc.getRootElement().getChildren(\"terrain\")) {\n+        vanilla = XMLUtils.parseBoolean(elTerrain.getAttribute(\"vanilla\"), vanilla);\n+        String seedText = elTerrain.getAttributeValue(\"seed\");\n+        if (seedText != null) {\n+          try {\n+            seed = Long.parseLong(seedText);\n+          } catch (NumberFormatException e) {\n+            seed = (long) seedText.hashCode();\n+          }\n+        }\n+      }\n+\n+      return new TerrainModule(new TerrainOptions(vanilla, seed));\n+    }\n+  }\n+}\n", "next_change": {"commit": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/terrain/TerrainModule.java b/src/main/java/tc/oc/pgm/terrain/TerrainModule.java\ndeleted file mode 100644\nindex 744d99d5..00000000\n--- a/src/main/java/tc/oc/pgm/terrain/TerrainModule.java\n+++ /dev/null\n", "chunk": "@@ -1,65 +0,0 @@\n-package tc.oc.pgm.terrain;\n-\n-import java.util.Random;\n-import java.util.logging.Logger;\n-import javax.annotation.Nullable;\n-import org.bukkit.generator.ChunkGenerator;\n-import org.jdom2.Document;\n-import org.jdom2.Element;\n-import tc.oc.chunk.NullChunkGenerator;\n-import tc.oc.pgm.api.map.MapContext;\n-import tc.oc.pgm.api.map.MapModule;\n-import tc.oc.pgm.api.map.factory.MapModuleFactory;\n-import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.api.match.MatchModule;\n-import tc.oc.pgm.util.XMLUtils;\n-import tc.oc.xml.InvalidXMLException;\n-\n-public class TerrainModule implements MapModule {\n-\n-  private final TerrainOptions options;\n-\n-  public TerrainModule(TerrainOptions options) {\n-    this.options = options;\n-  }\n-\n-  public @Nullable ChunkGenerator getChunkGenerator() {\n-    return options.vanilla ? null : new NullChunkGenerator();\n-  }\n-\n-  public long getSeed() {\n-    if (options.seed == null) {\n-      return new Random().nextLong();\n-    } else {\n-      return options.seed;\n-    }\n-  }\n-\n-  @Override\n-  public MatchModule createMatchModule(Match match) {\n-    return null;\n-  }\n-\n-  public static class Factory implements MapModuleFactory<TerrainModule> {\n-    @Override\n-    public TerrainModule parse(MapContext context, Logger logger, Document doc)\n-        throws InvalidXMLException {\n-      boolean vanilla = false;\n-      Long seed = null;\n-\n-      for (Element elTerrain : doc.getRootElement().getChildren(\"terrain\")) {\n-        vanilla = XMLUtils.parseBoolean(elTerrain.getAttribute(\"vanilla\"), vanilla);\n-        String seedText = elTerrain.getAttributeValue(\"seed\");\n-        if (seedText != null) {\n-          try {\n-            seed = Long.parseLong(seedText);\n-          } catch (NumberFormatException e) {\n-            seed = (long) seedText.hashCode();\n-          }\n-        }\n-      }\n-\n-      return new TerrainModule(new TerrainOptions(vanilla, seed));\n-    }\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944145", "body": "Why complete removal?", "bodyText": "Why complete removal?", "bodyHTML": "<p dir=\"auto\">Why complete removal?</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:05:19Z", "path": "src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java", "diffHunk": "@@ -1,103 +1,89 @@\n package tc.oc.pgm.timelimit;\n \n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.jdom2.Attribute;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapProtos;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.bossbar.BossBarModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.ProtoVersions;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.result.VictoryCondition;\n import tc.oc.pgm.result.VictoryConditions;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Time Limit\",\n-    requires = {BossBarModule.class})\n-public class TimeLimitModule extends MapModule<TimeLimitMatchModule> {\n-\n-  private static final MapTag TIMELIMIT_TAG = MapTag.forName(\"timelimit\");\n-\n+public class TimeLimitModule implements MapModule {\n   private final @Nullable TimeLimit timeLimit;\n \n   public TimeLimitModule(@Nullable TimeLimit limit) {\n     this.timeLimit = limit;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (timeLimit != null) tags.add(TIMELIMIT_TAG);\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDQ0MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944441", "bodyText": "Too many tags.. you have to keep it simple.", "author": "Electroid", "createdAt": "2020-01-25T17:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjQzNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946436", "bodyText": "You could easily differentiate maps where you have to score n amount of points to win the match and maps where you have to score most points before the time ends. This one was pretty useful.", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java b/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\nindex ba2dd917..7c55a3c4 100644\n--- a/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\n+++ b/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\n", "chunk": "@@ -17,6 +15,9 @@ import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n+import javax.annotation.Nullable;\n+import java.util.logging.Logger;\n+\n public class TimeLimitModule implements MapModule {\n   private final @Nullable TimeLimit timeLimit;\n \n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java b/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\nindex 7c55a3c4..ba2dd917 100644\n--- a/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\n+++ b/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\n", "chunk": "@@ -15,9 +17,6 @@ import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n-import javax.annotation.Nullable;\n-import java.util.logging.Logger;\n-\n public class TimeLimitModule implements MapModule {\n   private final @Nullable TimeLimit timeLimit;\n \n", "next_change": {"commit": "c02af41697dbe0326b0e03435ce31be894676c31", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java b/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\nindex ba2dd917..e10c9955 100644\n--- a/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\n+++ b/src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java\n", "chunk": "@@ -18,12 +22,19 @@ import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n public class TimeLimitModule implements MapModule {\n+  private static final Collection<MapTag> TAGS =\n+      ImmutableList.of(MapTag.create(\"timelimit\", \"Timelimit\", false, true));\n   private final @Nullable TimeLimit timeLimit;\n \n   public TimeLimitModule(@Nullable TimeLimit limit) {\n     this.timeLimit = limit;\n   }\n \n+  @Override\n+  public Collection<MapTag> getTags() {\n+    return timeLimit == null ? Collections.emptyList() : TAGS;\n+  }\n+\n   @Override\n   public MatchModule createMatchModule(Match match) {\n     return new TimeLimitMatchModule(match, this.timeLimit);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDMwMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944303", "body": "Here too", "bodyText": "Here too", "bodyHTML": "<p dir=\"auto\">Here too</p>", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:08:10Z", "path": "src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java", "diffHunk": "@@ -32,50 +28,48 @@ public WorldBorderModule(List<WorldBorder> borders) {\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    tags.add(WORLDBORDER_TAG);\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "459c36b117ef8f6a377836da5cc44a4be4e00b66", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java b/src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java\nindex c914011e..72d7e78a 100644\n--- a/src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java\n+++ b/src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java\n", "chunk": "@@ -20,13 +22,19 @@ import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n public class WorldBorderModule implements MapModule {\n-\n+  private final Collection<MapTag> TAGS =\n+      ImmutableList.of(MapTag.create(\"border\", \"World Border\", false, true));\n   private final List<WorldBorder> borders;\n \n   public WorldBorderModule(List<WorldBorder> borders) {\n     this.borders = borders;\n   }\n \n+  @Override\n+  public Collection<MapTag> getTags() {\n+    return TAGS;\n+  }\n+\n   @Override\n   public MatchModule createMatchModule(Match match) {\n     return new WorldBorderMatchModule(match, borders);\n", "next_change": null}]}}, {"oid": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "url": "https://github.com/PGMDev/PGM/commit/5fd3b360256ee9c73a19d35b4985291cda634b6a", "message": "Make Node a weak reference in XMLFeatureReference\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-27T08:08:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371461791", "body": "Is this assuming a map if a next map is missing? \r\nNext map not being defined is completely normal (for example, on voted pools) and shouldn't be avoided or treated like an error.", "bodyText": "Is this assuming a map if a next map is missing?\nNext map not being defined is completely normal (for example, on voted pools) and shouldn't be avoided or treated like an error.", "bodyHTML": "<p dir=\"auto\">Is this assuming a map if a next map is missing?<br>\nNext map not being defined is completely normal (for example, on voted pools) and shouldn't be avoided or treated like an error.</p>", "author": "Pablete1234", "createdAt": "2020-01-27T20:20:21Z", "path": "src/main/java/tc/oc/pgm/listeners/MotdListener.java", "diffHunk": "@@ -31,7 +31,9 @@ public MotdListener() {\n     this.format = Config.Motd.format();\n \n     // Ensure there are always default keys\n-    final MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    if (map == null) map = PGM.get().getMapLibrary().getMaps().next();", "originalCommit": "a3d3f979d271a5e4d5d4542cc9e6372615a71717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzMjk0Mg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371932942", "bodyText": "If we don't know what the true next map will be, what should the motd say? > PGM < ?", "author": "Electroid", "createdAt": "2020-01-28T17:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk5NzAwOA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371997008", "bodyText": "Either the current map, or something else like Deciding next map, PGM, or whatever other placeholder", "author": "Pablete1234", "createdAt": "2020-01-28T19:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/listeners/MotdListener.java b/src/main/java/tc/oc/pgm/listeners/MotdListener.java\nindex 36fbd5f3..4381a62e 100644\n--- a/src/main/java/tc/oc/pgm/listeners/MotdListener.java\n+++ b/src/main/java/tc/oc/pgm/listeners/MotdListener.java\n", "chunk": "@@ -27,23 +25,16 @@ public class MotdListener implements Listener {\n   private static final Map<String, String> MOTD_DATA = Maps.newHashMap();\n   private String format;\n \n+  // Show the default MOTD until a match has loaded\n+  private boolean ready = false;\n+\n   public MotdListener() {\n     this.format = Config.Motd.format();\n-\n-    // Ensure there are always default keys\n-    MapInfo map = PGM.get().getMapOrder().getNextMap();\n-    if (map == null) map = PGM.get().getMapLibrary().getMaps().next();\n-\n-    MOTD_DATA.put(MAP_NAME_KEY, map.getName());\n-    MOTD_DATA.put(MAP_VERSION_KEY, map.getVersion().toString());\n-    MOTD_DATA.put(STATE_NAME_KEY, \"Idle\");\n-    MOTD_DATA.put(STATE_NAME_LOWER_KEY, \"idle\");\n-    MOTD_DATA.put(STATE_COLOR_KEY, Config.Motd.Colors.idle().toString());\n   }\n \n   @EventHandler\n   public void onServerListPing(ServerListPingEvent event) {\n-    if (!Config.Motd.enabled()) return;\n+    if (!Config.Motd.enabled() || !ready) return;\n \n     String motd = format;\n     // There's no nice named string placeholder system built directly into Java :(.\n", "next_change": {"commit": "5e311631c9253e7b9e8c9961850da792089034ec", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/listeners/MotdListener.java b/src/main/java/tc/oc/pgm/listeners/MotdListener.java\nindex 4381a62e..15f7228c 100644\n--- a/src/main/java/tc/oc/pgm/listeners/MotdListener.java\n+++ b/src/main/java/tc/oc/pgm/listeners/MotdListener.java\n", "chunk": "@@ -25,16 +27,21 @@ public class MotdListener implements Listener {\n   private static final Map<String, String> MOTD_DATA = Maps.newHashMap();\n   private String format;\n \n-  // Show the default MOTD until a match has loaded\n-  private boolean ready = false;\n-\n   public MotdListener() {\n     this.format = Config.Motd.format();\n+\n+    // Ensure there are always default keys\n+    final MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    MOTD_DATA.put(MAP_NAME_KEY, map.getName());\n+    MOTD_DATA.put(MAP_VERSION_KEY, map.getVersion().toString());\n+    MOTD_DATA.put(STATE_NAME_KEY, \"Idle\");\n+    MOTD_DATA.put(STATE_NAME_LOWER_KEY, \"idle\");\n+    MOTD_DATA.put(STATE_COLOR_KEY, Config.Motd.Colors.idle().toString());\n   }\n \n   @EventHandler\n   public void onServerListPing(ServerListPingEvent event) {\n-    if (!Config.Motd.enabled() || !ready) return;\n+    if (!Config.Motd.enabled()) return;\n \n     String motd = format;\n     // There's no nice named string placeholder system built directly into Java :(.\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ3NzQ0NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371477444", "body": "should probably just use:\r\n\r\n```\r\n        final Map<Boolean, Set<String>> tagSet = Stream.of(tags.split(\",\"))\r\n                .map(String::toLowerCase)\r\n                .map(String::trim)\r\n                .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\"),\r\n                        Collectors.mapping(\r\n                                (String s) ->  s.startsWith(\"!\") ? s.substring(1) : s,\r\n                                Collectors.toSet())));\r\n```\r\nthat does both partitioning and removing the first char, that way you avoid the later transformation on the filter.\r\n\r\nAlso, i don't think linked lists are a good fit, should probably just use hash sets.", "bodyText": "should probably just use:\n        final Map<Boolean, Set<String>> tagSet = Stream.of(tags.split(\",\"))\n                .map(String::toLowerCase)\n                .map(String::trim)\n                .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\"),\n                        Collectors.mapping(\n                                (String s) ->  s.startsWith(\"!\") ? s.substring(1) : s,\n                                Collectors.toSet())));\n\nthat does both partitioning and removing the first char, that way you avoid the later transformation on the filter.\nAlso, i don't think linked lists are a good fit, should probably just use hash sets.", "bodyHTML": "<p dir=\"auto\">should probably just use:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        final Map&lt;Boolean, Set&lt;String&gt;&gt; tagSet = Stream.of(tags.split(&quot;,&quot;))\n                .map(String::toLowerCase)\n                .map(String::trim)\n                .collect(Collectors.partitioningBy(s -&gt; s.startsWith(&quot;!&quot;),\n                        Collectors.mapping(\n                                (String s) -&gt;  s.startsWith(&quot;!&quot;) ? s.substring(1) : s,\n                                Collectors.toSet())));\"><pre><code>        final Map&lt;Boolean, Set&lt;String&gt;&gt; tagSet = Stream.of(tags.split(\",\"))\n                .map(String::toLowerCase)\n                .map(String::trim)\n                .collect(Collectors.partitioningBy(s -&gt; s.startsWith(\"!\"),\n                        Collectors.mapping(\n                                (String s) -&gt;  s.startsWith(\"!\") ? s.substring(1) : s,\n                                Collectors.toSet())));\n</code></pre></div>\n<p dir=\"auto\">that does both partitioning and removing the first char, that way you avoid the later transformation on the filter.</p>\n<p dir=\"auto\">Also, i don't think linked lists are a good fit, should probably just use hash sets.</p>", "author": "Pablete1234", "createdAt": "2020-01-27T20:55:55Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -62,12 +66,19 @@ public static void maplist(\n       throws CommandException {\n     Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n     if (tags != null) {\n-      final Set<String> tagSet =\n+      final Map<Boolean, List<String>> tagSet =\n           Stream.of(tags.split(\",\"))\n               .map(String::toLowerCase)\n               .map(String::trim)\n-              .collect(Collectors.toSet());\n-      search = search.filter(map -> matchesTags(map, tagSet));\n+              .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\")));\n+      search =\n+          search.filter(\n+              map ->\n+                  matchesTags(\n+                      map,\n+                      tagSet.getOrDefault(false, new LinkedList<>()),\n+                      Collections2.transform(\n+                          tagSet.getOrDefault(true, new LinkedList<>()), s -> s.substring(1))));", "originalCommit": "40753435ea04caad64af2fede440d6d4c7f4e4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81301d06f6b907a9c86b9be370024f996c1a4a59", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 661ad728..71fbca68 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -32,101 +17,57 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n import tc.oc.pgm.api.map.MapLibrary;\n-import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.util.components.ComponentUtils;\n-import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n   @Command(\n-      aliases = {\"loadnewmaps\"},\n-      desc = \"Loads new maps and outputs any errors\")\n-  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n-    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n-  }\n-\n-  @Command(\n-      aliases = {\"maps\", \"maplist\", \"ml\"},\n+      aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-t <tag1>,<tag2>]\",\n+      usage = \"[page]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience,\n-      CommandSender sender,\n-      MapLibrary library,\n-      @Default(\"1\") Integer page,\n-      @Fallback(Type.NULL) @Switch('t') String tags,\n-      @Fallback(Type.NULL) @Switch('a') String author)\n+      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n       throws CommandException {\n-    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n-    if (tags != null) {\n-      final Map<Boolean, List<String>> tagSet =\n-          Stream.of(tags.split(\",\"))\n-              .map(String::toLowerCase)\n-              .map(String::trim)\n-              .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\")));\n-      search =\n-          search.filter(\n-              map ->\n-                  matchesTags(\n-                      map,\n-                      tagSet.getOrDefault(false, new LinkedList<>()),\n-                      Collections2.transform(\n-                          tagSet.getOrDefault(true, new LinkedList<>()), s -> s.substring(1))));\n-    }\n+    final Set<MapContext> maps = ImmutableSortedSet.copyOf(library.getMaps());\n \n-    if (author != null) {\n-      search = search.filter(map -> matchesAuthor(map, author));\n-    }\n-\n-    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n-    int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n+    int pages = (library.getMaps().size() + resultsPerPage - 1) / resultsPerPage;\n \n-    String title =\n-        ComponentUtils.paginate(\n-            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n-\n-    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n+        ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \"---------------\"\n+            + ChatColor.RESET\n+            + \" \"\n+            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n+            + ChatColor.DARK_AQUA\n+            + \" (\"\n+            + ChatColor.AQUA\n+            + page\n+            + ChatColor.DARK_AQUA\n+            + \" of \"\n+            + ChatColor.AQUA\n+            + pages\n+            + ChatColor.DARK_AQUA\n+            + \") \"\n+            + ChatColor.BLUE.toString()\n+            + ChatColor.STRIKETHROUGH\n+            + \" ---------------\"\n+            + ChatColor.RESET;\n+\n+    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapInfo map, int index) {\n-        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n-      }\n-    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n-  }\n-\n-  private static boolean matchesTags(\n-      MapInfo map, Collection<String> posTags, Collection<String> negTags) {\n-    int matches = 0;\n-    for (MapTag tag : checkNotNull(map).getTags()) {\n-      if (negTags.contains(tag.getId())) {\n-        return false;\n-      }\n-      if (posTags.contains(tag.getId())) {\n-        matches++;\n+      public String format(MapContext map, int index) {\n+        return (index + 1) + \". \" + map.getInfo().getDescription();\n       }\n-    }\n-    return matches == posTags.size();\n-  }\n-\n-  private static boolean matchesAuthor(MapInfo map, String query) {\n-    checkNotNull(map);\n-    query = checkNotNull(query).toLowerCase();\n-\n-    for (Contributor contributor : map.getAuthors()) {\n-      if (contributor.getName().toLowerCase().contains(query)) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    }.display(audience, maps, page);\n   }\n \n   @Command(\n", "next_change": {"commit": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 71fbca68..ecd202ed 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -65,7 +66,7 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getDescription();\n+        return (index + 1) + \". \" + map.getDescription();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "d61de25fe678a93112b686f50bc4e120cd8aa053", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex ecd202ed..69503185 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -63,10 +65,11 @@ public class MapCommands {\n             + \" ---------------\"\n             + ChatColor.RESET;\n \n-    new PrettyPaginatedResult<MapContext>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(MapContext map, int index) {\n-        return (index + 1) + \". \" + map.getDescription();\n+      public String format(MapInfo map, int index) {\n+        // TODO: fix misc.authorship\n+        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 69503185..15598937 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -69,7 +68,15 @@ public class MapCommands {\n       @Override\n       public String format(MapInfo map, int index) {\n         // TODO: fix misc.authorship\n-        return (index + 1) + \". \" + ChatColor.RED + map.getName() + \" \" + ChatColor.DARK_PURPLE + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors()).render(sender).toLegacyText();\n+        return (index + 1)\n+            + \". \"\n+            + ChatColor.RED\n+            + map.getName()\n+            + \" \"\n+            + ChatColor.DARK_PURPLE\n+            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                .render(sender)\n+                .toLegacyText();\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 15598937..3ce76bfc 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -67,16 +67,17 @@ public class MapCommands {\n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        // TODO: fix misc.authorship\n         return (index + 1)\n             + \". \"\n-            + ChatColor.RED\n-            + map.getName()\n-            + \" \"\n-            + ChatColor.DARK_PURPLE\n-            + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                .render(sender)\n-                .toLegacyText();\n+            + AllTranslations.get()\n+                .translate(\n+                    \"misc.authorship\",\n+                    sender,\n+                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n+                    ChatColor.DARK_PURPLE\n+                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n+                            .render(sender)\n+                            .toLegacyText());\n       }\n     }.display(audience, maps, page);\n   }\n", "next_change": {"commit": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "changed_code": [{"header": "diff --git a/src/main/java/tc/oc/pgm/commands/MapCommands.java b/src/main/java/tc/oc/pgm/commands/MapCommands.java\nindex 3ce76bfc..464c33b7 100644\n--- a/src/main/java/tc/oc/pgm/commands/MapCommands.java\n+++ b/src/main/java/tc/oc/pgm/commands/MapCommands.java\n", "chunk": "@@ -17,69 +27,67 @@ import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapContext;\n import tc.oc.pgm.api.map.MapInfo;\n-import tc.oc.pgm.api.map.MapInfoExtra;\n import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n-import tc.oc.pgm.util.TranslationUtils;\n import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[page]\",\n+      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n-      Audience audience, CommandSender sender, MapLibrary library, @Default(\"1\") int page)\n+      Audience audience,\n+      CommandSender sender,\n+      MapLibrary library,\n+      @Fallback(Type.NULL) @Switch('a') String author,\n+      @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n-    final Set<MapInfo> maps = ImmutableSortedSet.copyOf(library.getMaps());\n+    if (page == null) page = 1;\n+\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    // FIXME: Add tag support again\n+    if (author != null) {\n+      search = search.filter(map -> matchesAuthor(map, author));\n+    }\n \n+    Set<MapInfo> maps = search.collect(Collectors.toCollection(TreeSet::new));\n     int resultsPerPage = 8;\n     int pages = (maps.size() + resultsPerPage - 1) / resultsPerPage;\n \n+    String title =\n+        ComponentUtils.paginate(\n+            AllTranslations.get().translate(\"command.map.mapList.title\", sender), page, pages);\n     String listHeader =\n-        ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \"---------------\"\n-            + ChatColor.RESET\n-            + \" \"\n-            + AllTranslations.get().translate(\"command.map.mapList.title\", sender)\n-            + ChatColor.DARK_AQUA\n-            + \" (\"\n-            + ChatColor.AQUA\n-            + page\n-            + ChatColor.DARK_AQUA\n-            + \" of \"\n-            + ChatColor.AQUA\n-            + pages\n-            + ChatColor.DARK_AQUA\n-            + \") \"\n-            + ChatColor.BLUE.toString()\n-            + ChatColor.STRIKETHROUGH\n-            + \" ---------------\"\n-            + ChatColor.RESET;\n+        ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n     new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n       public String format(MapInfo map, int index) {\n-        return (index + 1)\n-            + \". \"\n-            + AllTranslations.get()\n-                .translate(\n-                    \"misc.authorship\",\n-                    sender,\n-                    ChatColor.GOLD + map.getName() + ChatColor.RESET,\n-                    ChatColor.DARK_PURPLE\n-                        + TranslationUtils.nameList(NameStyle.FANCY, map.getAuthors())\n-                            .render(sender)\n-                            .toLegacyText());\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n+      }\n+    }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n+  }\n+\n+  private static boolean matchesAuthor(MapInfo map, String query) {\n+    checkNotNull(map);\n+    query = checkNotNull(query).toLowerCase();\n+\n+    for (Contributor contributor : map.getAuthors()) {\n+      if (contributor.getName().toLowerCase().contains(query)) {\n+        return true;\n       }\n-    }.display(audience, maps, page);\n+    }\n+    return false;\n   }\n \n   @Command(\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "81301d06f6b907a9c86b9be370024f996c1a4a59", "url": "https://github.com/PGMDev/PGM/commit/81301d06f6b907a9c86b9be370024f996c1a4a59", "message": "WIP: Map, MapModule, and MatchModule refactors\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:32Z", "type": "commit"}, {"oid": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "url": "https://github.com/PGMDev/PGM/commit/b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "message": "WIP: Extract parsing and loading of MapContext into MapFactory\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:33Z", "type": "commit"}, {"oid": "d61de25fe678a93112b686f50bc4e120cd8aa053", "url": "https://github.com/PGMDev/PGM/commit/d61de25fe678a93112b686f50bc4e120cd8aa053", "message": "WIP: Loading works, now need to fix small bugs\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:33Z", "type": "commit"}, {"oid": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "url": "https://github.com/PGMDev/PGM/commit/de80d65322aee79cc6aa0a100514b1946bb85ae0", "message": "WIP: Fix formatting\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "url": "https://github.com/PGMDev/PGM/commit/702a285d3db3a34bac62e89b45f6fb58e9affc2f", "message": "WIP: Improve module loading and fix deadlock issues\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "54ea8df0c1b17aa541250d525a715b016f946ca0", "url": "https://github.com/PGMDev/PGM/commit/54ea8df0c1b17aa541250d525a715b016f946ca0", "message": "WIP: Refine MapInfo interfaces\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "22f1ab6219494f2e3ee6095bb9b23a93248a73a4", "url": "https://github.com/PGMDev/PGM/commit/22f1ab6219494f2e3ee6095bb9b23a93248a73a4", "message": "WIP: Fix various Match/Map related memory leaks\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "ccb9ded661cc71f48011a9b812cad8bf59e9194d", "url": "https://github.com/PGMDev/PGM/commit/ccb9ded661cc71f48011a9b812cad8bf59e9194d", "message": "WIP: Remove various debug statements\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "url": "https://github.com/PGMDev/PGM/commit/6a190392217e758d6648c5c6e9fe3973d60c54b8", "message": "WIP: Fix scoreboard, map tags, and some XML parsing\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:18Z", "type": "commit"}, {"oid": "284743996dd3ab36539b4084bf118b1c410c6f4f", "url": "https://github.com/PGMDev/PGM/commit/284743996dd3ab36539b4084bf118b1c410c6f4f", "message": "WIP: Fix formatting of map errors\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:39Z", "type": "commit"}, {"oid": "e06b78ffe3ece94c8a73e8b6af357d848ecec925", "url": "https://github.com/PGMDev/PGM/commit/e06b78ffe3ece94c8a73e8b6af357d848ecec925", "message": "WIP: Add default maps back\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "880a7bc94df17b2871006fd79dac1877f7df3886", "url": "https://github.com/PGMDev/PGM/commit/880a7bc94df17b2871006fd79dac1877f7df3886", "message": "WIP: Cycle to next map if there is an error, recursively\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "c8161dd6c939114ddc9c94df606e42d6b035b743", "url": "https://github.com/PGMDev/PGM/commit/c8161dd6c939114ddc9c94df606e42d6b035b743", "message": "WIP: End of WIP\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "ec756dce695ef7298cd98867a3a5c90a5bb6f813", "url": "https://github.com/PGMDev/PGM/commit/ec756dce695ef7298cd98867a3a5c90a5bb6f813", "message": "Fix NPE when Contributor names are still being loaded\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "f048768e4874fe36201ab51542a5b15b4a9bc9f4", "url": "https://github.com/PGMDev/PGM/commit/f048768e4874fe36201ab51542a5b15b4a9bc9f4", "message": "Fix various CME/NPE exceptions\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "5e311631c9253e7b9e8c9961850da792089034ec", "url": "https://github.com/PGMDev/PGM/commit/5e311631c9253e7b9e8c9961850da792089034ec", "message": "Teleport players over time on cycle\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "url": "https://github.com/PGMDev/PGM/commit/1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "message": "Refine World loading\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "19ad99b9fbf1ca636ef19ce89e7f1733d451c991", "url": "https://github.com/PGMDev/PGM/commit/19ad99b9fbf1ca636ef19ce89e7f1733d451c991", "message": "Make Node a weak reference in XMLFeatureReference\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "459c36b117ef8f6a377836da5cc44a4be4e00b66", "url": "https://github.com/PGMDev/PGM/commit/459c36b117ef8f6a377836da5cc44a4be4e00b66", "message": "Rebase to master and fix\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "db1ace89fd7d89448af44a543dcd461ce7371f83", "url": "https://github.com/PGMDev/PGM/commit/db1ace89fd7d89448af44a543dcd461ce7371f83", "message": "Fix commands when there is no match\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "c02af41697dbe0326b0e03435ce31be894676c31", "url": "https://github.com/PGMDev/PGM/commit/c02af41697dbe0326b0e03435ce31be894676c31", "message": "Add more documentation and bring back a few tags\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "3ecabb11647cdcc1a4bbbde1e6716241d4be475e", "url": "https://github.com/PGMDev/PGM/commit/3ecabb11647cdcc1a4bbbde1e6716241d4be475e", "message": "Fix contributor name fetching\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "fc98b55754aec855218c20b83308c0b31f8ef17f", "url": "https://github.com/PGMDev/PGM/commit/fc98b55754aec855218c20b83308c0b31f8ef17f", "message": "Fix map tags command search\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "e0bb667b32e9af7f321a48e2bd54885ec6bff2a9", "url": "https://github.com/PGMDev/PGM/commit/e0bb667b32e9af7f321a48e2bd54885ec6bff2a9", "message": "Remove debug cycle messages\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "9b2a830a20e789cf74090d1eea89dc14b75337e1", "url": "https://github.com/PGMDev/PGM/commit/9b2a830a20e789cf74090d1eea89dc14b75337e1", "message": "Fix default map sources\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "5c8524c7e6e38a75c7c0fd3438886ca7bb123d39", "url": "https://github.com/PGMDev/PGM/commit/5c8524c7e6e38a75c7c0fd3438886ca7bb123d39", "message": "Add negated map tags\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "e430378b97fc38be076427f469b513c914c87f8a", "url": "https://github.com/PGMDev/PGM/commit/e430378b97fc38be076427f469b513c914c87f8a", "message": "Fix NPE when map order fails\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "85f58ef6c8dbf472f0e280baaa84bbfac021de8f", "url": "https://github.com/PGMDev/PGM/commit/85f58ef6c8dbf472f0e280baaa84bbfac021de8f", "message": "Allow /cancel to interrupt match precycle\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "1f9a27591228c799422d015f0dac33add052180b", "url": "https://github.com/PGMDev/PGM/commit/1f9a27591228c799422d015f0dac33add052180b", "message": "Improve match lazy loading with a lock\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "f5fd03be0158f766c5257449d6123ec16fc1edf7", "url": "https://github.com/PGMDev/PGM/commit/f5fd03be0158f766c5257449d6123ec16fc1edf7", "message": "Move sentry from Server to PGM\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "88c131acbb7e2f2c493d4c26bc6a1a1f9eadb8d3", "url": "https://github.com/PGMDev/PGM/commit/88c131acbb7e2f2c493d4c26bc6a1a1f9eadb8d3", "message": "Only send tc.oc errors to sentry\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "aa6633345107e7989e4f35552b6a7650e6b7c0b6", "url": "https://github.com/PGMDev/PGM/commit/aa6633345107e7989e4f35552b6a7650e6b7c0b6", "message": "Add workflow for a beta branch\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "382be0654a79f94651b3b83bb90d3f010ade1251", "url": "https://github.com/PGMDev/PGM/commit/382be0654a79f94651b3b83bb90d3f010ade1251", "message": "Fix workflow stage names\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "65a8fb73a43ddd8cec8daf4de3493e45a6bb58ed", "url": "https://github.com/PGMDev/PGM/commit/65a8fb73a43ddd8cec8daf4de3493e45a6bb58ed", "message": "Add build badge to readme\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "79ce7636fbb9fe8d084141846f3183793b3b36bd", "url": "https://github.com/PGMDev/PGM/commit/79ce7636fbb9fe8d084141846f3183793b3b36bd", "message": "Seperate workflows into build and deploy\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "8a47ed2a8ca0d09bc90e5716d0a25175965d832a", "url": "https://github.com/PGMDev/PGM/commit/8a47ed2a8ca0d09bc90e5716d0a25175965d832a", "message": "Do not build, only deploy on master/beta\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "4abfb580d27d58b3235f9740a9126df9fd874ea8", "url": "https://github.com/PGMDev/PGM/commit/4abfb580d27d58b3235f9740a9126df9fd874ea8", "message": "Fix bad deploy artifacts\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "482086ff60161039d75dd160c70b16209cf7c907", "url": "https://github.com/PGMDev/PGM/commit/482086ff60161039d75dd160c70b16209cf7c907", "message": "Do not append master to master branch deploys\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "7ff85c3786b6ce83cfe194d9b1559ed47f698dbb", "url": "https://github.com/PGMDev/PGM/commit/7ff85c3786b6ce83cfe194d9b1559ed47f698dbb", "message": "Allow PGM to perform magic and unload the first world\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "b5d597d2ca23da1748eb4cb007ceb77be9f4955a", "url": "https://github.com/PGMDev/PGM/commit/b5d597d2ca23da1748eb4cb007ceb77be9f4955a", "message": "Fix formatting\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:23:06Z", "type": "commit"}, {"oid": "db5dd5c9f1de6c5863a382f54bdde4cdb2124de7", "url": "https://github.com/PGMDev/PGM/commit/db5dd5c9f1de6c5863a382f54bdde4cdb2124de7", "message": "Fix observers ui command\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:27:58Z", "type": "commit"}, {"oid": "155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "url": "https://github.com/PGMDev/PGM/commit/155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "message": "Fix double command reegistration\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T05:49:50Z", "type": "commit"}, {"oid": "155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "url": "https://github.com/PGMDev/PGM/commit/155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "message": "Fix double command reegistration\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T05:49:50Z", "type": "forcePushed"}, {"oid": "53f3fc4e1d43671bac8f6eadb4b429cf4bed04a0", "url": "https://github.com/PGMDev/PGM/commit/53f3fc4e1d43671bac8f6eadb4b429cf4bed04a0", "message": "Fix various map order issues\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T16:02:06Z", "type": "commit"}, {"oid": "d7e18f7f3b3d2655c8fd93fbb3dad517fcf1dac7", "url": "https://github.com/PGMDev/PGM/commit/d7e18f7f3b3d2655c8fd93fbb3dad517fcf1dac7", "message": "Fix hashtag now showing on map tags\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T16:53:27Z", "type": "commit"}]}