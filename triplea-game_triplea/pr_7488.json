{"pr_number": 7488, "pr_title": "Speed up db rider tests", "pr_author": "DanVanAtta", "pr_createdAt": "2020-08-30T03:40:49Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7488", "timeline": [{"oid": "d7fc3653d9bfe27af5fecceccc7873c4924274da", "url": "https://github.com/triplea-game/triplea/commit/d7fc3653d9bfe27af5fecceccc7873c4924274da", "message": "Update DropWizardExtension: clean after each test & init JDBI once & fail if server already started\n\n1. Re-creating DB connection takes some time, if we already have a DB\nconnection (ie: jdbi != null), then do not re-created it. This is\na matter of adding an if null check around the JDBI instantiation.\n\n2. Clean DB after each test, this helps avoid FK violations between\ntests within a test class. The execution of the clean-up is quite\nfast, this makes it easier to write valid tests without slowing\nthings down noticably.\n\n3. To improve error handling and error messaging, configure the drop wizard\nextension server startup (starts server when tests execute) to fail if\nthe server is already running. Given we no longer manually start a server\nin CI, this is okay.", "committedDate": "2020-08-30T03:38:36Z", "type": "commit"}, {"oid": "7f1c16880d1c47fba1472ed29e1b790928ae81c3", "url": "https://github.com/triplea-game/triplea/commit/7f1c16880d1c47fba1472ed29e1b790928ae81c3", "message": "Speed up Tests: Update all @DataSet to have 'useSequenceFiltering = false'\n\nThis is a big boost in performance for DBRider tests that has more than a\nfew tables. SequenceFiltering checks the right order in which to insert tables,\npresumably by attempting permutations. By not doing this, we see pretty significant\ntest execution speed-ups.\n\nA downside to this udate is that DbRider will typically fail if we define\nmultiple tables in a single YML. The order of tables in YML does not determine\nthe order of creation in DbRider. To fix this, we can put each database table\nin its own YML and include multiple YML files per @Dataset. The order of included\nYMLs is deterministic relative to table creation and in this way we can\nensure tables are created in the right order.", "committedDate": "2020-08-30T03:38:36Z", "type": "commit"}, {"oid": "009fc32852dfcba56bc8b334a2055f813a2a95ce", "url": "https://github.com/triplea-game/triplea/commit/009fc32852dfcba56bc8b334a2055f813a2a95ce", "message": "Delete unused test DataSet", "committedDate": "2020-08-30T03:51:40Z", "type": "commit"}, {"oid": "3f5ef5bf9df456755b351caeb0aa6d553d348426", "url": "https://github.com/triplea-game/triplea/commit/3f5ef5bf9df456755b351caeb0aa6d553d348426", "message": "Fix checkstyle violation (line too long and variable ordering)", "committedDate": "2020-08-30T03:52:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4MTY4NQ==", "url": "https://github.com/triplea-game/triplea/pull/7488#discussion_r479781685", "body": "Some thoughts here:\r\nIt seems that JUnit does not make any guarantees when an Extension is instantiated + there is no explicit closing of the DB connection in this Extension.\r\n\r\nI did a little bit of research and from what I was able to tell here's how it's supposed to be done:\r\nInstead of using static fields, the `ExtensionContext` provides a store to store intermediate values.\r\nThis would also allow to make use of the `ExtensionContext.Store.CloseableResource` interface to do the automated cleanup. Something like\r\n```java\r\n\r\n@Override\r\nvoid beforeAll(ExtensionContext context) {\r\n  context.getStore(ExtensionContext.Namespace.GLOBAL).getOrComputeIfAbsent(\"JDBI\", () -> new JdbiWrapper(/* create jdbi*/), JdbiWrapper .class).getJdbi();;\r\n}\r\n\r\n@AllArgsConstructor\r\n@Getter\r\nstatic class JdbiWrapper implements ExtensionContext.Store.CloseableResource {\r\n\r\n  private final Jdbi jdbi;\r\n\r\n  @Override\r\n  void close() {\r\n    // cleanup of jdbi\r\n  }\r\n}\r\n```\r\n\r\nThoughts?", "bodyText": "Some thoughts here:\nIt seems that JUnit does not make any guarantees when an Extension is instantiated + there is no explicit closing of the DB connection in this Extension.\nI did a little bit of research and from what I was able to tell here's how it's supposed to be done:\nInstead of using static fields, the ExtensionContext provides a store to store intermediate values.\nThis would also allow to make use of the ExtensionContext.Store.CloseableResource interface to do the automated cleanup. Something like\n@Override\nvoid beforeAll(ExtensionContext context) {\n  context.getStore(ExtensionContext.Namespace.GLOBAL).getOrComputeIfAbsent(\"JDBI\", () -> new JdbiWrapper(/* create jdbi*/), JdbiWrapper .class).getJdbi();;\n}\n\n@AllArgsConstructor\n@Getter\nstatic class JdbiWrapper implements ExtensionContext.Store.CloseableResource {\n\n  private final Jdbi jdbi;\n\n  @Override\n  void close() {\n    // cleanup of jdbi\n  }\n}\nThoughts?", "bodyHTML": "<p dir=\"auto\">Some thoughts here:<br>\nIt seems that JUnit does not make any guarantees when an Extension is instantiated + there is no explicit closing of the DB connection in this Extension.</p>\n<p dir=\"auto\">I did a little bit of research and from what I was able to tell here's how it's supposed to be done:<br>\nInstead of using static fields, the <code>ExtensionContext</code> provides a store to store intermediate values.<br>\nThis would also allow to make use of the <code>ExtensionContext.Store.CloseableResource</code> interface to do the automated cleanup. Something like</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n@Override\nvoid beforeAll(ExtensionContext context) {\n  context.getStore(ExtensionContext.Namespace.GLOBAL).getOrComputeIfAbsent(&quot;JDBI&quot;, () -&gt; new JdbiWrapper(/* create jdbi*/), JdbiWrapper .class).getJdbi();;\n}\n\n@AllArgsConstructor\n@Getter\nstatic class JdbiWrapper implements ExtensionContext.Store.CloseableResource {\n\n  private final Jdbi jdbi;\n\n  @Override\n  void close() {\n    // cleanup of jdbi\n  }\n}\"><pre><span class=\"pl-k\">@Override</span>\n<span class=\"pl-k\">void</span> beforeAll(<span class=\"pl-smi\">ExtensionContext</span> context) {\n  context<span class=\"pl-k\">.</span>getStore(<span class=\"pl-smi\">ExtensionContext</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">Namespace</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>GLOBAL</span>)<span class=\"pl-k\">.</span>getOrComputeIfAbsent(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>JDBI<span class=\"pl-pds\">\"</span></span>, () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">JdbiWrapper</span>(<span class=\"pl-c\"><span class=\"pl-c\">/*</span> create jdbi<span class=\"pl-c\">*/</span></span>), <span class=\"pl-smi\">JdbiWrapper</span> .class)<span class=\"pl-k\">.</span>getJdbi();;\n}\n\n<span class=\"pl-k\">@AllArgsConstructor</span>\n<span class=\"pl-k\">@Getter</span>\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">JdbiWrapper</span> <span class=\"pl-k\">implements</span> <span class=\"pl-e\">ExtensionContext</span>.<span class=\"pl-e\">Store</span>.<span class=\"pl-e\">CloseableResource</span> {\n\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Jdbi</span> jdbi;\n\n  <span class=\"pl-k\">@Override</span>\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">close</span>() {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> cleanup of jdbi</span>\n  }\n}</pre></div>\n<p dir=\"auto\">Thoughts?</p>", "author": "RoiEXLab", "createdAt": "2020-08-30T15:12:48Z", "path": "dropwizard-common-test/src/main/java/org/triplea/dropwizard/test/DropwizardServerExtension.java", "diffHunk": "@@ -60,25 +60,24 @@\n   @Override\n   public void beforeAll(final ExtensionContext context) {\n     final DropwizardTestSupport<C> support = getSupport();\n-    try {\n-      log.info(\"Starting local server for testing..\");\n-      support.before();\n+    log.info(\"Starting local server for testing..\");\n+    support.before();\n+\n+    if (jdbi == null) {\n       jdbi =\n           Jdbi.create(getDatabase().getUrl(), getDatabase().getUser(), getDatabase().getPassword());\n       jdbi.installPlugin(new SqlObjectPlugin());\n       rowMappers().forEach(jdbi::registerRowMapper);\n-\n       log.info(\"Created JDBI connection to: {}\", getDatabase().getUrl());\n-      final String localUri = \"http://localhost:\" + support.getLocalPort();\n-      serverUri = URI.create(localUri);\n-      log.info(\"Local server URL set to: {}\", localUri);\n-    } catch (final RuntimeException e) {\n-      log.warn(\"Ignoring setup error, server already started: {}\", e.getMessage());\n     }\n+\n+    final String localUri = \"http://localhost:\" + support.getLocalPort();\n+    serverUri = URI.create(localUri);\n+    log.info(\"Local server URL set to: {}\", localUri);", "originalCommit": "3f5ef5bf9df456755b351caeb0aa6d553d348426", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4NjU4Nw==", "url": "https://github.com/triplea-game/triplea/pull/7488#discussion_r479786587", "bodyText": "We used to do a 'suppport.close()' as well and that is removed.\nThe static field is needed as it turns out otherwise the support server and jdbi connection are all killed after the 'afterAll' phase. You'll get a server starting up anew for every test.\nRe: closing of connection\nIs it really needed? When the tests execute, if the connection is closed then, we're good, right? The tests closing are pretty much a System.exit, after which the connections should not survive. If we created many connections, then perhaps they would stack up, but we only have one. If we run all tests and somehow you get the server tests before others, having the connection be left open while those tests run does not seem like a big issue. Overall, the cleanup happens when the tests exit, is there really reason to do so explicitly?\nRe: scope\nThis is quite arguably existing code at this point, the change here is not adding new connections/state. The conversion of the db-cleanup to after-each is to make the tests more reliable. To avoid having many iterative PRs the jdbi optimization is included as otherwise that would conflict with the db-cleanup update.", "author": "DanVanAtta", "createdAt": "2020-08-30T16:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4MTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc5Nzc5Mg==", "url": "https://github.com/triplea-game/triplea/pull/7488#discussion_r479797792", "bodyText": "The static field is needed as it turns out otherwise the support server and jdbi connection are all killed after the 'afterAll' phase.\n\nIs that the case even with ExtensionContext.Store?\nI thought that the store has a longer lifespan than the individual tests and the store was the intended way of storing \"state\" between tests. Maybe I'm missing something though.\n\nThe tests closing are pretty much a System.exit\n\nFair point, but not the cleanest approach in my opinion.\nI mean on the same level one could argue that memory leaks in test code is fine because the tests never run for a long amount of time, but I just feel like some mechanism should take care of that.", "author": "RoiEXLab", "createdAt": "2020-08-30T17:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4MTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc5ODA3MQ==", "url": "https://github.com/triplea-game/triplea/pull/7488#discussion_r479798071", "bodyText": "Looking at this a bit more:\n\n\nI'm not seeing a why to even close a JDBI, I'm not sure it truly needs it. This query can be used to check open connections:\n  select sum(numbackends) from pg_stat_database;\nWhile executing tests this goes up to around 11 and then when the tests are done it goes back down. It appears that the connections are getting cleaned up without any need to do so explicitly.\n\n\nThe ContextExtension namespace is only good for the lifecycle of the extension. Specifically this is one test file where you have a 'beforeAll' and an 'afterAll' being executed. By making the support and JDBI variables static we ensure that we only have one copy between tests (across life cycle). The 'support.before' is what launches the server and it's a no-op if the server already exists. If we were to tie those to each unit test file, we might see issues with unable to bind to port and things would generally get quite slow because the server would be stopped and started for each test file.", "author": "DanVanAtta", "createdAt": "2020-08-30T17:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4MTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwMDE4MQ==", "url": "https://github.com/triplea-game/triplea/pull/7488#discussion_r479800181", "bodyText": "Is that the case even with ExtensionContext.Store?\nI thought that the store has a longer lifespan than the individual tests and the store was the intended way of storing \"state\" between tests. Maybe I'm missing something though.\n\nI did an experiment where I checked a value from a store in a 'beforeAll', set a value in a store and checked the value again. I found that that when we hit the 'beforeAll' the stored value is always initially unset.\nSo I think it depends on how you define individual tests. For the context of a store, that means the \"@test\" methods, not the test file. Once the 'afterAll' is executed, it seems the store is wiped away. AFAIK the extension is instantiated on each test class that has it, hence the beforeAll and afterAll are executed as part of each test files life cycle.\n\nI mean on the same level one could argue that memory leaks in test code is fine because the tests never run for a long amount of time, but I just feel like some mechanism should take care of that.\n\nWe should avoid hyperbole, but one could make the same argument that you should set all of your variables to null to explicitly close them. It seems that the 'support' is doing its job of closing when the tests exit. I don't think there is a memory leak here at all. If you re-run the tests, you'll have all memory reclaimed in-between.\nDB connections can be leaked and remain open. Tomee is an example of a server notorious for that and after enough restarts your DB crashes because you exhaust all available connections. It's not the case for us though, DB connections are being closed and the server is being stopped.\nDo we need the server to be stopped after a sup-project is done being tested? No.\nCan we stop a server after the sub-project is done being tested? I'm not sure if we can, it requires the test runner to know that there are more test files to be executed. AfterAll is just the scope of one test file.\nI don't think what we're doing here is actually all that dirty at all even. static variables can lead to some dangerous patterns, but this seems like an exact fit for what we want here.", "author": "DanVanAtta", "createdAt": "2020-08-30T18:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4MTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwMDM3MQ==", "url": "https://github.com/triplea-game/triplea/pull/7488#discussion_r479800371", "bodyText": "Fair point, but not the cleanest approach in my opinion.\nI mean on the same level one could argue that memory leaks in test code is fine because the tests never run for a long amount of time, but I just feel like some mechanism should take care of that.\n\nIf memory or connections are still allocated after a System.exit, that is a leak and would be bad for any kind of code. In our case we're intentionally leaving the server and DB connection open so that the next test file does not need to re-establish it. Given it's all closed up on System.exit, I would not call this a memory leak, it's intentionally left open between test (files).", "author": "DanVanAtta", "createdAt": "2020-08-30T18:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4MTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgwMTU3MA==", "url": "https://github.com/triplea-game/triplea/pull/7488#discussion_r479801570", "bodyText": "I did an experiment where I checked a value from a store in a 'beforeAll', set a value in a store and checked the value again. I found that that when we hit the 'beforeAll' the stored value is always initially unset.\n\nOk, in this case I'm a bit disappointed that there's no \"real\" mechanism to allocate a \"global\" resource and deallocate it within junit. Feels like something that's a very common thing to require.\nGo ahead then \ud83d\udc4d", "author": "RoiEXLab", "createdAt": "2020-08-30T18:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4MTY4NQ=="}], "type": "inlineReview"}]}