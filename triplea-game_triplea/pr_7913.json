{"pr_number": 7913, "pr_title": "Make sure the default game is there or clear it if it isn't", "pr_author": "trevan", "pr_createdAt": "2020-10-16T03:06:57Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7913", "timeline": [{"oid": "d7a3996ed93367b67cc10eeb8826124f1167e7b4", "url": "https://github.com/triplea-game/triplea/commit/d7a3996ed93367b67cc10eeb8826124f1167e7b4", "message": "Make sure the default game is there or clear it if it isn't\n\nIf the default game is not on the system, it wasn't being cleared out of\nthe game.  This would leave the game in an odd state where it is\npartially loaded but has unused objects listening for events.\n\nBy calling resetDefaultGame when the default game is missing, the game\ncan be reset to an initial state where no map has been selected.\n\nIn addition, the checks to see if the file exists had issues when the\nuri had special prefixes and suffixes.  So those are stripped before the\nchecks.", "committedDate": "2020-10-16T03:00:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4OTMyMQ==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r506989321", "body": "There is a good bit going on in this filter method. I worry that this method has a mixture of abstraction levels. From what I've seen, it's generally best to keep most logic out of lambdas and try to convert them to be method references by extracting that logic to a helper method.\r\n\r\nWDYT of extracting these filter predicates to helper methods? In that case the filter chain would stay quite high level, eg:\r\n\r\n```\r\nClientSetting.defaultGameUri\r\n   .getValue()\r\n   .filter(GameSelectorModel::defaultGameIsInUserRootFolder)\r\n   .filter(GameSelectorModel::defaultGameExists)\r\n   .map(...)\r\n     \r\n```", "bodyText": "There is a good bit going on in this filter method. I worry that this method has a mixture of abstraction levels. From what I've seen, it's generally best to keep most logic out of lambdas and try to convert them to be method references by extracting that logic to a helper method.\nWDYT of extracting these filter predicates to helper methods? In that case the filter chain would stay quite high level, eg:\nClientSetting.defaultGameUri\n   .getValue()\n   .filter(GameSelectorModel::defaultGameIsInUserRootFolder)\n   .filter(GameSelectorModel::defaultGameExists)\n   .map(...)", "bodyHTML": "<p dir=\"auto\">There is a good bit going on in this filter method. I worry that this method has a mixture of abstraction levels. From what I've seen, it's generally best to keep most logic out of lambdas and try to convert them to be method references by extracting that logic to a helper method.</p>\n<p dir=\"auto\">WDYT of extracting these filter predicates to helper methods? In that case the filter chain would stay quite high level, eg:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"ClientSetting.defaultGameUri\n   .getValue()\n   .filter(GameSelectorModel::defaultGameIsInUserRootFolder)\n   .filter(GameSelectorModel::defaultGameExists)\n   .map(...)\n     \n\"><pre><code>ClientSetting.defaultGameUri\n   .getValue()\n   .filter(GameSelectorModel::defaultGameIsInUserRootFolder)\n   .filter(GameSelectorModel::defaultGameExists)\n   .map(...)\n     \n</code></pre></div>", "author": "DanVanAtta", "createdAt": "2020-10-17T22:11:59Z", "path": "game-core/src/main/java/games/strategy/engine/framework/startup/ui/panels/main/game/selector/GameSelectorModel.java", "diffHunk": "@@ -186,10 +189,28 @@ public void loadDefaultGameSameThread() {\n         // can load. (ie: if a previous version of triplea was using running a game within its\n         // root folder, we shouldn't open it)\n         .filter(\n-            defaultGame ->\n-                defaultGame.contains(ClientFileSystemHelper.getUserRootFolder().toURI().toString()))\n-        .filter(defaultGame -> new File(defaultGame).exists())\n+            defaultGame -> {\n+              String rootFolder = ClientFileSystemHelper.getUserRootFolder().toURI().toString();", "originalCommit": "d7a3996ed93367b67cc10eeb8826124f1167e7b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4OTM0Nw==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r506989347", "body": "I wonder if the check for a given parent folder would not be easier to use the `Path` API and  do a recursive check of parents or use the `iterator()` method to check folders. The special casing by OS is hard to grok, I could envision someone testing this and thinking it is unnecessary code (also we really want the code to be as cross-platform as possible, if this needs modification, most of us have no access to a MAC and would SOL).\r\n\r\nWe have a `FileUtils` class, as a suggestion, what do you think of creating a helper method there to check if a given parent folder exists on a given path, that can be tested readily, and then use that utility method here?", "bodyText": "I wonder if the check for a given parent folder would not be easier to use the Path API and  do a recursive check of parents or use the iterator() method to check folders. The special casing by OS is hard to grok, I could envision someone testing this and thinking it is unnecessary code (also we really want the code to be as cross-platform as possible, if this needs modification, most of us have no access to a MAC and would SOL).\nWe have a FileUtils class, as a suggestion, what do you think of creating a helper method there to check if a given parent folder exists on a given path, that can be tested readily, and then use that utility method here?", "bodyHTML": "<p dir=\"auto\">I wonder if the check for a given parent folder would not be easier to use the <code>Path</code> API and  do a recursive check of parents or use the <code>iterator()</code> method to check folders. The special casing by OS is hard to grok, I could envision someone testing this and thinking it is unnecessary code (also we really want the code to be as cross-platform as possible, if this needs modification, most of us have no access to a MAC and would SOL).</p>\n<p dir=\"auto\">We have a <code>FileUtils</code> class, as a suggestion, what do you think of creating a helper method there to check if a given parent folder exists on a given path, that can be tested readily, and then use that utility method here?</p>", "author": "DanVanAtta", "createdAt": "2020-10-17T22:12:37Z", "path": "game-core/src/main/java/games/strategy/engine/framework/startup/ui/panels/main/game/selector/GameSelectorModel.java", "diffHunk": "@@ -186,10 +189,28 @@ public void loadDefaultGameSameThread() {\n         // can load. (ie: if a previous version of triplea was using running a game within its\n         // root folder, we shouldn't open it)\n         .filter(\n-            defaultGame ->\n-                defaultGame.contains(ClientFileSystemHelper.getUserRootFolder().toURI().toString()))\n-        .filter(defaultGame -> new File(defaultGame).exists())\n+            defaultGame -> {\n+              String rootFolder = ClientFileSystemHelper.getUserRootFolder().toURI().toString();", "originalCommit": "d7a3996ed93367b67cc10eeb8826124f1167e7b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5MDIzNw==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r507190237", "bodyText": "Path#startsWith does the checking so I switched to that once I've created a Path object.", "author": "trevan", "createdAt": "2020-10-18T17:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk4OTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MDEyNw==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r506990127", "body": "The lack of an else implies that the default game can be a third case, that would be valid. If not valid, then we keep processing rather than flagging an error here, which I think the \"fail early\" principle would suggest that it would be better to throw an exception or some other error handling. Even better probably would be to ensure that we cannot have an invalid value set in default game, and if so to remove it, all before we get to this point. WDYT?", "bodyText": "The lack of an else implies that the default game can be a third case, that would be valid. If not valid, then we keep processing rather than flagging an error here, which I think the \"fail early\" principle would suggest that it would be better to throw an exception or some other error handling. Even better probably would be to ensure that we cannot have an invalid value set in default game, and if so to remove it, all before we get to this point. WDYT?", "bodyHTML": "<p dir=\"auto\">The lack of an else implies that the default game can be a third case, that would be valid. If not valid, then we keep processing rather than flagging an error here, which I think the \"fail early\" principle would suggest that it would be better to throw an exception or some other error handling. Even better probably would be to ensure that we cannot have an invalid value set in default game, and if so to remove it, all before we get to this point. WDYT?</p>", "author": "DanVanAtta", "createdAt": "2020-10-17T22:23:21Z", "path": "game-core/src/main/java/games/strategy/engine/framework/startup/ui/panels/main/game/selector/GameSelectorModel.java", "diffHunk": "@@ -186,10 +189,28 @@ public void loadDefaultGameSameThread() {\n         // can load. (ie: if a previous version of triplea was using running a game within its\n         // root folder, we shouldn't open it)\n         .filter(\n-            defaultGame ->\n-                defaultGame.contains(ClientFileSystemHelper.getUserRootFolder().toURI().toString()))\n-        .filter(defaultGame -> new File(defaultGame).exists())\n+            defaultGame -> {\n+              String rootFolder = ClientFileSystemHelper.getUserRootFolder().toURI().toString();\n+              if (rootFolder.startsWith(\"file:\")) {\n+                // strip off this prefix so it matches better against the defaultGame string\n+                rootFolder = rootFolder.substring(\"file:\".length());\n+              }\n+              return defaultGame.contains(rootFolder);\n+            })\n+        // ensure the default game hasn't been deleted since it was last loaded\n+        .filter(\n+            defaultGame -> {\n+              if (defaultGame.startsWith(\"jar:file:\")) {\n+                // when the game is from a zip file, it starts with jar:file: and uses a '!'\n+                // to separate the local file from the zip content\n+                defaultGame = defaultGame.substring(\"jar:file:\".length(), defaultGame.indexOf('!'));\n+              } else if (defaultGame.startsWith(\"file://\")) {\n+                // when the game is from a local file, it starts with file://\n+                defaultGame = defaultGame.substring(\"file://\".length());\n+              }", "originalCommit": "d7a3996ed93367b67cc10eeb8826124f1167e7b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MDM5Nw==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r506990397", "bodyText": "Second thought, can we use any of the 'isFile' APIs or otherwise to check if we are dealing with a zip file?\nThis SO seems to have one suggestion we could use:\nString contentType = Files.probeContentType(Paths.get(pathToFile);\n\nif (!contentType.equals(\"application/zip\")) {\n\n    throw new NotZipFileException();\n}\n\nhttps://stackoverflow.com/questions/33934178/how-to-identify-a-zip-file-in-java\nI suspect this is another candidate method to be added to FileUtils so we can remove this logic from GameSelectorModel. The game selector model certainly has a number of issues, but it knowing how to do file system processing and detection seems to be adding to SRP violation, so I am very much in favor of removing complexity from it to a helper to simplify the file system ops.", "author": "DanVanAtta", "createdAt": "2020-10-17T22:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MDEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5MDU4MA==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r507190580", "bodyText": "I got Path.of to work but it wasn't as easy as just calling Path.of.  If the uri is \"jar:file:/location/to/file.zip!/location/to/map.xml\", then Path.of will return a path pointing to the xml file.  But that file is inside of the zip file and isn't what we want.  But the first file store of the Path object is the \"zipfs\" store which has a name of the actual zip file.  And that can be used to create a Path.\nOnce I did that, the code simplified to just using Path objects.  I believe this should be cross-platform.", "author": "trevan", "createdAt": "2020-10-18T17:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MDEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MDg4OQ==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r506990889", "body": "This set game data seems to be an unnecessary store coming from line 88. It's also not consistent as the other lines sets the game data directly and this uses a setter method. Generally, AFAIK it's better to avoid setter methods within a class (lest someone overrides your setter method and then suddenly they've changed a lot more code then expected).\r\n\r\n2nd, the abstraction of the method above seems to be kinda mixed. It's basically:\r\n```\r\nlow level checks\r\nlow level setting\r\nlow level checks\r\n\r\nif( low level condition)\r\n    do medium level\r\nelse\r\n   do low level\r\n```\r\n\r\nI recommend to accept a `GameData` parameter to this method and then you can re-use. Arguably it's a method so that the code can be re-used, but we still have the same calls on lines 91 and 92 (it's not the same, but the data we set is the same, that would be the idea behind DRY, the information of which values to set is repeated in 2 places).\r\n\r\nAs a method, it would be:\r\n```\r\nprivate void setDefaultGame(@Nullable final URI fileUri, @Nullable final GAmeData gamedata) {\r\n  if(gameData == null) {\r\n    ClientSetting.defaultGameName.resetValue();\r\n    ClientSetting.defaultGameUri.resetValue();  \r\n  } else {\r\n      ClientSetting.defaultGameName.setValue(gameData.getGameName());\r\n      ClientSetting.defaultGameUri.setValue(uri.toString());\r\n  }\r\n   ClientSetting.flush();\r\n}\r\n\r\n```\r\n\r\nNow, looking at the above, the fact we have a decoupled file uri and game name is really not good too. That looks very much like a data clump code smell and would do well to be unified behind a single object or a single data type. I think that is probably best resolved as a follow up where we stop storing the default game name, just the default uri, and lookup the game name from that URI when it is needed.", "bodyText": "This set game data seems to be an unnecessary store coming from line 88. It's also not consistent as the other lines sets the game data directly and this uses a setter method. Generally, AFAIK it's better to avoid setter methods within a class (lest someone overrides your setter method and then suddenly they've changed a lot more code then expected).\n2nd, the abstraction of the method above seems to be kinda mixed. It's basically:\nlow level checks\nlow level setting\nlow level checks\n\nif( low level condition)\n    do medium level\nelse\n   do low level\n\nI recommend to accept a GameData parameter to this method and then you can re-use. Arguably it's a method so that the code can be re-used, but we still have the same calls on lines 91 and 92 (it's not the same, but the data we set is the same, that would be the idea behind DRY, the information of which values to set is repeated in 2 places).\nAs a method, it would be:\nprivate void setDefaultGame(@Nullable final URI fileUri, @Nullable final GAmeData gamedata) {\n  if(gameData == null) {\n    ClientSetting.defaultGameName.resetValue();\n    ClientSetting.defaultGameUri.resetValue();  \n  } else {\n      ClientSetting.defaultGameName.setValue(gameData.getGameName());\n      ClientSetting.defaultGameUri.setValue(uri.toString());\n  }\n   ClientSetting.flush();\n}\n\n\nNow, looking at the above, the fact we have a decoupled file uri and game name is really not good too. That looks very much like a data clump code smell and would do well to be unified behind a single object or a single data type. I think that is probably best resolved as a follow up where we stop storing the default game name, just the default uri, and lookup the game name from that URI when it is needed.", "bodyHTML": "<p dir=\"auto\">This set game data seems to be an unnecessary store coming from line 88. It's also not consistent as the other lines sets the game data directly and this uses a setter method. Generally, AFAIK it's better to avoid setter methods within a class (lest someone overrides your setter method and then suddenly they've changed a lot more code then expected).</p>\n<p dir=\"auto\">2nd, the abstraction of the method above seems to be kinda mixed. It's basically:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"low level checks\nlow level setting\nlow level checks\n\nif( low level condition)\n    do medium level\nelse\n   do low level\"><pre><code>low level checks\nlow level setting\nlow level checks\n\nif( low level condition)\n    do medium level\nelse\n   do low level\n</code></pre></div>\n<p dir=\"auto\">I recommend to accept a <code>GameData</code> parameter to this method and then you can re-use. Arguably it's a method so that the code can be re-used, but we still have the same calls on lines 91 and 92 (it's not the same, but the data we set is the same, that would be the idea behind DRY, the information of which values to set is repeated in 2 places).</p>\n<p dir=\"auto\">As a method, it would be:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private void setDefaultGame(@Nullable final URI fileUri, @Nullable final GAmeData gamedata) {\n  if(gameData == null) {\n    ClientSetting.defaultGameName.resetValue();\n    ClientSetting.defaultGameUri.resetValue();  \n  } else {\n      ClientSetting.defaultGameName.setValue(gameData.getGameName());\n      ClientSetting.defaultGameUri.setValue(uri.toString());\n  }\n   ClientSetting.flush();\n}\n\"><pre><code>private void setDefaultGame(@Nullable final URI fileUri, @Nullable final GAmeData gamedata) {\n  if(gameData == null) {\n    ClientSetting.defaultGameName.resetValue();\n    ClientSetting.defaultGameUri.resetValue();  \n  } else {\n      ClientSetting.defaultGameName.setValue(gameData.getGameName());\n      ClientSetting.defaultGameUri.setValue(uri.toString());\n  }\n   ClientSetting.flush();\n}\n\n</code></pre></div>\n<p dir=\"auto\">Now, looking at the above, the fact we have a decoupled file uri and game name is really not good too. That looks very much like a data clump code smell and would do well to be unified behind a single object or a single data type. I think that is probably best resolved as a follow up where we stop storing the default game name, just the default uri, and lookup the game name from that URI when it is needed.</p>", "author": "DanVanAtta", "createdAt": "2020-10-17T22:32:57Z", "path": "game-core/src/main/java/games/strategy/engine/framework/startup/ui/panels/main/game/selector/GameSelectorModel.java", "diffHunk": "@@ -85,16 +85,19 @@ public void load(final URI uri) {\n     fileName = null;\n     this.gameData = parseAndValidate(uri);\n     if (gameData == null || gameData.getGameName() == null || uri == null) {\n-      ClientSetting.defaultGameName.resetValue();\n-      ClientSetting.defaultGameUri.resetValue();\n-      this.fileName = \"-\";\n-      this.gameName = \"-\";\n-      this.gameRound = \"-\";\n+      this.resetDefaultGame();\n     } else {\n       setGameData(gameData);\n       ClientSetting.defaultGameName.setValue(gameData.getGameName());\n       ClientSetting.defaultGameUri.setValue(uri.toString());\n+      ClientSetting.flush();\n     }\n+  }\n+\n+  private void resetDefaultGame() {\n+    setGameData(null);", "originalCommit": "d7a3996ed93367b67cc10eeb8826124f1167e7b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5MDY0Mg==", "url": "https://github.com/triplea-game/triplea/pull/7913#discussion_r507190642", "bodyText": "I made this change.", "author": "trevan", "createdAt": "2020-10-18T17:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MDg4OQ=="}], "type": "inlineReview"}, {"oid": "c537dc7c8a07e6194db7771b59accb09abfa434a", "url": "https://github.com/triplea-game/triplea/commit/c537dc7c8a07e6194db7771b59accb09abfa434a", "message": "Merge remote-tracking branch 'upstream/master' into fix-loading-unsaved-game", "committedDate": "2020-10-18T17:08:22Z", "type": "commit"}, {"oid": "a0b5cccf8e66417589c428bc17765752a0390afe", "url": "https://github.com/triplea-game/triplea/commit/a0b5cccf8e66417589c428bc17765752a0390afe", "message": "Use Path.of to turn the uris into paths that can be checked", "committedDate": "2020-10-18T17:31:26Z", "type": "commit"}, {"oid": "fe8cf72034cd1d51e62f6e370f21687f1988f3eb", "url": "https://github.com/triplea-game/triplea/commit/fe8cf72034cd1d51e62f6e370f21687f1988f3eb", "message": "Don't set the gameData in setDefaultGame", "committedDate": "2020-10-18T17:37:48Z", "type": "commit"}]}