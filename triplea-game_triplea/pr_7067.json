{"pr_number": 7067, "pr_title": "Add tests for UnitImageFactory#getBaseImageName", "pr_author": "trevan", "pr_createdAt": "2020-07-08T00:17:28Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7067", "timeline": [{"oid": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "url": "https://github.com/triplea-game/triplea/commit/2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "message": "Add tests for UnitImageFactory#getBaseImageName", "committedDate": "2020-07-08T00:14:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE1MDY5Ng==", "url": "https://github.com/triplea-game/triplea/pull/7067#discussion_r453150696", "body": "nit, it's a bit more conventional to do test set up and assertions as separate steps. EG:\r\n\r\n```\r\ngiven  // establish state\r\n\r\nwhen   // do the action under state\r\n\r\nthen   // assert return value has expected value\r\n          // assert expected post-state\r\n```\r\n\r\nThe pattern is \"arrange act assert\" (AAA): https://medium.com/@pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80\r\n\r\nSo in this case, having the 'assert' and the 'given' split would perhaps be more canonical.", "bodyText": "nit, it's a bit more conventional to do test set up and assertions as separate steps. EG:\ngiven  // establish state\n\nwhen   // do the action under state\n\nthen   // assert return value has expected value\n          // assert expected post-state\n\nThe pattern is \"arrange act assert\" (AAA): https://medium.com/@pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80\nSo in this case, having the 'assert' and the 'given' split would perhaps be more canonical.", "bodyHTML": "<p dir=\"auto\">nit, it's a bit more conventional to do test set up and assertions as separate steps. EG:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"given  // establish state\n\nwhen   // do the action under state\n\nthen   // assert return value has expected value\n          // assert expected post-state\"><pre><code>given  // establish state\n\nwhen   // do the action under state\n\nthen   // assert return value has expected value\n          // assert expected post-state\n</code></pre></div>\n<p dir=\"auto\">The pattern is \"arrange act assert\" (AAA): <a href=\"https://medium.com/@pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80\" rel=\"nofollow\">https://medium.com/@pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80</a></p>\n<p dir=\"auto\">So in this case, having the 'assert' and the 'given' split would perhaps be more canonical.</p>", "author": "DanVanAtta", "createdAt": "2020-07-11T03:49:37Z", "path": "game-core/src/test/java/games/strategy/triplea/image/UnitImageFactoryTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+package games.strategy.triplea.image;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.TechnologyFrontier;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class UnitImageFactoryTest {\n+  @Mock GameData gameData;\n+\n+  @Nested\n+  class GetBaseImageName {\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      final TechnologyFrontier technologyFrontier = new TechnologyFrontier(\"Tech\", gameData);\n+      when(gameData.getTechnologyFrontier()).thenReturn(technologyFrontier);\n+      lenient().when(gameData.getDiceSides()).thenReturn(6);\n+      final GameProperties gameProperties = new GameProperties(gameData);\n+      lenient().when(gameData.getProperties()).thenReturn(gameProperties);\n+    }\n+\n+    @Test\n+    void basicUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasSuffix(List.of(), List.of(), \"\");", "originalCommit": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE1MDkwNA==", "url": "https://github.com/triplea-game/triplea/pull/7067#discussion_r453150904", "body": "Any thoughts to extract '_hit' (and other magic suffixes) to a constant?\r\n\r\nIf we were to use a constant, and we were for example to change the suffix or otherwise, then the tests would automatically be updated. Keeping test maintenance and coupling to production code low is a good thing. One can get into a case where small changes results in many test changes (while having tests is better than none,  keeping them maintainable helps avoid at least that secondary trap).", "bodyText": "Any thoughts to extract '_hit' (and other magic suffixes) to a constant?\nIf we were to use a constant, and we were for example to change the suffix or otherwise, then the tests would automatically be updated. Keeping test maintenance and coupling to production code low is a good thing. One can get into a case where small changes results in many test changes (while having tests is better than none,  keeping them maintainable helps avoid at least that secondary trap).", "bodyHTML": "<p dir=\"auto\">Any thoughts to extract '_hit' (and other magic suffixes) to a constant?</p>\n<p dir=\"auto\">If we were to use a constant, and we were for example to change the suffix or otherwise, then the tests would automatically be updated. Keeping test maintenance and coupling to production code low is a good thing. One can get into a case where small changes results in many test changes (while having tests is better than none,  keeping them maintainable helps avoid at least that secondary trap).</p>", "author": "DanVanAtta", "createdAt": "2020-07-11T03:51:48Z", "path": "game-core/src/test/java/games/strategy/triplea/image/UnitImageFactoryTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+package games.strategy.triplea.image;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.TechnologyFrontier;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class UnitImageFactoryTest {\n+  @Mock GameData gameData;\n+\n+  @Nested\n+  class GetBaseImageName {\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      final TechnologyFrontier technologyFrontier = new TechnologyFrontier(\"Tech\", gameData);\n+      when(gameData.getTechnologyFrontier()).thenReturn(technologyFrontier);\n+      lenient().when(gameData.getDiceSides()).thenReturn(6);\n+      final GameProperties gameProperties = new GameProperties(gameData);\n+      lenient().when(gameData.getProperties()).thenReturn(gameProperties);\n+    }\n+\n+    @Test\n+    void basicUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasSuffix(List.of(), List.of(), \"\");\n+    }\n+\n+    @Test\n+    void basicDamagedUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasName(\n+          \"infantry\", List.of(), List.of(), true, false, \"infantry_hit\");", "originalCommit": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE1MTYzNA==", "url": "https://github.com/triplea-game/triplea/pull/7067#discussion_r453151634", "body": "Boolean parameters can be difficult to understand. Overloaded methods or a parameter object can help clarify this.\r\n\r\nFor example, with a parameter object, we could have something like:\r\n```\r\n\r\n\r\ngivenTestSetup(SetupParameters.builder()\r\n       .unitTypeName(\"infantry\")\r\n        .unitAttachmentProperties(List.of())\r\n        .techAttachmentProperties(List.of())\r\n        .damaged(false)\r\n        .disabled(true))\r\n   .build());\r\n\r\nfinal String imageName =\r\n          UnitImageFactory.getBaseImageName(unitType, player, damaged, disabled);\r\n\r\nassertThat(imageName, is(\"infantry_disabled\");\r\n```\r\n\r\nThe above refactor of course does not work since we need direct parameters.. This indicates a production code change to accept a parameter object is perhaps all we need and then the testing becomes drastically simplified.\r\n\r\nTo get there, you can create a method overload that accepts the parameter object and then invokes the original method. Then you can invoke the method overload from test. Once you have the test in place, it's a question of migrating the rest of the production code to use the better API.\r\n\r\nEG:\r\n\r\n```\r\nfinal String imageName =\r\n          UnitImageFactory.getBaseImageName(  ImageNameParameters.builder()\r\n                .unitTypeName(\"infantry\")\r\n                .unitAttachmentProperties(List.of())\r\n                .techAttachmentProperties(List.of())\r\n                .damaged(false)\r\n                .disabled(true))\r\n   .build());\r\n\r\nassertThat(imageName, is(\"infantry_disabled\");\r\n```\r\n\r\nFrom here, test parameterization could help and the API's would be straight forward. EG:\r\n\r\n@ParameterizedTest\r\n@MethodSource\r\nvoid verifyBaseImageName(ImageNameParameters. parameters, String expectedName) {\r\n    final String imageName =\r\n            UnitImageFactory.getBaseImageName(parameters);\r\n\r\n     assertThat(imageName, is(expectedName);\r\n}\r\n```\r\n\r\n\r\nThoughts @trevan ?", "bodyText": "Boolean parameters can be difficult to understand. Overloaded methods or a parameter object can help clarify this.\nFor example, with a parameter object, we could have something like:\n\n\ngivenTestSetup(SetupParameters.builder()\n       .unitTypeName(\"infantry\")\n        .unitAttachmentProperties(List.of())\n        .techAttachmentProperties(List.of())\n        .damaged(false)\n        .disabled(true))\n   .build());\n\nfinal String imageName =\n          UnitImageFactory.getBaseImageName(unitType, player, damaged, disabled);\n\nassertThat(imageName, is(\"infantry_disabled\");\n\nThe above refactor of course does not work since we need direct parameters.. This indicates a production code change to accept a parameter object is perhaps all we need and then the testing becomes drastically simplified.\nTo get there, you can create a method overload that accepts the parameter object and then invokes the original method. Then you can invoke the method overload from test. Once you have the test in place, it's a question of migrating the rest of the production code to use the better API.\nEG:\nfinal String imageName =\n          UnitImageFactory.getBaseImageName(  ImageNameParameters.builder()\n                .unitTypeName(\"infantry\")\n                .unitAttachmentProperties(List.of())\n                .techAttachmentProperties(List.of())\n                .damaged(false)\n                .disabled(true))\n   .build());\n\nassertThat(imageName, is(\"infantry_disabled\");\n\nFrom here, test parameterization could help and the API's would be straight forward. EG:\n@ParameterizedTest\n@MethodSource\nvoid verifyBaseImageName(ImageNameParameters. parameters, String expectedName) {\nfinal String imageName =\nUnitImageFactory.getBaseImageName(parameters);\n assertThat(imageName, is(expectedName);\n\n}\n\n\nThoughts @trevan ?", "bodyHTML": "<p dir=\"auto\">Boolean parameters can be difficult to understand. Overloaded methods or a parameter object can help clarify this.</p>\n<p dir=\"auto\">For example, with a parameter object, we could have something like:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n\ngivenTestSetup(SetupParameters.builder()\n       .unitTypeName(&quot;infantry&quot;)\n        .unitAttachmentProperties(List.of())\n        .techAttachmentProperties(List.of())\n        .damaged(false)\n        .disabled(true))\n   .build());\n\nfinal String imageName =\n          UnitImageFactory.getBaseImageName(unitType, player, damaged, disabled);\n\nassertThat(imageName, is(&quot;infantry_disabled&quot;);\"><pre><code>\n\ngivenTestSetup(SetupParameters.builder()\n       .unitTypeName(\"infantry\")\n        .unitAttachmentProperties(List.of())\n        .techAttachmentProperties(List.of())\n        .damaged(false)\n        .disabled(true))\n   .build());\n\nfinal String imageName =\n          UnitImageFactory.getBaseImageName(unitType, player, damaged, disabled);\n\nassertThat(imageName, is(\"infantry_disabled\");\n</code></pre></div>\n<p dir=\"auto\">The above refactor of course does not work since we need direct parameters.. This indicates a production code change to accept a parameter object is perhaps all we need and then the testing becomes drastically simplified.</p>\n<p dir=\"auto\">To get there, you can create a method overload that accepts the parameter object and then invokes the original method. Then you can invoke the method overload from test. Once you have the test in place, it's a question of migrating the rest of the production code to use the better API.</p>\n<p dir=\"auto\">EG:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"final String imageName =\n          UnitImageFactory.getBaseImageName(  ImageNameParameters.builder()\n                .unitTypeName(&quot;infantry&quot;)\n                .unitAttachmentProperties(List.of())\n                .techAttachmentProperties(List.of())\n                .damaged(false)\n                .disabled(true))\n   .build());\n\nassertThat(imageName, is(&quot;infantry_disabled&quot;);\"><pre><code>final String imageName =\n          UnitImageFactory.getBaseImageName(  ImageNameParameters.builder()\n                .unitTypeName(\"infantry\")\n                .unitAttachmentProperties(List.of())\n                .techAttachmentProperties(List.of())\n                .damaged(false)\n                .disabled(true))\n   .build());\n\nassertThat(imageName, is(\"infantry_disabled\");\n</code></pre></div>\n<p dir=\"auto\">From here, test parameterization could help and the API's would be straight forward. EG:</p>\n<p dir=\"auto\">@ParameterizedTest<br>\n@MethodSource<br>\nvoid verifyBaseImageName(ImageNameParameters. parameters, String expectedName) {<br>\nfinal String imageName =<br>\nUnitImageFactory.getBaseImageName(parameters);</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\" assertThat(imageName, is(expectedName);\"><pre><code> assertThat(imageName, is(expectedName);\n</code></pre></div>\n<p dir=\"auto\">}</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n\nThoughts @trevan ?\"><pre><code>\n\nThoughts @trevan ?\n</code></pre></div>", "author": "DanVanAtta", "createdAt": "2020-07-11T04:00:45Z", "path": "game-core/src/test/java/games/strategy/triplea/image/UnitImageFactoryTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+package games.strategy.triplea.image;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.MutableProperty;\n+import games.strategy.engine.data.TechnologyFrontier;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.data.properties.GameProperties;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.attachments.TechAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class UnitImageFactoryTest {\n+  @Mock GameData gameData;\n+\n+  @Nested\n+  class GetBaseImageName {\n+\n+    @BeforeEach\n+    void setupGameData() {\n+      final TechnologyFrontier technologyFrontier = new TechnologyFrontier(\"Tech\", gameData);\n+      when(gameData.getTechnologyFrontier()).thenReturn(technologyFrontier);\n+      lenient().when(gameData.getDiceSides()).thenReturn(6);\n+      final GameProperties gameProperties = new GameProperties(gameData);\n+      lenient().when(gameData.getProperties()).thenReturn(gameProperties);\n+    }\n+\n+    @Test\n+    void basicUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasSuffix(List.of(), List.of(), \"\");\n+    }\n+\n+    @Test\n+    void basicDamagedUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasName(\n+          \"infantry\", List.of(), List.of(), true, false, \"infantry_hit\");\n+    }\n+\n+    @Test\n+    void basicDisabledUnitType() throws MutableProperty.InvalidValueException {\n+      givenUnitTypeAndTechnologyAssertThatImageHasName(\n+          \"infantry\", List.of(), List.of(), false, true, \"infantry_disabled\");", "originalCommit": "2fdd81769394d5f06b63dcb0ff9baf7ec0635567", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}