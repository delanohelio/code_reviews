{"pr_number": 7528, "pr_title": "xds: synchronize LoadReportClient operations with lock", "pr_author": "voidzcy", "pr_createdAt": "2020-10-17T02:24:46Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7528", "timeline": [{"oid": "4421741df7dba7c84ab4f2019fbf53ce0577235f", "url": "https://github.com/grpc/grpc-java/commit/4421741df7dba7c84ab4f2019fbf53ce0577235f", "message": "Eliminate unnecessary response conversion.", "committedDate": "2020-10-17T01:22:22Z", "type": "commit"}, {"oid": "fa51f4854bc84def8457956c4a0ea2364e3c9f42", "url": "https://github.com/grpc/grpc-java/commit/fa51f4854bc84def8457956c4a0ea2364e3c9f42", "message": "Create and use its own SynchronizationContext in LoadReportClient.", "committedDate": "2020-10-17T02:22:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4MzM4Mg==", "url": "https://github.com/grpc/grpc-java/pull/7528#discussion_r506783382", "body": "These two helper classes are redundant, they just repackage the fields in the proto messages/data structs. We can simply pass them as individual arguments to methods to be called.", "bodyText": "These two helper classes are redundant, they just repackage the fields in the proto messages/data structs. We can simply pass them as individual arguments to methods to be called.", "bodyHTML": "<p dir=\"auto\">These two helper classes are redundant, they just repackage the fields in the proto messages/data structs. We can simply pass them as individual arguments to methods to be called.</p>", "author": "voidzcy", "createdAt": "2020-10-17T02:27:02Z", "path": "xds/src/main/java/io/grpc/xds/LoadReportClient.java", "diffHunk": "@@ -392,93 +426,24 @@ public void run() {\n           LoadReportingServiceGrpc.newStub(xdsChannel.getManagedChannel());\n       lrsRequestWriterV3 = stubV3.withWaitForReady().streamLoadStats(lrsResponseReaderV3);\n       logger.log(XdsLogLevel.DEBUG, \"Sending initial LRS request\");\n-      sendLoadStatsRequest(new LoadStatsRequestData(node, null));\n+      sendLoadStatsRequest(Collections.<ClusterStats>emptyList());\n     }\n \n     @Override\n-    void sendLoadStatsRequest(LoadStatsRequestData request) {\n-      LoadStatsRequest requestProto = request.toEnvoyProtoV3();\n-      lrsRequestWriterV3.onNext(requestProto);\n-      logger.log(XdsLogLevel.DEBUG, \"Sent LoadStatsRequest\\n{0}\", requestProto);\n+    void sendLoadStatsRequest(List<ClusterStats> clusterStatsList) {\n+      LoadStatsRequest.Builder requestBuilder =\n+          LoadStatsRequest.newBuilder().setNode(node.toEnvoyProtoNode());\n+      for (ClusterStats stats : clusterStatsList) {\n+        requestBuilder.addClusterStats(stats.toEnvoyProtoClusterStats());\n+      }\n+      LoadStatsRequest request = requestBuilder.build();\n+      lrsRequestWriterV3.onNext(request);\n+      logger.log(XdsLogLevel.DEBUG, \"Sent LoadStatsRequest\\n{0}\", request);\n     }\n \n     @Override\n     void sendError(Exception error) {\n       lrsRequestWriterV3.onError(error);\n     }\n   }\n-\n-  private static final class LoadStatsRequestData {", "originalCommit": "fa51f4854bc84def8457956c4a0ea2364e3c9f42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "27562b9ba6b3345782baa08d4b2f39c0bca6f9be", "url": "https://github.com/grpc/grpc-java/commit/27562b9ba6b3345782baa08d4b2f39c0bca6f9be", "message": "Eliminated usage of SynchronizationContext in LoadReportClient compleltely to avoid mixing lock and SynchronizationContext for its caller.", "committedDate": "2020-10-19T18:54:30Z", "type": "commit"}, {"oid": "601cef3ec7f82cf7592c4377d9e6313a8e015a12", "url": "https://github.com/grpc/grpc-java/commit/601cef3ec7f82cf7592c4377d9e6313a8e015a12", "message": "Fixed rawtype warning.", "committedDate": "2020-10-19T19:40:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NTg0NA==", "url": "https://github.com/grpc/grpc-java/pull/7528#discussion_r508775844", "body": "There is a race condition: \r\n- `stopLoadReporting()` is called and holds the lock.\r\n- `LrsRpcRetryTask.run()` is called, trying to acquire the lock, and being blocked because the lock can not be acquired.\r\n- `stopLoadReporting()` turns `started = false`, and then calls `lrsRpcRetryTimer.cancel(false)` which does nothing because `LrsRpcRetryTask.run()` is already running and still trying to acquire the lock.\r\n- `stopLoadReporting()` returns and releases the lock.\r\n- `LrsRpcRetryTask.run()` finally acquires the lock and calls `startLrsRpc()`.", "bodyText": "There is a race condition:\n\nstopLoadReporting() is called and holds the lock.\nLrsRpcRetryTask.run() is called, trying to acquire the lock, and being blocked because the lock can not be acquired.\nstopLoadReporting() turns started = false, and then calls lrsRpcRetryTimer.cancel(false) which does nothing because LrsRpcRetryTask.run() is already running and still trying to acquire the lock.\nstopLoadReporting() returns and releases the lock.\nLrsRpcRetryTask.run() finally acquires the lock and calls startLrsRpc().", "bodyHTML": "<p dir=\"auto\">There is a race condition:</p>\n<ul dir=\"auto\">\n<li><code>stopLoadReporting()</code> is called and holds the lock.</li>\n<li><code>LrsRpcRetryTask.run()</code> is called, trying to acquire the lock, and being blocked because the lock can not be acquired.</li>\n<li><code>stopLoadReporting()</code> turns <code>started = false</code>, and then calls <code>lrsRpcRetryTimer.cancel(false)</code> which does nothing because <code>LrsRpcRetryTask.run()</code> is already running and still trying to acquire the lock.</li>\n<li><code>stopLoadReporting()</code> returns and releases the lock.</li>\n<li><code>LrsRpcRetryTask.run()</code> finally acquires the lock and calls <code>startLrsRpc()</code>.</li>\n</ul>", "author": "dapengzhang0", "createdAt": "2020-10-20T19:12:35Z", "path": "xds/src/main/java/io/grpc/xds/LoadReportClient.java", "diffHunk": "@@ -97,35 +92,39 @@\n    * no-op.\n    */\n   void startLoadReporting() {\n-    if (started) {\n-      return;\n+    synchronized (lock) {\n+      if (started) {\n+        return;\n+      }\n+      started = true;\n+      logger.log(XdsLogLevel.INFO, \"Starting load reporting RPC\");\n+      startLrsRpc();\n     }\n-    started = true;\n-    logger.log(XdsLogLevel.INFO, \"Starting load reporting RPC\");\n-    startLrsRpc();\n   }\n \n   /**\n    * Terminates load reporting. Calling this method on an already stopped\n    * {@link LoadReportClient} is no-op.\n    */\n   void stopLoadReporting() {\n-    if (!started) {\n-      return;\n-    }\n-    logger.log(XdsLogLevel.INFO, \"Stopping load reporting RPC\");\n-    if (lrsRpcRetryTimer != null) {\n-      lrsRpcRetryTimer.cancel();\n-    }\n-    if (lrsStream != null) {\n-      lrsStream.close(Status.CANCELLED.withDescription(\"stop load reporting\").asException());\n+    synchronized (lock) {\n+      if (!started) {\n+        return;\n+      }\n+      started = false;\n+      logger.log(XdsLogLevel.INFO, \"Stopping load reporting RPC\");\n+      if (lrsRpcRetryTimer != null) {\n+        lrsRpcRetryTimer.cancel(false);\n+      }", "originalCommit": "601cef3ec7f82cf7592c4377d9e6313a8e015a12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3ODY5MA==", "url": "https://github.com/grpc/grpc-java/pull/7528#discussion_r508778690", "bodyText": "I've considered this. When stopLoadReporting() is releasing the lock, started should have been set to false. The first statement of startLrsRpc() checks that and return immediately if already stopped.\n(Similar things happen for LoadReportingTask)", "author": "voidzcy", "createdAt": "2020-10-20T19:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NTg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MTg3MA==", "url": "https://github.com/grpc/grpc-java/pull/7528#discussion_r508851870", "bodyText": "Oh, the method name startLrsRpc() confused me, it actually should be restartLrsRpc().", "author": "dapengzhang0", "createdAt": "2020-10-20T21:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NTg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDE2Mg==", "url": "https://github.com/grpc/grpc-java/pull/7528#discussion_r508854162", "bodyText": "start* is fine, it is used both for the first time start and restart cases.", "author": "voidzcy", "createdAt": "2020-10-20T21:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NTg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5NDc3MQ==", "url": "https://github.com/grpc/grpc-java/pull/7528#discussion_r508894771", "body": "nit: We don't need check `if (delayNanos <= 0)`, `schedule()` should handle <=0 delay correctly.", "bodyText": "nit: We don't need check if (delayNanos <= 0), schedule() should handle <=0 delay correctly.", "bodyHTML": "<p dir=\"auto\">nit: We don't need check <code>if (delayNanos &lt;= 0)</code>, <code>schedule()</code> should handle &lt;=0 delay correctly.</p>", "author": "dapengzhang0", "createdAt": "2020-10-20T23:16:39Z", "path": "xds/src/main/java/io/grpc/xds/LoadReportClient.java", "diffHunk": "@@ -263,8 +267,7 @@ private void handleStreamClosed(Status status) {\n         startLrsRpc();\n       } else {\n         lrsRpcRetryTimer =\n-            syncContext.schedule(new LrsRpcRetryTask(), delayNanos, TimeUnit.NANOSECONDS,\n-                timerService);\n+            timerService.schedule(new LrsRpcRetryTask(), delayNanos, TimeUnit.NANOSECONDS);", "originalCommit": "601cef3ec7f82cf7592c4377d9e6313a8e015a12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMjg0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7528#discussion_r508902847", "bodyText": "Yeah, I remember we discussed the same thing for XdsClient before. I don't have strong preference, they should behave the same, only test needs to explicitly call runDueTasks(). Let's keep what we have now, as that's not related to what's this PR is intending for.", "author": "voidzcy", "createdAt": "2020-10-20T23:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5NDc3MQ=="}], "type": "inlineReview"}]}