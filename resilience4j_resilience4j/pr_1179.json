{"pr_number": 1179, "pr_title": "Micronaut support final", "pr_author": "Romeh", "pr_createdAt": "2020-09-25T10:02:38Z", "pr_url": "https://github.com/resilience4j/resilience4j/pull/1179", "merge_commit": "86f7868c0f523e7764ed121976d24483c19934a1", "timeline": [{"oid": "db718dfb8f04fa3066fb984fd72021f1d3e212c3", "url": "https://github.com/resilience4j/resilience4j/commit/db718dfb8f04fa3066fb984fd72021f1d3e212c3", "message": "Micronaut support (#1036)", "committedDate": "2020-06-22T09:02:28Z", "type": "commit"}, {"oid": "7c17948c5e2860dda68192b146546f43c3d43e1a", "url": "https://github.com/resilience4j/resilience4j/commit/7c17948c5e2860dda68192b146546f43c3d43e1a", "message": "Added qualifier to resilience4j-micronaut to correct multiple resolved types (#1051)", "committedDate": "2020-06-29T07:34:47Z", "type": "commit"}, {"oid": "6623abc15ea4c685edc1b6454d4191843200a12c", "url": "https://github.com/resilience4j/resilience4j/commit/6623abc15ea4c685edc1b6454d4191843200a12c", "message": "Removed annotation mapper (#1104)", "committedDate": "2020-08-12T06:52:23Z", "type": "commit"}, {"oid": "5ab4e5d73df97788622c5ff1e64d92e6eeb81573", "url": "https://github.com/resilience4j/resilience4j/commit/5ab4e5d73df97788622c5ff1e64d92e6eeb81573", "message": "cleanup and remove unused imports", "committedDate": "2020-09-02T03:50:45Z", "type": "commit"}, {"oid": "bbe2a7ef11e6b1bc44b34db088bd9f55520316cc", "url": "https://github.com/resilience4j/resilience4j/commit/bbe2a7ef11e6b1bc44b34db088bd9f55520316cc", "message": "clean up code and rename test", "committedDate": "2020-09-03T22:09:28Z", "type": "commit"}, {"oid": "419c6143c7342718917725b05b26254f3b3e75d1", "url": "https://github.com/resilience4j/resilience4j/commit/419c6143c7342718917725b05b26254f3b3e75d1", "message": "remove http server for test and clean up imports", "committedDate": "2020-09-14T19:53:51Z", "type": "commit"}, {"oid": "c82679d6220153693cc533c8c994fd28496af44c", "url": "https://github.com/resilience4j/resilience4j/commit/c82679d6220153693cc533c8c994fd28496af44c", "message": "simplify test and added coverage for timelimiter", "committedDate": "2020-09-14T23:24:06Z", "type": "commit"}, {"oid": "62568873c933d9663ba4d8a317269a9d45859a1b", "url": "https://github.com/resilience4j/resilience4j/commit/62568873c933d9663ba4d8a317269a9d45859a1b", "message": "Merge remote-tracking branch 'upstream/master' into micronaut", "committedDate": "2020-09-24T12:06:57Z", "type": "commit"}, {"oid": "031c90268a7ef2a67a32341dd34ecd3c37576cd5", "url": "https://github.com/resilience4j/resilience4j/commit/031c90268a7ef2a67a32341dd34ecd3c37576cd5", "message": "Merge remote-tracking branch 'upstream/micronaut' into rework_cleanup", "committedDate": "2020-09-25T09:49:41Z", "type": "commit"}, {"oid": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "url": "https://github.com/resilience4j/resilience4j/commit/e00af2462a8f45c1ad1983e17249824c82a30dd3", "message": "update the package to include micronaut plus cleaning java doc", "committedDate": "2020-09-25T12:40:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786749", "body": "@RobWin @pollend  is that right ?  i guess we need to wrap the call in bulkhead.executeCompletionStage not the result of the proceed ?", "bodyText": "@RobWin @pollend  is that right ?  i guess we need to wrap the call in bulkhead.executeCompletionStage not the result of the proceed ?", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RobWin/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RobWin\">@RobWin</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/pollend/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/pollend\">@pollend</a>  is that right ?  i guess we need to wrap the call in bulkhead.executeCompletionStage not the result of the proceed ?</p>", "author": "Romeh", "createdAt": "2020-09-28T08:55:14Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MTUzNQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496541535", "bodyText": "Yes, correct.\nPlease see https://github.com/resilience4j/resilience4j/blob/master/resilience4j-spring/src/main/java/io/github/resilience4j/bulkhead/configure/BulkheadAspect.java#L221-L230", "author": "RobWin", "createdAt": "2020-09-29T08:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NTUwOQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496885509", "bodyText": "The result it is used in an executeCompletionStage on line 104. I write it to an object first to do a null check. so would it just execute the proceeded within the executeCompletionStage? if its null then it will error out right? I guess it shouldn't matter because it will still throw it back to the fallbackCompletable.\nreturn this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);", "author": "pollend", "createdAt": "2020-09-29T16:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "676da2d940165295c5e20a81e3076628c3e64961", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 71557e23..76fdf7d3 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,11 +97,7 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 76fdf7d3..71557e23 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,7 +97,11 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "4a774192bfd0b024b2b621237da37b7e936865d7", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 71557e23..76fdf7d3 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,11 +97,7 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 76fdf7d3..367fe5e0 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,7 +97,13 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> {\n+                try {\n+                    return ((CompletableFuture<?>) context.proceed());\n+                } catch (Throwable e) {\n+                    throw new CompletionException(e);\n+                }\n+            }), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "386aa68ef63a85e682b28458e976e85258b4392d", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 367fe5e0..14ef61e4 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,22 +98,12 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> {\n-                try {\n-                    return ((CompletableFuture<?>) context.proceed());\n-                } catch (Throwable e) {\n-                    throw new CompletionException(e);\n-                }\n-            }), context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> toCompletionStage(context)), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<Object> flowable = ConversionService.SHARED\n+            Flowable<?> flowable = ConversionService.SHARED\n                 .convert(result, Flowable.class)\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-\n             flowable = this.fallbackFlowable(flowable.compose(BulkheadOperator.of(bulkhead)), context);\n             return ConversionService.SHARED\n                 .convert(flowable, context.getReturnType().asArgument())\n", "next_change": {"commit": "44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 14ef61e4..830d339f 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -101,6 +98,9 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n             return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> toCompletionStage(context)), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n             Flowable<?> flowable = ConversionService.SHARED\n                 .convert(result, Flowable.class)\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n", "next_change": {"commit": "2312e448c39790e37bc9c7493a4fde3ee68cc537", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java\nsimilarity index 63%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java\nindex 830d339f..75c4d196 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -81,38 +83,42 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n     @Override\n     public Object intercept(MethodInvocationContext<Object, Object> context) {\n \n-        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        Optional<AnnotationValue<io.github.resilience4j.micronaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.micronaut.annotation.Bulkhead.class);\n         if (!opt.isPresent()) {\n             return context.proceed();\n         }\n-        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n-        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+        final io.github.resilience4j.micronaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.micronaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.micronaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.micronaut.annotation.Bulkhead.Type.SEMAPHORE) {\n             return context.proceed();\n         }\n \n         final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n         Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> toCompletionStage(context)), context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<?> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-            flowable = this.fallbackFlowable(flowable.compose(BulkheadOperator.of(bulkhead)), context);\n-            return ConversionService.SHARED\n-                .convert(flowable, context.getReturnType().asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n+\n+        InterceptedMethod interceptedMethod = InterceptedMethod.of(context);\n         try {\n-            return bulkhead.executeSupplier(context::proceed);\n-        } catch (Throwable exception) {\n-            return this.fallback(context, exception);\n+            switch (interceptedMethod.resultType()){\n+                case PUBLISHER:\n+                    return interceptedMethod.handleResult(fallbackReactiveTypes(\n+                        Flowable.fromPublisher(interceptedMethod.interceptResultAsPublisher()).compose(BulkheadOperator.of(bulkhead)),\n+                        context));\n+                case COMPLETION_STAGE:\n+                    return interceptedMethod.handleResult(\n+                        fallbackForFuture(\n+                            bulkhead.executeCompletionStage(interceptedMethod::interceptResultAsCompletionStage),\n+                            context)\n+                    );\n+                case SYNCHRONOUS:\n+                    try {\n+                        return bulkhead.executeCheckedSupplier(context::proceed);\n+                    } catch (Throwable exception) {\n+                        return fallback(context, exception);\n+                    }\n+                default:\n+                    return interceptedMethod.unsupported();\n+            }\n+        } catch (Exception e) {\n+            return interceptedMethod.handleException(e);\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\ndeleted file mode 100644\nindex 71557e23..00000000\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ /dev/null\n", "chunk": "@@ -1,128 +0,0 @@\n-/*\n- * Copyright 2019 Michael Pollind\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *        http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.github.resilience4j.mirconaut.bulkhead;\n-\n-import io.github.resilience4j.bulkhead.Bulkhead;\n-import io.github.resilience4j.bulkhead.BulkheadRegistry;\n-import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n-import io.github.resilience4j.mirconaut.BaseInterceptor;\n-import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n-import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n-import io.micronaut.aop.MethodInterceptor;\n-import io.micronaut.aop.MethodInvocationContext;\n-import io.micronaut.context.BeanContext;\n-import io.micronaut.context.annotation.Requires;\n-import io.micronaut.core.annotation.AnnotationValue;\n-import io.micronaut.core.async.publisher.Publishers;\n-import io.micronaut.core.convert.ConversionService;\n-import io.micronaut.core.type.ReturnType;\n-import io.micronaut.inject.ExecutableMethod;\n-import io.micronaut.inject.MethodExecutionHandle;\n-import io.reactivex.Flowable;\n-\n-import javax.inject.Singleton;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionStage;\n-\n-/**\n- * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n- * annotation.\n- **/\n-@Singleton\n-@Requires(beans = BulkheadRegistry.class)\n-public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n-\n-    private final BulkheadRegistry bulkheadRegistry;\n-    private final BeanContext beanContext;\n-\n-    /**\n-     *\n-     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n-     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n-     */\n-    public BulkheadInterceptor(BeanContext beanContext,\n-                               BulkheadRegistry bulkheadRegistry) {\n-        this.bulkheadRegistry = bulkheadRegistry;\n-        this.beanContext = beanContext;\n-    }\n-\n-    @Override\n-    public int getOrder() {\n-        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n-    }\n-\n-    /**\n-     * Finds a fallback method for the given context.\n-     *\n-     * @param context The context\n-     * @return The fallback method if it is present\n-     */\n-    @Override\n-    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n-        ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n-        Class<?> declaringType = context.getDeclaringType();\n-        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n-    }\n-\n-    @Override\n-    public Object intercept(MethodInvocationContext<Object, Object> context) {\n-\n-        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n-        if (!opt.isPresent()) {\n-            return context.proceed();\n-        }\n-        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n-        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n-            return context.proceed();\n-        }\n-\n-        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n-        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<Object> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-\n-            flowable = this.fallbackFlowable(flowable.compose(BulkheadOperator.of(bulkhead)),context);\n-            return ConversionService.SHARED\n-                .convert(flowable, context.getReturnType().asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n-        try {\n-            return bulkhead.executeSupplier(context::proceed);\n-        } catch (RuntimeException exception) {\n-            return this.fallback(context, exception);\n-        } catch (Throwable throwable) {\n-            throw new UnhandledFallbackException(\"Error invoking fallback for type [\" + context.getTarget().getClass().getName() + \"]: \" + throwable.getMessage(), throwable);\n-        }\n-    }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495786947", "body": "Same comment as above ?", "bodyText": "Same comment as above ?", "bodyHTML": "<p dir=\"auto\">Same comment as above ?</p>", "author": "Romeh", "createdAt": "2020-09-28T08:55:35Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = BulkheadRegistry.class)\n+public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n+\n+    private final BulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     *\n+     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public BulkheadInterceptor(BeanContext beanContext,\n+                               BulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+            return context.proceed();\n+        }\n+\n+        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n+        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0MzU3Nw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496543577", "bodyText": "No, here it's fine.\nA Publisher is emitting events, when someone subscribes.", "author": "RobWin", "createdAt": "2020-09-29T08:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4Njk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "676da2d940165295c5e20a81e3076628c3e64961", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 71557e23..76fdf7d3 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,11 +97,7 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 76fdf7d3..71557e23 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,7 +97,11 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "4a774192bfd0b024b2b621237da37b7e936865d7", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 71557e23..76fdf7d3 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,11 +97,7 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 76fdf7d3..367fe5e0 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,7 +97,13 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())),context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> {\n+                try {\n+                    return ((CompletableFuture<?>) context.proceed());\n+                } catch (Throwable e) {\n+                    throw new CompletionException(e);\n+                }\n+            }), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "386aa68ef63a85e682b28458e976e85258b4392d", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 367fe5e0..14ef61e4 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -97,22 +98,12 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> {\n-                try {\n-                    return ((CompletableFuture<?>) context.proceed());\n-                } catch (Throwable e) {\n-                    throw new CompletionException(e);\n-                }\n-            }), context);\n+            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> toCompletionStage(context)), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<Object> flowable = ConversionService.SHARED\n+            Flowable<?> flowable = ConversionService.SHARED\n                 .convert(result, Flowable.class)\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-\n             flowable = this.fallbackFlowable(flowable.compose(BulkheadOperator.of(bulkhead)), context);\n             return ConversionService.SHARED\n                 .convert(flowable, context.getReturnType().asArgument())\n", "next_change": {"commit": "44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nindex 14ef61e4..830d339f 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -101,6 +98,9 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n             return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> toCompletionStage(context)), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n             Flowable<?> flowable = ConversionService.SHARED\n                 .convert(result, Flowable.class)\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n", "next_change": {"commit": "2312e448c39790e37bc9c7493a4fde3ee68cc537", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java\nsimilarity index 63%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java\nindex 830d339f..75c4d196 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/BulkheadInterceptor.java\n", "chunk": "@@ -81,38 +83,42 @@ public class BulkheadInterceptor extends BaseInterceptor implements MethodInterc\n     @Override\n     public Object intercept(MethodInvocationContext<Object, Object> context) {\n \n-        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        Optional<AnnotationValue<io.github.resilience4j.micronaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.micronaut.annotation.Bulkhead.class);\n         if (!opt.isPresent()) {\n             return context.proceed();\n         }\n-        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n-        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n+        final io.github.resilience4j.micronaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.micronaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.micronaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.micronaut.annotation.Bulkhead.Type.SEMAPHORE) {\n             return context.proceed();\n         }\n \n         final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n         Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> toCompletionStage(context)), context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<?> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-            flowable = this.fallbackFlowable(flowable.compose(BulkheadOperator.of(bulkhead)), context);\n-            return ConversionService.SHARED\n-                .convert(flowable, context.getReturnType().asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n+\n+        InterceptedMethod interceptedMethod = InterceptedMethod.of(context);\n         try {\n-            return bulkhead.executeSupplier(context::proceed);\n-        } catch (Throwable exception) {\n-            return this.fallback(context, exception);\n+            switch (interceptedMethod.resultType()){\n+                case PUBLISHER:\n+                    return interceptedMethod.handleResult(fallbackReactiveTypes(\n+                        Flowable.fromPublisher(interceptedMethod.interceptResultAsPublisher()).compose(BulkheadOperator.of(bulkhead)),\n+                        context));\n+                case COMPLETION_STAGE:\n+                    return interceptedMethod.handleResult(\n+                        fallbackForFuture(\n+                            bulkhead.executeCompletionStage(interceptedMethod::interceptResultAsCompletionStage),\n+                            context)\n+                    );\n+                case SYNCHRONOUS:\n+                    try {\n+                        return bulkhead.executeCheckedSupplier(context::proceed);\n+                    } catch (Throwable exception) {\n+                        return fallback(context, exception);\n+                    }\n+                default:\n+                    return interceptedMethod.unsupported();\n+            }\n+        } catch (Exception e) {\n+            return interceptedMethod.handleException(e);\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\ndeleted file mode 100644\nindex 71557e23..00000000\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/BulkheadInterceptor.java\n+++ /dev/null\n", "chunk": "@@ -1,128 +0,0 @@\n-/*\n- * Copyright 2019 Michael Pollind\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *        http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.github.resilience4j.mirconaut.bulkhead;\n-\n-import io.github.resilience4j.bulkhead.Bulkhead;\n-import io.github.resilience4j.bulkhead.BulkheadRegistry;\n-import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n-import io.github.resilience4j.mirconaut.BaseInterceptor;\n-import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n-import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n-import io.micronaut.aop.MethodInterceptor;\n-import io.micronaut.aop.MethodInvocationContext;\n-import io.micronaut.context.BeanContext;\n-import io.micronaut.context.annotation.Requires;\n-import io.micronaut.core.annotation.AnnotationValue;\n-import io.micronaut.core.async.publisher.Publishers;\n-import io.micronaut.core.convert.ConversionService;\n-import io.micronaut.core.type.ReturnType;\n-import io.micronaut.inject.ExecutableMethod;\n-import io.micronaut.inject.MethodExecutionHandle;\n-import io.reactivex.Flowable;\n-\n-import javax.inject.Singleton;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionStage;\n-\n-/**\n- * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n- * annotation.\n- **/\n-@Singleton\n-@Requires(beans = BulkheadRegistry.class)\n-public class BulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object>{\n-\n-    private final BulkheadRegistry bulkheadRegistry;\n-    private final BeanContext beanContext;\n-\n-    /**\n-     *\n-     * @param beanContext The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n-     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n-     */\n-    public BulkheadInterceptor(BeanContext beanContext,\n-                               BulkheadRegistry bulkheadRegistry) {\n-        this.bulkheadRegistry = bulkheadRegistry;\n-        this.beanContext = beanContext;\n-    }\n-\n-    @Override\n-    public int getOrder() {\n-        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n-    }\n-\n-    /**\n-     * Finds a fallback method for the given context.\n-     *\n-     * @param context The context\n-     * @return The fallback method if it is present\n-     */\n-    @Override\n-    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n-        ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n-        Class<?> declaringType = context.getDeclaringType();\n-        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n-    }\n-\n-    @Override\n-    public Object intercept(MethodInvocationContext<Object, Object> context) {\n-\n-        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n-        if (!opt.isPresent()) {\n-            return context.proceed();\n-        }\n-        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n-        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE) {\n-            return context.proceed();\n-        }\n-\n-        final String name = opt.get().stringValue(\"name\").orElse(\"default\");\n-        Bulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(bulkhead.executeCompletionStage(() -> ((CompletableFuture<?>) result)),context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<Object> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-\n-            flowable = this.fallbackFlowable(flowable.compose(BulkheadOperator.of(bulkhead)),context);\n-            return ConversionService.SHARED\n-                .convert(flowable, context.getReturnType().asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n-        try {\n-            return bulkhead.executeSupplier(context::proceed);\n-        } catch (RuntimeException exception) {\n-            return this.fallback(context, exception);\n-        } catch (Throwable throwable) {\n-            throw new UnhandledFallbackException(\"Error invoking fallback for type [\" + context.getTarget().getClass().getName() + \"]: \" + throwable.getMessage(), throwable);\n-        }\n-    }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495788546", "body": "why we are doing the process call here ?", "bodyText": "why we are doing the process call here ?", "bodyHTML": "<p dir=\"auto\">why we are doing the process call here ?</p>", "author": "Romeh", "createdAt": "2020-09-28T08:58:13Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.bulkhead;\n+\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;\n+import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+\n+/**\n+ * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n+ * annotation.\n+ **/\n+@Singleton\n+@Requires(beans = ThreadPoolBulkheadRegistry.class)\n+public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolBulkheadInterceptor.class);\n+\n+    private final ThreadPoolBulkheadRegistry bulkheadRegistry;\n+    private final BeanContext beanContext;\n+\n+    /**\n+     * @param beanContext      The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n+     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n+     */\n+    public ThreadPoolBulkheadInterceptor(BeanContext beanContext,\n+                                         ThreadPoolBulkheadRegistry bulkheadRegistry) {\n+        this.bulkheadRegistry = bulkheadRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+\n+        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n+            return context.proceed();\n+        }\n+        final String name = opt.get().stringValue().orElse(\"default\");\n+        ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDU4Mw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544583", "bodyText": "Method must be decorated, before it is executed.", "author": "RobWin", "createdAt": "2020-09-29T08:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4ODU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1954c7335d322093e67bf5627178053dcf068edd", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\nindex 5be76c31..fee6a111 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n", "chunk": "@@ -97,14 +97,10 @@ public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements Me\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n             return this.fallbackCompletable(bulkhead.executeSupplier(() -> {\n                 try {\n-                    return ((CompletableFuture<?>) result).get();\n-                } catch (InterruptedException | ExecutionException e) {\n+                    return ((CompletableFuture<?>) context.proceed()).get();\n+                } catch (Throwable e) {\n                     throw new CompletionException(e);\n                 }\n             }),context);\n", "next_change": {"commit": "386aa68ef63a85e682b28458e976e85258b4392d", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\nindex fee6a111..4336d076 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n", "chunk": "@@ -94,48 +91,18 @@ public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements Me\n         }\n         final String name = opt.get().stringValue().orElse(\"default\");\n         ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n+\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n+        CompletableFuture<Object> completableFuture = this.fallbackCompletable(bulkhead.executeSupplier(() -> toCompletionStage(context)), context);\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeSupplier(() -> {\n-                try {\n-                    return ((CompletableFuture<?>) context.proceed()).get();\n-                } catch (Throwable e) {\n-                    throw new CompletionException(e);\n-                }\n-            }),context);\n+            return completableFuture;\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             throw new IllegalStateException(\n                 \"ThreadPool bulkhead is only applicable for completable futures \");\n         }\n-\n-        CompletableFuture<Object> newFuture = new CompletableFuture<>();\n-        bulkhead.executeSupplier(context::proceed).whenComplete((o, throwable) -> {\n-            if (throwable == null) {\n-                newFuture.complete(o);\n-            } else {\n-                Optional<? extends MethodExecutionHandle<?, Object>> fallbackMethod = findFallbackMethod(context);\n-                if (fallbackMethod.isPresent()) {\n-                    MethodExecutionHandle<?, Object> fallbackHandle = fallbackMethod.get();\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Type [{}] resolved fallback: {}\", context.getTarget().getClass(), fallbackHandle);\n-                    }\n-                    try {\n-                        Object result = fallbackHandle.invoke(context.getParameterValues());\n-                        newFuture.complete(result);\n-                    } catch (Exception e) {\n-                        if (logger.isErrorEnabled()) {\n-                            logger.error(\"Error invoking Fallback [\" + fallbackHandle + \"]: \" + e.getMessage(), e);\n-                        }\n-                        newFuture.completeExceptionally(throwable);\n-                    }\n-                } else {\n-                    newFuture.completeExceptionally(throwable);\n-                }\n-            }\n-        });\n         try {\n-            return newFuture.get();\n+            return completableFuture.get();\n         } catch (RuntimeException e) {\n             throw e;\n         } catch (Throwable throwable) {\n", "next_change": {"commit": "e9548783f39ea78ff5f2a511a15bdb568bf1d4b5", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\nindex 4336d076..05d19bf6 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n", "chunk": "@@ -94,15 +94,46 @@ public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements Me\n \n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n-        CompletableFuture<Object> completableFuture = this.fallbackCompletable(bulkhead.executeSupplier(() -> toCompletionStage(context)), context);\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return completableFuture;\n+            return this.fallbackCompletable(bulkhead.executeSupplier(() -> {\n+                try {\n+                    return ((CompletableFuture<?>) context.proceed()).get();\n+                } catch (Throwable e) {\n+                    throw new CompletionException(e);\n+                }\n+            }), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             throw new IllegalStateException(\n                 \"ThreadPool bulkhead is only applicable for completable futures \");\n         }\n+\n+        CompletableFuture<Object> newFuture = new CompletableFuture<>();\n+        bulkhead.executeSupplier(context::proceed).whenComplete((o, throwable) -> {\n+            if (throwable == null) {\n+                newFuture.complete(o);\n+            } else {\n+                Optional<? extends MethodExecutionHandle<?, Object>> fallbackMethod = findFallbackMethod(context);\n+                if (fallbackMethod.isPresent()) {\n+                    MethodExecutionHandle<?, Object> fallbackHandle = fallbackMethod.get();\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Type [{}] resolved fallback: {}\", context.getTarget().getClass(), fallbackHandle);\n+                    }\n+                    try {\n+                        Object result = fallbackHandle.invoke(context.getParameterValues());\n+                        newFuture.complete(result);\n+                    } catch (Exception e) {\n+                        if (logger.isErrorEnabled()) {\n+                            logger.error(\"Error invoking Fallback [\" + fallbackHandle + \"]: \" + e.getMessage(), e);\n+                        }\n+                        newFuture.completeExceptionally(throwable);\n+                    }\n+                } else {\n+                    newFuture.completeExceptionally(throwable);\n+                }\n+            }\n+        });\n         try {\n-            return completableFuture.get();\n+            return newFuture.get();\n         } catch (RuntimeException e) {\n             throw e;\n         } catch (Throwable throwable) {\n", "next_change": {"commit": "1399292fc70afe0555a4ac46dd8e3e2c33e3072e", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/ThreadPoolBulkheadInterceptor.java\nsimilarity index 59%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/ThreadPoolBulkheadInterceptor.java\nindex 05d19bf6..e739eb29 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n", "chunk": "@@ -74,70 +75,36 @@ public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements Me\n     @Override\n     public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n         ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n         Class<?> declaringType = context.getDeclaringType();\n         return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n     }\n \n     @Override\n     public Object intercept(MethodInvocationContext<Object, Object> context) {\n-        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n+        Optional<AnnotationValue<io.github.resilience4j.micronaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.micronaut.annotation.Bulkhead.class);\n         if (!opt.isPresent()) {\n             return context.proceed();\n         }\n-        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n-        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n+        final io.github.resilience4j.micronaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.micronaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.micronaut.annotation.Bulkhead.Type.SEMAPHORE);\n+        if (type != io.github.resilience4j.micronaut.annotation.Bulkhead.Type.THREADPOOL) {\n             return context.proceed();\n         }\n         final String name = opt.get().stringValue().orElse(\"default\");\n         ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n \n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(bulkhead.executeSupplier(() -> {\n+        InterceptedMethod interceptedMethod = InterceptedMethod.of(context);\n+        if(interceptedMethod.resultType() == InterceptedMethod.ResultType.COMPLETION_STAGE){\n+            return this.fallbackForFuture(bulkhead.executeSupplier(() -> {\n                 try {\n                     return ((CompletableFuture<?>) context.proceed()).get();\n                 } catch (Throwable e) {\n                     throw new CompletionException(e);\n                 }\n             }), context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            throw new IllegalStateException(\n-                \"ThreadPool bulkhead is only applicable for completable futures \");\n         }\n \n-        CompletableFuture<Object> newFuture = new CompletableFuture<>();\n-        bulkhead.executeSupplier(context::proceed).whenComplete((o, throwable) -> {\n-            if (throwable == null) {\n-                newFuture.complete(o);\n-            } else {\n-                Optional<? extends MethodExecutionHandle<?, Object>> fallbackMethod = findFallbackMethod(context);\n-                if (fallbackMethod.isPresent()) {\n-                    MethodExecutionHandle<?, Object> fallbackHandle = fallbackMethod.get();\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Type [{}] resolved fallback: {}\", context.getTarget().getClass(), fallbackHandle);\n-                    }\n-                    try {\n-                        Object result = fallbackHandle.invoke(context.getParameterValues());\n-                        newFuture.complete(result);\n-                    } catch (Exception e) {\n-                        if (logger.isErrorEnabled()) {\n-                            logger.error(\"Error invoking Fallback [\" + fallbackHandle + \"]: \" + e.getMessage(), e);\n-                        }\n-                        newFuture.completeExceptionally(throwable);\n-                    }\n-                } else {\n-                    newFuture.completeExceptionally(throwable);\n-                }\n-            }\n-        });\n-        try {\n-            return newFuture.get();\n-        } catch (RuntimeException e) {\n-            throw e;\n-        } catch (Throwable throwable) {\n-            return new CompletionException(throwable);\n-        }\n+        throw new IllegalStateException(\n+            \"ThreadPool bulkhead is only applicable for completable futures\");\n     }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\ndeleted file mode 100644\nindex 5be76c31..00000000\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/bulkhead/ThreadPoolBulkheadInterceptor.java\n+++ /dev/null\n", "chunk": "@@ -1,150 +0,0 @@\n-/*\n- * Copyright 2020 Michael Pollind\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *        http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.github.resilience4j.mirconaut.bulkhead;\n-\n-import io.github.resilience4j.bulkhead.Bulkhead;\n-import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;\n-import io.github.resilience4j.bulkhead.ThreadPoolBulkheadRegistry;\n-import io.github.resilience4j.mirconaut.BaseInterceptor;\n-import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n-import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n-import io.micronaut.aop.MethodInterceptor;\n-import io.micronaut.aop.MethodInvocationContext;\n-import io.micronaut.context.BeanContext;\n-import io.micronaut.context.annotation.Requires;\n-import io.micronaut.core.annotation.AnnotationValue;\n-import io.micronaut.core.async.publisher.Publishers;\n-import io.micronaut.core.type.ReturnType;\n-import io.micronaut.inject.ExecutableMethod;\n-import io.micronaut.inject.MethodExecutionHandle;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.inject.Singleton;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n-import java.util.concurrent.CompletionStage;\n-import java.util.concurrent.ExecutionException;\n-\n-/**\n- * A {@link MethodInterceptor} that intercepts all method calls which are annotated with a {@link io.github.resilience4j.mirconaut.annotation.Bulkhead}\n- * annotation.\n- **/\n-@Singleton\n-@Requires(beans = ThreadPoolBulkheadRegistry.class)\n-public class ThreadPoolBulkheadInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n-    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolBulkheadInterceptor.class);\n-\n-    private final ThreadPoolBulkheadRegistry bulkheadRegistry;\n-    private final BeanContext beanContext;\n-\n-    /**\n-     * @param beanContext      The bean context to allow for DI of class annotated with {@link javax.inject.Inject}.\n-     * @param bulkheadRegistry bulkhead registry used to retrieve {@link Bulkhead} by name\n-     */\n-    public ThreadPoolBulkheadInterceptor(BeanContext beanContext,\n-                                         ThreadPoolBulkheadRegistry bulkheadRegistry) {\n-        this.bulkheadRegistry = bulkheadRegistry;\n-        this.beanContext = beanContext;\n-    }\n-\n-    @Override\n-    public int getOrder() {\n-        return ResilienceInterceptPhase.BULKHEAD.getPosition();\n-    }\n-\n-    /**\n-     * Finds a fallback method for the given context.\n-     *\n-     * @param context The context\n-     * @return The fallback method if it is present\n-     */\n-    @Override\n-    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n-        ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Bulkhead.class, \"fallbackMethod\").orElse(\"\");\n-        Class<?> declaringType = context.getDeclaringType();\n-        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n-    }\n-\n-    @Override\n-    public Object intercept(MethodInvocationContext<Object, Object> context) {\n-\n-        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Bulkhead>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Bulkhead.class);\n-        if (!opt.isPresent()) {\n-            return context.proceed();\n-        }\n-        final io.github.resilience4j.mirconaut.annotation.Bulkhead.Type type = opt.get().enumValue(\"type\", io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.class).orElse(io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.SEMAPHORE);\n-        if (type != io.github.resilience4j.mirconaut.annotation.Bulkhead.Type.THREADPOOL) {\n-            return context.proceed();\n-        }\n-        final String name = opt.get().stringValue().orElse(\"default\");\n-        ThreadPoolBulkhead bulkhead = this.bulkheadRegistry.bulkhead(name);\n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(bulkhead.executeSupplier(() -> {\n-                try {\n-                    return ((CompletableFuture<?>) result).get();\n-                } catch (InterruptedException | ExecutionException e) {\n-                    throw new CompletionException(e);\n-                }\n-            }),context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            throw new IllegalStateException(\n-                \"ThreadPool bulkhead is only applicable for completable futures \");\n-        }\n-\n-        CompletableFuture<Object> newFuture = new CompletableFuture<>();\n-        bulkhead.executeSupplier(context::proceed).whenComplete((o, throwable) -> {\n-            if (throwable == null) {\n-                newFuture.complete(o);\n-            } else {\n-                Optional<? extends MethodExecutionHandle<?, Object>> fallbackMethod = findFallbackMethod(context);\n-                if (fallbackMethod.isPresent()) {\n-                    MethodExecutionHandle<?, Object> fallbackHandle = fallbackMethod.get();\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Type [{}] resolved fallback: {}\", context.getTarget().getClass(), fallbackHandle);\n-                    }\n-                    try {\n-                        Object result = fallbackHandle.invoke(context.getParameterValues());\n-                        newFuture.complete(result);\n-                    } catch (Exception e) {\n-                        if (logger.isErrorEnabled()) {\n-                            logger.error(\"Error invoking Fallback [\" + fallbackHandle + \"]: \" + e.getMessage(), e);\n-                        }\n-                        newFuture.completeExceptionally(throwable);\n-                    }\n-                } else {\n-                    newFuture.completeExceptionally(throwable);\n-                }\n-            }\n-        });\n-        try {\n-            return newFuture.get();\n-        } catch (RuntimeException e) {\n-            throw e;\n-        } catch (Throwable throwable) {\n-            throw new UnhandledFallbackException(\"Error invoking fallback for type [\" + context.getTarget().getClass().getName() + \"]: \" + throwable.getMessage(), throwable);\n-        }\n-\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r495789037", "body": "why not wrapping the proceed call with circuitBreaker.executeCompletionStage()  ?", "bodyText": "why not wrapping the proceed call with circuitBreaker.executeCompletionStage()  ?", "bodyHTML": "<p dir=\"auto\">why not wrapping the proceed call with circuitBreaker.executeCompletionStage()  ?</p>", "author": "Romeh", "createdAt": "2020-09-28T08:59:00Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.circuitbreaker;\n+\n+import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n+import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+@Singleton\n+@Requires(beans = CircuitBreakerRegistry.class)\n+public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final CircuitBreakerRegistry circuitBreakerRegistry;\n+    private final BeanContext beanContext;\n+\n+\n+    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n+        this.circuitBreakerRegistry = circuitBreakerRegistry;\n+        this.beanContext = beanContext;\n+    }\n+\n+    @Override\n+    public int getOrder() {\n+        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n+    }\n+\n+    /**\n+     * Finds a fallback method for the given context.\n+     *\n+     * @param context The context\n+     * @return The fallback method if it is present\n+     */\n+    @Override\n+    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        Class<?> declaringType = context.getDeclaringType();\n+        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n+    }\n+\n+    @Override\n+    public Object intercept(MethodInvocationContext<Object, Object> context) {\n+        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        if (!opt.isPresent()) {\n+            return context.proceed();\n+        }\n+\n+        ExecutableMethod executableMethod = context.getExecutableMethod();\n+        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n+        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+\n+        ReturnType<Object> rt = context.getReturnType();\n+        Class<Object> returnType = rt.getType();\n+        if (CompletionStage.class.isAssignableFrom(returnType)) {\n+            Object result = context.proceed();", "originalCommit": "e00af2462a8f45c1ad1983e17249824c82a30dd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU0NDc3MA==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r496544770", "bodyText": "Same as above", "author": "RobWin", "createdAt": "2020-09-29T08:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4OTAzNw=="}], "type": "inlineReview", "revised_code": {"commit": "676da2d940165295c5e20a81e3076628c3e64961", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex d4e9a48b..8750e742 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -83,11 +83,7 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex 8750e742..d4e9a48b 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -83,7 +83,11 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())), context);\n+            Object result = context.proceed();\n+            if (result == null) {\n+                return result;\n+            }\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "4a774192bfd0b024b2b621237da37b7e936865d7", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex d4e9a48b..8750e742 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -83,11 +83,7 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex 8750e742..520b9ee7 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -83,7 +84,13 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) context.proceed())), context);\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> {\n+                try {\n+                    return ((CompletableFuture<?>) context.proceed());\n+                } catch (Throwable e) {\n+                    throw new CompletionException(e);\n+                }\n+            }), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n", "next_change": {"commit": "386aa68ef63a85e682b28458e976e85258b4392d", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex 520b9ee7..07df8447 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -84,32 +83,24 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n         ReturnType<Object> rt = context.getReturnType();\n         Class<Object> returnType = rt.getType();\n         if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> {\n-                try {\n-                    return ((CompletableFuture<?>) context.proceed());\n-                } catch (Throwable e) {\n-                    throw new CompletionException(e);\n-                }\n-            }), context);\n+            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> toCompletionStage(context)), context);\n         } else if (Publishers.isConvertibleToPublisher(returnType)) {\n             Object result = context.proceed();\n             if (result == null) {\n                 return result;\n             }\n-            Flowable<Object> flowable = ConversionService.SHARED\n+            Flowable<?> flowable = ConversionService.SHARED\n                 .convert(result, Flowable.class)\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n             flowable = this.fallbackFlowable(flowable.compose(CircuitBreakerOperator.of(circuitBreaker)), context);\n             return ConversionService.SHARED\n-                .convert(flowable, context.getReturnType().asArgument())\n+                .convert(flowable, rt.asArgument())\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n         }\n         try {\n             return circuitBreaker.executeCheckedSupplier(context::proceed);\n-        } catch (RuntimeException exception) {\n+        } catch (Throwable exception) {\n             return fallback(context, exception);\n-        } catch (Throwable throwable) {\n-            throw new UnhandledFallbackException(\"Error invoking fallback for type [\" + context.getTarget().getClass().getName() + \"]: \" + throwable.getMessage(), throwable);\n         }\n     }\n }\n", "next_change": {"commit": "2312e448c39790e37bc9c7493a4fde3ee68cc537", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/circuitbreaker/CircuitBreakerInterceptor.java\nsimilarity index 58%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex 07df8447..07ce440a 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -65,42 +64,46 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n     @Override\n     public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n         ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n         Class<?> declaringType = context.getDeclaringType();\n         return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n     }\n \n     @Override\n     public Object intercept(MethodInvocationContext<Object, Object> context) {\n-        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        Optional<AnnotationValue<io.github.resilience4j.micronaut.annotation.CircuitBreaker>> opt = context.findAnnotation(io.github.resilience4j.micronaut.annotation.CircuitBreaker.class);\n         if (!opt.isPresent()) {\n             return context.proceed();\n         }\n         ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n-        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+        final String name = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.CircuitBreaker.class, \"name\").orElse(\"default\");\n+        CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n \n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> toCompletionStage(context)), context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<?> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-            flowable = this.fallbackFlowable(flowable.compose(CircuitBreakerOperator.of(circuitBreaker)), context);\n-            return ConversionService.SHARED\n-                .convert(flowable, rt.asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n+        InterceptedMethod interceptedMethod = InterceptedMethod.of(context);\n         try {\n-            return circuitBreaker.executeCheckedSupplier(context::proceed);\n-        } catch (Throwable exception) {\n-            return fallback(context, exception);\n+            switch (interceptedMethod.resultType()){\n+                case PUBLISHER:\n+                    return interceptedMethod.handleResult(fallbackReactiveTypes(\n+                        Flowable.fromPublisher(interceptedMethod.interceptResultAsPublisher()).compose(CircuitBreakerOperator.of(circuitBreaker)),\n+                        context));\n+                case COMPLETION_STAGE:\n+                    return interceptedMethod.handleResult(\n+                        fallbackForFuture(\n+                            circuitBreaker.executeCompletionStage(interceptedMethod::interceptResultAsCompletionStage),\n+                            context)\n+                    );\n+                case SYNCHRONOUS:\n+                    try {\n+                        return circuitBreaker.executeCheckedSupplier(context::proceed);\n+                    } catch (Throwable exception) {\n+                        return fallback(context, exception);\n+                    }\n+                default:\n+                    return interceptedMethod.unsupported();\n+            }\n+        } catch (Exception e) {\n+            return interceptedMethod.handleException(e);\n         }\n+\n     }\n }\n", "next_change": null}]}}]}}, {"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex 8750e742..520b9ee7 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -92,7 +99,7 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n             Flowable<Object> flowable = ConversionService.SHARED\n                 .convert(result, Flowable.class)\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-            flowable = this.fallbackFlowable(flowable.compose(CircuitBreakerOperator.of(circuitBreaker)),context);\n+            flowable = this.fallbackFlowable(flowable.compose(CircuitBreakerOperator.of(circuitBreaker)), context);\n             return ConversionService.SHARED\n                 .convert(flowable, context.getReturnType().asArgument())\n                 .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n", "next_change": {"commit": "bd485881cad4f2d7d27f45ed4568fd2910fab95e", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex 520b9ee7..36ecc9a6 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -106,10 +106,8 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n         }\n         try {\n             return circuitBreaker.executeCheckedSupplier(context::proceed);\n-        } catch (RuntimeException exception) {\n+        } catch (Throwable exception) {\n             return fallback(context, exception);\n-        } catch (Throwable throwable) {\n-            throw new UnhandledFallbackException(\"Error invoking fallback for type [\" + context.getTarget().getClass().getName() + \"]: \" + throwable.getMessage(), throwable);\n         }\n     }\n }\n", "next_change": {"commit": "2312e448c39790e37bc9c7493a4fde3ee68cc537", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/circuitbreaker/CircuitBreakerInterceptor.java\nsimilarity index 56%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/circuitbreaker/CircuitBreakerInterceptor.java\nindex 36ecc9a6..07ce440a 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/circuitbreaker/CircuitBreakerInterceptor.java\n", "chunk": "@@ -65,49 +64,46 @@ public class CircuitBreakerInterceptor extends BaseInterceptor implements Method\n     @Override\n     public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n         ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n+        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n         Class<?> declaringType = context.getDeclaringType();\n         return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n     }\n \n     @Override\n     public Object intercept(MethodInvocationContext<Object, Object> context) {\n-        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n+        Optional<AnnotationValue<io.github.resilience4j.micronaut.annotation.CircuitBreaker>> opt = context.findAnnotation(io.github.resilience4j.micronaut.annotation.CircuitBreaker.class);\n         if (!opt.isPresent()) {\n             return context.proceed();\n         }\n-\n         ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n-        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n+        final String name = executableMethod.stringValue(io.github.resilience4j.micronaut.annotation.CircuitBreaker.class, \"name\").orElse(\"default\");\n+        CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n \n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> {\n-                try {\n-                    return ((CompletableFuture<?>) context.proceed());\n-                } catch (Throwable e) {\n-                    throw new CompletionException(e);\n-                }\n-            }), context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<Object> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-            flowable = this.fallbackFlowable(flowable.compose(CircuitBreakerOperator.of(circuitBreaker)), context);\n-            return ConversionService.SHARED\n-                .convert(flowable, context.getReturnType().asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n+        InterceptedMethod interceptedMethod = InterceptedMethod.of(context);\n         try {\n-            return circuitBreaker.executeCheckedSupplier(context::proceed);\n-        } catch (Throwable exception) {\n-            return fallback(context, exception);\n+            switch (interceptedMethod.resultType()){\n+                case PUBLISHER:\n+                    return interceptedMethod.handleResult(fallbackReactiveTypes(\n+                        Flowable.fromPublisher(interceptedMethod.interceptResultAsPublisher()).compose(CircuitBreakerOperator.of(circuitBreaker)),\n+                        context));\n+                case COMPLETION_STAGE:\n+                    return interceptedMethod.handleResult(\n+                        fallbackForFuture(\n+                            circuitBreaker.executeCompletionStage(interceptedMethod::interceptResultAsCompletionStage),\n+                            context)\n+                    );\n+                case SYNCHRONOUS:\n+                    try {\n+                        return circuitBreaker.executeCheckedSupplier(context::proceed);\n+                    } catch (Throwable exception) {\n+                        return fallback(context, exception);\n+                    }\n+                default:\n+                    return interceptedMethod.unsupported();\n+            }\n+        } catch (Exception e) {\n+            return interceptedMethod.handleException(e);\n         }\n+\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\ndeleted file mode 100644\nindex d4e9a48b..00000000\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/circuitbreaker/CircuitBreakerInterceptor.java\n+++ /dev/null\n", "chunk": "@@ -1,112 +0,0 @@\n-/*\n- * Copyright 2019 Michael Pollind\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *        http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.github.resilience4j.mirconaut.circuitbreaker;\n-\n-import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n-import io.github.resilience4j.circuitbreaker.operator.CircuitBreakerOperator;\n-import io.github.resilience4j.mirconaut.BaseInterceptor;\n-import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n-import io.github.resilience4j.mirconaut.annotation.CircuitBreaker;\n-import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n-import io.micronaut.aop.MethodInterceptor;\n-import io.micronaut.aop.MethodInvocationContext;\n-import io.micronaut.context.BeanContext;\n-import io.micronaut.context.annotation.Requires;\n-import io.micronaut.core.annotation.AnnotationValue;\n-import io.micronaut.core.async.publisher.Publishers;\n-import io.micronaut.core.convert.ConversionService;\n-import io.micronaut.core.type.ReturnType;\n-import io.micronaut.inject.ExecutableMethod;\n-import io.micronaut.inject.MethodExecutionHandle;\n-import io.reactivex.Flowable;\n-\n-import javax.inject.Singleton;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionStage;\n-\n-@Singleton\n-@Requires(beans = CircuitBreakerRegistry.class)\n-public class CircuitBreakerInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n-    private final CircuitBreakerRegistry circuitBreakerRegistry;\n-    private final BeanContext beanContext;\n-\n-\n-    public CircuitBreakerInterceptor(BeanContext beanContext, CircuitBreakerRegistry circuitBreakerRegistry) {\n-        this.circuitBreakerRegistry = circuitBreakerRegistry;\n-        this.beanContext = beanContext;\n-    }\n-\n-    @Override\n-    public int getOrder() {\n-        return ResilienceInterceptPhase.CIRCUIT_BREAKER.getPosition();\n-    }\n-\n-    /**\n-     * Finds a fallback method for the given context.\n-     *\n-     * @param context The context\n-     * @return The fallback method if it is present\n-     */\n-    @Override\n-    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n-        ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(CircuitBreaker.class, \"fallbackMethod\").orElse(\"\");\n-        Class<?> declaringType = context.getDeclaringType();\n-        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n-    }\n-\n-    @Override\n-    public Object intercept(MethodInvocationContext<Object, Object> context) {\n-        Optional<AnnotationValue<CircuitBreaker>> opt = context.findAnnotation(CircuitBreaker.class);\n-        if (!opt.isPresent()) {\n-            return context.proceed();\n-        }\n-\n-        ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String name = executableMethod.stringValue(CircuitBreaker.class, \"name\").orElse(\"default\");\n-        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.circuitBreakerRegistry.circuitBreaker(name);\n-\n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            return this.fallbackCompletable(circuitBreaker.executeCompletionStage(() -> ((CompletableFuture<?>) result)), context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<Object> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-            flowable = this.fallbackFlowable(flowable.compose(CircuitBreakerOperator.of(circuitBreaker)),context);\n-            return ConversionService.SHARED\n-                .convert(flowable, context.getReturnType().asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n-        try {\n-            return circuitBreaker.executeCheckedSupplier(context::proceed);\n-        } catch (RuntimeException exception) {\n-            return fallback(context, exception);\n-        } catch (Throwable throwable) {\n-            throw new UnhandledFallbackException(\"Error invoking fallback for type [\" + context.getTarget().getClass().getName() + \"]: \" + throwable.getMessage(), throwable);\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"oid": "676da2d940165295c5e20a81e3076628c3e64961", "url": "https://github.com/resilience4j/resilience4j/commit/676da2d940165295c5e20a81e3076628c3e64961", "message": "move proceed into excuteCompletionStage", "committedDate": "2020-09-29T17:05:31Z", "type": "commit"}, {"oid": "c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "url": "https://github.com/resilience4j/resilience4j/commit/c361563bba4ef9b40b383d9d56d2d9c0f94be4df", "message": "enable event listening", "committedDate": "2020-09-29T18:01:49Z", "type": "commit"}, {"oid": "c1f27f6b8e855b01a0e425d2265789223972eec0", "url": "https://github.com/resilience4j/resilience4j/commit/c1f27f6b8e855b01a0e425d2265789223972eec0", "message": "tweak for flowable test case", "committedDate": "2020-09-29T19:41:19Z", "type": "commit"}, {"oid": "4a774192bfd0b024b2b621237da37b7e936865d7", "url": "https://github.com/resilience4j/resilience4j/commit/4a774192bfd0b024b2b621237da37b7e936865d7", "message": "Merge branch 'feature/flowable-test' into feature/tweak-completion-stage", "committedDate": "2020-09-29T19:42:10Z", "type": "commit"}, {"oid": "9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "url": "https://github.com/resilience4j/resilience4j/commit/9f2d54c8cfc4bc2a3ba5172957eb048325fc319b", "message": "correct flowable and exception", "committedDate": "2020-09-29T21:30:52Z", "type": "commit"}, {"oid": "bd485881cad4f2d7d27f45ed4568fd2910fab95e", "url": "https://github.com/resilience4j/resilience4j/commit/bd485881cad4f2d7d27f45ed4568fd2910fab95e", "message": "tweak intercept for fallback", "committedDate": "2020-09-29T21:57:36Z", "type": "commit"}, {"oid": "1954c7335d322093e67bf5627178053dcf068edd", "url": "https://github.com/resilience4j/resilience4j/commit/1954c7335d322093e67bf5627178053dcf068edd", "message": "correct recovery for threadpool bulkhead", "committedDate": "2020-09-29T22:04:29Z", "type": "commit"}, {"oid": "e938994915810ec176d1091c682b90a05861082e", "url": "https://github.com/resilience4j/resilience4j/commit/e938994915810ec176d1091c682b90a05861082e", "message": "bump", "committedDate": "2020-10-01T19:12:34Z", "type": "commit"}, {"oid": "58b991464c47c5584304f1c11517ff2e6c8bdc73", "url": "https://github.com/resilience4j/resilience4j/commit/58b991464c47c5584304f1c11517ff2e6c8bdc73", "message": "Merge pull request #1183 from pollend/feature/tweak-completion-stage\n\nfeat(micronaut): update intercept and test cases", "committedDate": "2020-10-02T08:04:51Z", "type": "commit"}, {"oid": "386aa68ef63a85e682b28458e976e85258b4392d", "url": "https://github.com/resilience4j/resilience4j/commit/386aa68ef63a85e682b28458e976e85258b4392d", "message": "remove duplicate code", "committedDate": "2020-10-06T19:24:44Z", "type": "commit"}, {"oid": "a76a6800287e5b14de84b6cb6914f77925911a1b", "url": "https://github.com/resilience4j/resilience4j/commit/a76a6800287e5b14de84b6cb6914f77925911a1b", "message": "clean up imports", "committedDate": "2020-10-06T19:28:06Z", "type": "commit"}, {"oid": "6bc66e039d40f11730c3bc7640f268b4ac3fdc3a", "url": "https://github.com/resilience4j/resilience4j/commit/6bc66e039d40f11730c3bc7640f268b4ac3fdc3a", "message": "correct javadocs", "committedDate": "2020-10-06T19:37:38Z", "type": "commit"}, {"oid": "e9548783f39ea78ff5f2a511a15bdb568bf1d4b5", "url": "https://github.com/resilience4j/resilience4j/commit/e9548783f39ea78ff5f2a511a15bdb568bf1d4b5", "message": "correct bulkhead", "committedDate": "2020-10-06T19:56:57Z", "type": "commit"}, {"oid": "44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "url": "https://github.com/resilience4j/resilience4j/commit/44c82b3cb4de9eb2ed22989819edb8b7c95689c5", "message": "add back null check", "committedDate": "2020-10-06T20:11:58Z", "type": "commit"}, {"oid": "be03fecd0850883f170896b9a0315e84fc308141", "url": "https://github.com/resilience4j/resilience4j/commit/be03fecd0850883f170896b9a0315e84fc308141", "message": "Merge pull request #1190 from pollend/feature/micronaut-fix-duplication\n\nlower code duplication for micronaut", "committedDate": "2020-10-06T20:32:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MDYwNQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501470605", "body": "For this, you may want to consider in Micronaut 2.1 using the new `InterceptedMethod` API which simplifies handling future/reactive/synchronous cases. See https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/runtime/src/main/java/io/micronaut/retry/intercept/RecoveryInterceptor.java#L79", "bodyText": "For this, you may want to consider in Micronaut 2.1 using the new InterceptedMethod API which simplifies handling future/reactive/synchronous cases. See https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/runtime/src/main/java/io/micronaut/retry/intercept/RecoveryInterceptor.java#L79", "bodyHTML": "<p dir=\"auto\">For this, you may want to consider in Micronaut 2.1 using the new <code>InterceptedMethod</code> API which simplifies handling future/reactive/synchronous cases. See <a href=\"https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/runtime/src/main/java/io/micronaut/retry/intercept/RecoveryInterceptor.java#L79\">https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/runtime/src/main/java/io/micronaut/retry/intercept/RecoveryInterceptor.java#L79</a></p>", "author": "graemerocher", "createdAt": "2020-10-08T06:13:20Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.bulkhead.operator.BulkheadOperator;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.discovery.exceptions.NoAvailableServiceException;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+import io.reactivex.FlowableTransformer;\n+import org.reactivestreams.Publisher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+public abstract class BaseInterceptor {", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18f44fd27466086da055aa6b931fece30838b614", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/BaseInterceptor.java\nsimilarity index 96%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/BaseInterceptor.java\nindex 98f0d610..33189a6b 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/BaseInterceptor.java\n", "chunk": "@@ -31,7 +29,6 @@ import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CompletionException;\n import java.util.concurrent.CompletionStage;\n-import java.util.function.Supplier;\n \n public abstract class BaseInterceptor {\n     private static final Logger logger = LoggerFactory.getLogger(BaseInterceptor.class);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/BaseInterceptor.java\nsimilarity index 71%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/BaseInterceptor.java\nindex 98f0d610..978b68c8 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/BaseInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/BaseInterceptor.java\n", "chunk": "@@ -31,27 +29,12 @@ import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CompletionException;\n import java.util.concurrent.CompletionStage;\n-import java.util.function.Supplier;\n \n public abstract class BaseInterceptor {\n     private static final Logger logger = LoggerFactory.getLogger(BaseInterceptor.class);\n \n     public abstract Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context);\n \n-    /**\n-     * convert context to a {@link CompletableFuture}\n-     * @param context invocation context\n-     * @return the future stage from the context\n-     */\n-    public CompletableFuture<?> toCompletionStage(MethodInvocationContext<Object, Object> context) {\n-        try {\n-            return ((CompletableFuture<?>) context.proceed());\n-        } catch (Throwable e) {\n-            throw new CompletionException(e);\n-        }\n-    }\n-\n-\n     /**\n      * Resolves a fallback for the given execution context and exception.\n      *\n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTIxMQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471211", "body": "You may want to make these values relative to the built in values in Micronaut https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/aop/src/main/java/io/micronaut/aop/InterceptPhase.java#L43", "bodyText": "You may want to make these values relative to the built in values in Micronaut https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/aop/src/main/java/io/micronaut/aop/InterceptPhase.java#L43", "bodyHTML": "<p dir=\"auto\">You may want to make these values relative to the built in values in Micronaut <a href=\"https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/aop/src/main/java/io/micronaut/aop/InterceptPhase.java#L43\">https://github.com/micronaut-projects/micronaut-core/blob/2.1.x/aop/src/main/java/io/micronaut/aop/InterceptPhase.java#L43</a></p>", "author": "graemerocher", "createdAt": "2020-10-08T06:14:53Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut;\n+\n+import io.github.resilience4j.mirconaut.retry.RetryInterceptor;\n+import io.micronaut.aop.Interceptor;\n+\n+/**\n+ * <p>{@link Interceptor} classes implement the {@link io.micronaut.core.order.Ordered} interface\n+ * in order to control the order of execution when multiple interceptors are present.</p>\n+ *\n+ * <p> This class provides a set of phases used for resilience4j</p>\n+ * <p>\n+ * The default order of phases are: <code>Retry ( CircuitBreaker ( RateLimiter ( TimeLimiter ( Bulkhead ( Function ) ) ) ) )</code>\n+ * The order places this at {@link RetryInterceptor} and before {@link io.micronaut.retry.intercept.RecoveryInterceptor}\n+ */\n+public enum ResilienceInterceptPhase {\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RETRY(-60),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    CIRCUIT_BREAKER(-55),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    RATE_LIMITER(-50),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    TIME_LIMITER(-45),\n+\n+    /**\n+     * Retry phase of execution.\n+     */\n+    BULKHEAD(-40);", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "73bb54660f3dde616d46a62904897316316b773a", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/ResilienceInterceptPhase.java\nsimilarity index 93%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/ResilienceInterceptPhase.java\nindex dee534da..865c1d46 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/ResilienceInterceptPhase.java\n", "chunk": "@@ -52,7 +52,7 @@ public enum ResilienceInterceptPhase {\n     /**\n      * Retry phase of execution.\n      */\n-    BULKHEAD(-40);\n+    BULKHEAD(-42);\n \n     private final int position;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/ResilienceInterceptPhase.java\nsimilarity index 93%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/ResilienceInterceptPhase.java\nindex dee534da..865c1d46 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/ResilienceInterceptPhase.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/ResilienceInterceptPhase.java\n", "chunk": "@@ -52,7 +52,7 @@ public enum ResilienceInterceptPhase {\n     /**\n      * Retry phase of execution.\n      */\n-    BULKHEAD(-40);\n+    BULKHEAD(-42);\n \n     private final int position;\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MTU5MQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501471591", "body": "For Micronaut 2.0 and above you will need to add `@Executable` meta annotation to these annotations", "bodyText": "For Micronaut 2.0 and above you will need to add @Executable meta annotation to these annotations", "bodyHTML": "<p dir=\"auto\">For Micronaut 2.0 and above you will need to add <code>@Executable</code> meta annotation to these annotations</p>", "author": "graemerocher", "createdAt": "2020-10-08T06:15:59Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package io.github.resilience4j.mirconaut.annotation;\n+\n+import io.github.resilience4j.mirconaut.bulkhead.BulkheadInterceptor;\n+import io.github.resilience4j.mirconaut.bulkhead.ThreadPoolBulkheadInterceptor;\n+import io.micronaut.aop.Around;\n+import io.micronaut.context.annotation.Type;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * This annotation can be applied to a class or a specific method. Applying it on a class is\n+ * equivalent to applying it on all its public methods.\n+ */\n+@Retention(value = RetentionPolicy.RUNTIME)\n+@Target(value = {ElementType.METHOD, ElementType.TYPE})\n+@Around\n+@Type({BulkheadInterceptor.class, ThreadPoolBulkheadInterceptor.class})\n+@Documented\n+public @interface Bulkhead {", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bad74de92dc11dfa15e502ece51804928844371b", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/annotation/Bulkhead.java\nsimilarity index 82%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/annotation/Bulkhead.java\nindex bb37815e..18cb0fec 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/annotation/Bulkhead.java\n", "chunk": "@@ -16,6 +17,7 @@ import java.lang.annotation.*;\n @Around\n @Type({BulkheadInterceptor.class, ThreadPoolBulkheadInterceptor.class})\n @Documented\n+@Executable\n public @interface Bulkhead {\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/annotation/Bulkhead.java\nsimilarity index 79%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/annotation/Bulkhead.java\nindex bb37815e..a7f535aa 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/annotation/Bulkhead.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/annotation/Bulkhead.java\n", "chunk": "@@ -14,8 +14,9 @@ import java.lang.annotation.*;\n @Retention(value = RetentionPolicy.RUNTIME)\n @Target(value = {ElementType.METHOD, ElementType.TYPE})\n @Around\n-@Type({BulkheadInterceptor.class, ThreadPoolBulkheadInterceptor.class})\n+@Type({BulkheadInterceptor.class})\n @Documented\n+@Executable\n public @interface Bulkhead {\n \n     /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MjM3NQ==", "url": "https://github.com/resilience4j/resilience4j/pull/1179#discussion_r501472375", "body": "This thread pool should be shutdown in a `@PreDestroy` method. Alternatively if you can use one of Micronaut's built in thread pools by injecting for example `@Named(TasksExecutors.IO) ScheduledExecutorService executorService`", "bodyText": "This thread pool should be shutdown in a @PreDestroy method. Alternatively if you can use one of Micronaut's built in thread pools by injecting for example @Named(TasksExecutors.IO) ScheduledExecutorService executorService", "bodyHTML": "<p dir=\"auto\">This thread pool should be shutdown in a <code>@PreDestroy</code> method. Alternatively if you can use one of Micronaut's built in thread pools by injecting for example <code>@Named(TasksExecutors.IO) ScheduledExecutorService executorService</code></p>", "author": "graemerocher", "createdAt": "2020-10-08T06:18:12Z", "path": "resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019 Michael Pollind\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.github.resilience4j.mirconaut.retry;\n+\n+import io.github.resilience4j.mirconaut.BaseInterceptor;\n+import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n+import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n+import io.github.resilience4j.retry.Retry;\n+import io.github.resilience4j.retry.RetryRegistry;\n+import io.github.resilience4j.retry.transformer.RetryTransformer;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.context.BeanContext;\n+import io.micronaut.context.annotation.Requires;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.async.publisher.Publishers;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.MethodExecutionHandle;\n+import io.reactivex.Flowable;\n+\n+import javax.inject.Singleton;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+@Singleton\n+@Requires(beans = RetryRegistry.class)\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+    private final RetryRegistry retryRegistry;\n+    private final BeanContext beanContext;\n+    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());", "originalCommit": "be03fecd0850883f170896b9a0315e84fc308141", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bad74de92dc11dfa15e502ece51804928844371b", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/retry/RetryInterceptor.java\nsimilarity index 79%\nrename from resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java\nrename to resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/retry/RetryInterceptor.java\nindex 6dec8424..8ee1281a 100644\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java\n+++ b/resilience4j-micronaut/src/main/java/io/github/resilience4j/micronaut/retry/RetryInterceptor.java\n", "chunk": "@@ -33,15 +33,17 @@ import io.micronaut.inject.ExecutableMethod;\n import io.micronaut.inject.MethodExecutionHandle;\n import io.reactivex.Flowable;\n \n+import javax.annotation.PreDestroy;\n import javax.inject.Singleton;\n import java.util.Optional;\n import java.util.concurrent.CompletionStage;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n @Singleton\n @Requires(beans = RetryRegistry.class)\n-public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n+public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object, Object> {\n     private final RetryRegistry retryRegistry;\n     private final BeanContext beanContext;\n     private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n", "next_change": null}]}, "revised_code_in_main": {"commit": "86f7868c0f523e7764ed121976d24483c19934a1", "changed_code": [{"header": "diff --git a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java b/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java\ndeleted file mode 100644\nindex 6dec8424..00000000\n--- a/resilience4j-micronaut/src/main/java/io/github/resilience4j/mirconaut/retry/RetryInterceptor.java\n+++ /dev/null\n", "chunk": "@@ -1,109 +0,0 @@\n-/*\n- * Copyright 2019 Michael Pollind\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *        http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.github.resilience4j.mirconaut.retry;\n-\n-import io.github.resilience4j.mirconaut.BaseInterceptor;\n-import io.github.resilience4j.mirconaut.ResilienceInterceptPhase;\n-import io.github.resilience4j.mirconaut.fallback.UnhandledFallbackException;\n-import io.github.resilience4j.retry.Retry;\n-import io.github.resilience4j.retry.RetryRegistry;\n-import io.github.resilience4j.retry.transformer.RetryTransformer;\n-import io.micronaut.aop.MethodInterceptor;\n-import io.micronaut.aop.MethodInvocationContext;\n-import io.micronaut.context.BeanContext;\n-import io.micronaut.context.annotation.Requires;\n-import io.micronaut.core.annotation.AnnotationValue;\n-import io.micronaut.core.async.publisher.Publishers;\n-import io.micronaut.core.convert.ConversionService;\n-import io.micronaut.core.type.ReturnType;\n-import io.micronaut.inject.ExecutableMethod;\n-import io.micronaut.inject.MethodExecutionHandle;\n-import io.reactivex.Flowable;\n-\n-import javax.inject.Singleton;\n-import java.util.Optional;\n-import java.util.concurrent.CompletionStage;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-\n-@Singleton\n-@Requires(beans = RetryRegistry.class)\n-public class RetryInterceptor extends BaseInterceptor implements MethodInterceptor<Object,Object> {\n-    private final RetryRegistry retryRegistry;\n-    private final BeanContext beanContext;\n-    private static final ScheduledExecutorService retryExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());\n-\n-\n-    public RetryInterceptor(BeanContext beanContext, RetryRegistry retryRegistry) {\n-        this.retryRegistry = retryRegistry;\n-        this.beanContext = beanContext;\n-    }\n-\n-\n-    @Override\n-    public int getOrder() {\n-        return ResilienceInterceptPhase.RETRY.getPosition();\n-    }\n-\n-    /**\n-     * Finds a fallback method for the given context.\n-     *\n-     * @param context The context\n-     * @return The fallback method if it is present\n-     */\n-    @Override\n-    public Optional<? extends MethodExecutionHandle<?, Object>> findFallbackMethod(MethodInvocationContext<Object, Object> context) {\n-        ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String fallbackMethod = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"fallbackMethod\").orElse(\"\");\n-        Class<?> declaringType = context.getDeclaringType();\n-        return beanContext.findExecutionHandle(declaringType, fallbackMethod, context.getArgumentTypes());\n-    }\n-\n-    @Override\n-    public Object intercept(MethodInvocationContext<Object, Object> context) {\n-        Optional<AnnotationValue<io.github.resilience4j.mirconaut.annotation.Retry>> opt = context.findAnnotation(io.github.resilience4j.mirconaut.annotation.Retry.class);\n-        if (!opt.isPresent()) {\n-            return context.proceed();\n-        }\n-\n-        ExecutableMethod executableMethod = context.getExecutableMethod();\n-        final String name = executableMethod.stringValue(io.github.resilience4j.mirconaut.annotation.Retry.class, \"name\").orElse(\"default\");\n-        Retry retry = retryRegistry.retry(name);\n-\n-        ReturnType<Object> rt = context.getReturnType();\n-        Class<Object> returnType = rt.getType();\n-        if (CompletionStage.class.isAssignableFrom(returnType)) {\n-            return this.fallbackCompletable(retry.executeCompletionStage(retryExecutorService, () -> toCompletionStage(context)), context);\n-        } else if (Publishers.isConvertibleToPublisher(returnType)) {\n-            Object result = context.proceed();\n-            if (result == null) {\n-                return result;\n-            }\n-            Flowable<?> flowable = ConversionService.SHARED\n-                .convert(result, Flowable.class)\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-            flowable = this.fallbackFlowable(flowable.compose(RetryTransformer.of(retry)), context);\n-            return ConversionService.SHARED\n-                .convert(flowable, rt.asArgument())\n-                .orElseThrow(() -> new UnhandledFallbackException(\"Unsupported Reactive type: \" + result));\n-        }\n-        try {\n-            return retry.executeCheckedSupplier(context::proceed);\n-        } catch (Throwable exception) {\n-            return fallback(context, exception);\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "86f7868c0f523e7764ed121976d24483c19934a1", "message": "Merge commit", "committedDate": null}]}, {"oid": "18f44fd27466086da055aa6b931fece30838b614", "url": "https://github.com/resilience4j/resilience4j/commit/18f44fd27466086da055aa6b931fece30838b614", "message": "Correct resilience4j-micronaut package name (#1195)", "committedDate": "2020-10-08T06:22:52Z", "type": "commit"}, {"oid": "bad74de92dc11dfa15e502ece51804928844371b", "url": "https://github.com/resilience4j/resilience4j/commit/bad74de92dc11dfa15e502ece51804928844371b", "message": "review comments for micronaut integration", "committedDate": "2020-10-08T13:24:02Z", "type": "commit"}, {"oid": "73bb54660f3dde616d46a62904897316316b773a", "url": "https://github.com/resilience4j/resilience4j/commit/73bb54660f3dde616d46a62904897316316b773a", "message": "review comments for micronaut integration", "committedDate": "2020-10-08T13:33:26Z", "type": "commit"}, {"oid": "2312e448c39790e37bc9c7493a4fde3ee68cc537", "url": "https://github.com/resilience4j/resilience4j/commit/2312e448c39790e37bc9c7493a4fde3ee68cc537", "message": "update intercept", "committedDate": "2020-10-08T17:28:57Z", "type": "commit"}, {"oid": "8df034e63c1060c89b38076d496b3605fd134f5f", "url": "https://github.com/resilience4j/resilience4j/commit/8df034e63c1060c89b38076d496b3605fd134f5f", "message": "tweak to assignment", "committedDate": "2020-10-08T17:45:27Z", "type": "commit"}, {"oid": "8670290e4bb5c3c8981b200adad0462b540a7481", "url": "https://github.com/resilience4j/resilience4j/commit/8670290e4bb5c3c8981b200adad0462b540a7481", "message": "fix problem with test not running", "committedDate": "2020-10-08T18:44:47Z", "type": "commit"}, {"oid": "7943edc8eefdce244c09cc44a09ccb92111e65b8", "url": "https://github.com/resilience4j/resilience4j/commit/7943edc8eefdce244c09cc44a09ccb92111e65b8", "message": "Merge pull request #1197 from pollend/feature/rework-intercept\n\nUpdate Micronaut intercept", "committedDate": "2020-10-08T18:55:17Z", "type": "commit"}, {"oid": "d87effab2edfdb3562814b63ee3cd373818ce879", "url": "https://github.com/resilience4j/resilience4j/commit/d87effab2edfdb3562814b63ee3cd373818ce879", "message": "pump the versions", "committedDate": "2020-10-08T18:57:24Z", "type": "commit"}, {"oid": "1f643d71fe6eb6f51065303184e3e7f648be6129", "url": "https://github.com/resilience4j/resilience4j/commit/1f643d71fe6eb6f51065303184e3e7f648be6129", "message": "Adding more test and reverting groovy version plus code imports optimziation", "committedDate": "2020-10-08T19:21:36Z", "type": "commit"}, {"oid": "02b44886ca7309327d17ac828d135bdc8df911c7", "url": "https://github.com/resilience4j/resilience4j/commit/02b44886ca7309327d17ac828d135bdc8df911c7", "message": "Adding more test and reverting groovy version plus code imports optimziation", "committedDate": "2020-10-08T19:30:19Z", "type": "commit"}, {"oid": "acf680cfb9afa7dbb309caaabb577a872d30bcf5", "url": "https://github.com/resilience4j/resilience4j/commit/acf680cfb9afa7dbb309caaabb577a872d30bcf5", "message": "Adding NULL test case for one of reactive types", "committedDate": "2020-10-08T19:37:25Z", "type": "commit"}, {"oid": "51498b4046b0eab4d2a0f251463ccfa272adc939", "url": "https://github.com/resilience4j/resilience4j/commit/51498b4046b0eab4d2a0f251463ccfa272adc939", "message": "rolling back wrong commit", "committedDate": "2020-10-08T19:40:00Z", "type": "commit"}, {"oid": "9544bd2a33074aa039d01e4ddfccc804a5bba578", "url": "https://github.com/resilience4j/resilience4j/commit/9544bd2a33074aa039d01e4ddfccc804a5bba578", "message": "Logging formatting", "committedDate": "2020-10-08T19:51:37Z", "type": "commit"}, {"oid": "1399292fc70afe0555a4ac46dd8e3e2c33e3072e", "url": "https://github.com/resilience4j/resilience4j/commit/1399292fc70afe0555a4ac46dd8e3e2c33e3072e", "message": "feat(micronaut): add non recoverable test cases and replaced UnhandledFallbackException with micronaut Fallback Exception", "committedDate": "2020-10-08T23:17:27Z", "type": "commit"}, {"oid": "b2ede431833cc8398edab494b9abb2cd4df51e1c", "url": "https://github.com/resilience4j/resilience4j/commit/b2ede431833cc8398edab494b9abb2cd4df51e1c", "message": "add fallback spec", "committedDate": "2020-10-08T23:57:11Z", "type": "commit"}, {"oid": "2144e19cc341ba318423f01c7cdcad5f69765797", "url": "https://github.com/resilience4j/resilience4j/commit/2144e19cc341ba318423f01c7cdcad5f69765797", "message": "correct stuck executor service", "committedDate": "2020-10-09T00:37:20Z", "type": "commit"}, {"oid": "544e72cebbf794061e684f45c062dce0c5a0a6bb", "url": "https://github.com/resilience4j/resilience4j/commit/544e72cebbf794061e684f45c062dce0c5a0a6bb", "message": "update executor service", "committedDate": "2020-10-09T00:46:24Z", "type": "commit"}, {"oid": "3b4d95fc0c6676e897c6d6c8c0c6b6bc2e1263e0", "url": "https://github.com/resilience4j/resilience4j/commit/3b4d95fc0c6676e897c6d6c8c0c6b6bc2e1263e0", "message": "Merge pull request #1198 from pollend/fix/add-more-test-cases\n\nfeat(micronaut): add non recoverable test cases and replaced UnhandledFallbackException with micronaut Fallback Exception", "committedDate": "2020-10-09T08:35:36Z", "type": "commit"}, {"oid": "36a8ef1d942206b472ef4e7fbbdff8d7f557a1c2", "url": "https://github.com/resilience4j/resilience4j/commit/36a8ef1d942206b472ef4e7fbbdff8d7f557a1c2", "message": "merging thread pool and Bulkhead interceptors plus more exception handling.", "committedDate": "2020-10-09T09:04:31Z", "type": "commit"}, {"oid": "14b6256c55329001f02868f570f22c8b4d5a3397", "url": "https://github.com/resilience4j/resilience4j/commit/14b6256c55329001f02868f570f22c8b4d5a3397", "message": "Use more idiomatic configuration / cleanup", "committedDate": "2020-10-15T10:14:33Z", "type": "commit"}, {"oid": "027e5370df7ddc540a4eb5face9889c9db408352", "url": "https://github.com/resilience4j/resilience4j/commit/027e5370df7ddc540a4eb5face9889c9db408352", "message": "Merge pull request #1207 from graemerocher/micronaut_final\n\nMicronaut: Use more idiomatic configuration / cleanup", "committedDate": "2020-10-15T11:09:43Z", "type": "commit"}]}