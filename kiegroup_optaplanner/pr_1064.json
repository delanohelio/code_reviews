{"pr_number": 1064, "pr_title": "PLANNER-2269: Proper CS-B node indexing", "pr_author": "triceo", "pr_createdAt": "2020-12-03T15:53:40Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/1064", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTI4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535359281", "body": "Don't like it, but I needed this for the test.\r\nThis is not public API, so we should be good.", "bodyText": "Don't like it, but I needed this for the test.\nThis is not public API, so we should be good.", "bodyHTML": "<p dir=\"auto\">Don't like it, but I needed this for the test.<br>\nThis is not public API, so we should be good.</p>", "author": "triceo", "createdAt": "2020-12-03T15:55:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java", "diffHunk": "@@ -172,4 +172,11 @@ public void afterProblemFactRemoved(Object problemFact) {\n         super.afterProblemFactRemoved(problemFact);\n     }\n \n+    // ************************************************************************\n+    // Getters/setters\n+    // ************************************************************************\n+\n+    public ConstraintSession<Solution_, Score_> getSession() {\n+        return session;\n+    }", "originalCommit": "1abadeb996e5d33f537da94ce7ec6014adff6489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NzMzNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536197335", "bodyText": "Ok. Someday we need to talk about merging ConstraintStreamSession and ConstraintStreamScoreDirector to avoid unneeded indirection :)", "author": "ge0ffrey", "createdAt": "2020-12-04T15:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTI4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\nindex 0d1d658177..cc2a13dba6 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\n", "chunk": "@@ -172,11 +172,4 @@ public class ConstraintStreamScoreDirector<Solution_, Score_ extends Score<Score\n         super.afterProblemFactRemoved(problemFact);\n     }\n \n-    // ************************************************************************\n-    // Getters/setters\n-    // ************************************************************************\n-\n-    public ConstraintSession<Solution_, Score_> getSession() {\n-        return session;\n-    }\n }\n", "next_change": {"commit": "fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\nindex cc2a13dba6..0d1d658177 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\n", "chunk": "@@ -172,4 +172,11 @@ public class ConstraintStreamScoreDirector<Solution_, Score_ extends Score<Score\n         super.afterProblemFactRemoved(problemFact);\n     }\n \n+    // ************************************************************************\n+    // Getters/setters\n+    // ************************************************************************\n+\n+    public ConstraintSession<Solution_, Score_> getSession() {\n+        return session;\n+    }\n }\n", "next_change": null}]}}]}}, {"oid": "5edeb52291e18cf365daf34b7ad2a42958e47364", "url": "https://github.com/kiegroup/optaplanner/commit/5edeb52291e18cf365daf34b7ad2a42958e47364", "message": "Finishing touches", "committedDate": "2020-12-03T16:01:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2NjA5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535366090", "body": "This is the test that checks, for a sufficiently complex stream, that the ordering is correct.", "bodyText": "This is the test that checks, for a sufficiently complex stream, that the ordering is correct.", "bodyHTML": "<p dir=\"auto\">This is the test that checks, for a sufficiently complex stream, that the ordering is correct.</p>", "author": "triceo", "createdAt": "2020-12-03T16:03:53Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bavet;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintStreamImplType;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirector;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.stream.bavet.common.BavetScoringNode;\n+import org.optaplanner.core.impl.score.stream.bavet.tri.BavetScoringTriNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetAbstractUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFilterUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetJoinBridgeUniNode;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishEntity;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishSolution;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValue;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValueGroup;\n+\n+public class BavetConstraintStreamNodeOrderingTest {", "originalCommit": "5edeb52291e18cf365daf34b7ad2a42958e47364", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java\ndeleted file mode 100644\nindex 7073d115ad..0000000000\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java\n+++ /dev/null\n", "chunk": "@@ -1,155 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.optaplanner.core.impl.score.stream.bavet;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.optaplanner.core.api.score.stream.Joiners.equal;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Function;\n-\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n-import org.optaplanner.core.api.score.stream.Constraint;\n-import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n-import org.optaplanner.core.api.score.stream.ConstraintFactory;\n-import org.optaplanner.core.api.score.stream.ConstraintStreamImplType;\n-import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirector;\n-import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirectorFactory;\n-import org.optaplanner.core.impl.score.stream.bavet.common.BavetScoringNode;\n-import org.optaplanner.core.impl.score.stream.bavet.tri.BavetScoringTriNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetAbstractUniNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFilterUniNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetJoinBridgeUniNode;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishEntity;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishSolution;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValue;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValueGroup;\n-\n-public class BavetConstraintStreamNodeOrderingTest {\n-\n-    private final Function<ConstraintFactory, Constraint> constraintProvider =\n-            factory -> factory.fromUniquePair(TestdataLavishEntity.class,\n-                    equal(TestdataLavishEntity::getEntityGroup))\n-                    .groupBy((a, b) -> a, ConstraintCollectors.countBi())\n-                    .filter((a, count) -> count > 0)\n-                    .join(TestdataLavishValueGroup.class)\n-                    .filter((a, b, valueGroup) -> false)\n-                    .penalize(\"Some constraint\", SimpleScore.ONE);\n-    private BavetConstraintSession<TestdataLavishSolution, SimpleScore> session;\n-\n-    @BeforeEach\n-    void initializeSession() {\n-        ConstraintStreamScoreDirector<TestdataLavishSolution, SimpleScore> scoreDirector =\n-                buildScoreDirector(constraintProvider);\n-        scoreDirector.setWorkingSolution(TestdataLavishSolution.generateSolution());\n-        session = (BavetConstraintSession<TestdataLavishSolution, SimpleScore>) scoreDirector.getSession();\n-    }\n-\n-    @Test\n-    void correctNumberOfFromNodes() {\n-        List<BavetFromUniNode<Object>> lavishEntityFromNodeList = session.findFromNodeList(TestdataLavishEntity.class);\n-        assertThat(lavishEntityFromNodeList).hasSize(1); // fromUniquePair() uses just one fromNode.\n-        List<BavetFromUniNode<Object>> lavishValueGroupFromNodeList =\n-                session.findFromNodeList(TestdataLavishValueGroup.class);\n-        assertThat(lavishValueGroupFromNodeList).hasSize(1); // join uses just one fromNode.\n-        List<BavetFromUniNode<Object>> lavishValueFromNodeList = session.findFromNodeList(TestdataLavishValue.class);\n-        assertThat(lavishValueFromNodeList).isEmpty(); // Not used in the constraint.\n-    }\n-\n-    @Test\n-    void fromUniquePair() {\n-        List<BavetFromUniNode<Object>> lavishEntityFromNodeList = session.findFromNodeList(TestdataLavishEntity.class);\n-\n-        BavetFromUniNode<Object> fromNode = lavishEntityFromNodeList.get(0);\n-        assertThat(fromNode.getNodeIndex())\n-                .as(\"fromNode is the first node of the constraint stream.\")\n-                .isEqualTo(0);\n-\n-        List<BavetAbstractUniNode<Object>> fromNodeChildNodes = fromNode.getChildNodes();\n-        assertThat(fromNodeChildNodes)\n-                .as(\"fromNode has a single child, a filterNode.\")\n-                .hasSize(1);\n-\n-        BavetFilterUniNode<Object> filterNode = (BavetFilterUniNode<Object>) fromNodeChildNodes.get(0);\n-        assertThat(filterNode.getNodeIndex())\n-                .as(\"filterNode is the second node of the constraint stream.\")\n-                .isEqualTo(1);\n-\n-        List<BavetAbstractUniNode<Object>> filterChildNodes = filterNode.getChildNodes();\n-        assertThat(filterChildNodes)\n-                .as(\"filterNode has two children, left and right join bridge for the unique pair.\")\n-                .hasSize(2);\n-\n-        BavetJoinBridgeUniNode<Object> leftJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) filterChildNodes.get(0);\n-        assertThat(leftJoinBridgeNode.getNodeIndex())\n-                .as(\"Left JoinBridge is the third node of the constraint stream.\")\n-                .isEqualTo(2);\n-\n-        BavetJoinBridgeUniNode<Object> rightJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) filterChildNodes.get(1);\n-        assertThat(rightJoinBridgeNode.getNodeIndex())\n-                .as(\"Right JoinBridge is the fourth node of the constraint stream.\")\n-                .isEqualTo(3);\n-    }\n-\n-    @Test\n-    void secondJoin() {\n-        List<BavetFromUniNode<Object>> lavishValueGroupFromNodeList = session.findFromNodeList(TestdataLavishValueGroup.class);\n-\n-        BavetFromUniNode<Object> fromNode = lavishValueGroupFromNodeList.get(0);\n-        assertThat(fromNode.getNodeIndex())\n-                .as(\"Second fromNode follows the join (4), group (6), filter (7), left join bridge (8).\")\n-                .isEqualTo(9);\n-\n-        List<BavetAbstractUniNode<Object>> fromNodeChildNodes = fromNode.getChildNodes();\n-        assertThat(fromNodeChildNodes)\n-                .as(\"Second fromNode has a single child, the right JoinBridge.\")\n-                .hasSize(1);\n-\n-        BavetJoinBridgeUniNode<Object> rightJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) fromNodeChildNodes.get(0);\n-        assertThat(rightJoinBridgeNode.getNodeIndex())\n-                .as(\"Right JoinBridge is the eleventh node of the constraint stream.\")\n-                .isEqualTo(10);\n-    }\n-\n-    @Test\n-    void scoring() {\n-        List<BavetScoringNode> scoringNodeCollection = new ArrayList<>(session.getScoringNodes());\n-        assertThat(scoringNodeCollection).hasSize(1);\n-        assertThat(scoringNodeCollection)\n-                .first()\n-                .isInstanceOf(BavetScoringTriNode.class);\n-        BavetScoringTriNode<Object, Object, Object> scoringNode =\n-                (BavetScoringTriNode<Object, Object, Object>) scoringNodeCollection.get(0);\n-        assertThat(scoringNode.getNodeIndex())\n-                .as(\"Single scoring node follows final join (11) and filter (12).\")\n-                .isEqualTo(13);\n-    }\n-\n-    protected ConstraintStreamScoreDirector<TestdataLavishSolution, SimpleScore> buildScoreDirector(\n-            Function<ConstraintFactory, Constraint> function) {\n-        ConstraintStreamScoreDirectorFactory<TestdataLavishSolution, SimpleScore> scoreDirectorFactory =\n-                new ConstraintStreamScoreDirectorFactory<>(TestdataLavishSolution.buildSolutionDescriptor(),\n-                        (constraintFactory) -> new Constraint[] { function.apply(constraintFactory) },\n-                        ConstraintStreamImplType.BAVET);\n-        return scoreDirectorFactory.buildScoreDirector(false, false);\n-    }\n-\n-}\n", "next_change": {"commit": "fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "changed_code": [{"header": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java\nnew file mode 100644\nindex 0000000000..11acbbc9ca\n--- /dev/null\n+++ b/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java\n", "chunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bavet;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintStreamImplType;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirector;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetAbstractUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFilterUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetJoinBridgeUniNode;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishEntity;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishSolution;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValue;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValueGroup;\n+\n+public class BavetConstraintStreamNodeOrderingTest {\n+\n+    private final Function<ConstraintFactory, Constraint> constraintProvider =\n+            factory -> factory.fromUniquePair(TestdataLavishEntity.class,\n+                    equal(TestdataLavishEntity::getEntityGroup))\n+                    .filter((a, b) -> !a.equals(b))\n+                    .join(TestdataLavishValueGroup.class)\n+                    .filter((a, b, valueGroup) -> false)\n+                    .penalize(\"Some constraint\", SimpleScore.ONE);\n+    private BavetConstraintSession<TestdataLavishSolution, SimpleScore> session;\n+\n+    @BeforeEach\n+    void initializeSession() {\n+        ConstraintStreamScoreDirector<TestdataLavishSolution, SimpleScore> scoreDirector =\n+                buildScoreDirector(constraintProvider);\n+        scoreDirector.setWorkingSolution(TestdataLavishSolution.generateSolution());\n+        session = (BavetConstraintSession<TestdataLavishSolution, SimpleScore>) scoreDirector.getSession();\n+    }\n+\n+    @Test\n+    void correctNumberOfFromNodes() {\n+        List<BavetFromUniNode<Object>> lavishEntityFromNodeList = session.findFromNodeList(TestdataLavishEntity.class);\n+        assertThat(lavishEntityFromNodeList).hasSize(1); // fromUniquePair() uses just one fromNode.\n+        List<BavetFromUniNode<Object>> lavishValueGroupFromNodeList =\n+                session.findFromNodeList(TestdataLavishValueGroup.class);\n+        assertThat(lavishValueGroupFromNodeList).hasSize(1); // join uses just one fromNode.\n+        List<BavetFromUniNode<Object>> lavishValueFromNodeList = session.findFromNodeList(TestdataLavishValue.class);\n+        assertThat(lavishValueFromNodeList).isEmpty(); // Not used in the constraint.\n+    }\n+\n+    @Test\n+    void fromUniquePair() {\n+        List<BavetFromUniNode<Object>> lavishEntityFromNodeList = session.findFromNodeList(TestdataLavishEntity.class);\n+\n+        BavetFromUniNode<Object> fromNode = lavishEntityFromNodeList.get(0);\n+        assertThat(fromNode.getNodeIndex())\n+                .as(\"fromNode is the first node of the constraint stream.\")\n+                .isEqualTo(0);\n+\n+        List<BavetAbstractUniNode<Object>> fromNodeChildNodes = fromNode.getChildNodes();\n+        assertThat(fromNodeChildNodes)\n+                .as(\"fromNode has a single child, a filterNode.\")\n+                .hasSize(1);\n+\n+        BavetFilterUniNode<Object> filterNode = (BavetFilterUniNode<Object>) fromNodeChildNodes.get(0);\n+        assertThat(filterNode.getNodeIndex())\n+                .as(\"filterNode is the second node of the constraint stream.\")\n+                .isEqualTo(1);\n+\n+        List<BavetAbstractUniNode<Object>> filterChildNodes = filterNode.getChildNodes();\n+        assertThat(filterChildNodes)\n+                .as(\"filterNode has two children, left and right join bridge for the unique pair.\")\n+                .hasSize(2);\n+\n+        BavetJoinBridgeUniNode<Object> leftJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) filterChildNodes.get(0);\n+        assertThat(leftJoinBridgeNode.getNodeIndex())\n+                .as(\"Left JoinBridge is the third node of the constraint stream.\")\n+                .isEqualTo(2);\n+\n+        BavetJoinBridgeUniNode<Object> rightJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) filterChildNodes.get(1);\n+        assertThat(rightJoinBridgeNode.getNodeIndex())\n+                .as(\"Right JoinBridge is the fourth node of the constraint stream.\")\n+                .isEqualTo(2); // TODO needs to be 3\n+    }\n+\n+    protected ConstraintStreamScoreDirector<TestdataLavishSolution, SimpleScore> buildScoreDirector(\n+            Function<ConstraintFactory, Constraint> function) {\n+        ConstraintStreamScoreDirectorFactory<TestdataLavishSolution, SimpleScore> scoreDirectorFactory =\n+                new ConstraintStreamScoreDirectorFactory<>(TestdataLavishSolution.buildSolutionDescriptor(),\n+                        (constraintFactory) -> new Constraint[] { function.apply(constraintFactory) },\n+                        ConstraintStreamImplType.BAVET);\n+        return scoreDirectorFactory.buildScoreDirector(false, false);\n+    }\n+\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMDk4NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535710984", "body": "This is not consistent with `equals()`.", "bodyText": "This is not consistent with equals().", "bodyHTML": "<p dir=\"auto\">This is not consistent with <code>equals()</code>.</p>", "author": "triceo", "createdAt": "2020-12-03T23:04:38Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java", "diffHunk": "@@ -21,20 +21,24 @@\n public class BavetAbstractNode implements BavetNode {\n \n     protected final BavetConstraintSession session;\n-    protected final int nodeOrder;\n+    protected final int nodeIndex;\n \n-    public BavetAbstractNode(BavetConstraintSession session, int nodeOrder) {\n+    public BavetAbstractNode(BavetConstraintSession session, int nodeIndex) {\n         this.session = session;\n-        this.nodeOrder = nodeOrder;\n+        this.nodeIndex = nodeIndex;\n     }\n \n     // ************************************************************************\n     // Getters/setters\n     // ************************************************************************\n \n     @Override\n-    public int getNodeOrder() {\n-        return nodeOrder;\n+    public int getNodeIndex() {\n+        return nodeIndex;\n     }\n \n+    @Override\n+    public int compareTo(BavetNode o) {\n+        return Integer.compare(this.nodeIndex, o.getNodeIndex());\n+    }", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\nindex 3673b170f5..2eb137a7ed 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n", "chunk": "@@ -37,8 +37,4 @@ public class BavetAbstractNode implements BavetNode {\n         return nodeIndex;\n     }\n \n-    @Override\n-    public int compareTo(BavetNode o) {\n-        return Integer.compare(this.nodeIndex, o.getNodeIndex());\n-    }\n }\n", "next_change": {"commit": "27fa44052c64164d4601346b7943f38c78c21e4d", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\nindex 2eb137a7ed..3673b170f5 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n", "chunk": "@@ -37,4 +37,8 @@ public class BavetAbstractNode implements BavetNode {\n         return nodeIndex;\n     }\n \n+    @Override\n+    public int compareTo(BavetNode o) {\n+        return Integer.compare(this.nodeIndex, o.getNodeIndex());\n+    }\n }\n", "next_change": {"commit": "f9a1e04141463e78f1a976ea90b6165268a2a710", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\nindex 3673b170f5..2eb137a7ed 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n", "chunk": "@@ -37,8 +37,4 @@ public class BavetAbstractNode implements BavetNode {\n         return nodeIndex;\n     }\n \n-    @Override\n-    public int compareTo(BavetNode o) {\n-        return Integer.compare(this.nodeIndex, o.getNodeIndex());\n-    }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535712258", "body": "All node indexes are unique now. Therefore this fail-fast makes no sense anymore.", "bodyText": "All node indexes are unique now. Therefore this fail-fast makes no sense anymore.", "bodyHTML": "<p dir=\"auto\">All node indexes are unique now. Therefore this fail-fast makes no sense anymore.</p>", "author": "triceo", "createdAt": "2020-12-03T23:06:22Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -37,18 +37,11 @@ public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount)\n         constraintIdToScoringNodeMap = new LinkedHashMap<>(constraintCount);\n     }\n \n-    public void updateNodeOrderMaximum(int nodeOrder) {\n-        if (nodeOrderMaximum < nodeOrder) {\n-            nodeOrderMaximum = nodeOrder;\n-        }\n-    }\n-\n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        if (node.getNodeOrder() != sharedNode.getNodeOrder()) {\n-            throw new IllegalStateException(\"Impossible state: the node (\" + node\n-                    + \")'s nodeOrder (\" + node.getNodeOrder() + \") differs from the sharedNode (\" + sharedNode\n-                    + \")'s nodeOrder (\" + sharedNode.getNodeOrder() + \").\");", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNzc4Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536217783", "bodyText": "Crap, ideally when a node is replaced by a sharedNode, it doesn't take up an extra nodeIndex.\nBecause it does, the nodeSize will be actually bigger than the number of actual nodes in place. (so it shouldn't be called nodeSize indeed and a comment should specify that strange behaviour). So the queue will have a number of empty spaces. Actually, that hurts performance...\n... so we need to recycle nodeIndexes of nodes that get shared. Maybe upon sharing, call BuildPolicy.undoNextIndex() that does nextNodeIndex--?", "author": "ge0ffrey", "createdAt": "2020-12-04T16:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2NzQzOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536267439", "bodyText": "This is not an issue. Node indexes are perfectly sequential, they are never duplicated. (The \"+1 trick\" takes care of that.)", "author": "triceo", "createdAt": "2020-12-04T17:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 68d8ed9a11..6e5241e921 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -37,12 +37,19 @@ public class BavetNodeBuildPolicy<Solution_> {\n         constraintIdToScoringNodeMap = new LinkedHashMap<>(constraintCount);\n     }\n \n-    public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n-        Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        int nodeIndex = sharedNode.getNodeIndex();\n+    public void updateNodeIndexMaximum(int nodeIndex) {\n         if (nodeIndexMaximum < nodeIndex) {\n             nodeIndexMaximum = nodeIndex;\n         }\n+    }\n+\n+    public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n+        Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n+        if (node.getNodeIndex() != sharedNode.getNodeIndex()) {\n+            throw new IllegalStateException(\"Impossible state: the node (\" + node\n+                    + \")'s nodeIndex (\" + node.getNodeIndex() + \") differs from the sharedNode (\" + sharedNode\n+                    + \")'s nodeIndex (\" + sharedNode.getNodeIndex() + \").\");\n+        }\n         return sharedNode;\n     }\n \n", "next_change": {"commit": "05cd93dfd907bb33499b74c02647722c2cfda9e3", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 6e5241e921..9f50eddfaa 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -37,18 +37,11 @@ public class BavetNodeBuildPolicy<Solution_> {\n         constraintIdToScoringNodeMap = new LinkedHashMap<>(constraintCount);\n     }\n \n-    public void updateNodeIndexMaximum(int nodeIndex) {\n-        if (nodeIndexMaximum < nodeIndex) {\n-            nodeIndexMaximum = nodeIndex;\n-        }\n-    }\n-\n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        if (node.getNodeIndex() != sharedNode.getNodeIndex()) {\n-            throw new IllegalStateException(\"Impossible state: the node (\" + node\n-                    + \")'s nodeIndex (\" + node.getNodeIndex() + \") differs from the sharedNode (\" + sharedNode\n-                    + \")'s nodeIndex (\" + sharedNode.getNodeIndex() + \").\");\n+        int nodeIndex = sharedNode.getNodeIndex();\n+        if (nodeIndexMaximum < nodeIndex) {\n+            nodeIndexMaximum = nodeIndex;\n         }\n         return sharedNode;\n     }\n", "next_change": {"commit": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 9f50eddfaa..27a0657f8f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -40,6 +42,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n         int nodeIndex = sharedNode.getNodeIndex();\n+        System.out.println(nodeIndex + \": \" + node);\n         if (nodeIndexMaximum < nodeIndex) {\n             nodeIndexMaximum = nodeIndex;\n         }\n", "next_change": {"commit": "9eee086026884c89f406ef9ee9f3f5c06079d728", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 27a0657f8f..68d8ed9a11 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -42,7 +40,6 @@ public class BavetNodeBuildPolicy<Solution_> {\n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n         int nodeIndex = sharedNode.getNodeIndex();\n-        System.out.println(nodeIndex + \": \" + node);\n         if (nodeIndexMaximum < nodeIndex) {\n             nodeIndexMaximum = nodeIndex;\n         }\n", "next_change": {"commit": "fc41f88d9974326125ccaf02637d6d574378a1ac", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 68d8ed9a11..fe736c2185 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -39,6 +39,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n+        System.out.println(sharedNode.getNodeIndex() + \" \" + sharedNode);\n         int nodeIndex = sharedNode.getNodeIndex();\n         if (nodeIndexMaximum < nodeIndex) {\n             nodeIndexMaximum = nodeIndex;\n", "next_change": {"commit": "6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex fe736c2185..2dad1baae6 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -39,10 +39,8 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        System.out.println(sharedNode.getNodeIndex() + \" \" + sharedNode);\n-        int nodeIndex = sharedNode.getNodeIndex();\n-        if (nodeIndexMaximum < nodeIndex) {\n-            nodeIndexMaximum = nodeIndex;\n+        if (sharedNode != node) { // We are throwing away the new instance; throw away the new index, too.\n+            nextNodeIndex--;\n         }\n         return sharedNode;\n     }\n", "next_change": {"commit": "e5154a1a05c9a512d6a903ea5a685467b20af7cc", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 2dad1baae6..c91f14ccce 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -41,6 +45,14 @@ public class BavetNodeBuildPolicy<Solution_> {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n         if (sharedNode != node) { // We are throwing away the new instance; throw away the new index, too.\n             nextNodeIndex--;\n+        } else { // Node indexes must be an uninterrupted sequence, starting at zero.\n+            int newNodeIndex = node.getNodeIndex();\n+            int expectedNodeIndex = createdNodes.size();\n+            if (newNodeIndex != expectedNodeIndex) {\n+                throw new IllegalStateException(\"Impossible state: node index (\" + newNodeIndex + \") of node (\" + node +\n+                        \") is out of sync with expected node index (\" + expectedNodeIndex + \").\");\n+            }\n+            createdNodes.add(node.getNodeIndex(), node);\n         }\n         return sharedNode;\n     }\n", "next_change": {"commit": "fa8e08e69551986e0522a604deb3956a63936d09", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex c91f14ccce..ac68549ed3 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -45,14 +49,6 @@ public class BavetNodeBuildPolicy<Solution_> {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n         if (sharedNode != node) { // We are throwing away the new instance; throw away the new index, too.\n             nextNodeIndex--;\n-        } else { // Node indexes must be an uninterrupted sequence, starting at zero.\n-            int newNodeIndex = node.getNodeIndex();\n-            int expectedNodeIndex = createdNodes.size();\n-            if (newNodeIndex != expectedNodeIndex) {\n-                throw new IllegalStateException(\"Impossible state: node index (\" + newNodeIndex + \") of node (\" + node +\n-                        \") is out of sync with expected node index (\" + expectedNodeIndex + \").\");\n-            }\n-            createdNodes.add(node.getNodeIndex(), node);\n         }\n         return sharedNode;\n     }\n", "next_change": {"commit": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..9cbe22dcf0 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -47,8 +46,9 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        if (sharedNode != node) { // We are throwing away the new instance; throw away the new index, too.\n-            nextNodeIndex--;\n+        if (sharedNode != node) {\n+            // We are throwing away the new instance; throw away the new index, too.\n+            nextNodeIndex = node.getNodeIndex();\n         }\n         return sharedNode;\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NzY4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536197680", "body": "Actually, this is now just nodeSize (the number of nodes), I'd argue. Wdyt?", "bodyText": "Actually, this is now just nodeSize (the number of nodes), I'd argue. Wdyt?", "bodyHTML": "<p dir=\"auto\">Actually, this is now just nodeSize (the number of nodes), I'd argue. Wdyt?</p>", "author": "ge0ffrey", "createdAt": "2020-12-04T15:52:46Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java", "diffHunk": "@@ -48,12 +49,12 @@\n     private final ScoreInliner<Score_> scoreInliner;\n \n     private final Map<Class<?>, BavetFromUniNode<Object>> declaredClassToNodeMap;\n-    private final int nodeOrderSize;\n+    private final int nodeIndexSize;", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb1fec593b0245fd99cd51eff63dacae9e947d32", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java\nindex d3741a47b8..9e31c6f010 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java\n", "chunk": "@@ -49,7 +50,8 @@ public final class BavetConstraintSession<Solution_, Score_ extends Score<Score_\n     private final ScoreInliner<Score_> scoreInliner;\n \n     private final Map<Class<?>, BavetFromUniNode<Object>> declaredClassToNodeMap;\n-    private final int nodeIndexSize;\n+    private final List<BavetNode> nodeIndexedNodeMap;\n+    private final int nodeCount;\n     private final Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n \n     private final Map<Class<?>, List<BavetFromUniNode<Object>>> effectiveClassToNodeListMap;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMTkxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536211919", "body": "I wouldn't write this as an `else if` because the 2 conditions are unrelated and it creates the confusion that they are.\r\n\r\nSuggestion: replace the else with a line break. - because the sharedNode check is a quick return (special condition for which the main content of this method doesn't apply).", "bodyText": "I wouldn't write this as an else if because the 2 conditions are unrelated and it creates the confusion that they are.\nSuggestion: replace the else with a line break. - because the sharedNode check is a quick return (special condition for which the main content of this method doesn't apply).", "bodyHTML": "<p dir=\"auto\">I wouldn't write this as an <code>else if</code> because the 2 conditions are unrelated and it creates the confusion that they are.</p>\n<p dir=\"auto\">Suggestion: replace the else with a line break. - because the sharedNode check is a quick return (special condition for which the main content of this method doesn't apply).</p>", "author": "ge0ffrey", "createdAt": "2020-12-04T16:13:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java", "diffHunk": "@@ -277,39 +277,35 @@ public final Constraint impactScoreConfigurableBigDecimal(String constraintPacka\n     // ************************************************************************\n \n     public BavetAbstractBiNode<A, B> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, nodeOrder, parentNode);\n-        node = processNode(buildPolicy, nodeOrder, parentNode, node);\n-        createChildNodeChains(buildPolicy, constraintWeight, nodeOrder, node);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, parentNode);\n+        node = processNode(buildPolicy, parentNode, node);\n+        createChildNodeChains(buildPolicy, constraintWeight, node);\n         return node;\n     }\n \n-    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy, int nodeOrder,\n+    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n             BavetAbstractBiNode<A, B> parentNode, BavetAbstractBiNode<A, B> node) {\n-        buildPolicy.updateNodeOrderMaximum(nodeOrder);\n         BavetAbstractBiNode<A, B> sharedNode = buildPolicy.retrieveSharedNode(node);\n-        if (sharedNode != node) {\n-            // Share node\n-            node = sharedNode;\n-        } else {\n-            if (parentNode != null) { // TODO remove null check and don't go through this code like this for from and joins\n-                parentNode.addChildNode(node);\n-            }\n+        if (sharedNode != node) { // Share node\n+            return sharedNode;\n+        } else if (parentNode != null) { // TODO remove null check and don't go through this for from and joins", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\nindex 83f280b82f..4fb9d5bd95 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n", "chunk": "@@ -277,35 +277,39 @@ public abstract class BavetAbstractBiConstraintStream<Solution_, A, B> extends B\n     // ************************************************************************\n \n     public BavetAbstractBiNode<A, B> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, parentNode);\n-        node = processNode(buildPolicy, parentNode, node);\n-        createChildNodeChains(buildPolicy, constraintWeight, node);\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode) {\n+        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, nodeIndex, parentNode);\n+        node = processNode(buildPolicy, nodeIndex, parentNode, node);\n+        createChildNodeChains(buildPolicy, constraintWeight, nodeIndex, node);\n         return node;\n     }\n \n-    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n+    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy, int nodeIndex,\n             BavetAbstractBiNode<A, B> parentNode, BavetAbstractBiNode<A, B> node) {\n+        buildPolicy.updateNodeIndexMaximum(nodeIndex);\n         BavetAbstractBiNode<A, B> sharedNode = buildPolicy.retrieveSharedNode(node);\n-        if (sharedNode != node) { // Share node\n-            return sharedNode;\n-        } else if (parentNode != null) { // TODO remove null check and don't go through this for from and joins\n-            parentNode.addChildNode(node);\n+        if (sharedNode != node) {\n+            // Share node\n+            node = sharedNode;\n+        } else {\n+            if (parentNode != null) { // TODO remove null check and don't go through this code like this for from and joins\n+                parentNode.addChildNode(node);\n+            }\n         }\n         return node;\n     }\n \n     protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight,\n-            BavetAbstractBiNode<A, B> node) {\n+            int nodeIndex, BavetAbstractBiNode<A, B> node) {\n         if (childStreamList.isEmpty()) {\n             throw new IllegalStateException(\"The stream (\" + this + \") leads to nowhere.\\n\"\n                     + \"Maybe don't create it.\");\n         }\n         for (BavetAbstractBiConstraintStream<Solution_, A, B> childStream : childStreamList) {\n-            childStream.createNodeChain(buildPolicy, constraintWeight, node);\n+            childStream.createNodeChain(buildPolicy, constraintWeight, nodeIndex + 1, node);\n         }\n     }\n \n     protected abstract BavetAbstractBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode);\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode);\n }\n", "next_change": {"commit": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\nindex 4fb9d5bd95..4408d2c61c 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n", "chunk": "@@ -311,5 +307,5 @@ public abstract class BavetAbstractBiConstraintStream<Solution_, A, B> extends B\n     }\n \n     protected abstract BavetAbstractBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode);\n }\n", "next_change": {"commit": "943539854e2fce9fb385cf7b038acf4d4af62eb2", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\nindex 4408d2c61c..83f280b82f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n", "chunk": "@@ -296,13 +296,13 @@ public abstract class BavetAbstractBiConstraintStream<Solution_, A, B> extends B\n     }\n \n     protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight,\n-            int nodeIndex, BavetAbstractBiNode<A, B> node) {\n+            BavetAbstractBiNode<A, B> node) {\n         if (childStreamList.isEmpty()) {\n             throw new IllegalStateException(\"The stream (\" + this + \") leads to nowhere.\\n\"\n                     + \"Maybe don't create it.\");\n         }\n         for (BavetAbstractBiConstraintStream<Solution_, A, B> childStream : childStreamList) {\n-            childStream.createNodeChain(buildPolicy, constraintWeight, nodeIndex + 1, node);\n+            childStream.createNodeChain(buildPolicy, constraintWeight, node);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMjk2OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536212968", "body": "(important)\r\nThis is very wierd.\r\nI would expect the it take as the next Index from the buildPolicy.\r\nThis way the next Index doesn't increment. That's a bug I think?", "bodyText": "(important)\nThis is very wierd.\nI would expect the it take as the next Index from the buildPolicy.\nThis way the next Index doesn't increment. That's a bug I think?", "bodyHTML": "<p dir=\"auto\">(important)<br>\nThis is very wierd.<br>\nI would expect the it take as the next Index from the buildPolicy.<br>\nThis way the next Index doesn't increment. That's a bug I think?</p>", "author": "ge0ffrey", "createdAt": "2020-12-04T16:15:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java", "diffHunk": "@@ -51,8 +51,8 @@ public BavetFilterBiConstraintStream(BavetConstraintFactory<Solution_> constrain\n \n     @Override\n     protected BavetFilterBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        return new BavetFilterBiNode<>(buildPolicy.getSession(), nodeOrder, parentNode, predicate);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, parentNode, predicate);", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2ODEzMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536268131", "bodyText": "The index is incremented immediately after this, when the node is checked for sharing. There is a test that checks for this.\nI am interested in counter-examples.", "author": "triceo", "createdAt": "2020-12-04T17:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMjk2OA=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\nindex c61f860649..9af0c0e2ef 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n", "chunk": "@@ -51,8 +51,8 @@ public final class BavetFilterBiConstraintStream<Solution_, A, B> extends BavetA\n \n     @Override\n     protected BavetFilterBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n-        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, parentNode, predicate);\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetFilterBiNode<>(buildPolicy.getSession(), nodeIndex, parentNode, predicate);\n     }\n \n     @Override\n", "next_change": {"commit": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\nindex 9af0c0e2ef..c61f860649 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n", "chunk": "@@ -51,8 +51,8 @@ public final class BavetFilterBiConstraintStream<Solution_, A, B> extends BavetA\n \n     @Override\n     protected BavetFilterBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode) {\n-        return new BavetFilterBiNode<>(buildPolicy.getSession(), nodeIndex, parentNode, predicate);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, parentNode, predicate);\n     }\n \n     @Override\n", "next_change": {"commit": "6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\nindex c61f860649..59a3f7d577 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n", "chunk": "@@ -52,7 +52,7 @@ public final class BavetFilterBiConstraintStream<Solution_, A, B> extends BavetA\n     @Override\n     protected BavetFilterBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n             Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n-        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, parentNode, predicate);\n+        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.nextNodeIndex(), parentNode, predicate);\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMzQwOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536213409", "body": "No. This appraoch won't work with composition approaches. For complex networks we can't predict the gaps.", "bodyText": "No. This appraoch won't work with composition approaches. For complex networks we can't predict the gaps.", "bodyHTML": "<p dir=\"auto\">No. This appraoch won't work with composition approaches. For complex networks we can't predict the gaps.</p>", "author": "ge0ffrey", "createdAt": "2020-12-04T16:16:01Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java", "diffHunk": "@@ -50,19 +50,20 @@ public BavetGroupBiConstraintStream(BavetConstraintFactory<Solution_> constraint\n \n     @Override\n     public BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         return (BavetGroupBiNode<GroupKey_, ResultContainer_, Result_>) super.createNodeChain(buildPolicy, constraintWeight,\n-                nodeOrder, parentNode);\n+                parentNode);\n     }\n \n     @Override\n     protected BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         if (parentNode != null) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), nodeOrder, finisher);\n+        // GroupBridgeNodes are created after GroupNodes, so increment by 2 to create room for the bridge inbetween.\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2ODgxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536268819", "bodyText": "Assuming that Group is always preceded by a GroupBridge, this is perfectly safe.\nOtherwise I'll need to see an example of a network where that is not the case.", "author": "triceo", "createdAt": "2020-12-04T17:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMzQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\nindex 7031d6a5ea..25eae899bc 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n", "chunk": "@@ -50,20 +50,19 @@ public final class BavetGroupBiConstraintStream<Solution_, GroupKey_, ResultCont\n \n     @Override\n     public BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         return (BavetGroupBiNode<GroupKey_, ResultContainer_, Result_>) super.createNodeChain(buildPolicy, constraintWeight,\n-                parentNode);\n+                nodeIndex, parentNode);\n     }\n \n     @Override\n     protected BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         if (parentNode != null) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        // GroupBridgeNodes are created after GroupNodes, so increment by 2 to create room for the bridge inbetween.\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), nodeIndex, finisher);\n     }\n \n     @Override\n", "next_change": {"commit": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\nindex 25eae899bc..47438d6d4f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n", "chunk": "@@ -57,12 +57,13 @@ public final class BavetGroupBiConstraintStream<Solution_, GroupKey_, ResultCont\n \n     @Override\n     protected BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         if (parentNode != null) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), nodeIndex, finisher);\n+        // GroupBridgeNodes are created before GroupNodes, so increment by 2 to create room for the bridge inbetween.\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);\n     }\n \n     @Override\n", "next_change": {"commit": "c7d6e55179f5eb79667316b4b446af33b7e4b247", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\nindex 47438d6d4f..7031d6a5ea 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n", "chunk": "@@ -62,7 +62,7 @@ public final class BavetGroupBiConstraintStream<Solution_, GroupKey_, ResultCont\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        // GroupBridgeNodes are created before GroupNodes, so increment by 2 to create room for the bridge inbetween.\n+        // GroupBridgeNodes are created after GroupNodes, so increment by 2 to create room for the bridge inbetween.\n         return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);\n     }\n \n", "next_change": {"commit": "fc41f88d9974326125ccaf02637d6d574378a1ac", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\nindex 7031d6a5ea..347aa537d4 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n", "chunk": "@@ -62,8 +62,7 @@ public final class BavetGroupBiConstraintStream<Solution_, GroupKey_, ResultCont\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        // GroupBridgeNodes are created after GroupNodes, so increment by 2 to create room for the bridge inbetween.\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, finisher);\n     }\n \n     @Override\n", "next_change": {"commit": "6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\nindex 347aa537d4..c963bbe75f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n", "chunk": "@@ -62,7 +62,7 @@ public final class BavetGroupBiConstraintStream<Solution_, GroupKey_, ResultCont\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, finisher);\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.nextNodeIndex(), finisher);\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNjA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536216091", "body": "My suggestion is to remove this field and instead have\r\n\r\n```suggestion\r\n    private int nextNodeIndex = 0;\r\n    \r\n    public int nextNodeIndex() {\r\n        return nextNodeIndex++;\r\n    }\r\n```\r\n\r\nEvery time a new node is created, it call this method and automatically gets the next one.\r\nRemember that join nodes are created after both bridges are created, so a join will never be before it's bridges or anything before it (but we should test those nodeIndexes with a unit test).\r\n", "bodyText": "My suggestion is to remove this field and instead have\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.\n          \n          \n            \n                private int nextNodeIndex = 0;\n          \n          \n            \n                \n          \n          \n            \n                public int nextNodeIndex() {\n          \n          \n            \n                    return nextNodeIndex++;\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nEvery time a new node is created, it call this method and automatically gets the next one.\nRemember that join nodes are created after both bridges are created, so a join will never be before it's bridges or anything before it (but we should test those nodeIndexes with a unit test).", "bodyHTML": "<p dir=\"auto\">My suggestion is to remove this field and instead have</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">int</span> <span class=\"x x-first x-last\">nodeIndexMaximum</span> <span class=\"pl-k\">=</span> <span class=\"pl-k x x-first\">-</span><span class=\"pl-c1 x\">1</span><span class=\"x\">; </span><span class=\"pl-c\"><span class=\"pl-c x\">//</span><span class=\"x x-last\"> So that the first node starts at 0 when it increments.</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">int</span> <span class=\"x x-first x-last\">nextNodeIndex</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1 x x-first\">0</span><span class=\"x x-last\">;</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    </td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">int</span> nextNodeIndex() {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> nextNodeIndex<span class=\"pl-k\">++</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Every time a new node is created, it call this method and automatically gets the next one.<br>\nRemember that join nodes are created after both bridges are created, so a join will never be before it's bridges or anything before it (but we should test those nodeIndexes with a unit test).</p>", "author": "ge0ffrey", "createdAt": "2020-12-04T16:19:42Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -26,7 +26,7 @@\n \n     private final BavetConstraintSession session;\n \n-    private int nodeOrderMaximum = 0;\n+    private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2OTUxOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536269518", "bodyText": "No. The entire algorithm depends on the fact, that nodeIndex is only ever actually incremented when node sharing is ruled out. It makes the algorithm incredibly simple and effective - no need for any sort of rollback.", "author": "triceo", "createdAt": "2020-12-04T17:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNjA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 68d8ed9a11..6e5241e921 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -26,7 +26,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     private final BavetConstraintSession session;\n \n-    private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.\n+    private int nodeIndexMaximum = 0;\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n", "next_change": {"commit": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 6e5241e921..27a0657f8f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -21,12 +21,14 @@ import java.util.LinkedHashMap;\n import java.util.Map;\n \n import org.optaplanner.core.impl.score.stream.bavet.BavetConstraintSession;\n+import org.optaplanner.core.impl.score.stream.bavet.bi.BavetGroupBridgeBiNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetGroupBridgeUniNode;\n \n public class BavetNodeBuildPolicy<Solution_> {\n \n     private final BavetConstraintSession session;\n \n-    private int nodeIndexMaximum = 0;\n+    private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n", "next_change": {"commit": "6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 27a0657f8f..2dad1baae6 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -21,14 +21,12 @@ import java.util.LinkedHashMap;\n import java.util.Map;\n \n import org.optaplanner.core.impl.score.stream.bavet.BavetConstraintSession;\n-import org.optaplanner.core.impl.score.stream.bavet.bi.BavetGroupBridgeBiNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetGroupBridgeUniNode;\n \n public class BavetNodeBuildPolicy<Solution_> {\n \n     private final BavetConstraintSession session;\n \n-    private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.\n+    private int nextNodeIndex = 0;\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n", "next_change": {"commit": "e5154a1a05c9a512d6a903ea5a685467b20af7cc", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 2dad1baae6..c91f14ccce 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -30,7 +33,8 @@ public class BavetNodeBuildPolicy<Solution_> {\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>();\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);\n+    private List<BavetNode> createdNodes = new ArrayList<>(0);\n \n     public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount) {\n         this.session = session;\n", "next_change": {"commit": "71b570172a360afbf4a710a5ef20bef1cf2a2b41", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex c91f14ccce..6ca78816f1 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -33,7 +38,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new LinkedHashMap<>(0);\n     private List<BavetNode> createdNodes = new ArrayList<>(0);\n \n     public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount) {\n", "next_change": {"commit": "fa8e08e69551986e0522a604deb3956a63936d09", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 6ca78816f1..ac68549ed3 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -38,8 +38,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new LinkedHashMap<>(0);\n-    private List<BavetNode> createdNodes = new ArrayList<>(0);\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);\n \n     public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount) {\n         this.session = session;\n", "next_change": {"commit": "b496437ad158f4ae76af1f3602a74da64435f92b", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..ff408c3a40 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -38,7 +38,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>();\n \n     public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount) {\n         this.session = session;\n", "next_change": {"commit": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ff408c3a40..9cbe22dcf0 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -47,8 +46,9 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        if (sharedNode != node) { // We are throwing away the new instance; throw away the new index, too.\n-            nextNodeIndex--;\n+        if (sharedNode != node) {\n+            // We are throwing away the new instance; throw away the new index, too.\n+            nextNodeIndex = node.getNodeIndex();\n         }\n         return sharedNode;\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0NzA3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r537447074", "body": "This is heavy. Thankfully it is only ever used in `BavetConstraintSession` constructor.\r\nConsidering that it gives us a fail-fast on a pretty important thing, I say we need it.", "bodyText": "This is heavy. Thankfully it is only ever used in BavetConstraintSession constructor.\nConsidering that it gives us a fail-fast on a pretty important thing, I say we need it.", "bodyHTML": "<p dir=\"auto\">This is heavy. Thankfully it is only ever used in <code>BavetConstraintSession</code> constructor.<br>\nConsidering that it gives us a fail-fast on a pretty important thing, I say we need it.</p>", "author": "triceo", "createdAt": "2020-12-07T11:52:44Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +86,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()\n+                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n+                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                }, TreeMap::new));\n+        // Ensure there are no gaps in that list.\n+        int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n+        int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n+        if (maxNodeIndex != expectedMaxNodeIndex) {\n+            throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n+                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n+        }\n+        return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n+    }", "originalCommit": "98513aa276d23bb2ceac3bfc7f897abc906c6777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzOTY0Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538239643", "bodyText": "100% agree that it is worth it.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0NzA3NA=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 6ca78816f1..6e5241e921 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -86,22 +77,4 @@ public class BavetNodeBuildPolicy<Solution_> {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n-    public List<BavetNode> getCreatedNodes() {\n-        // Make a sequential list of unique nodes.\n-        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n-                constraintIdToScoringNodeMap.values().stream())\n-                .distinct()\n-                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n-                }, TreeMap::new));\n-        // Ensure there are no gaps in that list.\n-        int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n-        int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n-        if (maxNodeIndex != expectedMaxNodeIndex) {\n-            throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n-                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n-        }\n-        return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n-    }\n-\n }\n", "next_change": {"commit": "e5154a1a05c9a512d6a903ea5a685467b20af7cc", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 6e5241e921..c91f14ccce 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -77,4 +81,8 @@ public class BavetNodeBuildPolicy<Solution_> {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        return Collections.unmodifiableList(createdNodes);\n+    }\n+\n }\n", "next_change": {"commit": "71b570172a360afbf4a710a5ef20bef1cf2a2b41", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex c91f14ccce..6ca78816f1 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -82,7 +87,21 @@ public class BavetNodeBuildPolicy<Solution_> {\n     }\n \n     public List<BavetNode> getCreatedNodes() {\n-        return Collections.unmodifiableList(createdNodes);\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()\n+                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n+                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                }, TreeMap::new));\n+        // Ensure there are no gaps in that list.\n+        int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n+        int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n+        if (maxNodeIndex != expectedMaxNodeIndex) {\n+            throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n+                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n+        }\n+        return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n     }\n \n }\n", "next_change": {"commit": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 6ca78816f1..9cbe22dcf0 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -88,18 +79,17 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public List<BavetNode> getCreatedNodes() {\n         // Make a sequential list of unique nodes.\n-        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n-                constraintIdToScoringNodeMap.values().stream())\n-                .distinct()\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = sharableNodeMap.keySet().stream()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b +\n+                            \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n         // Ensure there are no gaps in that list.\n         int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n         int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n         if (maxNodeIndex != expectedMaxNodeIndex) {\n             throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n-                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n+                    \") does not match the expected maximum node index (\" + expectedMaxNodeIndex + \").\");\n         }\n         return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n     }\n", "next_change": null}]}}]}}]}}]}}, {"oid": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "url": "https://github.com/kiegroup/optaplanner/commit/6dee0a469c93a206012d395d5b6cc72aca40b2fd", "message": "NodeOrder becomes NodeIndex", "committedDate": "2020-12-07T13:24:23Z", "type": "commit"}, {"oid": "27fa44052c64164d4601346b7943f38c78c21e4d", "url": "https://github.com/kiegroup/optaplanner/commit/27fa44052c64164d4601346b7943f38c78c21e4d", "message": "BavetNode becomes Comparable", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "url": "https://github.com/kiegroup/optaplanner/commit/fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "message": "Add a simple node index test", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "a577c40520644bf3c937f8264179be7ad88bfafe", "url": "https://github.com/kiegroup/optaplanner/commit/a577c40520644bf3c937f8264179be7ad88bfafe", "message": "processNode() does not need node index", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "05cd93dfd907bb33499b74c02647722c2cfda9e3", "url": "https://github.com/kiegroup/optaplanner/commit/05cd93dfd907bb33499b74c02647722c2cfda9e3", "message": "internalize node order maximum updates", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "url": "https://github.com/kiegroup/optaplanner/commit/66eaceb994ffd49a63b1050212006a93c3b4fd35", "message": "Order stuff properly", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "943539854e2fce9fb385cf7b038acf4d4af62eb2", "url": "https://github.com/kiegroup/optaplanner/commit/943539854e2fce9fb385cf7b038acf4d4af62eb2", "message": "Finally remove all node index arguments", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "9eee086026884c89f406ef9ee9f3f5c06079d728", "url": "https://github.com/kiegroup/optaplanner/commit/9eee086026884c89f406ef9ee9f3f5c06079d728", "message": "Finishing touches", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "d85f892cacea8d12965a891b40927b62a70dfe8b", "url": "https://github.com/kiegroup/optaplanner/commit/d85f892cacea8d12965a891b40927b62a70dfe8b", "message": "Remove a bit more code", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "4c0e92a181a7ab0f4daa502ba16352430beb8513", "url": "https://github.com/kiegroup/optaplanner/commit/4c0e92a181a7ab0f4daa502ba16352430beb8513", "message": "Remove some unused code", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "c7d6e55179f5eb79667316b4b446af33b7e4b247", "url": "https://github.com/kiegroup/optaplanner/commit/c7d6e55179f5eb79667316b4b446af33b7e4b247", "message": "Fix comment", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "fc41f88d9974326125ccaf02637d6d574378a1ac", "url": "https://github.com/kiegroup/optaplanner/commit/fc41f88d9974326125ccaf02637d6d574378a1ac", "message": "Create group bridges in sequence", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "url": "https://github.com/kiegroup/optaplanner/commit/6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "message": "Better node indexing algorithm", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "e5154a1a05c9a512d6a903ea5a685467b20af7cc", "url": "https://github.com/kiegroup/optaplanner/commit/e5154a1a05c9a512d6a903ea5a685467b20af7cc", "message": "Fail fast on node indexing", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "fb1fec593b0245fd99cd51eff63dacae9e947d32", "url": "https://github.com/kiegroup/optaplanner/commit/fb1fec593b0245fd99cd51eff63dacae9e947d32", "message": "Make nodes available outside of the session", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "dcd96290c8cdddb8ddbd7d07e9b791bcebc64cf4", "url": "https://github.com/kiegroup/optaplanner/commit/dcd96290c8cdddb8ddbd7d07e9b791bcebc64cf4", "message": "Improve test", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "d356b05b228975847d87854ed088983cbbdc5e43", "url": "https://github.com/kiegroup/optaplanner/commit/d356b05b228975847d87854ed088983cbbdc5e43", "message": "Address code review comments", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "71b570172a360afbf4a710a5ef20bef1cf2a2b41", "url": "https://github.com/kiegroup/optaplanner/commit/71b570172a360afbf4a710a5ef20bef1cf2a2b41", "message": "Make the node list complete", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "fa8e08e69551986e0522a604deb3956a63936d09", "url": "https://github.com/kiegroup/optaplanner/commit/fa8e08e69551986e0522a604deb3956a63936d09", "message": "Remove unused code", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "f9a1e04141463e78f1a976ea90b6165268a2a710", "url": "https://github.com/kiegroup/optaplanner/commit/f9a1e04141463e78f1a976ea90b6165268a2a710", "message": "Nodes need not be Comparable", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "e483776c84cf3f5c3cf8842ef231c84d08106714", "url": "https://github.com/kiegroup/optaplanner/commit/e483776c84cf3f5c3cf8842ef231c84d08106714", "message": "Remove test that is no longer necessary", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "e483776c84cf3f5c3cf8842ef231c84d08106714", "url": "https://github.com/kiegroup/optaplanner/commit/e483776c84cf3f5c3cf8842ef231c84d08106714", "message": "Remove test that is no longer necessary", "committedDate": "2020-12-07T13:24:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r537556204", "body": "Not useful anymore. We now have a better test, and that one checks the node indexes directly.", "bodyText": "Not useful anymore. We now have a better test, and that one checks the node indexes directly.", "bodyHTML": "<p dir=\"auto\">Not useful anymore. We now have a better test, and that one checks the node indexes directly.</p>", "author": "triceo", "createdAt": "2020-12-07T14:37:54Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStreamTest.java", "diffHunk": "@@ -1419,45 +1419,6 @@ public void duplicateConstraintId() {\n                 constraintStreamImplType));\n     }\n \n-    @TestTemplate\n-    public void globalNodeOrder() {", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NDgzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538244837", "bodyText": "By removing it, this test also doesn't run on CS-D any more?\n+0 to remove if it's fully duplicate for Bavet, including the actual scoreCalculation verification (which seems to be the case).\nYour call.\nIf we do keep it, maybe it should be renamed to something like \"nodeIndexChallenger\" or \"joinFilterLeftBridgeVersusJoinFilterRightBridge\"? Idunno.", "author": "ge0ffrey", "createdAt": "2020-12-08T11:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0Nzk5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538247996", "bodyText": "CS-D never had node indexes, we need not worry about these things there.\nEverything else this test does is covered elsewhere.", "author": "triceo", "createdAt": "2020-12-08T11:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzMjkwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538232907", "body": "Interesting approach by pushing that here. It's inline with the rest of what Bavet currently does, so +1.", "bodyText": "Interesting approach by pushing that here. It's inline with the rest of what Bavet currently does, so +1.", "bodyHTML": "<p dir=\"auto\">Interesting approach by pushing that here. It's inline with the rest of what Bavet currently does, so +1.</p>", "author": "ge0ffrey", "createdAt": "2020-12-08T10:44:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBridgeBiConstraintStream.java", "diffHunk": "@@ -57,20 +57,23 @@ public void setGroupStream(BavetGroupBiConstraintStream<Solution_, NewA, ResultC\n \n     @Override\n     protected BavetAbstractBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetGroupBiNode<NewA, ResultContainer_, NewB> groupNode = groupStream.createNodeChain(buildPolicy, constraintWeight,\n-                nodeOrder + 1, null);\n-        BavetGroupBridgeBiNode<A, B, NewA, ResultContainer_, NewB> node = new BavetGroupBridgeBiNode<>(\n-                buildPolicy.getSession(), nodeOrder, parentNode, groupKeyMapping, collector, groupNode);\n-        return node;\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetGroupBridgeBiNode<>(buildPolicy.getSession(), buildPolicy.nextNodeIndex(), parentNode,\n+                groupKeyMapping, collector);\n     }\n \n     @Override\n-    protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight, int nodeOrder,\n+    protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight,\n             BavetAbstractBiNode<A, B> node) {\n         if (!childStreamList.isEmpty()) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") has an non-empty childStreamList (\" + childStreamList + \") but it's a groupBy bridge.\");\n         }\n+        BavetGroupBiNode<NewA, ResultContainer_, NewB> groupNode = groupStream.createNodeChain(buildPolicy,\n+                constraintWeight, null);", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNTgxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538235819", "body": "Adding that zero is strange. Use at least 16 (or better yet the default): the memory cost of 16 is triviial, especially as only a handfully policy elements will exist, while the cost of sharing 9 nodes will be quite significant already.\r\n\r\nBy the way, due to from() filtering on initialized variables only, there is pretty much always node sharing.\r\n\r\nSo my advise is to remove this line's change.", "bodyText": "Adding that zero is strange. Use at least 16 (or better yet the default): the memory cost of 16 is triviial, especially as only a handfully policy elements will exist, while the cost of sharing 9 nodes will be quite significant already.\nBy the way, due to from() filtering on initialized variables only, there is pretty much always node sharing.\nSo my advise is to remove this line's change.", "bodyHTML": "<p dir=\"auto\">Adding that zero is strange. Use at least 16 (or better yet the default): the memory cost of 16 is triviial, especially as only a handfully policy elements will exist, while the cost of sharing 9 nodes will be quite significant already.</p>\n<p dir=\"auto\">By the way, due to from() filtering on initialized variables only, there is pretty much always node sharing.</p>\n<p dir=\"auto\">So my advise is to remove this line's change.</p>", "author": "ge0ffrey", "createdAt": "2020-12-08T10:48:56Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -16,39 +16,39 @@\n \n package org.optaplanner.core.impl.score.stream.bavet.common;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.optaplanner.core.impl.score.stream.bavet.BavetConstraintSession;\n \n public class BavetNodeBuildPolicy<Solution_> {\n \n     private final BavetConstraintSession session;\n \n-    private int nodeOrderMaximum = 0;\n+    private int nextNodeIndex = 0;\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>();\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b496437ad158f4ae76af1f3602a74da64435f92b", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..ff408c3a40 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -38,7 +38,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>();\n \n     public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount) {\n         this.session = session;\n", "next_change": {"commit": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ff408c3a40..9cbe22dcf0 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -47,8 +46,9 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        if (sharedNode != node) { // We are throwing away the new instance; throw away the new index, too.\n-            nextNodeIndex--;\n+        if (sharedNode != node) {\n+            // We are throwing away the new instance; throw away the new index, too.\n+            nextNodeIndex = node.getNodeIndex();\n         }\n         return sharedNode;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNzc0NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538237745", "body": "Why is the distinct needed on the nodes? I'd argue if they are not distinct, then node sharing is broken and we want it to fail fast.", "bodyText": "Why is the distinct needed on the nodes? I'd argue if they are not distinct, then node sharing is broken and we want it to fail fast.", "bodyHTML": "<p dir=\"auto\">Why is the distinct needed on the nodes? I'd argue if they are not distinct, then node sharing is broken and we want it to fail fast.</p>", "author": "ge0ffrey", "createdAt": "2020-12-08T10:51:45Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +77,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..883e506d06 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -83,7 +83,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n                 constraintIdToScoringNodeMap.values().stream())\n                 .distinct()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n         // Ensure there are no gaps in that list.\n         int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n", "next_change": {"commit": "b496437ad158f4ae76af1f3602a74da64435f92b", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 883e506d06..ff408c3a40 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -81,7 +81,6 @@ public class BavetNodeBuildPolicy<Solution_> {\n         // Make a sequential list of unique nodes.\n         SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n                 constraintIdToScoringNodeMap.values().stream())\n-                .distinct()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n                     throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n", "next_change": {"commit": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ff408c3a40..9cbe22dcf0 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -79,17 +79,17 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public List<BavetNode> getCreatedNodes() {\n         // Make a sequential list of unique nodes.\n-        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n-                constraintIdToScoringNodeMap.values().stream())\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = sharableNodeMap.keySet().stream()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n+                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b +\n+                            \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n         // Ensure there are no gaps in that list.\n         int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n         int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n         if (maxNodeIndex != expectedMaxNodeIndex) {\n             throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n-                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n+                    \") does not match the expected maximum node index (\" + expectedMaxNodeIndex + \").\");\n         }\n         return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n     }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzODYwMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538238603", "body": "```suggestion\r\n                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n          \n          \n            \n                                throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">IllegalStateException</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Impossible state: nodes (<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> a <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">) and (</span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> b <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>) share index.<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">IllegalStateException</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Impossible state: <span class=\"x x-first x-last\">2 </span>nodes (<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> a <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">, </span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> b <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>) share <span class=\"x x-first x-last\">the same </span>index<span class=\"x x-first\"> (</span><span class=\"pl-pds x\">\"</span></span><span class=\"x\"> </span><span class=\"pl-k x\">+</span><span class=\"x\"> a</span><span class=\"pl-k x\">.</span><span class=\"x\">getNodeIndex() </span><span class=\"pl-k x\">+</span><span class=\"x\"> </span><span class=\"pl-s\"><span class=\"pl-pds x\">\"</span><span class=\"x x-last\">)</span>.<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ge0ffrey", "createdAt": "2020-12-08T10:52:57Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +77,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()\n+                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n+                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzOTAzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538239030", "bodyText": "Motivation: grammar (\"the\", etc) and show the node index in that error message if we have it available anyway.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzODYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..883e506d06 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -83,7 +83,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n                 constraintIdToScoringNodeMap.values().stream())\n                 .distinct()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n         // Ensure there are no gaps in that list.\n         int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n", "next_change": {"commit": "b496437ad158f4ae76af1f3602a74da64435f92b", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 883e506d06..ff408c3a40 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -81,7 +81,6 @@ public class BavetNodeBuildPolicy<Solution_> {\n         // Make a sequential list of unique nodes.\n         SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n                 constraintIdToScoringNodeMap.values().stream())\n-                .distinct()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n                     throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n", "next_change": {"commit": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "changed_code": [{"header": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ff408c3a40..9cbe22dcf0 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n", "chunk": "@@ -79,17 +79,17 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     public List<BavetNode> getCreatedNodes() {\n         // Make a sequential list of unique nodes.\n-        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n-                constraintIdToScoringNodeMap.values().stream())\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = sharableNodeMap.keySet().stream()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n+                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b +\n+                            \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n         // Ensure there are no gaps in that list.\n         int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n         int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n         if (maxNodeIndex != expectedMaxNodeIndex) {\n             throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n-                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n+                    \") does not match the expected maximum node index (\" + expectedMaxNodeIndex + \").\");\n         }\n         return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n     }\n", "next_change": null}]}}]}}]}}, {"oid": "d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "url": "https://github.com/kiegroup/optaplanner/commit/d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "message": "Update optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\nCo-authored-by: Geoffrey De Smet <gds.geoffrey.de.smet@gmail.com>", "committedDate": "2020-12-08T11:07:46Z", "type": "commit"}, {"oid": "b496437ad158f4ae76af1f3602a74da64435f92b", "url": "https://github.com/kiegroup/optaplanner/commit/b496437ad158f4ae76af1f3602a74da64435f92b", "message": "Address code review comments", "committedDate": "2020-12-08T11:09:13Z", "type": "commit"}, {"oid": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "url": "https://github.com/kiegroup/optaplanner/commit/64a07396c3afb79ad49c51513de8c2084bd8d9a0", "message": "Fix bug", "committedDate": "2020-12-08T11:27:46Z", "type": "commit"}]}