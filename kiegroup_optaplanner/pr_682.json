{"pr_number": 682, "pr_title": "PLANNER-1854 Fail fast on negative constraint match weight", "pr_author": "triceo", "pr_createdAt": "2020-02-12T08:41:50Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/682", "timeline": [{"oid": "2b885c04ec3fd703c028eb95b634acc768e22073", "url": "https://github.com/kiegroup/optaplanner/commit/2b885c04ec3fd703c028eb95b634acc768e22073", "message": "PLANNER-1854 Fail fast on negative constraint match weight", "committedDate": "2020-02-12T08:40:00Z", "type": "commit"}, {"oid": "ace237cd3ad12c1904ef58fb3f3ebb7e9ff1373b", "url": "https://github.com/kiegroup/optaplanner/commit/ace237cd3ad12c1904ef58fb3f3ebb7e9ff1373b", "message": "Reuse assertion method", "committedDate": "2020-02-12T08:50:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNTk5Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/682#discussion_r378115993", "body": "-1 Avoid number.doubleValue(), intValue(), ... like the plague. Why?\r\n- rounding errors, try `(double) 9007199254740993L`, see https://ge0ffrey.github.io/ge0ffrey-presentations/cornerCaseCheatSheet/cheatSheetJava.html\r\n- doubleValue() on some large or extremely accurate BigDecimals are questionable\r\n\r\nYou could in theory prove that the signum well never change by rounding. But seeing how Math.abs() behaves on MIN_VALUE, let's not take that risk. Furthermore, this causes auto-inboxing to Number, which will have a performance impact.\r\n\r\nAlso, keep the operands of the same type, to avoid java-puzzlers-bugs. So keep the second operand specifically a double: `if (impact.doubleValue() < 0.0) {`. (Same goes for longs: in LongScore etc, we use `0L` to send a zero long, not `0`.)\r\n\r\nThis implies we'll have an `assertPositiveImpact(, int)`, `assertPositiveImpact(, long)`, etc", "bodyText": "-1 Avoid number.doubleValue(), intValue(), ... like the plague. Why?\n\nrounding errors, try (double) 9007199254740993L, see https://ge0ffrey.github.io/ge0ffrey-presentations/cornerCaseCheatSheet/cheatSheetJava.html\ndoubleValue() on some large or extremely accurate BigDecimals are questionable\n\nYou could in theory prove that the signum well never change by rounding. But seeing how Math.abs() behaves on MIN_VALUE, let's not take that risk. Furthermore, this causes auto-inboxing to Number, which will have a performance impact.\nAlso, keep the operands of the same type, to avoid java-puzzlers-bugs. So keep the second operand specifically a double: if (impact.doubleValue() < 0.0) {. (Same goes for longs: in LongScore etc, we use 0L to send a zero long, not 0.)\nThis implies we'll have an assertPositiveImpact(, int), assertPositiveImpact(, long), etc", "bodyHTML": "<p dir=\"auto\">-1 Avoid number.doubleValue(), intValue(), ... like the plague. Why?</p>\n<ul dir=\"auto\">\n<li>rounding errors, try <code>(double) 9007199254740993L</code>, see <a href=\"https://ge0ffrey.github.io/ge0ffrey-presentations/cornerCaseCheatSheet/cheatSheetJava.html\" rel=\"nofollow\">https://ge0ffrey.github.io/ge0ffrey-presentations/cornerCaseCheatSheet/cheatSheetJava.html</a></li>\n<li>doubleValue() on some large or extremely accurate BigDecimals are questionable</li>\n</ul>\n<p dir=\"auto\">You could in theory prove that the signum well never change by rounding. But seeing how Math.abs() behaves on MIN_VALUE, let's not take that risk. Furthermore, this causes auto-inboxing to Number, which will have a performance impact.</p>\n<p dir=\"auto\">Also, keep the operands of the same type, to avoid java-puzzlers-bugs. So keep the second operand specifically a double: <code>if (impact.doubleValue() &lt; 0.0) {</code>. (Same goes for longs: in LongScore etc, we use <code>0L</code> to send a zero long, not <code>0</code>.)</p>\n<p dir=\"auto\">This implies we'll have an <code>assertPositiveImpact(, int)</code>, <code>assertPositiveImpact(, long)</code>, etc</p>", "author": "ge0ffrey", "createdAt": "2020-02-12T09:02:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractConstraintStream.java", "diffHunk": "@@ -68,4 +69,12 @@ public BavetAbstractConstraintStream(BavetConstraintFactory<Solution_> constrain\n         return constraintFactory;\n     }\n \n+    protected static void assertPositiveImpact(Constraint constraint, Number impact) {\n+        if (impact.doubleValue() < 0) {", "originalCommit": "ace237cd3ad12c1904ef58fb3f3ebb7e9ff1373b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3853f9bfb39c8bf44ca083d056b470cf31e2fd9a", "url": "https://github.com/kiegroup/optaplanner/commit/3853f9bfb39c8bf44ca083d056b470cf31e2fd9a", "message": "Address code review comments", "committedDate": "2020-02-12T09:47:15Z", "type": "commit"}]}