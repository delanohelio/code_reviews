{"pr_number": 879, "pr_title": "Resolves #866: Replace some aggregate metrics with accurate counters", "pr_author": "scgray", "pr_createdAt": "2020-03-27T15:54:02Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/879", "timeline": [{"oid": "6f374f884f70cbaa4c2ab1d2d6c49a39ff340f39", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/6f374f884f70cbaa4c2ab1d2d6c49a39ff340f39", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T16:25:06Z", "type": "forcePushed"}, {"oid": "1d9430155e620563859f41be886514399ef3a881", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1d9430155e620563859f41be886514399ef3a881", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T16:29:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NjgyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399366821", "body": "The original method probably should never have been public.  Should this one be `protected` at least? ", "bodyText": "The original method probably should never have been public.  Should this one be protected at least?", "bodyHTML": "<p dir=\"auto\">The original method probably should never have been public.  Should this one be <code>protected</code> at least?</p>", "author": "scgray", "createdAt": "2020-03-27T15:55:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabase.java", "diffHunk": "@@ -717,15 +718,48 @@ protected Executor newContextExecutor() {\n         return factory.newContextExecutor();\n     }\n \n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     * @deprecated use {@link #createTransaction(Executor, StoreTimer, Map, boolean)} instead\n+     */\n+    @Deprecated\n+    @API(API.Status.DEPRECATED)\n     public Transaction createTransaction(Executor executor, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {\n+        return createTransaction(executor, null, mdcContext, transactionIsTraced);\n+    }\n+\n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param storeTimer if not {@code null}, will be used too track low level operations (e.g. reads/writes/deletes)\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     */\n+    public Transaction createTransaction(Executor executor, @Nullable StoreTimer storeTimer, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {", "originalCommit": "9c7fcf88b03e0e0036dfe980854607df49d5cb03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyNzY4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399527682", "bodyText": "Yeah, I think either protected or private, even. Then the deprecation warning on the other method should tell people to use openContext or whatever it's called.", "author": "alecgrieser", "createdAt": "2020-03-27T20:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NjgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3MDUxNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400170516", "bodyText": "Done.  I also did some minor refactoring of how the FDBRecordContext is created.", "author": "scgray", "createdAt": "2020-03-30T12:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NjgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODg1MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399378850", "body": "As noted, do we want per-mutation type counters as well? Obviously can always come later...", "bodyText": "As noted, do we want per-mutation type counters as well? Obviously can always come later...", "bodyHTML": "<p dir=\"auto\">As noted, do we want per-mutation type counters as well? Obviously can always come later...</p>", "author": "scgray", "createdAt": "2020-03-27T16:12:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedTransaction.java", "diffHunk": "@@ -0,0 +1,401 @@\n+/*\n+ * InstrumentedTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.Database;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Spliterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * Wrapper around {@link Transaction} that instruments certain calls to expose their behavior with\n+ * {@link FDBStoreTimer} metrics.\n+ */\n+public class InstrumentedTransaction implements Transaction {\n+\n+    @Nullable\n+    protected StoreTimer timer;\n+    protected Transaction underlying;\n+\n+    public InstrumentedTransaction(@Nullable StoreTimer timer, Transaction underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public void addReadConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addReadConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addReadConflictKey(byte[] key) {\n+        underlying.addReadConflictKey(key);\n+    }\n+\n+    @Override\n+    public void addWriteConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addWriteConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addWriteConflictKey(byte[] key) {\n+        underlying.addWriteConflictKey(key);\n+    }\n+\n+    @Override\n+    public void set(byte[] key, byte[] value) {\n+        underlying.set(key, value);\n+        increment(FDBStoreTimer.Counts.WRITES, FDBStoreTimer.Counts.BYTES_WRITTEN, key.length + value.length);\n+    }\n+\n+    @Override\n+    public void clear(byte[] key) {\n+        underlying.clear(key);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.clear(keyBegin, keyEnd);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(Range range) {\n+        underlying.clear(range);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void clearRangeStartsWith(byte[] prefix) {\n+        underlying.clearRangeStartsWith(prefix);\n+        increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void mutate(MutationType opType, byte[] key, byte[] param) {\n+        underlying.mutate(opType, key, param);\n+        /* Do we want to track each mutation type separately as well? */", "originalCommit": "9c7fcf88b03e0e0036dfe980854607df49d5cb03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDU4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399614588", "bodyText": "I think this is probably fine for now. Maybe some day, though.", "author": "alecgrieser", "createdAt": "2020-03-28T03:44:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM5MTQ4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399391480", "body": "As noted, for these iterators, they are being counted a single read. Is this ok?  Can we do better? ", "bodyText": "As noted, for these iterators, they are being counted a single read. Is this ok?  Can we do better?", "bodyHTML": "<p dir=\"auto\">As noted, for these iterators, they are being counted a single read. Is this ok?  Can we do better?</p>", "author": "scgray", "createdAt": "2020-03-27T16:31:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedTransaction.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * InstrumentedTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.Database;\n+import com.apple.foundationdb.FDBException;\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.MutationType;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.Transaction;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.List;\n+import java.util.Spliterator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+/**\n+ * Wrapper around {@link Transaction} that instruments certain calls to expose their behavior with\n+ * {@link FDBStoreTimer} metrics.\n+ */\n+public class InstrumentedTransaction implements Transaction {\n+\n+    @Nonnull\n+    protected StoreTimer timer;\n+    @Nonnull\n+    protected Transaction underlying;\n+\n+    public InstrumentedTransaction(@Nonnull StoreTimer timer, @Nonnull Transaction underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public void addReadConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addReadConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addReadConflictKey(byte[] key) {\n+        underlying.addReadConflictKey(key);\n+    }\n+\n+    @Override\n+    public void addWriteConflictRange(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.addWriteConflictRange(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public void addWriteConflictKey(byte[] key) {\n+        underlying.addWriteConflictKey(key);\n+    }\n+\n+    @Override\n+    public void set(byte[] key, byte[] value) {\n+        underlying.set(key, value);\n+        timer.increment(FDBStoreTimer.Counts.WRITES);\n+        timer.increment(FDBStoreTimer.Counts.BYTES_WRITTEN, key.length + value.length);\n+    }\n+\n+    @Override\n+    public void clear(byte[] key) {\n+        underlying.clear(key);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(byte[] keyBegin, byte[] keyEnd) {\n+        underlying.clear(keyBegin, keyEnd);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void clear(Range range) {\n+        underlying.clear(range);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void clearRangeStartsWith(byte[] prefix) {\n+        underlying.clearRangeStartsWith(prefix);\n+        timer.increment(FDBStoreTimer.Counts.DELETES);\n+    }\n+\n+    @Override\n+    public void mutate(MutationType opType, byte[] key, byte[] param) {\n+        underlying.mutate(opType, key, param);\n+        /* Do we want to track each mutation type separately as well? */\n+        timer.increment(FDBStoreTimer.Counts.MUTATIONS);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> commit() {\n+        long startTimeNanos = System.nanoTime();\n+        return underlying.commit().whenComplete((v, ex) ->\n+                timer.recordSinceNanoTime(FDBStoreTimer.Events.COMMITS, startTimeNanos));\n+    }\n+\n+    @Override\n+    public Long getCommittedVersion() {\n+        return underlying.getCommittedVersion();\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getVersionstamp() {\n+        return underlying.getVersionstamp();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Transaction> onError(Throwable throwable) {\n+        return underlying.onError(throwable);\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        underlying.cancel();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> watch(byte[] bytes) throws FDBException {\n+        return underlying.watch(bytes);\n+    }\n+\n+    @Override\n+    public Database getDatabase() {\n+        return underlying.getDatabase();\n+    }\n+\n+    @Override\n+    public <T> T run(Function<? super Transaction, T> function) {\n+        return function.apply(this);\n+    }\n+\n+    @Override\n+    public <T> CompletableFuture<T> runAsync(Function<? super Transaction, ? extends CompletableFuture<T>> function) {\n+        return AsyncUtil.applySafely(function, this);\n+    }\n+\n+    @Override\n+    public void close() {\n+        underlying.close();\n+    }\n+\n+    @Override\n+    public boolean isSnapshot() {\n+        return underlying.isSnapshot();\n+    }\n+\n+    @Override\n+    public ReadTransaction snapshot() {\n+        return underlying.snapshot();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> getReadVersion() {\n+        return underlying.getReadVersion();\n+    }\n+\n+    @Override\n+    public void setReadVersion(long l) {\n+        underlying.setReadVersion(l);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictRangeIfNotSnapshot(byte[] keyBegin, byte[] keyEnd) {\n+        return underlying.addReadConflictRangeIfNotSnapshot(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictKeyIfNotSnapshot(byte[] key) {\n+        return underlying.addReadConflictKeyIfNotSnapshot(key);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> get(byte[] key) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.get(key).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getKey(KeySelector keySelector) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.getKey(keySelector).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end) {\n+        /* Should this could as one read? */\n+        timer.increment(FDBStoreTimer.Counts.READS);", "originalCommit": "1d9430155e620563859f41be886514399ef3a881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7da9b38afdc937a4de597d5997f055952d0e7b5d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7da9b38afdc937a4de597d5997f055952d0e7b5d", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T20:35:12Z", "type": "forcePushed"}, {"oid": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ded1808beaf1c6fcb792b1bd98431e4e5674e310", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T20:54:40Z", "type": "commit"}, {"oid": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/ded1808beaf1c6fcb792b1bd98431e4e5674e310", "message": "Resolves #866: Replace some aggregate metrics with accurate counters", "committedDate": "2020-03-27T20:54:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyODM3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399528378", "body": "`EventAggregates`, we hardly knew ye", "bodyText": "EventAggregates, we hardly knew ye", "bodyHTML": "<p dir=\"auto\"><code>EventAggregates</code>, we hardly knew ye</p>", "author": "alecgrieser", "createdAt": "2020-03-27T20:44:21Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -238,58 +240,6 @@ public String logKey() {\n         }\n     }\n \n-    /**\n-     * An aggregate over other count events.\n-     */\n-    public enum EventAggregates implements Aggregate, Event {", "originalCommit": "7da9b38afdc937a4de597d5997f055952d0e7b5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3MDY5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400170692", "bodyText": "Sniff", "author": "scgray", "createdAt": "2020-03-30T12:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyODM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MTY3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399541678", "body": "Alternatively, I suppose this could be:\r\n\r\n```java\r\nreturn underlying.asList().whenComplete((list, err) -> {\r\n   if (list != null) {\r\n       list.forEach(this::recordRead);\r\n   }\r\n});\r\n```\r\n\r\nI think then you don't need to copy things into the intermediate `result` list? Though it probably doesn't matter much either way.", "bodyText": "Alternatively, I suppose this could be:\nreturn underlying.asList().whenComplete((list, err) -> {\n   if (list != null) {\n       list.forEach(this::recordRead);\n   }\n});\nI think then you don't need to copy things into the intermediate result list? Though it probably doesn't matter much either way.", "bodyHTML": "<p dir=\"auto\">Alternatively, I suppose this could be:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"return underlying.asList().whenComplete((list, err) -&gt; {\n   if (list != null) {\n       list.forEach(this::recordRead);\n   }\n});\"><pre><span class=\"pl-k\">return</span> underlying<span class=\"pl-k\">.</span>asList()<span class=\"pl-k\">.</span>whenComplete((list, err) <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {\n   <span class=\"pl-k\">if</span> (list <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) {\n       list<span class=\"pl-k\">.</span>forEach(<span class=\"pl-c1\">this</span><span class=\"pl-k\">::</span>recordRead);\n   }\n});</pre></div>\n<p dir=\"auto\">I think then you don't need to copy things into the intermediate <code>result</code> list? Though it probably doesn't matter much either way.</p>", "author": "alecgrieser", "createdAt": "2020-03-27T21:15:52Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedReadTransaction.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * InstrumentedReadTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Function;\n+\n+abstract class InstrumentedReadTransaction<T extends ReadTransaction> implements ReadTransaction {\n+    @Nonnull\n+    protected StoreTimer timer;\n+    @Nonnull\n+    protected T underlying;\n+\n+    public InstrumentedReadTransaction(@Nonnull StoreTimer timer, @Nonnull T underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public boolean isSnapshot() {\n+        return underlying.isSnapshot();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> getReadVersion() {\n+        return underlying.getReadVersion();\n+    }\n+\n+    @Override\n+    public void setReadVersion(long l) {\n+        underlying.setReadVersion(l);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictRangeIfNotSnapshot(byte[] keyBegin, byte[] keyEnd) {\n+        return underlying.addReadConflictRangeIfNotSnapshot(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictKeyIfNotSnapshot(byte[] key) {\n+        return underlying.addReadConflictKeyIfNotSnapshot(key);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> get(byte[] key) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.get(key).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getKey(KeySelector keySelector) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.getKey(keySelector).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end) {\n+        /* Should this could as one read? */\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end, int limit) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end, int limit, boolean reverse) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end, int limit, boolean reverse, StreamingMode streamingMode) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse, streamingMode));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end, int limit) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end, int limit, boolean reverse) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(byte[] begin, byte[] end, int limit, boolean reverse, StreamingMode streamingMode) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(begin, end, limit, reverse, streamingMode));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range, int limit) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range, limit));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range, int limit, boolean reverse) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range, limit, reverse));\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(Range range, int limit, boolean reverse, StreamingMode streamingMode) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return new ByteCountingAsyncIterable(underlying.getRange(range, limit, reverse, streamingMode));\n+    }\n+\n+    @Override\n+    public TransactionOptions options() {\n+        return underlying.options();\n+    }\n+\n+    @Override\n+    public <T> T read(Function<? super ReadTransaction, T> function) {\n+        return function.apply(this);\n+    }\n+\n+    @Override\n+    public <T> CompletableFuture<T> readAsync(Function<? super ReadTransaction, ? extends CompletableFuture<T>> function) {\n+        return AsyncUtil.applySafely(function, this);\n+    }\n+\n+    @Override\n+    public Executor getExecutor() {\n+        return underlying.getExecutor();\n+    }\n+\n+    @Nullable\n+    protected byte[] recordRead(@Nullable byte[] value) {\n+        if (value != null) {\n+            timer.increment(FDBStoreTimer.Counts.BYTES_READ, value.length);\n+        }\n+        return value;\n+    }\n+\n+    @Nullable\n+    protected KeyValue recordRead(@Nonnull KeyValue keyValue) {\n+        timer.increment(FDBStoreTimer.Counts.BYTES_READ, keyValue.getKey().length + keyValue.getValue().length);\n+        return keyValue;\n+    }\n+\n+    private class ByteCountingAsyncIterable implements AsyncIterable<KeyValue> {\n+        private AsyncIterable<KeyValue> underlying;\n+\n+        public ByteCountingAsyncIterable(AsyncIterable<KeyValue> underlying) {\n+            this.underlying = underlying;\n+        }\n+\n+        @Override\n+        public AsyncIterator<KeyValue> iterator() {\n+            return new ByteCountingAsyncIterator(underlying.iterator());\n+        }\n+\n+        @Override\n+        public CompletableFuture<List<KeyValue>> asList() {\n+            final List<KeyValue> result = new ArrayList<>();\n+            final AsyncIterator<KeyValue> iterator = iterator();\n+            return AsyncUtil.whileTrue(() -> iterator.onHasNext().thenApply(hasNext -> {\n+                if (hasNext) {\n+                    result.add(iterator.next());\n+                }\n+                return hasNext;\n+            })).thenApply(vignore -> result);", "originalCommit": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3NDU4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400174581", "bodyText": "Presumably my loop is just doing what the underlying code would have done, however I agree that the underlying code should be in charge of building the list.  Updated.", "author": "scgray", "createdAt": "2020-03-30T13:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0OTM2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400349361", "bodyText": "Yeah, both the old loop and new look look the same in terms of \"what gets recorded\", but I was mostly \"concerned\" with reconstructing the list.", "author": "alecgrieser", "createdAt": "2020-03-30T17:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MTY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDcyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399614725", "body": "Good question. I think (?) that the FDB metric that goes into machine readable status is 1 range read = 1 read, so if we wanted to be able to correlated, say, reads from this timer to reads from that timer, we'd want them to be the same. This also means that we count work from empty range reads, which we may care about. I suppose we still know how many entries get back from our other, higher level metrics (like `FDBStoreTimer.Counts.LOAD_RECORD`). Hmm.", "bodyText": "Good question. I think (?) that the FDB metric that goes into machine readable status is 1 range read = 1 read, so if we wanted to be able to correlated, say, reads from this timer to reads from that timer, we'd want them to be the same. This also means that we count work from empty range reads, which we may care about. I suppose we still know how many entries get back from our other, higher level metrics (like FDBStoreTimer.Counts.LOAD_RECORD). Hmm.", "bodyHTML": "<p dir=\"auto\">Good question. I think (?) that the FDB metric that goes into machine readable status is 1 range read = 1 read, so if we wanted to be able to correlated, say, reads from this timer to reads from that timer, we'd want them to be the same. This also means that we count work from empty range reads, which we may care about. I suppose we still know how many entries get back from our other, higher level metrics (like <code>FDBStoreTimer.Counts.LOAD_RECORD</code>). Hmm.</p>", "author": "alecgrieser", "createdAt": "2020-03-28T03:46:40Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/InstrumentedReadTransaction.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * InstrumentedReadTransaction.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.KeySelector;\n+import com.apple.foundationdb.KeyValue;\n+import com.apple.foundationdb.Range;\n+import com.apple.foundationdb.ReadTransaction;\n+import com.apple.foundationdb.StreamingMode;\n+import com.apple.foundationdb.TransactionOptions;\n+import com.apple.foundationdb.async.AsyncIterable;\n+import com.apple.foundationdb.async.AsyncIterator;\n+import com.apple.foundationdb.async.AsyncUtil;\n+import com.apple.foundationdb.record.provider.common.StoreTimer;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.function.Function;\n+\n+abstract class InstrumentedReadTransaction<T extends ReadTransaction> implements ReadTransaction {\n+    @Nonnull\n+    protected StoreTimer timer;\n+    @Nonnull\n+    protected T underlying;\n+\n+    public InstrumentedReadTransaction(@Nonnull StoreTimer timer, @Nonnull T underlying) {\n+        this.timer = timer;\n+        this.underlying = underlying;\n+    }\n+\n+    @Override\n+    public boolean isSnapshot() {\n+        return underlying.isSnapshot();\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> getReadVersion() {\n+        return underlying.getReadVersion();\n+    }\n+\n+    @Override\n+    public void setReadVersion(long l) {\n+        underlying.setReadVersion(l);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictRangeIfNotSnapshot(byte[] keyBegin, byte[] keyEnd) {\n+        return underlying.addReadConflictRangeIfNotSnapshot(keyBegin, keyEnd);\n+    }\n+\n+    @Override\n+    public boolean addReadConflictKeyIfNotSnapshot(byte[] key) {\n+        return underlying.addReadConflictKeyIfNotSnapshot(key);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> get(byte[] key) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.get(key).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public CompletableFuture<byte[]> getKey(KeySelector keySelector) {\n+        timer.increment(FDBStoreTimer.Counts.READS);\n+        return underlying.getKey(keySelector).thenApply(this::recordRead);\n+    }\n+\n+    @Override\n+    public AsyncIterable<KeyValue> getRange(KeySelector begin, KeySelector end) {\n+        /* Should this could as one read? */", "originalCommit": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDg3MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r399614871", "body": "```suggestion\r\n        /** Total number of mutation operations. */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /** Total number of mutations operations. */\n          \n          \n            \n                    /** Total number of mutation operations. */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* Total number of <span class=\"x x-first x-last\">mutations</span> operations. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* Total number of <span class=\"x x-first x-last\">mutation</span> operations. <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "alecgrieser", "createdAt": "2020-03-28T03:48:29Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBStoreTimer.java", "diffHunk": "@@ -634,6 +584,18 @@ public String logKey() {\n         INVALID_KEY_LENGTH(\"invalid record key\", false),\n         /** The number of indexes that need to be rebuilt in the record store. */\n         INDEXES_NEED_REBUILDING(\"indexes need rebuilding\", false),\n+        /** The number of bytes read. */\n+        BYTES_READ(\"bytes read\", true),\n+        /** The number of bytes written, not including deletes. */\n+        BYTES_WRITTEN(\"bytes written\", true),\n+        /** Total number of delete (clear) operations. */\n+        READS(\"reads\", false),\n+        /** Total number of write operations. */\n+        WRITES(\"writes\", false),\n+        /** Total number of delete (clear) operations. */\n+        DELETES(\"deletes\", false),\n+        /** Total number of mutations operations. */", "originalCommit": "ded1808beaf1c6fcb792b1bd98431e4e5674e310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE3MTA1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400171053", "bodyText": "Done.", "author": "scgray", "createdAt": "2020-03-30T12:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYxNDg3MQ=="}], "type": "inlineReview"}, {"oid": "570540442eb123ef0b027da8b588b9b536c44371", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/570540442eb123ef0b027da8b588b9b536c44371", "message": "Respond to Alec's comments", "committedDate": "2020-03-30T14:06:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMyMjIwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/879#discussion_r400322207", "body": "```suggestion\r\n\r\n```", "bodyText": "Suggested change", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"765\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "alecgrieser", "createdAt": "2020-03-30T16:20:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/FDBDatabase.java", "diffHunk": "@@ -717,15 +722,57 @@ protected Executor newContextExecutor() {\n         return factory.newContextExecutor();\n     }\n \n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     * @deprecated use {@link #openContext()} instead\n+     */\n+    @Deprecated\n+    @API(API.Status.DEPRECATED)\n     public Transaction createTransaction(Executor executor, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {\n+        return createTransaction(executor, null, mdcContext, transactionIsTraced);\n+    }\n+\n+    /**\n+     * Creates a new transaction against the database.\n+     *\n+     * @param executor the executor to be used for asynchronous operations\n+     * @param storeTimer if not {@code null}, will be used too track low level operations (e.g. reads/writes/deletes)\n+     * @param mdcContext if not [@code null} and tracing is enabled, information in the context will be included\n+     *      in tracing log messages\n+     * @param transactionIsTraced if true, the transaction will produce tracing messages (for example, logging when\n+     *      the transaction is cleaned up without having been closed)\n+     * @return newly created transaction\n+     */\n+    private Transaction createTransaction(Executor executor, @Nullable StoreTimer storeTimer, @Nullable Map<String, String> mdcContext, boolean transactionIsTraced) {\n         Transaction transaction = database.createTransaction(executor);\n+\n+        if (storeTimer != null) {\n+            transaction = new InstrumentedTransaction(storeTimer, transaction);\n+        }\n+\n         if (transactionIsTraced) {\n-            return new TracedTransaction(transaction, mdcContext);\n-        } else {\n-            return transaction;\n+            transaction = new TracedTransaction(transaction, mdcContext);\n+        }\n+\n+        return transaction;\n+    }\n+\n+    protected Executor newExecutor(@Nullable Map<String, String> mdcContext) {\n+        Executor executor = newContextExecutor();\n+        if (mdcContext != null) {\n+            executor = new ContextRestoringExecutor(executor, mdcContext);\n         }\n+        return executor;\n     }\n-    \n+\n+", "originalCommit": "570540442eb123ef0b027da8b588b9b536c44371", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "message": "Respond to Alec's comments", "committedDate": "2020-03-31T13:38:53Z", "type": "commit"}, {"oid": "1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/1b5a09008914142fbb8da6b8754e1ffd2d3b8ff1", "message": "Respond to Alec's comments", "committedDate": "2020-03-31T13:38:53Z", "type": "forcePushed"}]}