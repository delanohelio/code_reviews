{"pr_number": 843, "pr_title": "ddlog-jooq: support UPDATE queries", "pr_createdAt": "2020-12-05T06:58:33Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/843", "merge_commit": "ec57c2952b3ac91a46f9b737179e410a636acebc", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MjkyMA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537782920", "body": "so you use two different parsers? Can't you standardize on one?", "bodyText": "so you use two different parsers? Can't you standardize on one?", "bodyHTML": "<p dir=\"auto\">so you use two different parsers? Can't you standardize on one?</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:45:16Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -107,6 +103,9 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         // We translate DDL statements from the Presto dialect to H2.\n         // We then execute these statements in a temporary database so that JOOQ can extract useful metadata\n         // that we will use later (for example, the record types for views).\n+        final com.facebook.presto.sql.parser.SqlParser parser = new com.facebook.presto.sql.parser.SqlParser();", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgwODc0OA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537808748", "bodyText": "This has implications for the ddlog-sql compiler. Right now, that code expects DDL in Presto's dialect, which is why I have to convert from Presto's dialect here (and therefore need the Presto parser).", "author": "lalithsuresh", "createdAt": "2020-12-07T20:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MjkyMA=="}], "type": "inlineReview", "revised_code": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -103,9 +99,6 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         // We translate DDL statements from the Presto dialect to H2.\n         // We then execute these statements in a temporary database so that JOOQ can extract useful metadata\n         // that we will use later (for example, the record types for views).\n-        final com.facebook.presto.sql.parser.SqlParser parser = new com.facebook.presto.sql.parser.SqlParser();\n-        final ParsingOptions options = ParsingOptions.builder().build();\n-        final TranslateCreateTableDialect translateCreateTableDialect = new TranslateCreateTableDialect();\n         for (final String sql : sqlStatements) {\n             final Statement statement = parser.createStatement(sql, options);\n             final String statementInH2Dialect = translateCreateTableDialect.process(statement, sql);\n", "next_change": {"commit": "41cb5cc105e607b6a7f3a456d936f7211c9008e5", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..90912c41 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -99,6 +97,8 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         // We translate DDL statements from the Presto dialect to H2.\n         // We then execute these statements in a temporary database so that JOOQ can extract useful metadata\n         // that we will use later (for example, the record types for views).\n+        final com.facebook.presto.sql.parser.SqlParser parser = new com.facebook.presto.sql.parser.SqlParser();\n+        final ParsingOptions options = ParsingOptions.builder().build();\n         for (final String sql : sqlStatements) {\n             final Statement statement = parser.createStatement(sql, options);\n             final String statementInH2Dialect = translateCreateTableDialect.process(statement, sql);\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 90912c41..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -99,6 +98,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         // that we will use later (for example, the record types for views).\n         final com.facebook.presto.sql.parser.SqlParser parser = new com.facebook.presto.sql.parser.SqlParser();\n         final ParsingOptions options = ParsingOptions.builder().build();\n+        final TranslateCreateTableDialect translateCreateTableDialect = new TranslateCreateTableDialect();\n         for (final String sql : sqlStatements) {\n             final Statement statement = parser.createStatement(sql, options);\n             final String statementInH2Dialect = translateCreateTableDialect.process(statement, sql);\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -106,7 +115,12 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         }\n         for (final Table<?> table: dslContext.meta().getTables()) {\n             if (table.getSchema().getName().equals(\"PUBLIC\")) { // H2-specific assumption\n+                Arrays.stream(table.fields()).forEach(\n+                        (field) -> tablesToFieldMap.computeIfAbsent(table.getName(), (k) -> new HashMap<>())\n+                                .put(field.getUnqualifiedName().last().toUpperCase(), field)\n+                );\n                 tablesToFields.put(table.getName(), Arrays.asList(table.fields()));\n+                tablesToJooqTable.put(table.getName(), table);\n                 if (table.getPrimaryKey() != null) {\n                     tablesToPrimaryKeys.put(table.getName(), table.getPrimaryKey().getFields());\n                 }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NDYzMQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537784631", "body": "Why not visitSelect((SqlSelect)call)?", "bodyText": "Why not visitSelect((SqlSelect)call)?", "bodyHTML": "<p dir=\"auto\">Why not visitSelect((SqlSelect)call)?</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:47:45Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -201,23 +208,23 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect(call);\n+                    return visitSelect((SqlSelect) call);\n                 case INSERT:\n-                    return visitInsert(call);\n+                    return visitInsert((SqlInsert) call);\n                 case DELETE:\n-                    return visitDelete(call);\n+                    return visitDelete((SqlDelete) call);\n                 case UPDATE:\n-                    return visitUpdate(call);\n+                    return visitUpdate((SqlUpdate) call);\n                 default:\n                     return exception(call.toString());\n             }\n         }\n \n-        private MockResult visitSelect(final SqlCall call) {\n+        private MockResult visitSelect(final SqlSelect select) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                    && select.getSelectList().get(0).toString().equals(\"*\")\n+                    && select.getFrom() instanceof SqlIdentifier)) {\n                 return exception(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -208,35 +181,41 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect((SqlSelect) call);\n+                    return visitSelect(call);\n+                case UPDATE:\n+                    break;\n                 case INSERT:\n-                    return visitInsert((SqlInsert) call);\n+                    return visitInsert(call);\n                 case DELETE:\n-                    return visitDelete((SqlDelete) call);\n-                case UPDATE:\n-                    return visitUpdate((SqlUpdate) call);\n+                    return visitDelete(call);\n                 default:\n-                    return exception(call.toString());\n+                    throw new UnsupportedOperationException(call.toString());\n             }\n+            throw new RuntimeException(call.toString());\n         }\n \n-        private MockResult visitSelect(final SqlSelect select) {\n+        private MockResult visitSelect(final SqlCall call) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\")\n-                    && select.getFrom() instanceof SqlIdentifier)) {\n-                return exception(\"Statement not supported: \" + context.sql());\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final Result<Record> result = fetchTable(tableName);\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            if (fields == null) {\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                        context.sql()));\n+            }\n+            final Result<Record> result = dslContext.newResult(fields);\n+            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitInsert(final SqlInsert insert) {\n-            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n-            // (see javadoc for the DDlogJooqProvider class)\n-            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(insert.toString());\n+        private MockResult visitInsert(final SqlCall call) {\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                throw new UnsupportedOperationException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -213,9 +216,11 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         }\n \n         private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new UnsupportedOperationException(call.toString());\n+                throw new DDlogJooqProviderException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -215,12 +215,17 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n+        private MockResult visitUpdate(final SqlCall call) {\n+            System.out.println(call);\n+            return null;\n+        }\n+\n         private MockResult visitInsert(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new DDlogJooqProviderException(call.toString());\n+                return exception(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -185,47 +208,35 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect(call);\n-                case UPDATE:\n-                    return visitUpdate(call);\n+                    return visitSelect((SqlSelect) call);\n                 case INSERT:\n-                    return visitInsert(call);\n+                    return visitInsert((SqlInsert) call);\n                 case DELETE:\n-                    return visitDelete(call);\n+                    return visitDelete((SqlDelete) call);\n+                case UPDATE:\n+                    return visitUpdate((SqlUpdate) call);\n                 default:\n                     return exception(call.toString());\n             }\n         }\n \n-        private MockResult visitSelect(final SqlCall call) {\n+        private MockResult visitSelect(final SqlSelect select) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                    && select.getSelectList().get(0).toString().equals(\"*\")\n+                    && select.getFrom() instanceof SqlIdentifier)) {\n                 return exception(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                return exception(String.format(\"Unknown table %s queried in statement: %s\",\n-                                                                    tableName, context.sql()));\n-            }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n+            final Result<Record> result = fetchTable(tableName);\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitUpdate(final SqlCall call) {\n-            System.out.println(call);\n-            return null;\n-        }\n-\n-        private MockResult visitInsert(final SqlCall call) {\n+        private MockResult visitInsert(final SqlInsert insert) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlInsert insert = (SqlInsert) call;\n-            if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                return exception(call.toString());\n+            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(insert.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": null}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -223,7 +228,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new UnsupportedOperationException(call.toString());\n+                    throw new DDlogJooqProviderException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NTc1Nw==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537785757", "body": "This is not checked, but I guess you will get an exception anyway if it's not just a table.", "bodyText": "This is not checked, but I guess you will get an exception anyway if it's not just a table.", "bodyHTML": "<p dir=\"auto\">This is not checked, but I guess you will get an exception anyway if it's not just a table.</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:49:45Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxMDgxOQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537810819", "bodyText": "Yes, I'm hoping it'll fail anyway.", "author": "lalithsuresh", "createdAt": "2020-12-07T20:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NTc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -201,23 +208,23 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect(call);\n+                    return visitSelect((SqlSelect) call);\n                 case INSERT:\n-                    return visitInsert(call);\n+                    return visitInsert((SqlInsert) call);\n                 case DELETE:\n-                    return visitDelete(call);\n+                    return visitDelete((SqlDelete) call);\n                 case UPDATE:\n-                    return visitUpdate(call);\n+                    return visitUpdate((SqlUpdate) call);\n                 default:\n                     return exception(call.toString());\n             }\n         }\n \n-        private MockResult visitSelect(final SqlCall call) {\n+        private MockResult visitSelect(final SqlSelect select) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                    && select.getSelectList().get(0).toString().equals(\"*\")\n+                    && select.getFrom() instanceof SqlIdentifier)) {\n                 return exception(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -208,35 +181,41 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect((SqlSelect) call);\n+                    return visitSelect(call);\n+                case UPDATE:\n+                    break;\n                 case INSERT:\n-                    return visitInsert((SqlInsert) call);\n+                    return visitInsert(call);\n                 case DELETE:\n-                    return visitDelete((SqlDelete) call);\n-                case UPDATE:\n-                    return visitUpdate((SqlUpdate) call);\n+                    return visitDelete(call);\n                 default:\n-                    return exception(call.toString());\n+                    throw new UnsupportedOperationException(call.toString());\n             }\n+            throw new RuntimeException(call.toString());\n         }\n \n-        private MockResult visitSelect(final SqlSelect select) {\n+        private MockResult visitSelect(final SqlCall call) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\")\n-                    && select.getFrom() instanceof SqlIdentifier)) {\n-                return exception(\"Statement not supported: \" + context.sql());\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final Result<Record> result = fetchTable(tableName);\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            if (fields == null) {\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                        context.sql()));\n+            }\n+            final Result<Record> result = dslContext.newResult(fields);\n+            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitInsert(final SqlInsert insert) {\n-            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n-            // (see javadoc for the DDlogJooqProvider class)\n-            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(insert.toString());\n+        private MockResult visitInsert(final SqlCall call) {\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                throw new UnsupportedOperationException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -213,9 +216,11 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         }\n \n         private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new UnsupportedOperationException(call.toString());\n+                throw new DDlogJooqProviderException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -215,12 +215,17 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n+        private MockResult visitUpdate(final SqlCall call) {\n+            System.out.println(call);\n+            return null;\n+        }\n+\n         private MockResult visitInsert(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new DDlogJooqProviderException(call.toString());\n+                return exception(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -185,47 +208,35 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect(call);\n-                case UPDATE:\n-                    return visitUpdate(call);\n+                    return visitSelect((SqlSelect) call);\n                 case INSERT:\n-                    return visitInsert(call);\n+                    return visitInsert((SqlInsert) call);\n                 case DELETE:\n-                    return visitDelete(call);\n+                    return visitDelete((SqlDelete) call);\n+                case UPDATE:\n+                    return visitUpdate((SqlUpdate) call);\n                 default:\n                     return exception(call.toString());\n             }\n         }\n \n-        private MockResult visitSelect(final SqlCall call) {\n+        private MockResult visitSelect(final SqlSelect select) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                    && select.getSelectList().get(0).toString().equals(\"*\")\n+                    && select.getFrom() instanceof SqlIdentifier)) {\n                 return exception(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                return exception(String.format(\"Unknown table %s queried in statement: %s\",\n-                                                                    tableName, context.sql()));\n-            }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n+            final Result<Record> result = fetchTable(tableName);\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitUpdate(final SqlCall call) {\n-            System.out.println(call);\n-            return null;\n-        }\n-\n-        private MockResult visitInsert(final SqlCall call) {\n+        private MockResult visitInsert(final SqlInsert insert) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlInsert insert = (SqlInsert) call;\n-            if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                return exception(call.toString());\n+            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(insert.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": null}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -223,7 +228,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new UnsupportedOperationException(call.toString());\n+                    throw new DDlogJooqProviderException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -225,12 +232,11 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitInsert(final SqlCall call) {\n+        private MockResult visitInsert(final SqlInsert insert) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlInsert insert = (SqlInsert) call;\n-            if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                return exception(call.toString());\n+            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(insert.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -208,35 +181,41 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect((SqlSelect) call);\n+                    return visitSelect(call);\n+                case UPDATE:\n+                    break;\n                 case INSERT:\n-                    return visitInsert((SqlInsert) call);\n+                    return visitInsert(call);\n                 case DELETE:\n-                    return visitDelete((SqlDelete) call);\n-                case UPDATE:\n-                    return visitUpdate((SqlUpdate) call);\n+                    return visitDelete(call);\n                 default:\n-                    return exception(call.toString());\n+                    throw new UnsupportedOperationException(call.toString());\n             }\n+            throw new RuntimeException(call.toString());\n         }\n \n-        private MockResult visitSelect(final SqlSelect select) {\n+        private MockResult visitSelect(final SqlCall call) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\")\n-                    && select.getFrom() instanceof SqlIdentifier)) {\n-                return exception(\"Statement not supported: \" + context.sql());\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final Result<Record> result = fetchTable(tableName);\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            if (fields == null) {\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                        context.sql()));\n+            }\n+            final Result<Record> result = dslContext.newResult(fields);\n+            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitInsert(final SqlInsert insert) {\n-            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n-            // (see javadoc for the DDlogJooqProvider class)\n-            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(insert.toString());\n+        private MockResult visitInsert(final SqlCall call) {\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                throw new UnsupportedOperationException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -213,9 +216,11 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         }\n \n         private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new UnsupportedOperationException(call.toString());\n+                throw new DDlogJooqProviderException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -215,12 +215,17 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n+        private MockResult visitUpdate(final SqlCall call) {\n+            System.out.println(call);\n+            return null;\n+        }\n+\n         private MockResult visitInsert(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new DDlogJooqProviderException(call.toString());\n+                return exception(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -185,47 +208,35 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect(call);\n-                case UPDATE:\n-                    return visitUpdate(call);\n+                    return visitSelect((SqlSelect) call);\n                 case INSERT:\n-                    return visitInsert(call);\n+                    return visitInsert((SqlInsert) call);\n                 case DELETE:\n-                    return visitDelete(call);\n+                    return visitDelete((SqlDelete) call);\n+                case UPDATE:\n+                    return visitUpdate((SqlUpdate) call);\n                 default:\n                     return exception(call.toString());\n             }\n         }\n \n-        private MockResult visitSelect(final SqlCall call) {\n+        private MockResult visitSelect(final SqlSelect select) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                    && select.getSelectList().get(0).toString().equals(\"*\")\n+                    && select.getFrom() instanceof SqlIdentifier)) {\n                 return exception(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                return exception(String.format(\"Unknown table %s queried in statement: %s\",\n-                                                                    tableName, context.sql()));\n-            }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n+            final Result<Record> result = fetchTable(tableName);\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitUpdate(final SqlCall call) {\n-            System.out.println(call);\n-            return null;\n-        }\n-\n-        private MockResult visitInsert(final SqlCall call) {\n+        private MockResult visitInsert(final SqlInsert insert) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlInsert insert = (SqlInsert) call;\n-            if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                return exception(call.toString());\n+            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(insert.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": null}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -223,7 +228,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new UnsupportedOperationException(call.toString());\n+                    throw new DDlogJooqProviderException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -244,7 +223,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(insert.toString());\n+                    throw new UnsupportedOperationException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -223,7 +228,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new UnsupportedOperationException(call.toString());\n+                    throw new DDlogJooqProviderException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4Njc4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537786781", "body": "other people put the else on the same line with the }", "bodyText": "other people put the else on the same line with the }", "bodyHTML": "<p dir=\"auto\">other people put the else on the same line with the }</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:51:25Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -249,8 +255,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                         final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n                         recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                }\n-                else {\n+                } else {\n                     // need to parse literals into DDLogRecords\n                     for (int i = 0; i < rowElements.length; i++) {\n                         final boolean isNullableField = fields.get(i).getDataType().nullable();\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -255,20 +234,22 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                         final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n                         recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                } else {\n+                }\n+                else {\n                     // need to parse literals into DDLogRecords\n                     for (int i = 0; i < rowElements.length; i++) {\n                         final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        final DDlogRecord result = rowElements[i].accept(parseLiterals);\n                         recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n                 }\n+                final DDlogRecord record;\n                 try {\n-                    final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n+                    record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n                 } catch (final DDlogException e) {\n-                    return exception(e);\n+                    throw new RuntimeException(e);\n                 }\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -239,17 +244,16 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                     // need to parse literals into DDLogRecords\n                     for (int i = 0; i < rowElements.length; i++) {\n                         final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                        final DDlogRecord result = rowElements[i].accept(parseLiterals);\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n                         recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n                 }\n-                final DDlogRecord record;\n                 try {\n-                    record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n+                    final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n                 } catch (final DDlogException e) {\n-                    throw new RuntimeException(e);\n+                    throw new DDlogJooqProviderException(e);\n                 }\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -253,7 +258,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n                 } catch (final DDlogException e) {\n-                    throw new DDlogJooqProviderException(e);\n+                    return exception(e);\n                 }\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NzkwNA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537787904", "body": "\"not supported\" sounds a bit better than \"unsupported\"", "bodyText": "\"not supported\" sounds a bit better than \"unsupported\"", "bodyHTML": "<p dir=\"auto\">\"not supported\" sounds a bit better than \"unsupported\"</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:53:07Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -273,15 +278,14 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(values.length, result);\n         }\n \n-        private MockResult visitDelete(final SqlCall call) {\n+        private MockResult visitDelete(final SqlDelete delete) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlDelete delete = (SqlDelete) call;\n-            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n-            if (delete.getCondition() == null) {\n-                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            if (delete.getCondition() == null || !(delete.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(\"Delete queries without where clauses are not supported: \" + context.sql());\n             }\n             try {\n+                final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n                 final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n                 final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n                 final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -278,66 +259,27 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(values.length, result);\n         }\n \n-        private MockResult visitDelete(final SqlDelete delete) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            if (delete.getCondition() == null || !(delete.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(\"Delete queries without where clauses are not supported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n                 final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n-                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n-                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n-                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n-            } catch (final DDlogException e) {\n-                return exception(e);\n-            }\n-            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-            resultRecord.setValue(updateCountField, 1);\n-            result.add(resultRecord);\n-            return new MockResult(1, result);\n-        }\n-\n-        private MockResult visitUpdate(final SqlUpdate update) {\n-            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n-            // (see javadoc for the DDlogJooqProvider class)\n-            if (update.getCondition() == null || !(update.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(\"Update queries without where clauses are not supported: \" + context.sql());\n-            }\n-            try {\n-                final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n-                final Map<String, Field<?>> allFields = tablesToFieldMap.get(tableName.toUpperCase());\n-                final int numColumnsToUpdate = update.getTargetColumnList().size();\n-                final SqlNodeList targetColumnList = update.getTargetColumnList();\n-                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n-                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n-                for (int i = 0; i < numColumnsToUpdate; i++) {\n-                    final String columnName = ((SqlIdentifier) targetColumnList.get(i)).getSimple()\n-                                                                                       .toLowerCase();\n-                    final Field<?> field = allFields.get(columnName.toUpperCase());\n-                    final boolean isNullableField = field.getDataType().nullable();\n-                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n-                            ? toValue(field, context.nextBinding())\n-                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n-                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n-                    updatedValues[i] = maybeWrapped;\n-                    columnsToUpdate[i] = columnName;\n-                }\n+                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName, context);\n+                where.accept(visitor);\n+                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n+                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                        : matchExpression[0];\n \n-                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n-                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n-                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n-\n-                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                return exception(e);\n+                throw new RuntimeException(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -279,7 +284,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                throw new DDlogJooqProviderException(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -284,7 +289,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new DDlogJooqProviderException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "4679477dae4d7dec057eb733edbd3983bb954f8a", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..65292ca3 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -297,21 +297,77 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n+\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n+\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n+\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n+            }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n     }\n \n-    private class WhereClauseToMatchExpression extends SqlBasicVisitor<Void> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n-        final QueryContext context;\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n \n-        public WhereClauseToMatchExpression(final String tableName, final QueryContext context) {\n-            this.tableName = tableName;\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n             this.context = context;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        public Void visit(final SqlCall call) {\n+        public DDlogRecord[] visit(final SqlCall call) {\n             final SqlBasicCall expr = (SqlBasicCall) call;\n             switch (expr.getOperator().getKind()) {\n                 case AND:\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "ec57c2952b3ac91a46f9b737179e410a636acebc", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -273,15 +278,14 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(values.length, result);\n         }\n \n-        private MockResult visitDelete(final SqlCall call) {\n+        private MockResult visitDelete(final SqlDelete delete) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlDelete delete = (SqlDelete) call;\n-            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n-            if (delete.getCondition() == null) {\n-                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            if (delete.getCondition() == null || !(delete.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(\"Delete queries without where clauses are not supported: \" + context.sql());\n             }\n             try {\n+                final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n                 final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n                 final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n                 final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n", "next_change": {"commit": "22bc06fe417c5beb3a248b802cddd38c3287fb09", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..698b4fca 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -288,6 +299,9 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                 final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n                 final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n                 final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                if (pkFields == null) {\n+                    return exception(String.format(\"Table %s does not exist: \", tableName) + context.sql());\n+                }\n                 final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n", "next_change": {"commit": "223a98d4a9a9139a40e79bddf5a20d424fb422b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 698b4fca..3e31d579 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -282,41 +363,113 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                     return exception(e);\n                 }\n             }\n-            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-            resultRecord.setValue(updateCountField, values.length);\n-            result.add(resultRecord);\n-            return new MockResult(values.length, result);\n+            return updateCountFieldResult();\n         }\n \n-        private MockResult visitDelete(final SqlDelete delete) throws DDlogException {\n+        // Check for case-insensitive string equality\n+        private boolean compareStringArrays(String[] ary1, String[] ary2) {\n+            if (ary1.length != ary2.length) {\n+                return false;\n+            }\n+            for (int i = 0; i < ary1.length; i++) {\n+                if (!ary1[i].equalsIgnoreCase(ary2[i])) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private MockResult deleteByIndex(String tableName, String[] ids, SqlBasicCall where) throws DDlogException {\n+            final List<DDlogRecord> clonedResults = new ArrayList<>();\n+\n+            // If there are no PKs for this table, or if the PK given doesn't match the fields requested by this\n+            // query, then we have to look in any indexes on the table.\n+            List<ParsedCreateIndex> indexes = tablesToIndexesMap.get(tableName);\n+            if (indexes == null) {\n+                return exception(String.format(\"Cannot delete from table %s: no appropriate primary key\" +\n+                        \"and no indexes\", tableName));\n+            }\n+            // Look through the indexes to see if there's a matching index\n+            ParsedCreateIndex matchingIndex = null;\n+            for (ParsedCreateIndex id : indexes) {\n+                // Check for equality\n+                if (!compareStringArrays(id.getColumns(), ids)) {\n+                    continue;\n+                }\n+                matchingIndex = id;\n+                break;\n+            }\n+            if (matchingIndex == null) {\n+                return exception(String.format(\"Cannot delete from table %s: no appropriate index\",\n+                        tableName));\n+            }\n+            // Use the matching index to fetch the row, and then delete it\n+            final DDlogRecord indexKey =\n+                    matchExpressionFromWhere(where, indexToFieldsMap.get(matchingIndex.getIndexName()), context);\n+\n+            dDlogAPI.queryIndex(DDlogIndexDeclaration.indexName(matchingIndex.getIndexName()), indexKey, x -> {\n+                clonedResults.add(x.clone());\n+            } );\n+\n+            if (clonedResults.size() == 0) {\n+                // There was nothing to delete\n+                return emptyMockResult();\n+            }\n+\n+            // Delete the records returned\n+            for (DDlogRecord r : clonedResults) {\n+                DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteVal,\n+                        dDlogAPI.getTableId(ddlogRelationName(tableName)), r);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                // Now release the cloned command\n+                r.release();\n+            }\n+            return updateCountFieldResult();\n+        }\n+\n+        private MockResult visitDelete(final SqlDelete delete) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n             if (delete.getCondition() == null || !(delete.getTargetTable() instanceof SqlIdentifier)) {\n                 return exception(\"Delete queries without where clauses are not supported: \" + context.sql());\n             }\n+\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+\n+            if (tablesToFields.get(tableName) == null) {\n+                return exception(String.format(\"Table %s does not exist: \", tableName) + context.sql());\n+            }\n+            // Get fields requested in the where condition\n+            WhereClauseGetIdentifiers getIdentifiers = new WhereClauseGetIdentifiers();\n+            String[] ids = where.accept(getIdentifiers).toArray(new String[0]);\n+\n+            final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName);\n+\n             try {\n-                final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n-                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n-                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n-                if (pkFields == null) {\n-                    return exception(String.format(\"Table %s does not exist: \", tableName) + context.sql());\n+                // If a primary key for this table exists AND its columns match the columns request in the WHERE clause,\n+                // then use the primary key\n+                if (pkFields != null &&\n+                        compareStringArrays(ids,\n+                                pkFields.stream().map(x -> x.getUnqualifiedName().unquotedName().toString()).toArray(String[]::new))) {\n+                    final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n+                    final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                    final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n+                    dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } else {\n+                    // If there are no PKs for this table, or if the PK given doesn't match the fields requested by this\n+                    // query, then we have to look in any indexes on the table.\n+                    return deleteByIndex(tableName, ids, where);\n                 }\n-                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n-                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n+                if (e.getMessage().contains(\"key not found\"))\n+                    return emptyMockResult();\n                 return exception(e);\n             }\n-            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-            resultRecord.setValue(updateCountField, 1);\n-            result.add(resultRecord);\n-            return new MockResult(1, result);\n+            return updateCountFieldResult();\n         }\n \n-        private MockResult visitUpdate(final SqlUpdate update) throws DDlogException {\n+        private MockResult visitUpdate(final SqlUpdate update) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n             // (see javadoc for the DDlogJooqProvider class)\n             if (update.getCondition() == null || !(update.getTargetTable() instanceof SqlIdentifier)) {\n", "next_change": {"commit": "20cf2bd8a7a8d08fa761aebd743008966fc2a235", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 3e31d579..60065281 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -477,9 +475,10 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             }\n             try {\n                 final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n-                final Map<String, Field<?>> allFields = tablesToFieldMap.get(tableName.toUpperCase());\n+                DDlogJooqHelper.NormalizedTableName tn = new DDlogJooqHelper.NormalizedTableName(tableName);\n+                final Map<String, Field<?>> allFields = tablesToFieldMap.get(tn);\n                 if (allFields == null) {\n-                    return exception(String.format(\"Table %s does not exist: \", tableName) + context.sql());\n+                    return exception(String.format(\"Table %s does not exist: \", tn) + context.sql());\n                 }\n                 final int numColumnsToUpdate = update.getTargetColumnList().size();\n                 final SqlNodeList targetColumnList = update.getTargetColumnList();\n", "next_change": {"commit": "a18d44be2f5365e1688d3ed674145c4676709987", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 60065281..30d7439d 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -475,7 +480,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             }\n             try {\n                 final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n-                DDlogJooqHelper.NormalizedTableName tn = new DDlogJooqHelper.NormalizedTableName(tableName);\n+                final DDlogJooqHelper.NormalizedTableName tn = new DDlogJooqHelper.NormalizedTableName(tableName);\n                 final Map<String, Field<?>> allFields = tablesToFieldMap.get(tn);\n                 if (allFields == null) {\n                     return exception(String.format(\"Table %s does not exist: \", tn) + context.sql());\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "ec57c2952b3ac91a46f9b737179e410a636acebc", "message": "Merge commit", "committedDate": null}, {"oid": "39416f589d1f11105494a197a7f8d2f60a209f49", "committedDate": "2021-03-11 22:58:28 -0800", "message": "Address review feedback."}, {"oid": "22bc06fe417c5beb3a248b802cddd38c3287fb09", "committedDate": "2021-07-30 11:27:02 -0700", "message": "sql: handle non-existent relation errors consistently (#1034)"}, {"oid": "bb7265165ae40131f747926f737a66acc703634f", "committedDate": "2021-08-12 11:20:22 -0700", "message": "Allow null values to be manipulated at runtime"}, {"oid": "45c06e09b3e009af2e01b3c4c84d9407e3f5feeb", "committedDate": "2021-08-12 11:20:22 -0700", "message": "Add more tests"}, {"oid": "60ffacbb1eb62f55501655cd4e613a987ac1bf21", "committedDate": "2021-08-12 11:20:22 -0700", "message": "Harden error handling; handle null values"}, {"oid": "90052e4f635871c7201860083f7c74bd5ccb1cc0", "committedDate": "2021-08-16 13:22:55 -0700", "message": "Use MIT license for all Java files in SQL compiler (#1049)"}, {"oid": "892d20b3f112c9607c5f12284037d762c7bae4a1", "committedDate": "2021-08-18 11:42:57 -0700", "message": "Add Calcite translator for ddlog-sql (#1044)"}, {"oid": "279af24b468961227cc0aa9c083618081338e482", "committedDate": "2021-09-23 10:41:09 -0700", "message": "Expose DDlogJooqProvider DSLContext (#1086)"}, {"oid": "decfd1d59da7e2c6e030db8382b3687b22ac1a34", "committedDate": "2021-09-28 10:31:30 -0700", "message": "Translate vector-type fields properly in DDlogJooqProvider (#1089)"}, {"oid": "369c7bb46cbb56d1d46704ba9eeafdc2330e8773", "committedDate": "2021-09-30 15:23:36 -0700", "message": "Add support for identity views for input tables in DDlogJooqProvider (#1094)"}, {"oid": "223a98d4a9a9139a40e79bddf5a20d424fb422b4", "committedDate": "2021-10-13 16:08:29 -0700", "message": "Support deletes on indexes in DDlogJooqProvider (#1100)"}, {"oid": "0ca0abe8ea795c2865b5e1c8525000c6aebdeb3c", "committedDate": "2021-10-14 09:09:45 -0700", "message": "Enable select * queries that write out all the column names in DDlogJooqProvider (#1103)"}, {"oid": "5a430677b51c5fcefe69cb4afd864df02df9cc6f", "committedDate": "2021-10-14 10:04:53 -0700", "message": "Support selects with where on matching index in DDlogJooqProvider (#1102)"}, {"oid": "15259e18707a5832284becadfcbd5f2187bf2ed4", "committedDate": "2021-11-01 10:07:17 -0700", "message": "Refactor and cleanup DDlogJooqProvider (#1104)"}, {"oid": "20cf2bd8a7a8d08fa761aebd743008966fc2a235", "committedDate": "2021-11-18 16:49:53 -0800", "message": "Efficient SQL join implementation (#1117)"}, {"oid": "a18d44be2f5365e1688d3ed674145c4676709987", "committedDate": "2021-11-30 13:18:44 -0800", "message": "Check for identity views in fetchTable() to permit fast reads of materialized views (#1119)"}, {"oid": "84409544e7e0ff80c9143e5c0310392ca134de76", "committedDate": "2021-11-30 13:47:34 -0800", "message": "fetchTable() should return a defensive copy of the records (#1121)"}, {"oid": "2fce9e84d1049bcd9c61523af5554d0489394418", "committedDate": "2021-11-30 14:11:02 -0800", "message": "Correctly account for identity views in fetchTable() (#1122)"}, {"oid": "7c379e3ee3b788009f22ba3edb122e2567b4ab41", "committedDate": "2022-02-11 17:34:17 -0800", "message": "Lock around new transaction in DDlogJooqProvider (#1138)"}, {"oid": "4ace4ea2fdad61b0c1aa068e84378a7ab1f6b0aa", "committedDate": "2022-02-16 10:31:44 -0800", "message": "Represent vector columns by reference (#1151)"}, {"oid": "675e45b12da55463e647654d72fd4b408ad06837", "committedDate": "2022-04-21 17:32:17 -0700", "message": "Upgrade libraries (#1156)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODM3Nw==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537788377", "body": "this line occurs in every function, maybe you can make it a separate method and do some nicer error handling?", "bodyText": "this line occurs in every function, maybe you can make it a separate method and do some nicer error handling?", "bodyHTML": "<p dir=\"auto\">this line occurs in every function, maybe you can make it a separate method and do some nicer error handling?</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:53:59Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxNDUyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537814521", "bodyText": "getTargetTable() and getFrom() are not abstract methods, so it won't be easy to have a single method to do this. I've added an instanceof check to the beginning of each visit method.", "author": "lalithsuresh", "createdAt": "2020-12-07T20:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODM3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -225,12 +232,11 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitInsert(final SqlCall call) {\n+        private MockResult visitInsert(final SqlInsert insert) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlInsert insert = (SqlInsert) call;\n-            if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                return exception(call.toString());\n+            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(insert.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -208,35 +181,41 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect((SqlSelect) call);\n+                    return visitSelect(call);\n+                case UPDATE:\n+                    break;\n                 case INSERT:\n-                    return visitInsert((SqlInsert) call);\n+                    return visitInsert(call);\n                 case DELETE:\n-                    return visitDelete((SqlDelete) call);\n-                case UPDATE:\n-                    return visitUpdate((SqlUpdate) call);\n+                    return visitDelete(call);\n                 default:\n-                    return exception(call.toString());\n+                    throw new UnsupportedOperationException(call.toString());\n             }\n+            throw new RuntimeException(call.toString());\n         }\n \n-        private MockResult visitSelect(final SqlSelect select) {\n+        private MockResult visitSelect(final SqlCall call) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\")\n-                    && select.getFrom() instanceof SqlIdentifier)) {\n-                return exception(\"Statement not supported: \" + context.sql());\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final Result<Record> result = fetchTable(tableName);\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            if (fields == null) {\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                        context.sql()));\n+            }\n+            final Result<Record> result = dslContext.newResult(fields);\n+            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitInsert(final SqlInsert insert) {\n-            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n-            // (see javadoc for the DDlogJooqProvider class)\n-            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(insert.toString());\n+        private MockResult visitInsert(final SqlCall call) {\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                throw new UnsupportedOperationException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -213,9 +216,11 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         }\n \n         private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new UnsupportedOperationException(call.toString());\n+                throw new DDlogJooqProviderException(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -215,12 +215,17 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n+        private MockResult visitUpdate(final SqlCall call) {\n+            System.out.println(call);\n+            return null;\n+        }\n+\n         private MockResult visitInsert(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n             final SqlInsert insert = (SqlInsert) call;\n             if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                throw new DDlogJooqProviderException(call.toString());\n+                return exception(call.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -185,47 +208,35 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         public MockResult visit(final SqlCall call) {\n             switch (call.getKind()) {\n                 case SELECT:\n-                    return visitSelect(call);\n-                case UPDATE:\n-                    return visitUpdate(call);\n+                    return visitSelect((SqlSelect) call);\n                 case INSERT:\n-                    return visitInsert(call);\n+                    return visitInsert((SqlInsert) call);\n                 case DELETE:\n-                    return visitDelete(call);\n+                    return visitDelete((SqlDelete) call);\n+                case UPDATE:\n+                    return visitUpdate((SqlUpdate) call);\n                 default:\n                     return exception(call.toString());\n             }\n         }\n \n-        private MockResult visitSelect(final SqlCall call) {\n+        private MockResult visitSelect(final SqlSelect select) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final SqlSelect select = (SqlSelect) call;\n             if (!(select.getSelectList().size() == 1\n-                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                    && select.getSelectList().get(0).toString().equals(\"*\")\n+                    && select.getFrom() instanceof SqlIdentifier)) {\n                 return exception(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                return exception(String.format(\"Unknown table %s queried in statement: %s\",\n-                                                                    tableName, context.sql()));\n-            }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n+            final Result<Record> result = fetchTable(tableName);\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitUpdate(final SqlCall call) {\n-            System.out.println(call);\n-            return null;\n-        }\n-\n-        private MockResult visitInsert(final SqlCall call) {\n+        private MockResult visitInsert(final SqlInsert insert) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlInsert insert = (SqlInsert) call;\n-            if (insert.getSource().getKind() != SqlKind.VALUES) {\n-                return exception(call.toString());\n+            if (insert.getSource().getKind() != SqlKind.VALUES || !(insert.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(insert.toString());\n             }\n             final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n             final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n", "next_change": null}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -223,7 +228,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new UnsupportedOperationException(call.toString());\n+                    throw new DDlogJooqProviderException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -244,7 +223,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(insert.toString());\n+                    throw new UnsupportedOperationException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -223,7 +228,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new UnsupportedOperationException(call.toString());\n+                    throw new DDlogJooqProviderException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -238,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -244,7 +223,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(insert.toString());\n+                    throw new UnsupportedOperationException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -223,7 +228,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new UnsupportedOperationException(call.toString());\n+                    throw new DDlogJooqProviderException(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -228,7 +233,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    throw new DDlogJooqProviderException(call.toString());\n+                    return exception(call.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": {"commit": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -233,7 +244,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n             for (final SqlNode value: values) {\n                 if (value.getKind() != SqlKind.ROW) {\n-                    return exception(call.toString());\n+                    return exception(insert.toString());\n                 }\n                 final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n                 final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODk2OQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537788969", "body": "do you want to lift getTargetColumnList out of the loop?", "bodyText": "do you want to lift getTargetColumnList out of the loop?", "bodyHTML": "<p dir=\"auto\">do you want to lift getTargetColumnList out of the loop?</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:54:53Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -298,26 +302,23 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitUpdate(final SqlCall call) {\n+        private MockResult visitUpdate(final SqlUpdate update) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlUpdate update = (SqlUpdate) call;\n-            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n-            if (update.getCondition() == null) {\n-                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            if (update.getCondition() == null || !(update.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(\"Update queries without where clauses are not supported: \" + context.sql());\n             }\n             try {\n-                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+                final Map<String, Field<?>> allFields = tablesToFieldMap.get(tableName.toUpperCase());\n                 final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final SqlNodeList targetColumnList = update.getTargetColumnList();\n                 final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n                 final String[] columnsToUpdate = new String[numColumnsToUpdate];\n                 for (int i = 0; i < numColumnsToUpdate; i++) {\n-                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n-                            .toLowerCase();\n-                    final Field<?> field = allFields.stream()\n-                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n-                            .findFirst()\n-                            .get();\n+                    final String columnName = ((SqlIdentifier) targetColumnList.get(i)).getSimple()\n+                                                                                       .toLowerCase();\n+                    final Field<?> field = allFields.get(columnName.toUpperCase());\n                     final boolean isNullableField = field.getDataType().nullable();\n                     final DDlogRecord valueToUpdateTo = context.hasBinding()\n                             ? toValue(field, context.nextBinding())\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -278,66 +259,27 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(values.length, result);\n         }\n \n-        private MockResult visitDelete(final SqlDelete delete) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            if (delete.getCondition() == null || !(delete.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(\"Delete queries without where clauses are not supported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n                 final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n-                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n-                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n-                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n-            } catch (final DDlogException e) {\n-                return exception(e);\n-            }\n-            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-            resultRecord.setValue(updateCountField, 1);\n-            result.add(resultRecord);\n-            return new MockResult(1, result);\n-        }\n-\n-        private MockResult visitUpdate(final SqlUpdate update) {\n-            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n-            // (see javadoc for the DDlogJooqProvider class)\n-            if (update.getCondition() == null || !(update.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(\"Update queries without where clauses are not supported: \" + context.sql());\n-            }\n-            try {\n-                final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n-                final Map<String, Field<?>> allFields = tablesToFieldMap.get(tableName.toUpperCase());\n-                final int numColumnsToUpdate = update.getTargetColumnList().size();\n-                final SqlNodeList targetColumnList = update.getTargetColumnList();\n-                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n-                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n-                for (int i = 0; i < numColumnsToUpdate; i++) {\n-                    final String columnName = ((SqlIdentifier) targetColumnList.get(i)).getSimple()\n-                                                                                       .toLowerCase();\n-                    final Field<?> field = allFields.get(columnName.toUpperCase());\n-                    final boolean isNullableField = field.getDataType().nullable();\n-                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n-                            ? toValue(field, context.nextBinding())\n-                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n-                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n-                    updatedValues[i] = maybeWrapped;\n-                    columnsToUpdate[i] = columnName;\n-                }\n+                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName, context);\n+                where.accept(visitor);\n+                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n+                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                        : matchExpression[0];\n \n-                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n-                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n-                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n-\n-                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                return exception(e);\n+                throw new RuntimeException(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -279,7 +284,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                throw new DDlogJooqProviderException(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -284,7 +289,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new DDlogJooqProviderException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "4679477dae4d7dec057eb733edbd3983bb954f8a", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..65292ca3 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -297,21 +297,77 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n+\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n+\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n+\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n+            }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n     }\n \n-    private class WhereClauseToMatchExpression extends SqlBasicVisitor<Void> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n-        final QueryContext context;\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n \n-        public WhereClauseToMatchExpression(final String tableName, final QueryContext context) {\n-            this.tableName = tableName;\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n             this.context = context;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        public Void visit(final SqlCall call) {\n+        public DDlogRecord[] visit(final SqlCall call) {\n             final SqlBasicCall expr = (SqlBasicCall) call;\n             switch (expr.getOperator().getKind()) {\n                 case AND:\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTYwNQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537789605", "body": "This is a linear search. Could become expensive if you have many fields. You could build a hashmap with this information...", "bodyText": "This is a linear search. Could become expensive if you have many fields. You could build a hashmap with this information...", "bodyHTML": "<p dir=\"auto\">This is a linear search. Could become expensive if you have many fields. You could build a hashmap with this information...</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:55:53Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..4d40c5ab 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -298,26 +302,23 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(1, result);\n         }\n \n-        private MockResult visitUpdate(final SqlCall call) {\n+        private MockResult visitUpdate(final SqlUpdate update) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n             // (see javadoc for the DDlogJooqProvider class)\n-            final SqlUpdate update = (SqlUpdate) call;\n-            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n-            if (update.getCondition() == null) {\n-                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            if (update.getCondition() == null || !(update.getTargetTable() instanceof SqlIdentifier)) {\n+                return exception(\"Update queries without where clauses are not supported: \" + context.sql());\n             }\n             try {\n-                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+                final Map<String, Field<?>> allFields = tablesToFieldMap.get(tableName.toUpperCase());\n                 final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final SqlNodeList targetColumnList = update.getTargetColumnList();\n                 final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n                 final String[] columnsToUpdate = new String[numColumnsToUpdate];\n                 for (int i = 0; i < numColumnsToUpdate; i++) {\n-                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n-                            .toLowerCase();\n-                    final Field<?> field = allFields.stream()\n-                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n-                            .findFirst()\n-                            .get();\n+                    final String columnName = ((SqlIdentifier) targetColumnList.get(i)).getSimple()\n+                                                                                       .toLowerCase();\n+                    final Field<?> field = allFields.get(columnName.toUpperCase());\n                     final boolean isNullableField = field.getDataType().nullable();\n                     final DDlogRecord valueToUpdateTo = context.hasBinding()\n                             ? toValue(field, context.nextBinding())\n", "next_change": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 4d40c5ab..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -278,66 +259,27 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             return new MockResult(values.length, result);\n         }\n \n-        private MockResult visitDelete(final SqlDelete delete) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            if (delete.getCondition() == null || !(delete.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(\"Delete queries without where clauses are not supported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n                 final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n-                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n-                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n-                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n-            } catch (final DDlogException e) {\n-                return exception(e);\n-            }\n-            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-            resultRecord.setValue(updateCountField, 1);\n-            result.add(resultRecord);\n-            return new MockResult(1, result);\n-        }\n-\n-        private MockResult visitUpdate(final SqlUpdate update) {\n-            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n-            // (see javadoc for the DDlogJooqProvider class)\n-            if (update.getCondition() == null || !(update.getTargetTable() instanceof SqlIdentifier)) {\n-                return exception(\"Update queries without where clauses are not supported: \" + context.sql());\n-            }\n-            try {\n-                final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n-                final Map<String, Field<?>> allFields = tablesToFieldMap.get(tableName.toUpperCase());\n-                final int numColumnsToUpdate = update.getTargetColumnList().size();\n-                final SqlNodeList targetColumnList = update.getTargetColumnList();\n-                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n-                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n-                for (int i = 0; i < numColumnsToUpdate; i++) {\n-                    final String columnName = ((SqlIdentifier) targetColumnList.get(i)).getSimple()\n-                                                                                       .toLowerCase();\n-                    final Field<?> field = allFields.get(columnName.toUpperCase());\n-                    final boolean isNullableField = field.getDataType().nullable();\n-                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n-                            ? toValue(field, context.nextBinding())\n-                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n-                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n-                    updatedValues[i] = maybeWrapped;\n-                    columnsToUpdate[i] = columnName;\n-                }\n+                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName, context);\n+                where.accept(visitor);\n+                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n+                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                        : matchExpression[0];\n \n-                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n-                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n-                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n-\n-                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                return exception(e);\n+                throw new RuntimeException(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..a35b7358 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -279,7 +284,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                throw new DDlogJooqProviderException(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex a35b7358..71843415 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -284,7 +289,7 @@ public final class DDlogJooqProvider implements MockDataProvider {\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new DDlogJooqProviderException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n", "next_change": {"commit": "4679477dae4d7dec057eb733edbd3983bb954f8a", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 71843415..65292ca3 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -297,21 +297,77 @@ public final class DDlogJooqProvider implements MockDataProvider {\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n+\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n+\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n+\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n+            }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n     }\n \n-    private class WhereClauseToMatchExpression extends SqlBasicVisitor<Void> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n-        final QueryContext context;\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n \n-        public WhereClauseToMatchExpression(final String tableName, final QueryContext context) {\n-            this.tableName = tableName;\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n             this.context = context;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        public Void visit(final SqlCall call) {\n+        public DDlogRecord[] visit(final SqlCall call) {\n             final SqlBasicCall expr = (SqlBasicCall) call;\n             switch (expr.getOperator().getKind()) {\n                 case AND:\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537792052", "body": "what does this do, concatenate the arrays?", "bodyText": "what does this do, concatenate the arrays?", "bodyHTML": "<p dir=\"auto\">what does this do, concatenate the arrays?</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:59:38Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n \n-        public ParseWhereClauseForDeletes(final String tableName) {\n-            this.tableName = tableName;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n-        }\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n \n-        @Override\n-        protected Void visitLogicalBinaryExpression(final LogicalBinaryExpression node, final QueryContext context) {\n-            if (!node.getOperator().equals(LogicalBinaryExpression.Operator.AND)) {\n-                throw new RuntimeException(\"Only equality-based comparisons on \" +\n-                        \"all (not some) primary-key columns are allowed: \" + node);\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n             }\n-            return super.visitLogicalBinaryExpression(node, context);\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n+    }\n+\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n+\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n+            this.context = context;\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        protected Void visitComparisonExpression(final ComparisonExpression node, final QueryContext context) {\n-            final Expression left = node.getLeft();\n-            final Expression right = node.getRight();\n-            if (context.hasBinding()) {\n-                if (left instanceof Identifier && right instanceof Parameter) {\n-                    setMatchExpression((Identifier) left, context.nextBinding());\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Parameter) {\n-                    setMatchExpression((Identifier) right, context.nextBinding());\n-                    return null;\n-                }\n-            } else {\n-                if (left instanceof Identifier && right instanceof Literal) {\n-                    setMatchExpression((Identifier) left, (Literal) right);\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Literal) {\n-                    setMatchExpression((Identifier) right, (Literal) left);\n-                    return null;\n-                }\n+        public DDlogRecord[] visit(final SqlCall call) {\n+            final SqlBasicCall expr = (SqlBasicCall) call;\n+            switch (expr.getOperator().getKind()) {\n+                case AND:\n+                    return super.visit(call);", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjYyOA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537842628", "bodyText": "It should, it doesn't, and good catch. :) I'll add a test that exercises this case.", "author": "lalithsuresh", "createdAt": "2020-12-07T21:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5OTg4Mg==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537899882", "bodyText": "Actually, now that I look at the code, there's no change necessary. It just returns the matchExpressions[] array, which by the time that call returns, would have traversed every \"EQUALS\" node.\nI still need to add a test for this case. Will do that in the updated PR.", "author": "lalithsuresh", "createdAt": "2020-12-07T23:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 65292ca3..27134e1e 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -346,28 +289,19 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         }\n     }\n \n-    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n-                                                        final List<? extends Field<?>> pkFields,\n-                                                        final QueryContext context) throws DDlogException {\n-        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n-        final DDlogRecord[] matchExpression = where.accept(visitor);\n-        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                              : matchExpression[0];\n-    }\n+    private class ParseWhereClauseForDeletes extends SqlBasicVisitor<Void> {\n+        final DDlogRecord[] matchExpressions;\n+        final String tableName;\n+        final QueryContext context;\n \n-    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n-        private final DDlogRecord[] matchExpressions;\n-        private final QueryContext context;\n-        private final List<? extends Field<?>> pkFields;\n-\n-        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n+        public ParseWhereClauseForDeletes(final String tableName, final QueryContext context) {\n+            this.tableName = tableName;\n             this.context = context;\n-            this.pkFields = pkFields;\n-            this.matchExpressions = new DDlogRecord[pkFields.size()];\n+            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n         }\n \n         @Override\n-        public DDlogRecord[] visit(final SqlCall call) {\n+        public Void visit(final SqlCall call) {\n             final SqlBasicCall expr = (SqlBasicCall) call;\n             switch (expr.getOperator().getKind()) {\n                 case AND:\n", "next_change": {"commit": "1b1275648226e7e3ea7d62750145dac195e341f4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\nindex 27134e1e..08756c11 100644\n--- a/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n+++ b/sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java\n", "chunk": "@@ -289,19 +297,19 @@ public final class DDlogJooqProvider implements MockDataProvider {\n         }\n     }\n \n-    private class ParseWhereClauseForDeletes extends SqlBasicVisitor<Void> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n-        final QueryContext context;\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n \n-        public ParseWhereClauseForDeletes(final String tableName, final QueryContext context) {\n-            this.tableName = tableName;\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n             this.context = context;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        public Void visit(final SqlCall call) {\n+        public DDlogRecord[] visit(final SqlCall call) {\n             final SqlBasicCall expr = (SqlBasicCall) call;\n             switch (expr.getOperator().getKind()) {\n                 case AND:\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjcyOA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537792728", "body": "CHAR is string?", "bodyText": "CHAR is string?", "bodyHTML": "<p dir=\"auto\">CHAR is string?</p>", "author": "mbudiu-vmw", "createdAt": "2020-12-07T20:00:47Z", "path": "sql/src/main/java/com/vmware/ddlog/ParseLiterals.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2018-2020 VMware, Inc. All Rights Reserved.\n+ * SPDX-License-Identifier: BSD-2\n+ */\n+\n+package com.vmware.ddlog;\n+\n+import ddlogapi.DDlogException;\n+import ddlogapi.DDlogRecord;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+\n+/*\n+ * Translates literals into corresponding DDlogRecord instances\n+ */\n+class ParseLiterals extends SqlBasicVisitor<DDlogRecord> {\n+\n+    @Override\n+    public DDlogRecord visit(final SqlLiteral sqlLiteral) {\n+        switch (sqlLiteral.getTypeName()) {\n+            case BOOLEAN:\n+                return new DDlogRecord(sqlLiteral.booleanValue());\n+            case DECIMAL:\n+                return new DDlogRecord(sqlLiteral.intValue(false));\n+            case CHAR:", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0Mjc4NA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537842784", "bodyText": "Surprised me too, but yes.", "author": "lalithsuresh", "createdAt": "2020-12-07T21:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/ParseLiterals.java b/sql/src/main/java/com/vmware/ddlog/ParseLiterals.java\ndeleted file mode 100644\nindex 1c84b878..00000000\n--- a/sql/src/main/java/com/vmware/ddlog/ParseLiterals.java\n+++ /dev/null\n", "chunk": "@@ -1,34 +0,0 @@\n-/*\n- * Copyright \u00a9 2018-2020 VMware, Inc. All Rights Reserved.\n- * SPDX-License-Identifier: BSD-2\n- */\n-\n-package com.vmware.ddlog;\n-\n-import ddlogapi.DDlogException;\n-import ddlogapi.DDlogRecord;\n-import org.apache.calcite.sql.SqlLiteral;\n-import org.apache.calcite.sql.util.SqlBasicVisitor;\n-\n-/*\n- * Translates literals into corresponding DDlogRecord instances\n- */\n-class ParseLiterals extends SqlBasicVisitor<DDlogRecord> {\n-\n-    @Override\n-    public DDlogRecord visit(final SqlLiteral sqlLiteral) {\n-        switch (sqlLiteral.getTypeName()) {\n-            case BOOLEAN:\n-                return new DDlogRecord(sqlLiteral.booleanValue());\n-            case DECIMAL:\n-                return new DDlogRecord(sqlLiteral.intValue(false));\n-            case CHAR:\n-                try {\n-                    return new DDlogRecord(sqlLiteral.toValue());\n-                } catch (final DDlogException ignored) {\n-                }\n-            default:\n-                throw new UnsupportedOperationException(sqlLiteral.toValue());\n-        }\n-    }\n-}\n", "next_change": {"commit": "3baab395a3425791ba9da7b6539a0f8382a579b4", "changed_code": [{"header": "diff --git a/sql/src/main/java/com/vmware/ddlog/ParseLiterals.java b/sql/src/main/java/com/vmware/ddlog/ParseLiterals.java\nnew file mode 100644\nindex 00000000..1c84b878\n--- /dev/null\n+++ b/sql/src/main/java/com/vmware/ddlog/ParseLiterals.java\n", "chunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2018-2020 VMware, Inc. All Rights Reserved.\n+ * SPDX-License-Identifier: BSD-2\n+ */\n+\n+package com.vmware.ddlog;\n+\n+import ddlogapi.DDlogException;\n+import ddlogapi.DDlogRecord;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+\n+/*\n+ * Translates literals into corresponding DDlogRecord instances\n+ */\n+class ParseLiterals extends SqlBasicVisitor<DDlogRecord> {\n+\n+    @Override\n+    public DDlogRecord visit(final SqlLiteral sqlLiteral) {\n+        switch (sqlLiteral.getTypeName()) {\n+            case BOOLEAN:\n+                return new DDlogRecord(sqlLiteral.booleanValue());\n+            case DECIMAL:\n+                return new DDlogRecord(sqlLiteral.intValue(false));\n+            case CHAR:\n+                try {\n+                    return new DDlogRecord(sqlLiteral.toValue());\n+                } catch (final DDlogException ignored) {\n+                }\n+            default:\n+                throw new UnsupportedOperationException(sqlLiteral.toValue());\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}, {"oid": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "url": "https://github.com/vmware/differential-datalog/commit/c8e7071ca84958a5ed6e25c1590b73f32ce06040", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-04T21:40:25Z", "type": "forcePushed"}, {"oid": "09f1408d8ad6000b1bb01f3bb238560b51124682", "url": "https://github.com/vmware/differential-datalog/commit/09f1408d8ad6000b1bb01f3bb238560b51124682", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-28T00:07:11Z", "type": "forcePushed"}, {"oid": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "url": "https://github.com/vmware/differential-datalog/commit/be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "message": "Migrate to new parsing API\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "41cb5cc105e607b6a7f3a456d936f7211c9008e5", "url": "https://github.com/vmware/differential-datalog/commit/41cb5cc105e607b6a7f3a456d936f7211c9008e5", "message": "Use fully qualified names for Presto parser\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "3baab395a3425791ba9da7b6539a0f8382a579b4", "url": "https://github.com/vmware/differential-datalog/commit/3baab395a3425791ba9da7b6539a0f8382a579b4", "message": "ddlog-jooq: move literal parsing visitor to its own class\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "url": "https://github.com/vmware/differential-datalog/commit/47b6a589885b6090be50f8cebccd8db3de9be1a9", "message": "ddlog-jooq: use MockResult API to propagate exceptions to callers\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "1b1275648226e7e3ea7d62750145dac195e341f4", "url": "https://github.com/vmware/differential-datalog/commit/1b1275648226e7e3ea7d62750145dac195e341f4", "message": "ddlog-jooq: make WhereClauseToMatchExpression static\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "7e431c4baec6f157e296edaccd55304d14924d7a", "url": "https://github.com/vmware/differential-datalog/commit/7e431c4baec6f157e296edaccd55304d14924d7a", "message": "ddlog-jooq: add an API to fetch results by short-cutting JOOQ\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "3ce804e09c32dda97e3fc2d1bab6f4c91f6a8317", "url": "https://github.com/vmware/differential-datalog/commit/3ce804e09c32dda97e3fc2d1bab6f4c91f6a8317", "message": "ddlog-jooq: add assert condition\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "c7f6b8c72ca02b69a1da31ef36d89d2271419952", "url": "https://github.com/vmware/differential-datalog/commit/c7f6b8c72ca02b69a1da31ef36d89d2271419952", "message": "ddlog-jooq: support update statements with bindings\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "4679477dae4d7dec057eb733edbd3983bb954f8a", "url": "https://github.com/vmware/differential-datalog/commit/4679477dae4d7dec057eb733edbd3983bb954f8a", "message": "ddlog-jooq: add documentation for UPDATE queries. Re-order methods.\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "url": "https://github.com/vmware/differential-datalog/commit/16e81dde1c59f7eead08b7cb755bdad9abe23c82", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "url": "https://github.com/vmware/differential-datalog/commit/16e81dde1c59f7eead08b7cb755bdad9abe23c82", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "forcePushed"}]}