{"pr_number": 9232, "pr_title": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)", "pr_author": "sidseth", "pr_createdAt": "2020-10-17T17:53:19Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9232", "timeline": [{"oid": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "url": "https://github.com/hortonworks/cloudbreak/commit/5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "message": "Fix test.", "committedDate": "2020-10-23T20:48:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3MTUwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527671502", "body": "I don't think `Node` should contain this `attributes` map. It's used only to create a pillar. The main purpose of this class is to pass these data to `SaltBootstrap` installed on the instances to configure them.\r\nInstead of adding this info to the node you could calculate it when it's need in `ClusterHostServiceRunner`", "bodyText": "I don't think Node should contain this attributes map. It's used only to create a pillar. The main purpose of this class is to pass these data to SaltBootstrap installed on the instances to configure them.\nInstead of adding this info to the node you could calculate it when it's need in ClusterHostServiceRunner", "bodyHTML": "<p dir=\"auto\">I don't think <code>Node</code> should contain this <code>attributes</code> map. It's used only to create a pillar. The main purpose of this class is to pass these data to <code>SaltBootstrap</code> installed on the instances to configure them.<br>\nInstead of adding this info to the node you could calculate it when it's need in <code>ClusterHostServiceRunner</code></p>", "author": "lacikaaa", "createdAt": "2020-11-20T12:52:59Z", "path": "orchestrator-api/src/main/java/com/sequenceiq/cloudbreak/orchestrator/model/Node.java", "diffHunk": "@@ -23,19 +25,33 @@\n \n     private String uuids;\n \n+    // Used for generic attributes associated with the node. e.g. YARN attributes when running NMs, Spot vs non-spot, etc\n+    private Map<String, Map<String, String>> attributes;", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNDk0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528114949", "bodyText": "Will look into this as an option.", "author": "sidseth", "createdAt": "2020-11-21T07:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3MTUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTI2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527679260", "body": "it would be nicer with stream:\r\n```\r\nMap<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\r\n                .filter(this::isYarnNodemanager)\r\n                .collect(toMap(Entry::getKey, Entry::getValue));\r\n\r\nprivate boolean isYarnNodemanager(Entry<String, Set<ServiceComponent>> entry) {\r\n        return entry.getValue().stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\r\n                && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\r\n    }\r\n```", "bodyText": "it would be nicer with stream:\nMap<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n\nprivate boolean isYarnNodemanager(Entry<String, Set<ServiceComponent>> entry) {\n        return entry.getValue().stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }", "bodyHTML": "<p dir=\"auto\">it would be nicer with stream:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Map&lt;String, Set&lt;ServiceComponent&gt;&gt; hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n\nprivate boolean isYarnNodemanager(Entry&lt;String, Set&lt;ServiceComponent&gt;&gt; entry) {\n        return entry.getValue().stream().anyMatch(sc -&gt; YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                &amp;&amp; YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }\"><pre><code>Map&lt;String, Set&lt;ServiceComponent&gt;&gt; hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n\nprivate boolean isYarnNodemanager(Entry&lt;String, Set&lt;ServiceComponent&gt;&gt; entry) {\n        return entry.getValue().stream().anyMatch(sc -&gt; YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                &amp;&amp; YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }\n</code></pre></div>", "author": "lacikaaa", "createdAt": "2020-11-20T13:08:27Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTUyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528115527", "bodyText": "I don't like using Java streams (not as easy to read). If that's the pattern that is generally used, I can switch it over. (Applies to other comments related to streams)", "author": "sidseth", "createdAt": "2020-11-21T07:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTQxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527679414", "body": "doesn't seem relevant, could you drop these?", "bodyText": "doesn't seem relevant, could you drop these?", "bodyHTML": "<p dir=\"auto\">doesn't seem relevant, could you drop these?</p>", "author": "lacikaaa", "createdAt": "2020-11-20T13:08:46Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNTkzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528115931", "bodyText": "Sure. This was a comment to indicate potential future changes.", "author": "sidseth", "createdAt": "2020-11-21T07:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY3OTQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MDY5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527680692", "body": "this part should be moved out and named in a separate method", "bodyText": "this part should be moved out and named in a separate method", "bodyHTML": "<p dir=\"auto\">this part should be moved out and named in a separate method</p>", "author": "lacikaaa", "createdAt": "2020-11-20T13:11:13Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n+        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(\n+                        toMap(\n+                                Entry::getKey,\n+                                e -> e.getValue().stream()\n+                                .map(ServiceComponent::getComponent)\n+                                .collect(Collectors.toUnmodifiableSet())", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTE2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527681160", "body": "instead of comment could you use variable and methods name reflecting the same?", "bodyText": "instead of comment could you use variable and methods name reflecting the same?", "bodyHTML": "<p dir=\"auto\">instead of comment could you use variable and methods name reflecting the same?</p>", "author": "lacikaaa", "createdAt": "2020-11-20T13:12:10Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODExNjYyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528116628", "bodyText": "Think this is very specific to CB code style? I think comments in the code can be quite helpful.", "author": "sidseth", "createdAt": "2020-11-21T07:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY3MDc5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r528670797", "bodyText": "comments tends to be outdated, misleading. Usually indicates the code is not \"clean\", doesn't speak for itself which could be improved by refactoring, like breaking into methods with good names, etc\nWe generally avoid them as much as possible and leave comments where it's really necessary.", "author": "lacikaaa", "createdAt": "2020-11-23T12:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MjIwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527682203", "body": "this comment also seems unnecessary or I'm missing something", "bodyText": "this comment also seems unnecessary or I'm missing something", "bodyHTML": "<p dir=\"auto\">this comment also seems unnecessary or I'm missing something</p>", "author": "lacikaaa", "createdAt": "2020-11-20T13:14:23Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n+        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(\n+                        toMap(\n+                                Entry::getKey,\n+                                e -> e.getValue().stream()\n+                                .map(ServiceComponent::getComponent)\n+                                .collect(Collectors.toUnmodifiableSet())\n+                ));\n+        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NTk4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r535865982", "bodyText": "Goign to modify this comment a bit. It is relevant in the sense that determining a node as 'compute' means that it can be AutoScaled, and so it is important to re-use the autoscale recommendation logic.", "author": "sidseth", "createdAt": "2020-12-04T06:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MjIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzA5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527687091", "body": "```        Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\r\n        for (String hg : componentsByHostGroup.keySet()) {\r\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\r\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\r\n            Map<String, ServiceAttributes> m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\r\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\r\n            result.put(hg, m);\r\n        }\r\n```\r\nseems a bit readable this way and could be moved to a separate method also", "bodyText": "for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map<String, ServiceAttributes> m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\n\nseems a bit readable this way and could be moved to a separate method also", "bodyHTML": "<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map&lt;String, ServiceAttributes&gt; m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\"><pre lang=\"Map&lt;String,\"><code>        for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map&lt;String, ServiceAttributes&gt; m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\n</code></pre></div>\n<p dir=\"auto\">seems a bit readable this way and could be moved to a separate method also</p>", "author": "lacikaaa", "createdAt": "2020-11-20T13:23:37Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n+        // The only attributes required at the moment relate to the YARN NodeManager.\n+        // This functionality can be moved to an interface / separated if additional components\n+        // need this functionality.\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n+        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = new HashMap<>();\n+        for (Entry<String, Set<ServiceComponent>> entry : hgToNonGwServiceComponents.entrySet()) {\n+            for (ServiceComponent sc : entry.getValue()) {\n+                if (sc.getService().equalsIgnoreCase(YarnRoles.YARN) && sc.getComponent()\n+                        .equalsIgnoreCase(YarnRoles.NODEMANAGER)) {\n+                    hgToNonGwServiceComponentsWithYarnNMs.put(entry.getKey(), entry.getValue());\n+                    break;\n+                }\n+            }\n+        }\n+        // We have the hostGroups without GATEWAY components with YARN NodeManagers\n+        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n+                .stream().collect(\n+                        toMap(\n+                                Entry::getKey,\n+                                e -> e.getValue().stream()\n+                                .map(ServiceComponent::getComponent)\n+                                .collect(Collectors.toUnmodifiableSet())\n+                ));\n+        // Re-using the current LoadBasedAutoScaling recommendation along with the above YARN filter.\n+        Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n+                true, componentsByHostGroup);\n+\n+        Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n+\n+        for (String hg : componentsByHostGroup.keySet()) {\n+            Map<String, ServiceAttributes> m;\n+            if (computeHostGroups.contains(hg)) {\n+                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE)));\n+            } else {\n+                m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n+                        Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER)));\n+            }\n+            result.put(hg, m);\n+        }\n+        LOGGER.debug(\"ServiceAttributes: {}\", result);", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzgyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527687823", "bodyText": "Also m is not a good variable name, please rename it to something more helpful", "author": "lacikaaa", "createdAt": "2020-11-20T13:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MTAyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r527691025", "body": "I ended up with this, but the method and variable names should be changed with more meaningful one I think. This is just an example:\r\n```    \r\n\t@Override\r\n    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\r\n        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostrgoup();\r\n        Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\r\n                true, componentsByHostGroup);\r\n        Map<String, Map<String, ServiceAttributes>> result = createServiceAttributeMap(componentsByHostGroup, computeHostGroups);\r\n        LOGGER.debug(\"ServiceAttributes: {}\", result);\r\n        return result;\r\n    }\r\n\r\n    private Map<String, Map<String, ServiceAttributes>> createServiceAttributeMap(Map<String, Set<String>> componentsByHostGroup, Set<String> computeHostGroups) {\r\n        Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\r\n        for (String hg : componentsByHostGroup.keySet()) {\r\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\r\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\r\n            Map<String, ServiceAttributes> m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\r\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\r\n            result.put(hg, m);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private Map<String, Set<String>> collectComponentsByHostrgoup() {\r\n        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\r\n        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\r\n                .filter(this::isYarnNodemanager)\r\n                .collect(toMap(Entry::getKey, Entry::getValue));\r\n        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\r\n                .stream().collect(toMap(Entry::getKey, this::collectComponents));\r\n        return componentsByHostGroup;\r\n    }\r\n\r\n    private Set<String> collectComponents(Entry<String, Set<ServiceComponent>> e) {\r\n        return e.getValue().stream()\r\n                .map(ServiceComponent::getComponent)\r\n                .collect(Collectors.toUnmodifiableSet());\r\n    }\r\n\r\n    private boolean isYarnNodemanager(Entry<String, Set<ServiceComponent>> entry) {\r\n        return entry.getValue().stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\r\n                && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\r\n    }", "bodyText": "I ended up with this, but the method and variable names should be changed with more meaningful one I think. This is just an example:\n\t@Override\n    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {\n        Map<String, Set<String>> componentsByHostGroup = collectComponentsByHostrgoup();\n        Set<String> computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                true, componentsByHostGroup);\n        Map<String, Map<String, ServiceAttributes>> result = createServiceAttributeMap(componentsByHostGroup, computeHostGroups);\n        LOGGER.debug(\"ServiceAttributes: {}\", result);\n        return result;\n    }\n\n    private Map<String, Map<String, ServiceAttributes>> createServiceAttributeMap(Map<String, Set<String>> componentsByHostGroup, Set<String> computeHostGroups) {\n        Map<String, Map<String, ServiceAttributes>> result = new HashMap<>();\n        for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map<String, ServiceAttributes> m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\n        return result;\n    }\n\n    private Map<String, Set<String>> collectComponentsByHostrgoup() {\n        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n        Map<String, Set<ServiceComponent>> hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n        Map<String, Set<String>> componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n                .stream().collect(toMap(Entry::getKey, this::collectComponents));\n        return componentsByHostGroup;\n    }\n\n    private Set<String> collectComponents(Entry<String, Set<ServiceComponent>> e) {\n        return e.getValue().stream()\n                .map(ServiceComponent::getComponent)\n                .collect(Collectors.toUnmodifiableSet());\n    }\n\n    private boolean isYarnNodemanager(Entry<String, Set<ServiceComponent>> entry) {\n        return entry.getValue().stream().anyMatch(sc -> YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                && YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }", "bodyHTML": "<p dir=\"auto\">I ended up with this, but the method and variable names should be changed with more meaningful one I think. This is just an example:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\t@Override\n    public Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; getHostGroupBasedServiceAttributes() {\n        Map&lt;String, Set&lt;String&gt;&gt; componentsByHostGroup = collectComponentsByHostrgoup();\n        Set&lt;String&gt; computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                true, componentsByHostGroup);\n        Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; result = createServiceAttributeMap(componentsByHostGroup, computeHostGroups);\n        LOGGER.debug(&quot;ServiceAttributes: {}&quot;, result);\n        return result;\n    }\n\n    private Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; createServiceAttributeMap(Map&lt;String, Set&lt;String&gt;&gt; componentsByHostGroup, Set&lt;String&gt; computeHostGroups) {\n        Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; result = new HashMap&lt;&gt;();\n        for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map&lt;String, ServiceAttributes&gt; m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\n        return result;\n    }\n\n    private Map&lt;String, Set&lt;String&gt;&gt; collectComponentsByHostrgoup() {\n        Map&lt;String, Set&lt;ServiceComponent&gt;&gt; hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n        Map&lt;String, Set&lt;ServiceComponent&gt;&gt; hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n        Map&lt;String, Set&lt;String&gt;&gt; componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n                .stream().collect(toMap(Entry::getKey, this::collectComponents));\n        return componentsByHostGroup;\n    }\n\n    private Set&lt;String&gt; collectComponents(Entry&lt;String, Set&lt;ServiceComponent&gt;&gt; e) {\n        return e.getValue().stream()\n                .map(ServiceComponent::getComponent)\n                .collect(Collectors.toUnmodifiableSet());\n    }\n\n    private boolean isYarnNodemanager(Entry&lt;String, Set&lt;ServiceComponent&gt;&gt; entry) {\n        return entry.getValue().stream().anyMatch(sc -&gt; YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                &amp;&amp; YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }\"><pre><code>\t@Override\n    public Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; getHostGroupBasedServiceAttributes() {\n        Map&lt;String, Set&lt;String&gt;&gt; componentsByHostGroup = collectComponentsByHostrgoup();\n        Set&lt;String&gt; computeHostGroups = getRecommendationByBlacklist(BlackListedLoadBasedAutoscaleRole.class,\n                true, componentsByHostGroup);\n        Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; result = createServiceAttributeMap(componentsByHostGroup, computeHostGroups);\n        LOGGER.debug(\"ServiceAttributes: {}\", result);\n        return result;\n    }\n\n    private Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; createServiceAttributeMap(Map&lt;String, Set&lt;String&gt;&gt; componentsByHostGroup, Set&lt;String&gt; computeHostGroups) {\n        Map&lt;String, Map&lt;String, ServiceAttributes&gt;&gt; result = new HashMap&lt;&gt;();\n        for (String hg : componentsByHostGroup.keySet()) {\n            String instanceType = computeHostGroups.contains(hg) ? YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_COMPUTE\n                    : YarnConstants.ATTRIBUTE_NODE_INSTANCE_TYPE_WORKER;\n            Map&lt;String, ServiceAttributes&gt; m = Collections.singletonMap(YarnRoles.YARN, new ServiceAttributes(ServiceComponent.of(YarnRoles.YARN, YarnRoles.NODEMANAGER),\n                    Collections.singletonMap(YarnConstants.ATTRIBUTE_NAME_NODE_INSTANCE_TYPE, instanceType)));\n            result.put(hg, m);\n        }\n        return result;\n    }\n\n    private Map&lt;String, Set&lt;String&gt;&gt; collectComponentsByHostrgoup() {\n        Map&lt;String, Set&lt;ServiceComponent&gt;&gt; hgToNonGwServiceComponents = getNonGatewayServicesByHostGroup();\n        Map&lt;String, Set&lt;ServiceComponent&gt;&gt; hgToNonGwServiceComponentsWithYarnNMs = hgToNonGwServiceComponents.entrySet().stream()\n                .filter(this::isYarnNodemanager)\n                .collect(toMap(Entry::getKey, Entry::getValue));\n        Map&lt;String, Set&lt;String&gt;&gt; componentsByHostGroup = hgToNonGwServiceComponentsWithYarnNMs.entrySet()\n                .stream().collect(toMap(Entry::getKey, this::collectComponents));\n        return componentsByHostGroup;\n    }\n\n    private Set&lt;String&gt; collectComponents(Entry&lt;String, Set&lt;ServiceComponent&gt;&gt; e) {\n        return e.getValue().stream()\n                .map(ServiceComponent::getComponent)\n                .collect(Collectors.toUnmodifiableSet());\n    }\n\n    private boolean isYarnNodemanager(Entry&lt;String, Set&lt;ServiceComponent&gt;&gt; entry) {\n        return entry.getValue().stream().anyMatch(sc -&gt; YarnRoles.YARN.equalsIgnoreCase(sc.getService())\n                &amp;&amp; YarnRoles.NODEMANAGER.equalsIgnoreCase(sc.getComponent()));\n    }\n</code></pre></div>", "author": "lacikaaa", "createdAt": "2020-11-20T13:30:12Z", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/CmTemplateProcessor.java", "diffHunk": "@@ -291,6 +311,52 @@ public String getStackVersion() {\n         return cmTemplate.getCdhVersion();\n     }\n \n+    @Override\n+    public Map<String, Map<String, ServiceAttributes>> getHostGroupBasedServiceAttributes() {", "originalCommit": "5e322a1c93e41fd3e42a2fb97de3b239710bf60d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2ODI1Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r535868256", "bodyText": "Thanks for the suggestions. Have broken up the method a bit, and made some other changes.", "author": "sidseth", "createdAt": "2020-12-04T06:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MTAyNQ=="}], "type": "inlineReview"}, {"oid": "6d8eff0171e7193f8244a88e2f45736ffa202b62", "url": "https://github.com/hortonworks/cloudbreak/commit/6d8eff0171e7193f8244a88e2f45736ffa202b62", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-04T06:56:44Z", "type": "forcePushed"}, {"oid": "b892b6d11bce5c14d61158af64d45257dabbc7a9", "url": "https://github.com/hortonworks/cloudbreak/commit/b892b6d11bce5c14d61158af64d45257dabbc7a9", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-05T04:39:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODI0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r540358245", "body": "I think this should be moved to a separate class together with `getAttributesForHostGroup`.\r\nAnd this method should return with a map, like:\r\n`Map.of(\"hostattrs\", new SaltPillarProperties(\"/nodes/hostattrs.sls\", singletonMap(\"hostattrs\", attributes)))`\r\nAnd in line 303 you would need only:\r\n`servicePillar.putAll(createHostAttributes(..));`\r\n\r\nI know there is a lot of code here (even written by me) where we add stuff to this map by passing it around but honestly it's not the best solution.\r\n\r\nMoving this method out would make `@VisibleForTesting` unnecessary which is already a sign that it should be in a separate class.", "bodyText": "I think this should be moved to a separate class together with getAttributesForHostGroup.\nAnd this method should return with a map, like:\nMap.of(\"hostattrs\", new SaltPillarProperties(\"/nodes/hostattrs.sls\", singletonMap(\"hostattrs\", attributes)))\nAnd in line 303 you would need only:\nservicePillar.putAll(createHostAttributes(..));\nI know there is a lot of code here (even written by me) where we add stuff to this map by passing it around but honestly it's not the best solution.\nMoving this method out would make @VisibleForTesting unnecessary which is already a sign that it should be in a separate class.", "bodyHTML": "<p dir=\"auto\">I think this should be moved to a separate class together with <code>getAttributesForHostGroup</code>.<br>\nAnd this method should return with a map, like:<br>\n<code>Map.of(\"hostattrs\", new SaltPillarProperties(\"/nodes/hostattrs.sls\", singletonMap(\"hostattrs\", attributes)))</code><br>\nAnd in line 303 you would need only:<br>\n<code>servicePillar.putAll(createHostAttributes(..));</code></p>\n<p dir=\"auto\">I know there is a lot of code here (even written by me) where we add stuff to this map by passing it around but honestly it's not the best solution.</p>\n<p dir=\"auto\">Moving this method out would make <code>@VisibleForTesting</code> unnecessary which is already a sign that it should be in a separate class.</p>", "author": "lacikaaa", "createdAt": "2020-12-10T17:28:01Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/host/ClusterHostServiceRunner.java", "diffHunk": "@@ -323,6 +331,26 @@ private SaltConfig createSaltConfig(Stack stack, Cluster cluster, GatewayConfig\n         return new SaltConfig(servicePillar, grainPropertiesService.createGrainProperties(gatewayConfigs, cluster, nodes));\n     }\n \n+    @VisibleForTesting\n+    void addHostAttributes(Stack stack, Map<String, SaltPillarProperties> servicePillar, Set<Node> nodes) {", "originalCommit": "b892b6d11bce5c14d61158af64d45257dabbc7a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NDEyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9232#discussion_r540574126", "bodyText": "Moving this into a HostAttributeDecorator, and having that set the PillarProperties instead of returning a map.\nI'm going to ask you to make changes to return a map if you feel strongly about that / other code style changes. Given I don't write a lot of CB patches - was avoiding any kind of re-structuring and following existing patterns as much as possible.", "author": "sidseth", "createdAt": "2020-12-10T23:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODI0NQ=="}], "type": "inlineReview"}, {"oid": "ec73d2cb416eb99a8d763667d69b0300b4b0619b", "url": "https://github.com/hortonworks/cloudbreak/commit/ec73d2cb416eb99a8d763667d69b0300b4b0619b", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-10T23:45:38Z", "type": "forcePushed"}, {"oid": "e015b220c1541d5b8658a647f383c8956b4977e3", "url": "https://github.com/hortonworks/cloudbreak/commit/e015b220c1541d5b8658a647f383c8956b4977e3", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-11T08:24:34Z", "type": "commit"}, {"oid": "e015b220c1541d5b8658a647f383c8956b4977e3", "url": "https://github.com/hortonworks/cloudbreak/commit/e015b220c1541d5b8658a647f383c8956b4977e3", "message": "CB-8147. Make node specific metadata (hostGroup, YARN NM attributes)\navailable on cluster nodes.\n\n- New metadata file created under /opt/metadata/node.json on cluster\nnodes, which contains the hostGroup name, and service specific\nattributes.\n- The service specific attributes introduced in this PR are for YARN,\nand specify whether a node is a compute or worker based on the services\nrunning on the node (instead of relying on the hostGroup name).", "committedDate": "2020-12-11T08:24:34Z", "type": "forcePushed"}]}