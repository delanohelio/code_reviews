{"pr_number": 12817, "pr_title": "Dynamic accelerator framework - Annotation for accelerator", "pr_createdAt": "2020-10-20T02:45:02Z", "pr_url": "https://github.com/cdapio/cdap/pull/12817", "merge_commit": "5ee1c35a20170ee677854b0b159b2241fe4d7f79", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNDEyMQ==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r508204121", "body": "Use the javadoc style for writing doc for public method:\r\n\r\n```\r\n/**\r\n * Description\r\n * @return \r\n */\r\n```", "bodyText": "Use the javadoc style for writing doc for public method:\n/**\n * Description\n * @return \n */", "bodyHTML": "<p dir=\"auto\">Use the javadoc style for writing doc for public method:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"/**\n * Description\n * @return \n */\"><pre><code>/**\n * Description\n * @return \n */\n</code></pre></div>", "author": "chtyim", "createdAt": "2020-10-20T04:37:24Z", "path": "cdap-api/src/main/java/io/cdap/cdap/api/annotation/Requirements.java", "diffHunk": "@@ -69,4 +69,7 @@\n public @interface Requirements {\n \n   String[] datasetTypes() default {};\n+\n+  //Name of associated add-ons or accelerators", "originalCommit": "2af5b202f3401d3d2b7d72f5af02fc23642200ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxNjExOQ==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r509816119", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-10-22T00:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNDEyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "79812780457fc997304d59d6315a3a2813fee3ea", "changed_code": [{"header": "diff --git a/cdap-api/src/main/java/io/cdap/cdap/api/annotation/Requirements.java b/cdap-api/src/main/java/io/cdap/cdap/api/annotation/Requirements.java\nindex 433a06e9169..e7447a2032f 100644\n--- a/cdap-api/src/main/java/io/cdap/cdap/api/annotation/Requirements.java\n+++ b/cdap-api/src/main/java/io/cdap/cdap/api/annotation/Requirements.java\n", "chunk": "@@ -70,6 +70,9 @@ public @interface Requirements {\n \n   String[] datasetTypes() default {};\n \n-  //Name of associated add-ons or accelerators\n+  /**\n+   * Names of associated add-ons or accelerators\n+   * @return String array of accelerator names\n+   */\n   String[] accelerators() default{};\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNzU5Ng==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r508207596", "body": "Don't use super generic method name unless this method is really that generic. This method is more like `getAnnotationValues`?", "bodyText": "Don't use super generic method name unless this method is really that generic. This method is more like getAnnotationValues?", "bodyHTML": "<p dir=\"auto\">Don't use super generic method name unless this method is really that generic. This method is more like <code>getAnnotationValues</code>?</p>", "author": "chtyim", "createdAt": "2020-10-20T04:51:05Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java", "diffHunk": "@@ -381,14 +381,18 @@ private String getPluginName(Class<?> cls) {\n    * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n    */\n   @VisibleForTesting\n-  Requirements getPluginRequirements(Class<?> cls) {\n+  Requirements getRequirementsAnnotation(Class<?> cls) {\n     io.cdap.cdap.api.annotation.Requirements annotation =\n       cls.getAnnotation(io.cdap.cdap.api.annotation.Requirements.class);\n     if (annotation == null) {\n       return Requirements.EMPTY;\n     }\n-    return new Requirements(Arrays.stream(annotation.datasetTypes()).map(s -> s.trim().toLowerCase())\n-                              .filter(s -> !Strings.isNullOrEmpty(s)).collect(Collectors.toSet()));\n+    return new Requirements(collect(annotation.datasetTypes()), collect(annotation.accelerators()));\n+  }\n+\n+  private Set<String> collect(String[] field) {", "originalCommit": "2af5b202f3401d3d2b7d72f5af02fc23642200ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxNjE3MQ==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r509816171", "bodyText": "changed.", "author": "greeshmaswaminathan", "createdAt": "2020-10-22T00:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNzU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "79812780457fc997304d59d6315a3a2813fee3ea", "changed_code": [{"header": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\nindex dd321832aeb..a45117c251d 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n", "chunk": "@@ -381,18 +381,19 @@ final class ArtifactInspector {\n    * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n    */\n   @VisibleForTesting\n-  Requirements getRequirementsAnnotation(Class<?> cls) {\n+  Requirements getArtifactRequirements(Class<?> cls) {\n     io.cdap.cdap.api.annotation.Requirements annotation =\n       cls.getAnnotation(io.cdap.cdap.api.annotation.Requirements.class);\n     if (annotation == null) {\n       return Requirements.EMPTY;\n     }\n-    return new Requirements(collect(annotation.datasetTypes()), collect(annotation.accelerators()));\n+    return new Requirements(getAnnotationValues(annotation.datasetTypes()),\n+                            getAnnotationValues(annotation.accelerators()));\n   }\n \n-  private Set<String> collect(String[] field) {\n-    return Arrays.stream(field).map(s -> s.trim().toLowerCase())\n-                              .filter(s -> !Strings.isNullOrEmpty(s)).collect(Collectors.toSet());\n+  private Set<String> getAnnotationValues(String[] field) {\n+    return Arrays.stream(field).map(String::trim).map(String::toLowerCase).filter(Objects::nonNull)\n+      .filter(s -> !s.isEmpty()).collect(Collectors.toSet());\n   }\n \n   /**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTM2Ng==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r508209366", "body": "A more idiomatic way to use stream (or functional style in general) is to only do one thing per function, since that layout the logic better.\r\n```\r\nArrays.stream(fields)\r\n  .map(String::trim)\r\n  .map(String::toLowerCase) \r\n  .filter(Object::nonNull)\r\n  .filter(s -> !s.isEmpty())\r\n  .collect(Collectors.toSet());\r\n```", "bodyText": "A more idiomatic way to use stream (or functional style in general) is to only do one thing per function, since that layout the logic better.\nArrays.stream(fields)\n  .map(String::trim)\n  .map(String::toLowerCase) \n  .filter(Object::nonNull)\n  .filter(s -> !s.isEmpty())\n  .collect(Collectors.toSet());", "bodyHTML": "<p dir=\"auto\">A more idiomatic way to use stream (or functional style in general) is to only do one thing per function, since that layout the logic better.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Arrays.stream(fields)\n  .map(String::trim)\n  .map(String::toLowerCase) \n  .filter(Object::nonNull)\n  .filter(s -&gt; !s.isEmpty())\n  .collect(Collectors.toSet());\"><pre><code>Arrays.stream(fields)\n  .map(String::trim)\n  .map(String::toLowerCase) \n  .filter(Object::nonNull)\n  .filter(s -&gt; !s.isEmpty())\n  .collect(Collectors.toSet());\n</code></pre></div>", "author": "chtyim", "createdAt": "2020-10-20T04:57:20Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java", "diffHunk": "@@ -381,14 +381,18 @@ private String getPluginName(Class<?> cls) {\n    * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n    */\n   @VisibleForTesting\n-  Requirements getPluginRequirements(Class<?> cls) {\n+  Requirements getRequirementsAnnotation(Class<?> cls) {\n     io.cdap.cdap.api.annotation.Requirements annotation =\n       cls.getAnnotation(io.cdap.cdap.api.annotation.Requirements.class);\n     if (annotation == null) {\n       return Requirements.EMPTY;\n     }\n-    return new Requirements(Arrays.stream(annotation.datasetTypes()).map(s -> s.trim().toLowerCase())\n-                              .filter(s -> !Strings.isNullOrEmpty(s)).collect(Collectors.toSet()));\n+    return new Requirements(collect(annotation.datasetTypes()), collect(annotation.accelerators()));\n+  }\n+\n+  private Set<String> collect(String[] field) {\n+    return Arrays.stream(field).map(s -> s.trim().toLowerCase())", "originalCommit": "2af5b202f3401d3d2b7d72f5af02fc23642200ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxNjIxMw==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r509816213", "bodyText": "Done.", "author": "greeshmaswaminathan", "createdAt": "2020-10-22T00:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "79812780457fc997304d59d6315a3a2813fee3ea", "changed_code": [{"header": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\nindex dd321832aeb..a45117c251d 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n", "chunk": "@@ -381,18 +381,19 @@ final class ArtifactInspector {\n    * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n    */\n   @VisibleForTesting\n-  Requirements getRequirementsAnnotation(Class<?> cls) {\n+  Requirements getArtifactRequirements(Class<?> cls) {\n     io.cdap.cdap.api.annotation.Requirements annotation =\n       cls.getAnnotation(io.cdap.cdap.api.annotation.Requirements.class);\n     if (annotation == null) {\n       return Requirements.EMPTY;\n     }\n-    return new Requirements(collect(annotation.datasetTypes()), collect(annotation.accelerators()));\n+    return new Requirements(getAnnotationValues(annotation.datasetTypes()),\n+                            getAnnotationValues(annotation.accelerators()));\n   }\n \n-  private Set<String> collect(String[] field) {\n-    return Arrays.stream(field).map(s -> s.trim().toLowerCase())\n-                              .filter(s -> !Strings.isNullOrEmpty(s)).collect(Collectors.toSet());\n+  private Set<String> getAnnotationValues(String[] field) {\n+    return Arrays.stream(field).map(String::trim).map(String::toLowerCase).filter(Objects::nonNull)\n+      .filter(s -> !s.isEmpty()).collect(Collectors.toSet());\n   }\n \n   /**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMzQ4Mw==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r508213483", "body": "This method actually returns the `Requirements` class, not the annotation, so better call it `getArtifactRequirements()`", "bodyText": "This method actually returns the Requirements class, not the annotation, so better call it getArtifactRequirements()", "bodyHTML": "<p dir=\"auto\">This method actually returns the <code>Requirements</code> class, not the annotation, so better call it <code>getArtifactRequirements()</code></p>", "author": "chtyim", "createdAt": "2020-10-20T05:12:29Z", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java", "diffHunk": "@@ -381,14 +381,18 @@ private String getPluginName(Class<?> cls) {\n    * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n    */\n   @VisibleForTesting\n-  Requirements getPluginRequirements(Class<?> cls) {\n+  Requirements getRequirementsAnnotation(Class<?> cls) {", "originalCommit": "2af5b202f3401d3d2b7d72f5af02fc23642200ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgxNjI4MA==", "url": "https://github.com/cdapio/cdap/pull/12817#discussion_r509816280", "bodyText": "done.", "author": "greeshmaswaminathan", "createdAt": "2020-10-22T00:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMzQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "79812780457fc997304d59d6315a3a2813fee3ea", "changed_code": [{"header": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\nindex dd321832aeb..a45117c251d 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n", "chunk": "@@ -381,18 +381,19 @@ final class ArtifactInspector {\n    * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n    */\n   @VisibleForTesting\n-  Requirements getRequirementsAnnotation(Class<?> cls) {\n+  Requirements getArtifactRequirements(Class<?> cls) {\n     io.cdap.cdap.api.annotation.Requirements annotation =\n       cls.getAnnotation(io.cdap.cdap.api.annotation.Requirements.class);\n     if (annotation == null) {\n       return Requirements.EMPTY;\n     }\n-    return new Requirements(collect(annotation.datasetTypes()), collect(annotation.accelerators()));\n+    return new Requirements(getAnnotationValues(annotation.datasetTypes()),\n+                            getAnnotationValues(annotation.accelerators()));\n   }\n \n-  private Set<String> collect(String[] field) {\n-    return Arrays.stream(field).map(s -> s.trim().toLowerCase())\n-                              .filter(s -> !Strings.isNullOrEmpty(s)).collect(Collectors.toSet());\n+  private Set<String> getAnnotationValues(String[] field) {\n+    return Arrays.stream(field).map(String::trim).map(String::toLowerCase).filter(Objects::nonNull)\n+      .filter(s -> !s.isEmpty()).collect(Collectors.toSet());\n   }\n \n   /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "5ee1c35a20170ee677854b0b159b2241fe4d7f79", "changed_code": [{"header": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\nindex dd321832aeb..a45117c251d 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n", "chunk": "@@ -381,18 +381,19 @@ final class ArtifactInspector {\n    * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n    */\n   @VisibleForTesting\n-  Requirements getRequirementsAnnotation(Class<?> cls) {\n+  Requirements getArtifactRequirements(Class<?> cls) {\n     io.cdap.cdap.api.annotation.Requirements annotation =\n       cls.getAnnotation(io.cdap.cdap.api.annotation.Requirements.class);\n     if (annotation == null) {\n       return Requirements.EMPTY;\n     }\n-    return new Requirements(collect(annotation.datasetTypes()), collect(annotation.accelerators()));\n+    return new Requirements(getAnnotationValues(annotation.datasetTypes()),\n+                            getAnnotationValues(annotation.accelerators()));\n   }\n \n-  private Set<String> collect(String[] field) {\n-    return Arrays.stream(field).map(s -> s.trim().toLowerCase())\n-                              .filter(s -> !Strings.isNullOrEmpty(s)).collect(Collectors.toSet());\n+  private Set<String> getAnnotationValues(String[] field) {\n+    return Arrays.stream(field).map(String::trim).map(String::toLowerCase).filter(Objects::nonNull)\n+      .filter(s -> !s.isEmpty()).collect(Collectors.toSet());\n   }\n \n   /**\n", "next_change": {"commit": "167da7ddca341b4e07859e8ba7c7cbcb8208fdde", "changed_code": [{"header": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\nindex a45117c251d..7f1e2325ea1 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n", "chunk": "@@ -16,519 +16,34 @@\n \n package io.cdap.cdap.internal.app.runtime.artifact;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Function;\n-import com.google.common.base.Predicate;\n-import com.google.common.base.Throwables;\n-import com.google.common.collect.AbstractIterator;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterators;\n-import com.google.common.collect.Maps;\n-import com.google.common.primitives.Primitives;\n-import com.google.common.reflect.TypeToken;\n-import io.cdap.cdap.api.Config;\n-import io.cdap.cdap.api.annotation.Description;\n-import io.cdap.cdap.api.annotation.Macro;\n-import io.cdap.cdap.api.annotation.Name;\n-import io.cdap.cdap.api.annotation.Plugin;\n-import io.cdap.cdap.api.app.Application;\n-import io.cdap.cdap.api.artifact.ApplicationClass;\n-import io.cdap.cdap.api.artifact.ArtifactClasses;\n-import io.cdap.cdap.api.artifact.ArtifactId;\n-import io.cdap.cdap.api.artifact.CloseableClassLoader;\n-import io.cdap.cdap.api.data.schema.Schema;\n-import io.cdap.cdap.api.data.schema.UnsupportedTypeException;\n import io.cdap.cdap.api.plugin.PluginClass;\n-import io.cdap.cdap.api.plugin.PluginConfig;\n-import io.cdap.cdap.api.plugin.PluginPropertyField;\n-import io.cdap.cdap.api.plugin.Requirements;\n-import io.cdap.cdap.app.program.ManifestFields;\n import io.cdap.cdap.common.InvalidArtifactException;\n-import io.cdap.cdap.common.conf.CConfiguration;\n-import io.cdap.cdap.common.conf.Constants;\n import io.cdap.cdap.common.id.Id;\n-import io.cdap.cdap.common.io.Locations;\n-import io.cdap.cdap.common.lang.jar.BundleJarUtil;\n-import io.cdap.cdap.common.utils.DirUtils;\n-import io.cdap.cdap.internal.app.runtime.plugin.PluginInstantiator;\n-import io.cdap.cdap.internal.io.ReflectionSchemaGenerator;\n-import org.apache.twill.filesystem.Location;\n-import org.objectweb.asm.AnnotationVisitor;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.Type;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.io.EOFException;\n import java.io.File;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n-import java.net.URL;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Enumeration;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n import java.util.Set;\n-import java.util.jar.Attributes;\n-import java.util.jar.JarFile;\n-import java.util.jar.Manifest;\n-import java.util.stream.Collectors;\n-import java.util.zip.ZipException;\n import javax.annotation.Nullable;\n \n /**\n  * Inspects a jar file to determine metadata about the artifact.\n  */\n-final class ArtifactInspector {\n-  private static final Logger LOG = LoggerFactory.getLogger(ArtifactInspector.class);\n-\n-  private final CConfiguration cConf;\n-  private final ArtifactClassLoaderFactory artifactClassLoaderFactory;\n-  private final ReflectionSchemaGenerator schemaGenerator;\n-\n-  ArtifactInspector(CConfiguration cConf, ArtifactClassLoaderFactory artifactClassLoaderFactory) {\n-    this.cConf = cConf;\n-    this.artifactClassLoaderFactory = artifactClassLoaderFactory;\n-    this.schemaGenerator = new ReflectionSchemaGenerator(false);\n-  }\n-\n+interface ArtifactInspector {\n   /**\n    * Inspect the given artifact to determine the classes contained in the artifact.\n    *\n    * @param artifactId the id of the artifact to inspect\n    * @param artifactFile the artifact file\n    * @param parentClassLoader the parent classloader to use when inspecting plugins contained in the artifact.\n-   *                          For example, a ProgramClassLoader created from the artifact the input artifact extends\n+   * For example, a ProgramClassLoader created from the artifact the input artifact extends\n    * @param additionalPlugins Additional plugin classes\n    * @return metadata about the classes contained in the artifact\n    * @throws IOException if there was an exception opening the jar file\n    * @throws InvalidArtifactException if the artifact is invalid. For example, if the application main class is not\n-   *                                  actually an Application.\n-   */\n-  ArtifactClasses inspectArtifact(Id.Artifact artifactId, File artifactFile,\n-                                  @Nullable ClassLoader parentClassLoader, Set<PluginClass> additionalPlugins)\n-    throws IOException, InvalidArtifactException {\n-    Path tmpDir = Paths.get(cConf.get(Constants.CFG_LOCAL_DATA_DIR),\n-                            cConf.get(Constants.AppFabric.TEMP_DIR)).toAbsolutePath();\n-    Files.createDirectories(tmpDir);\n-    Location artifactLocation = Locations.toLocation(artifactFile);\n-\n-    Path stageDir = Files.createTempDirectory(tmpDir, artifactFile.getName());\n-    try {\n-      File unpackedDir = BundleJarUtil.unJar(artifactLocation,\n-                                             Files.createTempDirectory(stageDir, \"unpacked-\").toFile());\n-      try (\n-        CloseableClassLoader artifactClassLoader = artifactClassLoaderFactory.createClassLoader(unpackedDir);\n-        PluginInstantiator pluginInstantiator =\n-          new PluginInstantiator(cConf, parentClassLoader == null ? artifactClassLoader : parentClassLoader,\n-                                 Files.createTempDirectory(stageDir, \"plugins-\").toFile(),\n-                                 false)) {\n-        pluginInstantiator.addArtifact(artifactLocation, artifactId.toArtifactId());\n-        ArtifactClasses.Builder builder = inspectApplications(artifactId, ArtifactClasses.builder(),\n-                                                              artifactLocation, artifactClassLoader);\n-        return inspectPlugins(builder, artifactFile, artifactId.toArtifactId(), pluginInstantiator,\n-                              additionalPlugins).build();\n-      }\n-    } catch (EOFException | ZipException e) {\n-      throw new InvalidArtifactException(\"Artifact \" + artifactId + \" is not a valid zip file.\", e);\n-    } finally {\n-      try {\n-        DirUtils.deleteDirectoryContents(stageDir.toFile());\n-      } catch (IOException e) {\n-        LOG.warn(\"Exception raised while deleting directory {}\", stageDir, e);\n-      }\n-    }\n-  }\n-\n-  private ArtifactClasses.Builder inspectApplications(Id.Artifact artifactId,\n-                                                      ArtifactClasses.Builder builder,\n-                                                      Location artifactLocation,\n-                                                      ClassLoader artifactClassLoader) throws IOException,\n-                                                                                              InvalidArtifactException {\n-\n-    // right now we force users to include the application main class as an attribute in their manifest,\n-    // which forces them to have a single application class.\n-    // in the future, we may want to let users do this or maybe specify a list of classes or\n-    // a package that will be searched for applications, to allow multiple applications in a single artifact.\n-    String mainClassName;\n-    try {\n-      Manifest manifest = BundleJarUtil.getManifest(artifactLocation);\n-      if (manifest == null) {\n-        return builder;\n-      }\n-      Attributes manifestAttributes = manifest.getMainAttributes();\n-      if (manifestAttributes == null) {\n-        return builder;\n-      }\n-      mainClassName = manifestAttributes.getValue(ManifestFields.MAIN_CLASS);\n-    } catch (ZipException e) {\n-      throw new InvalidArtifactException(String.format(\n-        \"Couldn't unzip artifact %s, please check it is a valid jar file.\", artifactId), e);\n-    }\n-\n-    if (mainClassName == null) {\n-      return builder;\n-    }\n-\n-    try {\n-      Object appMain = artifactClassLoader.loadClass(mainClassName).newInstance();\n-      if (!(appMain instanceof Application)) {\n-        // we don't want to error here, just don't record an application class.\n-        // possible for 3rd party plugin artifacts to have the main class set\n-        return builder;\n-      }\n-\n-      Application app = (Application) appMain;\n-\n-      java.lang.reflect.Type configType;\n-      // if the user parameterized their application, like 'xyz extends Application<T>',\n-      // we can deserialize the config into that object. Otherwise it'll just be a Config\n-      try {\n-        configType = Artifacts.getConfigType(app.getClass());\n-      } catch (Exception e) {\n-        throw new InvalidArtifactException(String.format(\n-          \"Could not resolve config type for Application class %s in artifact %s. \" +\n-            \"The type must extend Config and cannot be parameterized.\", mainClassName, artifactId));\n-      }\n-\n-      Schema configSchema = configType == Config.class ? null : schemaGenerator.generate(configType);\n-      builder.addApp(new ApplicationClass(mainClassName, \"\", configSchema, getArtifactRequirements(app.getClass())));\n-    } catch (ClassNotFoundException e) {\n-      throw new InvalidArtifactException(String.format(\n-        \"Could not find Application main class %s in artifact %s.\", mainClassName, artifactId));\n-    } catch (UnsupportedTypeException e) {\n-      throw new InvalidArtifactException(String.format(\n-        \"Config for Application %s in artifact %s has an unsupported schema. \" +\n-          \"The type must extend Config and cannot be parameterized.\", mainClassName, artifactId));\n-    } catch (InstantiationException | IllegalAccessException e) {\n-      throw new InvalidArtifactException(String.format(\n-        \"Could not instantiate Application class %s in artifact %s.\", mainClassName, artifactId), e);\n-    }\n-\n-    return builder;\n-  }\n-\n-  /**\n-   * Inspects the plugin file and extracts plugin classes information.\n-   */\n-  private ArtifactClasses.Builder inspectPlugins(ArtifactClasses.Builder builder, File artifactFile,\n-                                                 ArtifactId artifactId, PluginInstantiator pluginInstantiator,\n-                                                 Set<PluginClass> additionalPlugins)\n-    throws IOException, InvalidArtifactException {\n-    ClassLoader pluginClassLoader = pluginInstantiator.getArtifactClassLoader(artifactId);\n-    inspectAdditionalPlugins(artifactId, additionalPlugins, pluginClassLoader);\n-\n-    // See if there are export packages. Plugins should be in those packages\n-    Set<String> exportPackages = getExportPackages(artifactFile);\n-    if (exportPackages.isEmpty()) {\n-      return builder;\n-    }\n-\n-    try {\n-      for (Class<?> cls : getPluginClasses(exportPackages, pluginClassLoader)) {\n-        Plugin pluginAnnotation = cls.getAnnotation(Plugin.class);\n-        if (pluginAnnotation == null) {\n-          continue;\n-        }\n-        Map<String, PluginPropertyField> pluginProperties = Maps.newHashMap();\n-        try {\n-          String configField = getProperties(TypeToken.of(cls), pluginProperties);\n-          PluginClass pluginClass = new PluginClass(pluginAnnotation.type(), getPluginName(cls),\n-                                                    getPluginDescription(cls), cls.getName(),\n-                                                    configField, pluginProperties, getArtifactRequirements(cls));\n-          builder.addPlugin(pluginClass);\n-        } catch (UnsupportedTypeException e) {\n-          LOG.warn(\"Plugin configuration type not supported. Plugin ignored. {}\", cls, e);\n-        }\n-      }\n-    } catch (Throwable t) {\n-      throw new InvalidArtifactException(String.format(\n-        \"Class could not be found while inspecting artifact for plugins. \" +\n-          \"Please check dependencies are available, and that the correct parent artifact was specified. \" +\n-          \"Error class: %s, message: %s.\", t.getClass(), t.getMessage()), t);\n-    }\n-\n-    return builder;\n-  }\n-\n-  private void inspectAdditionalPlugins(ArtifactId artifactId, Set<PluginClass> additionalPlugins,\n-                                        ClassLoader pluginClassLoader) throws InvalidArtifactException {\n-    if (additionalPlugins != null) {\n-      for (PluginClass pluginClass : additionalPlugins) {\n-        try {\n-          // Make sure additional plugin classes can be loaded. This is to ensure that plugin artifacts without\n-          // plugin classes are not deployed.\n-          pluginClassLoader.loadClass(pluginClass.getClassName());\n-        } catch (ClassNotFoundException e) {\n-          throw new InvalidArtifactException(\n-            String.format(\"Artifact %s with version %s and scope %s does not have class %s.\",\n-                          artifactId.getName(), artifactId.getVersion(), artifactId.getScope().name(),\n-                          pluginClass.getClassName()), e);\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Returns the set of package names that are declared in \"Export-Package\" in the jar file Manifest.\n-   */\n-  private Set<String> getExportPackages(File file) throws IOException {\n-    try (JarFile jarFile = new JarFile(file)) {\n-      return ManifestFields.getExportPackages(jarFile.getManifest());\n-    }\n-  }\n-\n-  /**\n-   * Returns an {@link Iterable} of class name that are under the given list of package names that are loadable\n-   * through the plugin ClassLoader.\n-   */\n-  private Iterable<Class<?>> getPluginClasses(final Iterable<String> packages, final ClassLoader pluginClassLoader) {\n-    return new Iterable<Class<?>>() {\n-      @Override\n-      public Iterator<Class<?>> iterator() {\n-        final Iterator<String> packageIterator = packages.iterator();\n-\n-        return new AbstractIterator<Class<?>>() {\n-          Iterator<String> classIterator = ImmutableList.<String>of().iterator();\n-          String currentPackage;\n-\n-          @Override\n-          protected Class<?> computeNext() {\n-            while (!classIterator.hasNext()) {\n-              if (!packageIterator.hasNext()) {\n-                return endOfData();\n-              }\n-              currentPackage = packageIterator.next();\n-\n-              try {\n-                // Gets all package resource URL for the given package\n-                String resourceName = currentPackage.replace('.', File.separatorChar);\n-                Enumeration<URL> resources = pluginClassLoader.getResources(resourceName);\n-                List<Iterator<String>> iterators = new ArrayList<>();\n-                // Go though all available resources and collect all class names that are plugin classes.\n-                while (resources.hasMoreElements()) {\n-                  URL packageResource = resources.nextElement();\n-\n-                  // Only inspect classes in the top level jar file for Plugins.\n-                  // The jar manifest may have packages in Export-Package that are loadable from the bundled jar files,\n-                  // which is for classloading purpose. Those classes won't be inspected for plugin classes.\n-                  // There should be exactly one of resource that match, because it maps to a directory on the FS.\n-                  if (packageResource.getProtocol().equals(\"file\")) {\n-                    Iterator<String> classFiles = DirUtils.list(new File(packageResource.toURI()), \"class\").iterator();\n-\n-                    // Transform class file into class name and filter by @Plugin class only\n-                    iterators.add(Iterators.filter(\n-                      Iterators.transform(classFiles, new Function<String, String>() {\n-                        @Override\n-                        public String apply(String input) {\n-                          return getClassName(currentPackage, input);\n-                        }\n-                      }), new Predicate<String>() {\n-                        @Override\n-                        public boolean apply(String className) {\n-                          return isPlugin(className, pluginClassLoader);\n-                        }\n-                      }));\n-                  }\n-                }\n-                if (!iterators.isEmpty()) {\n-                  classIterator = Iterators.concat(iterators.iterator());\n-                }\n-              } catch (Exception e) {\n-                // Cannot happen\n-                throw Throwables.propagate(e);\n-              }\n-            }\n-\n-            try {\n-              return pluginClassLoader.loadClass(classIterator.next());\n-            } catch (ClassNotFoundException | NoClassDefFoundError e) {\n-              // Cannot happen, since the class name is from the list of the class files under the classloader.\n-              throw Throwables.propagate(e);\n-            }\n-          }\n-        };\n-      }\n-    };\n-  }\n-\n-  /**\n-   * Extracts and returns name of the plugin.\n-   */\n-  private String getPluginName(Class<?> cls) {\n-    Name annotation = cls.getAnnotation(Name.class);\n-    return annotation == null || annotation.value().isEmpty() ? cls.getName() : annotation.value();\n-  }\n-\n-  /**\n-   * Get all the {@link io.cdap.cdap.api.annotation.Requirements} specified by a plugin as {@link Requirements}.\n-   * The requirements are case insensitive and always represented in lowercase.\n-   *\n-   * @param cls the plugin class whose requirement needs to be found\n-   *\n-   * @return {@link Requirements} containing the requirements specified by the plugin (in lowercase). If the plugin does\n-   * not specify any {@link io.cdap.cdap.api.annotation.Requirements} then the {@link Requirements} will be empty.\n-   */\n-  @VisibleForTesting\n-  Requirements getArtifactRequirements(Class<?> cls) {\n-    io.cdap.cdap.api.annotation.Requirements annotation =\n-      cls.getAnnotation(io.cdap.cdap.api.annotation.Requirements.class);\n-    if (annotation == null) {\n-      return Requirements.EMPTY;\n-    }\n-    return new Requirements(getAnnotationValues(annotation.datasetTypes()),\n-                            getAnnotationValues(annotation.accelerators()));\n-  }\n-\n-  private Set<String> getAnnotationValues(String[] field) {\n-    return Arrays.stream(field).map(String::trim).map(String::toLowerCase).filter(Objects::nonNull)\n-      .filter(s -> !s.isEmpty()).collect(Collectors.toSet());\n-  }\n-\n-  /**\n-   * Returns description for the plugin.\n-   */\n-  private String getPluginDescription(Class<?> cls) {\n-    Description annotation = cls.getAnnotation(Description.class);\n-    return annotation == null ? \"\" : annotation.value();\n-  }\n-\n-  /**\n-   * Constructs the fully qualified class name based on the package name and the class file name.\n+   * actually an Application.\n    */\n-  private String getClassName(String packageName, String classFileName) {\n-    return packageName + \".\" + classFileName.substring(0, classFileName.length() - \".class\".length());\n-  }\n-\n-  /**\n-   * Gets all config properties for the given plugin.\n-   *\n-   * @return the name of the config field in the plugin class or {@code null} if the plugin doesn't have a config field\n-   */\n-  @Nullable\n-  private String getProperties(TypeToken<?> pluginType,\n-                               Map<String, PluginPropertyField> result) throws UnsupportedTypeException {\n-    // Get the config field\n-    for (TypeToken<?> type : pluginType.getTypes().classes()) {\n-      for (Field field : type.getRawType().getDeclaredFields()) {\n-        TypeToken<?> fieldType = TypeToken.of(field.getGenericType());\n-        if (PluginConfig.class.isAssignableFrom(fieldType.getRawType())) {\n-          // Pick up all config properties\n-          inspectConfigField(fieldType, result);\n-          return field.getName();\n-        }\n-      }\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * Inspects the plugin config class and build up a map for {@link PluginPropertyField}.\n-   *\n-   * @param configType type of the config class\n-   * @param result map for storing the result\n-   * @throws UnsupportedTypeException if a field type in the config class is not supported\n-   */\n-  private void inspectConfigField(TypeToken<?> configType,\n-                                  Map<String, PluginPropertyField> result) throws UnsupportedTypeException {\n-    for (TypeToken<?> type : configType.getTypes().classes()) {\n-      if (PluginConfig.class.equals(type.getRawType())) {\n-        break;\n-      }\n-\n-      for (Field field : type.getRawType().getDeclaredFields()) {\n-        int modifiers = field.getModifiers();\n-        if (Modifier.isTransient(modifiers) || Modifier.isStatic(modifiers) || field.isSynthetic()) {\n-          continue;\n-        }\n-\n-        PluginPropertyField property = createPluginProperty(field, type);\n-        if (result.containsKey(property.getName())) {\n-          throw new IllegalArgumentException(\"Plugin config with name \" + property.getName()\n-                                               + \" already defined in \" + configType.getRawType());\n-        }\n-        result.put(property.getName(), property);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Creates a {@link PluginPropertyField} based on the given field.\n-   */\n-  private PluginPropertyField createPluginProperty(Field field,\n-                                                   TypeToken<?> resolvingType) throws UnsupportedTypeException {\n-    TypeToken<?> fieldType = resolvingType.resolveType(field.getGenericType());\n-    Class<?> rawType = fieldType.getRawType();\n-\n-    Name nameAnnotation = field.getAnnotation(Name.class);\n-    Description descAnnotation = field.getAnnotation(Description.class);\n-    String name = nameAnnotation == null ? field.getName() : nameAnnotation.value();\n-    String description = descAnnotation == null ? \"\" : descAnnotation.value();\n-\n-    Macro macroAnnotation = field.getAnnotation(Macro.class);\n-    boolean macroSupported = macroAnnotation != null;\n-    if (rawType.isPrimitive()) {\n-      return new PluginPropertyField(name, description, rawType.getName(), true, macroSupported);\n-    }\n-\n-    rawType = Primitives.unwrap(rawType);\n-    if (!rawType.isPrimitive() && !String.class.equals(rawType)) {\n-      throw new UnsupportedTypeException(\"Only primitive and String types are supported\");\n-    }\n-\n-    boolean required = true;\n-    for (Annotation annotation : field.getAnnotations()) {\n-      if (annotation.annotationType().getName().endsWith(\".Nullable\")) {\n-        required = false;\n-        break;\n-      }\n-    }\n-\n-    return new PluginPropertyField(name, description, rawType.getSimpleName().toLowerCase(), required, macroSupported);\n-  }\n-\n-  /**\n-   * Detects if a class is annotated with {@link Plugin} without loading the class.\n-   *\n-   * @param className name of the class\n-   * @param classLoader ClassLoader for loading the class file of the given class\n-   * @return true if the given class is annotated with {@link Plugin}\n-   */\n-  private boolean isPlugin(String className, ClassLoader classLoader) {\n-    try (InputStream is = classLoader.getResourceAsStream(className.replace('.', '/') + \".class\")) {\n-      if (is == null) {\n-        return false;\n-      }\n-\n-      // Use ASM to inspect the class bytecode to see if it is annotated with @Plugin\n-      final boolean[] isPlugin = new boolean[1];\n-      ClassReader cr = new ClassReader(is);\n-      cr.accept(new ClassVisitor(Opcodes.ASM5) {\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n-          if (Plugin.class.getName().equals(Type.getType(desc).getClassName()) && visible) {\n-            isPlugin[0] = true;\n-          }\n-          return super.visitAnnotation(desc, visible);\n-        }\n-      }, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);\n-\n-      return isPlugin[0];\n-    } catch (IOException e) {\n-      // If failed to open the class file, then it cannot be a plugin\n-      LOG.warn(\"Failed to open class file for {}\", className, e);\n-      return false;\n-    }\n-  }\n+  ArtifactClassesWithMetadata inspectArtifact(Id.Artifact artifactId, File artifactFile,\n+                                              @Nullable ClassLoader parentClassLoader,\n+                                              Set<PluginClass> additionalPlugins)\n+    throws IOException, InvalidArtifactException;\n }\n", "next_change": {"commit": "a704d373c9a8483ffea857e76e0c501d62ecb733", "changed_code": [{"header": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\nindex 7f1e2325ea1..08917ce9dc9 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n", "chunk": "@@ -34,16 +35,15 @@ interface ArtifactInspector {\n    *\n    * @param artifactId the id of the artifact to inspect\n    * @param artifactFile the artifact file\n-   * @param parentClassLoader the parent classloader to use when inspecting plugins contained in the artifact.\n-   * For example, a ProgramClassLoader created from the artifact the input artifact extends\n+   * @param parentDescriptors {@link ArtifactDescriptor} of parent and grandparent (if any) artifacts.\n    * @param additionalPlugins Additional plugin classes\n    * @return metadata about the classes contained in the artifact\n-   * @throws IOException if there was an exception opening the jar file\n+   * @throws IOException              if there was an exception opening the jar file\n    * @throws InvalidArtifactException if the artifact is invalid. For example, if the application main class is not\n-   * actually an Application.\n+   *                                  actually an Application.\n    */\n   ArtifactClassesWithMetadata inspectArtifact(Id.Artifact artifactId, File artifactFile,\n-                                              @Nullable ClassLoader parentClassLoader,\n+                                              List<ArtifactDescriptor> parentDescriptors,\n                                               Set<PluginClass> additionalPlugins)\n     throws IOException, InvalidArtifactException;\n }\n", "next_change": {"commit": "e81bb233fa54e757ace4bbd36a91eec48d967675", "changed_code": [{"header": "diff --git a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\nindex 08917ce9dc9..3f9249665ff 100644\n--- a/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n+++ b/cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/artifact/ArtifactInspector.java\n", "chunk": "@@ -19,31 +19,31 @@ package io.cdap.cdap.internal.app.runtime.artifact;\n import io.cdap.cdap.api.plugin.PluginClass;\n import io.cdap.cdap.common.InvalidArtifactException;\n import io.cdap.cdap.common.id.Id;\n-\n import java.io.File;\n import java.io.IOException;\n import java.util.List;\n import java.util.Set;\n-import javax.annotation.Nullable;\n \n /**\n  * Inspects a jar file to determine metadata about the artifact.\n  */\n interface ArtifactInspector {\n+\n   /**\n    * Inspect the given artifact to determine the classes contained in the artifact.\n    *\n    * @param artifactId the id of the artifact to inspect\n    * @param artifactFile the artifact file\n-   * @param parentDescriptors {@link ArtifactDescriptor} of parent and grandparent (if any) artifacts.\n+   * @param parentDescriptors {@link ArtifactDescriptor} of parent and grandparent (if any)\n+   *     artifacts.\n    * @param additionalPlugins Additional plugin classes\n    * @return metadata about the classes contained in the artifact\n-   * @throws IOException              if there was an exception opening the jar file\n-   * @throws InvalidArtifactException if the artifact is invalid. For example, if the application main class is not\n-   *                                  actually an Application.\n+   * @throws IOException if there was an exception opening the jar file\n+   * @throws InvalidArtifactException if the artifact is invalid. For example, if the\n+   *     application main class is not actually an Application.\n    */\n   ArtifactClassesWithMetadata inspectArtifact(Id.Artifact artifactId, File artifactFile,\n-                                              List<ArtifactDescriptor> parentDescriptors,\n-                                              Set<PluginClass> additionalPlugins)\n-    throws IOException, InvalidArtifactException;\n+      List<ArtifactDescriptor> parentDescriptors,\n+      Set<PluginClass> additionalPlugins)\n+      throws IOException, InvalidArtifactException;\n }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "5ee1c35a20170ee677854b0b159b2241fe4d7f79", "message": "Merge commit", "committedDate": null}, {"oid": "6909c6dc8d5914ddfae0e455dcfa5bf7b5190c91", "committedDate": "2020-11-18 18:41:27 +0000", "message": "Rename accelerators to capabilities"}, {"oid": "25b8c1ab6f68348051f2c953110c12bb7c18f4ef", "committedDate": "2021-02-19 00:58:31 -0800", "message": "(CDAP-17610) Added OAuth macro function"}, {"oid": "ea31a28db91ca082aec16f0b12be408e49b085d9", "committedDate": "2021-03-22 11:17:44 -0700", "message": "[CDAP-17818] Optimize jar unpacking in PluginInstantiator"}, {"oid": "38644a22ebbd96b5f7c2a40db9bd3ab0a34e9c40", "committedDate": "2021-03-31 10:39:27 -0700", "message": "Further optimization of jar handling.  * Globally unpack only nested jars and manifests and use other classes/resources from the original jar as is.  * Cache jar creation in tests as it takes significant time on test start and it can be reused between tests and even within one test that creates multiple apps (e.g. DataPipelineTest)  * Replace file copy with hard links"}, {"oid": "668bab156136826942a4c2315d06dc4dd4cebb09", "committedDate": "2021-04-26 09:27:48 -0700", "message": "CDAP-17931 support category for plugins"}, {"oid": "15183234aab9b378495f08e8e8077e3fd2fe7b6c", "committedDate": "2021-05-04 11:31:09 -0700", "message": "CDAP-17903 Allow reusing connection in pipeline"}, {"oid": "e7cbe1eae862f40a1eb59f90c2e0ac1b34756ffd", "committedDate": "2021-05-04 13:47:23 -0700", "message": "CDAP-17905 support emit metadata in plugin"}, {"oid": "8e25fd97367428a93c569d8d7510d4eb304d9945", "committedDate": "2021-05-26 15:09:19 -0700", "message": "CDAP-18010: Renaming ArtifactInspector to DefaultArtifactInspector"}, {"oid": "167da7ddca341b4e07859e8ba7c7cbcb8208fdde", "committedDate": "2021-05-26 23:26:05 -0700", "message": "CDAP-18010: Introduce ArtifactInspector interface"}, {"oid": "a704d373c9a8483ffea857e76e0c501d62ecb733", "committedDate": "2021-06-29 18:09:58 -0700", "message": "CDAP-18010: Code refactoring to move parentClassloader creation into DefaultArtifactInspector"}, {"oid": "fab9cfd6b79cf3f23f74fa272771e5434b44d8c4", "committedDate": "2022-03-17 14:07:31 -0700", "message": "Added checks for unused imports"}, {"oid": "7623d5395ba95dd4464c10d6726f852d3b75ca4e", "committedDate": "2023-03-01 08:58:23 -0800", "message": "Migrate to Google-style checkstyle. High backwards compatibility is the goal, but much more checks will be done. Note that most checkstyle issues will be reported as warnings and will be enforced by code review / GitHub Actions checkstyle report."}, {"oid": "e81bb233fa54e757ace4bbd36a91eec48d967675", "committedDate": "2023-03-03 14:58:43 -0800", "message": "Reformat java code according to new style"}]}, {"oid": "79812780457fc997304d59d6315a3a2813fee3ea", "url": "https://github.com/cdapio/cdap/commit/79812780457fc997304d59d6315a3a2813fee3ea", "message": "(CDAP-17270) Add accelerators to Requirements annotation. Enable Requirements annotation for ApplicationClass.", "committedDate": "2020-10-22T00:35:30Z", "type": "commit"}, {"oid": "79812780457fc997304d59d6315a3a2813fee3ea", "url": "https://github.com/cdapio/cdap/commit/79812780457fc997304d59d6315a3a2813fee3ea", "message": "(CDAP-17270) Add accelerators to Requirements annotation. Enable Requirements annotation for ApplicationClass.", "committedDate": "2020-10-22T00:35:30Z", "type": "forcePushed"}]}