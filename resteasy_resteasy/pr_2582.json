{"pr_number": 2582, "pr_title": "Add test for https://github.com/resteasy/Resteasy/pull/2578", "pr_author": "jimma", "pr_createdAt": "2020-10-26T08:56:05Z", "pr_url": "https://github.com/resteasy/resteasy/pull/2582", "merge_commit": "1cad12e3c0e99f1013218f262ca363a1d6cf1cfe", "timeline": [{"oid": "3be33baeb41f065c38b02fdab57a3f4a08621e45", "url": "https://github.com/resteasy/resteasy/commit/3be33baeb41f065c38b02fdab57a3f4a08621e45", "message": "Dependency-free implementation of the SSE Publisher", "committedDate": "2020-10-22T15:06:21Z", "type": "commit"}, {"oid": "3d1c950100a39d8e0db959010853a594ae066c6c", "url": "https://github.com/resteasy/resteasy/commit/3d1c950100a39d8e0db959010853a594ae066c6c", "message": "Add sse publisher test", "committedDate": "2020-10-23T11:50:55Z", "type": "commit"}, {"oid": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a", "url": "https://github.com/resteasy/resteasy/commit/d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a", "message": "Add executor to SSEPublisher;Refactor test", "committedDate": "2020-10-26T08:33:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMzA3NQ==", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511823075", "body": "Shouldn't we remove this commented line?", "bodyText": "Shouldn't we remove this commented line?", "bodyHTML": "<p dir=\"auto\">Shouldn't we remove this commented line?</p>", "author": "cescoffier", "createdAt": "2020-10-26T09:30:51Z", "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java", "diffHunk": "@@ -20,6 +20,8 @@\n import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n+import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n+//import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;", "originalCommit": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0MTEyOQ==", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511841129", "bodyText": "Thanks. Fixed.", "author": "jimma", "createdAt": "2020-10-26T10:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMzA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7db7d440f8d0ed9ae0855134edbe1236b48f2be9", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\nindex 3fae1e60e2..9404ab0115 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n", "chunk": "@@ -21,7 +21,6 @@ import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n-//import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n import org.jboss.resteasy.spi.ResteasyProviderFactory;\n import org.jboss.resteasy.spi.ResteasyUriBuilder;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "1cad12e3c0e99f1013218f262ca363a1d6cf1cfe", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\nindex 3fae1e60e2..9404ab0115 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n", "chunk": "@@ -21,7 +21,6 @@ import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n-//import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n import org.jboss.resteasy.spi.ResteasyProviderFactory;\n import org.jboss.resteasy.spi.ResteasyUriBuilder;\n \n", "next_change": {"commit": "0fa5ac422bf358cf36ea0ded87e50d9d1ecd5c2c", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\nindex 9404ab0115..cc096644d9 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n", "chunk": "@@ -18,14 +14,11 @@ import org.jboss.resteasy.client.jaxrs.internal.LocalResteasyProviderFactory;\n import org.jboss.resteasy.microprofile.client.async.AsyncInterceptorRxInvokerProvider;\n import org.jboss.resteasy.microprofile.client.header.ClientHeaderProviders;\n import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n-import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n-import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n+import org.jboss.resteasy.specimpl.ResteasyUriBuilderImpl;\n import org.jboss.resteasy.spi.ResteasyProviderFactory;\n import org.jboss.resteasy.spi.ResteasyUriBuilder;\n \n-import javax.enterprise.inject.spi.BeanManager;\n-import javax.enterprise.inject.spi.CDI;\n import javax.net.ssl.HostnameVerifier;\n import javax.net.ssl.SSLContext;\n import javax.ws.rs.BeanParam;\n", "next_change": {"commit": "099515d3b60cd08b075710512de823e8bb7cb4f0", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\nindex cc096644d9..5ee300b9bf 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n", "chunk": "@@ -14,11 +18,17 @@ import org.jboss.resteasy.client.jaxrs.internal.LocalResteasyProviderFactory;\n import org.jboss.resteasy.microprofile.client.async.AsyncInterceptorRxInvokerProvider;\n import org.jboss.resteasy.microprofile.client.header.ClientHeaderProviders;\n import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n+import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n import org.jboss.resteasy.specimpl.ResteasyUriBuilderImpl;\n import org.jboss.resteasy.spi.ResteasyProviderFactory;\n import org.jboss.resteasy.spi.ResteasyUriBuilder;\n \n+\n+\n+\n+import javax.enterprise.inject.spi.BeanManager;\n+import javax.enterprise.inject.spi.CDI;\n import javax.net.ssl.HostnameVerifier;\n import javax.net.ssl.SSLContext;\n import javax.ws.rs.BeanParam;\n", "next_change": {"commit": "93fa2dc081b2b95d86e7200acd868ec4c117aef7", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\nindex 5ee300b9bf..334fba0ea1 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n", "chunk": "@@ -24,9 +24,6 @@ import org.jboss.resteasy.specimpl.ResteasyUriBuilderImpl;\n import org.jboss.resteasy.spi.ResteasyProviderFactory;\n import org.jboss.resteasy.spi.ResteasyUriBuilder;\n \n-\n-\n-\n import javax.enterprise.inject.spi.BeanManager;\n import javax.enterprise.inject.spi.CDI;\n import javax.net.ssl.HostnameVerifier;\n", "next_change": {"commit": "67aa3ba88e86df0f3d0a672ad9b1eabddc70ff4d", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\nindex 334fba0ea1..e249f1671b 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n", "chunk": "@@ -21,6 +21,7 @@ import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n import org.jboss.resteasy.microprofile.client.impl.MpClient;\n import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n import org.jboss.resteasy.specimpl.ResteasyUriBuilderImpl;\n+import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n import org.jboss.resteasy.spi.ResteasyProviderFactory;\n import org.jboss.resteasy.spi.ResteasyUriBuilder;\n \n", "next_change": {"commit": "6b42079f2566b9825825fb8a1bbace7fc3dadd88", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\ndeleted file mode 100644\nindex e249f1671b..0000000000\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/RestClientBuilderImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,779 +0,0 @@\n-package org.jboss.resteasy.microprofile.client;\n-\n-import org.eclipse.microprofile.config.Config;\n-import org.eclipse.microprofile.config.ConfigProvider;\n-import org.eclipse.microprofile.rest.client.RestClientBuilder;\n-import org.eclipse.microprofile.rest.client.RestClientDefinitionException;\n-import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n-import org.eclipse.microprofile.rest.client.ext.AsyncInvocationInterceptorFactory;\n-import org.eclipse.microprofile.rest.client.ext.QueryParamStyle;\n-import org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper;\n-import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n-import org.jboss.logging.Logger;\n-import org.jboss.resteasy.cdi.CdiInjectorFactory;\n-import org.jboss.resteasy.client.jaxrs.ResteasyClient;\n-import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;\n-import org.jboss.resteasy.client.jaxrs.engines.URLConnectionClientEngineBuilder;\n-import org.jboss.resteasy.client.jaxrs.internal.LocalResteasyProviderFactory;\n-import org.jboss.resteasy.microprofile.client.async.AsyncInterceptorRxInvokerProvider;\n-import org.jboss.resteasy.microprofile.client.header.ClientHeaderProviders;\n-import org.jboss.resteasy.microprofile.client.header.ClientHeadersRequestFilter;\n-import org.jboss.resteasy.microprofile.client.impl.MpClient;\n-import org.jboss.resteasy.microprofile.client.impl.MpClientBuilderImpl;\n-import org.jboss.resteasy.specimpl.ResteasyUriBuilderImpl;\n-import org.jboss.resteasy.microprofile.client.publisher.MpPublisherMessageBodyReader;\n-import org.jboss.resteasy.spi.ResteasyProviderFactory;\n-import org.jboss.resteasy.spi.ResteasyUriBuilder;\n-\n-import javax.enterprise.inject.spi.BeanManager;\n-import javax.enterprise.inject.spi.CDI;\n-import javax.net.ssl.HostnameVerifier;\n-import javax.net.ssl.SSLContext;\n-import javax.ws.rs.BeanParam;\n-import javax.ws.rs.HttpMethod;\n-import javax.ws.rs.Path;\n-import javax.ws.rs.PathParam;\n-import javax.ws.rs.Priorities;\n-import javax.ws.rs.core.Configuration;\n-import javax.ws.rs.core.MediaType;\n-import javax.ws.rs.ext.ParamConverterProvider;\n-\n-import java.io.Closeable;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AnnotatedElement;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Parameter;\n-import java.lang.reflect.Proxy;\n-import java.net.InetSocketAddress;\n-import java.net.ProxySelector;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.security.AccessController;\n-import java.security.KeyStore;\n-import java.security.PrivilegedAction;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import static org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder.PROPERTY_PROXY_HOST;\n-import static org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder.PROPERTY_PROXY_PORT;\n-import static org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder.PROPERTY_PROXY_SCHEME;\n-\n-public class RestClientBuilderImpl implements RestClientBuilder {\n-\n-    private static final String RESTEASY_PROPERTY_PREFIX = \"resteasy.\";\n-\n-    private static final String DEFAULT_MAPPER_PROP = \"microprofile.rest.client.disable.default.mapper\";\n-    private static final Logger LOGGER = Logger.getLogger(RestClientBuilderImpl.class);\n-    private static final DefaultMediaTypeFilter DEFAULT_MEDIA_TYPE_FILTER = new DefaultMediaTypeFilter();\n-    public static final MethodInjectionFilter METHOD_INJECTION_FILTER = new MethodInjectionFilter();\n-    public static final ClientHeadersRequestFilter HEADERS_REQUEST_FILTER = new ClientHeadersRequestFilter();\n-\n-    static ResteasyProviderFactory PROVIDER_FACTORY;\n-\n-    public static void setProviderFactory(ResteasyProviderFactory providerFactory) {\n-        PROVIDER_FACTORY = providerFactory;\n-    }\n-\n-    public RestClientBuilderImpl() {\n-        builderDelegate = new MpClientBuilderImpl();\n-\n-        if (PROVIDER_FACTORY != null) {\n-            ResteasyProviderFactory localProviderFactory = new LocalResteasyProviderFactory(PROVIDER_FACTORY);\n-            if (ResteasyProviderFactory.peekInstance() != null) {\n-                localProviderFactory.initializeClientProviders(ResteasyProviderFactory.getInstance());\n-            }\n-            builderDelegate.providerFactory(localProviderFactory);\n-        }\n-        if (getBeanManager() != null) {\n-            builderDelegate.getProviderFactory()\n-                    .setInjectorFactory(new CdiInjectorFactory(getBeanManager()));\n-        }\n-        configurationWrapper = new ConfigurationWrapper(builderDelegate.getConfiguration());\n-\n-        try {\n-            // configuration MP may not be available.\n-            config = ConfigProvider.getConfig();\n-        } catch (Throwable e) {\n-\n-        }\n-    }\n-\n-    public Configuration getConfigurationWrapper() {\n-        return configurationWrapper;\n-    }\n-\n-    @Override\n-    public RestClientBuilder followRedirects(boolean followRedirect) {\n-        this.followRedirect = followRedirect;\n-        return this;\n-    }\n-    public boolean isFollowRedirects() {\n-        return this.followRedirect;\n-    }\n-\n-    @Override\n-    public RestClientBuilder queryParamStyle(QueryParamStyle queryParamStyle) {\n-        this.queryParamStyle = queryParamStyle;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder proxyAddress(String host, int port){\n-        if (host == null) {\n-            throw new IllegalArgumentException(\"proxyHost must not be null\");\n-        }\n-        if (port <=0 || port > 65535) {\n-            throw new IllegalArgumentException(\"Invalid port number\");\n-        }\n-        this.proxyHost = host;\n-        this.proxyPort = port;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder baseUrl(URL url) {\n-        try {\n-            baseURI = url.toURI();\n-            return this;\n-        } catch (URISyntaxException e) {\n-            throw new RuntimeException(e.getMessage());\n-        }\n-    }\n-\n-    @Override\n-    public RestClientBuilder baseUri(URI uri) {\n-        baseURI = uri;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder connectTimeout(long l, TimeUnit timeUnit) {\n-        connectTimeout = l;\n-        connectTimeoutUnit = timeUnit;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder readTimeout(long time, TimeUnit timeUnit) {\n-        readTimeout = time;\n-        readTimeoutUnit = timeUnit;\n-        return this;\n-    }\n-\n-\n-    @Override\n-    public RestClientBuilder sslContext(SSLContext sslContext) {\n-        this.sslContext = sslContext;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder trustStore(KeyStore trustStore) {\n-        this.trustStore = trustStore;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder keyStore(KeyStore keyStore, String keystorePassword) {\n-        this.keyStore = keyStore;\n-        this.keystorePassword = keystorePassword;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder hostnameVerifier(HostnameVerifier hostnameVerifier) {\n-        this.hostnameVerifier = hostnameVerifier;\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder executorService(ExecutorService executor) {\n-        if (executor == null) {\n-            throw new IllegalArgumentException(\"ExecutorService must not be null\");\n-        }\n-        executorService = executor;\n-        return this;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> T build(Class<T> aClass) throws IllegalStateException, RestClientDefinitionException {\n-\n-        RestClientListeners.get().forEach(listener -> listener.onNewClient(aClass, this));\n-\n-        // Interface validity\n-        verifyInterface(aClass);\n-\n-        if (baseURI == null) {\n-            throw new IllegalStateException(\"Neither baseUri nor baseUrl was specified\");\n-        }\n-\n-        // Provider annotations\n-        RegisterProvider[] providers = aClass.getAnnotationsByType(RegisterProvider.class);\n-\n-        for (RegisterProvider provider : providers) {\n-            register(provider.value(), provider.priority());\n-        }\n-\n-        // Default exception mapper\n-        if (!isMapperDisabled()) {\n-            register(DefaultResponseExceptionMapper.class);\n-        }\n-\n-        builderDelegate.register(new ExceptionMapping(localProviderInstances), 1);\n-\n-        ClassLoader classLoader = aClass.getClassLoader();\n-\n-\n-\n-        T actualClient;\n-        ResteasyClient client;\n-\n-        ResteasyClientBuilder resteasyClientBuilder;\n-        List<String> noProxyHosts = Arrays.asList(\n-                getSystemProperty(\"http.nonProxyHosts\", \"localhost|127.*|[::1]\").split(\"\\\\|\"));\n-        if (this.proxyHost != null) {\n-            resteasyClientBuilder = builderDelegate.defaultProxy(proxyHost, this.proxyPort);\n-        } else {\n-            String envProxyHost = getSystemProperty(\"http.proxyHost\", null);\n-            boolean isUriMatched = false;\n-            if (envProxyHost != null && !noProxyHosts.isEmpty()) {\n-                for (String s : noProxyHosts) {\n-                    Pattern p = Pattern.compile(s);\n-                    Matcher m = p.matcher(baseURI.getHost());\n-                    isUriMatched = m.matches();\n-                    if (isUriMatched) {\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            if (envProxyHost != null && !isUriMatched) {\n-                // Use proxy, if defined in the env variables\n-                resteasyClientBuilder = builderDelegate.defaultProxy(envProxyHost,\n-                        Integer.parseInt(getSystemProperty(\"http.proxyPort\", \"80\")));\n-            } else {\n-                // Search for proxy settings passed in the client builder, if passed and use them if found\n-                String userProxyHost = Optional.ofNullable(getConfiguration().getProperty(PROPERTY_PROXY_HOST))\n-                        .filter(String.class::isInstance).map(String.class::cast).orElse(null);\n-\n-                Integer userProxyPort = Optional.ofNullable(getConfiguration().getProperty(PROPERTY_PROXY_PORT))\n-                        .filter(Integer.class::isInstance).map(Integer.class::cast).orElse(null);\n-\n-                String userProxyScheme = Optional.ofNullable(getConfiguration().getProperty(PROPERTY_PROXY_SCHEME))\n-                        .filter(String.class::isInstance).map(String.class::cast).orElse(null);\n-\n-                if (userProxyHost != null && userProxyPort != null) {\n-                    resteasyClientBuilder = builderDelegate.defaultProxy(userProxyHost, userProxyPort, userProxyScheme);\n-                } else {\n-                    // ProxySelector if applicable\n-                    selectHttpProxy().ifPresent(\n-                            proxyAddress -> builderDelegate.defaultProxy(proxyAddress.getHostString(), proxyAddress.getPort()));\n-\n-                    resteasyClientBuilder = builderDelegate;\n-                }\n-            }\n-        }\n-\n-        if (this.executorService != null) {\n-            resteasyClientBuilder.executorService(this.executorService);\n-        } else {\n-            this.executorService = Executors.newCachedThreadPool();\n-            resteasyClientBuilder.executorService(executorService, true);\n-        }\n-        resteasyClientBuilder.register(DEFAULT_MEDIA_TYPE_FILTER);\n-        resteasyClientBuilder.register(METHOD_INJECTION_FILTER);\n-        resteasyClientBuilder.register(HEADERS_REQUEST_FILTER);\n-        register(new MpPublisherMessageBodyReader(executorService));\n-        resteasyClientBuilder.sslContext(sslContext);\n-        resteasyClientBuilder.trustStore(trustStore);\n-        resteasyClientBuilder.keyStore(keyStore, keystorePassword);\n-\n-        resteasyClientBuilder.hostnameVerifier(hostnameVerifier);\n-        resteasyClientBuilder.setIsTrustSelfSignedCertificates(false);\n-        checkQueryParamStyleProperty(aClass);\n-        checkFollowRedirectProperty (aClass);\n-        resteasyClientBuilder.setFollowRedirects(followRedirect);\n-\n-        if (readTimeout != null) {\n-            resteasyClientBuilder.readTimeout(readTimeout, readTimeoutUnit);\n-        }\n-        if (connectTimeout != null) {\n-            resteasyClientBuilder.connectTimeout(connectTimeout, connectTimeoutUnit);\n-        }\n-\n-        if (useURLConnection()) {\n-            resteasyClientBuilder.httpEngine(new URLConnectionClientEngineBuilder().resteasyClientBuilder(resteasyClientBuilder).build());\n-            resteasyClientBuilder.sslContext(null);\n-            resteasyClientBuilder.trustStore(null);\n-            resteasyClientBuilder.keyStore(null, \"\");\n-        }\n-        client = resteasyClientBuilder\n-                .build();\n-        ((MpClient)client).setQueryParamStyle(queryParamStyle);\n-        client.register(AsyncInterceptorRxInvokerProvider.class);\n-        actualClient = client.target(baseURI)\n-                .proxyBuilder(aClass)\n-                .classloader(classLoader)\n-                .defaultConsumes(MediaType.APPLICATION_JSON)\n-                .defaultProduces(MediaType.APPLICATION_JSON).build();\n-\n-        Class<?>[] interfaces = new Class<?>[3];\n-        interfaces[0] = aClass;\n-        interfaces[1] = RestClientProxy.class;\n-        interfaces[2] = Closeable.class;\n-\n-        T proxy = (T) Proxy.newProxyInstance(classLoader, interfaces,\n-                new ProxyInvocationHandler(aClass, actualClient, getLocalProviderInstances(), client, getBeanManager()));\n-        ClientHeaderProviders.registerForClass(aClass, proxy);\n-        return proxy;\n-    }\n-\n-    /**\n-     * Determines whether or not to default to using the URLConnection instead of the Apache HTTP Client.\n-     * If the {@code org.jboss.resteasy.microprofile.defaultToURLConnectionHttpClient} system property is {@code true},\n-     * then this method returns {@code true}. In all other cases it returns {@code false}\n-     */\n-    private boolean useURLConnection() {\n-        if (useURLConnection == null) {\n-            String defaultToURLConnection = getSystemProperty(\"org.jboss.resteasy.microprofile.defaultToURLConnectionHttpClient\", \"false\");\n-            useURLConnection = defaultToURLConnection.toLowerCase().equals(\"true\");\n-        }\n-        return useURLConnection;\n-    }\n-\n-    private Optional<InetSocketAddress> selectHttpProxy() {\n-        return ProxySelector.getDefault().select(baseURI).stream()\n-                .filter(proxy -> proxy.type() == java.net.Proxy.Type.HTTP)\n-                .map(java.net.Proxy::address)\n-                .map(InetSocketAddress.class::cast)\n-                .findFirst();\n-    }\n-\n-    private void checkQueryParamStyleProperty(Class aClass) {\n-        // User's programmatic setting takes precedence over\n-        // microprofile-config.properties.\n-        if (queryParamStyle == null) {\n-            if (config != null) {\n-                // property using fully-qualified class name takes precedence\n-                Optional<String> prop = config.getOptionalValue(\n-                        aClass.getName()+\"/mp-rest/queryParamStyle\", String.class);\n-                if (prop.isPresent()) {\n-                    queryParamStyle(QueryParamStyle.valueOf(\n-                            prop.get().trim().toUpperCase()));\n-\n-                } else {\n-                    RegisterRestClient registerRestClient =\n-                            (RegisterRestClient)aClass.getAnnotation(RegisterRestClient.class);\n-                    if (registerRestClient !=null &&\n-                            registerRestClient.configKey() != null &&\n-                            !registerRestClient.configKey().isEmpty()) {\n-\n-                        //property using configKey\n-                        prop = config.getOptionalValue(registerRestClient.configKey()\n-                                + \"/mp-rest/queryParamStyle\", String.class);\n-                        if (prop.isPresent()) {\n-                            queryParamStyle(QueryParamStyle.valueOf(\n-                                    prop.get().trim().toUpperCase()));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if (queryParamStyle == null) {\n-            queryParamStyle = QueryParamStyle.MULTI_PAIRS;\n-        }\n-    }\n-\n-    private void checkFollowRedirectProperty (Class aClass) {\n-        // User's programmatic setting takes precedence over\n-        // microprofile-config.properties.\n-        if (!followRedirect) {\n-            if (config != null) {\n-                // property using fully-qualified class name takes precedence\n-                Optional<Boolean> prop = config.getOptionalValue(\n-                        aClass.getName()+\"/mp-rest/followRedirects\", Boolean.class);\n-                if (prop.isPresent()) {\n-                    if (prop.get() != followRedirect) {\n-                        followRedirects(prop.get());\n-                    }\n-                } else {\n-                    RegisterRestClient registerRestClient =\n-                            (RegisterRestClient)aClass.getAnnotation(RegisterRestClient.class);\n-                    if (registerRestClient !=null &&\n-                            registerRestClient.configKey() != null &&\n-                            !registerRestClient.configKey().isEmpty()) {\n-\n-                        //property using configKey\n-                        prop = config.getOptionalValue(\n-                                registerRestClient.configKey() + \"/mp-rest/followRedirects\", Boolean.class);\n-                        if (prop.isPresent()) {\n-                            if (prop.get() != followRedirect) {\n-                                followRedirects(prop.get());\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private boolean isMapperDisabled() {\n-        boolean disabled = false;\n-        Optional<Boolean> defaultMapperProp = config == null ? Optional.empty() : config.getOptionalValue(DEFAULT_MAPPER_PROP, Boolean.class);\n-\n-        // disabled through config api\n-        if (defaultMapperProp.isPresent() && defaultMapperProp.get().equals(Boolean.TRUE)) {\n-            disabled = true;\n-        } else if (!defaultMapperProp.isPresent()) {\n-\n-            // disabled through jaxrs property\n-            try {\n-                Object property = builderDelegate.getConfiguration().getProperty(DEFAULT_MAPPER_PROP);\n-                if (property != null) {\n-                    disabled = (Boolean) property;\n-                }\n-            } catch (Throwable e) {\n-                // ignore cast exception\n-            }\n-        }\n-        return disabled;\n-    }\n-\n-    private String getReflectName(AnnotatedElement element) {\n-        if (element instanceof Parameter) {\n-            return ((Parameter)element).getName();\n-        } else if (element instanceof Field) {\n-            return ((Field)element).getName();\n-        } else if (element instanceof Method) {\n-            Method m = (Method)element;\n-            if (!m.getName().startsWith(\"get\")) return null;\n-            return Character.toLowerCase(m.getName().charAt(3)) + m.getName().substring(4);\n-        }\n-        return null;\n-    }\n-\n-    private String getPathParamName(AnnotatedElement element) {\n-        if (element.isAnnotationPresent(PathParam.class)) {\n-            PathParam pp = element.getAnnotation(PathParam.class);\n-            return pp.value();\n-        } else if (element.isAnnotationPresent(org.jboss.resteasy.annotations.jaxrs.PathParam.class)) {\n-            org.jboss.resteasy.annotations.jaxrs.PathParam pp = element.getAnnotation(org.jboss.resteasy.annotations.jaxrs.PathParam.class);\n-            if (pp.value().length() > 0) return pp.value();\n-            return getReflectName(element);\n-        }\n-        return null;\n-    }\n-\n-    private void verifyBeanPathParam(Class<?> beanType, Map<String, Object> paramMap) {\n-        for (Field field : beanType.getDeclaredFields()) {\n-            String name = getPathParamName(field);\n-            if (name != null) {\n-                paramMap.put(name, \"foobar\");\n-            }\n-        }\n-\n-        for (Method m : beanType.getDeclaredMethods()) {\n-            String name = getPathParamName(m);\n-            if (name != null) {\n-                paramMap.put(name, \"foobar\");\n-            }\n-\n-        }\n-    }\n-\n-    private <T> void verifyInterface(Class<T> typeDef) {\n-\n-        Method[] methods = typeDef.getMethods();\n-\n-        // multiple verbs\n-        for (Method method : methods) {\n-            boolean hasHttpMethod = false;\n-            for (Annotation annotation : method.getAnnotations()) {\n-                boolean isHttpMethod = (annotation.annotationType().getAnnotation(HttpMethod.class) != null);\n-                if (!hasHttpMethod && isHttpMethod) {\n-                    hasHttpMethod = true;\n-                } else if (hasHttpMethod && isHttpMethod) {\n-                    throw new RestClientDefinitionException(\"Ambiguous @Httpmethod defintion on type \" + typeDef);\n-                }\n-            }\n-        }\n-\n-        // invalid parameter\n-        Path classPathAnno = typeDef.getAnnotation(Path.class);\n-\n-        ResteasyUriBuilder template = null;\n-        for (Method method : methods) {\n-            Path methodPathAnno = method.getAnnotation(Path.class);\n-            if (methodPathAnno != null) {\n-                template = classPathAnno == null ? (ResteasyUriBuilder) new ResteasyUriBuilderImpl().uri(methodPathAnno.value())\n-                        : (ResteasyUriBuilder) new ResteasyUriBuilderImpl().uri(classPathAnno.value() + \"/\" + methodPathAnno.value());\n-            } else if (classPathAnno != null) {\n-                template = (ResteasyUriBuilder) new ResteasyUriBuilderImpl().uri(classPathAnno.value());\n-            }\n-\n-            if (template == null) {\n-                continue;\n-            }\n-\n-            // it's not executed, so this can be anything - but a hostname needs to present\n-            template.host(\"localhost\");\n-\n-            Set<String> allVariables = new HashSet<>(template.getPathParamNamesInDeclarationOrder());\n-            Map<String, Object> paramMap = new HashMap<>();\n-            for (Parameter p : method.getParameters()) {\n-                PathParam pathParam = p.getAnnotation(PathParam.class);\n-                if (pathParam != null) {\n-                    paramMap.put(pathParam.value(), \"foobar\");\n-                } else if (p.isAnnotationPresent(org.jboss.resteasy.annotations.jaxrs.PathParam.class)){\n-                    org.jboss.resteasy.annotations.jaxrs.PathParam rePathParam = p.getAnnotation(org.jboss.resteasy.annotations.jaxrs.PathParam.class);\n-                    String name = rePathParam.value() == null || rePathParam.value().length() == 0 ? p.getName() : rePathParam.value();\n-                    paramMap.put(name, \"foobar\");\n-                } else if (p.isAnnotationPresent(BeanParam.class)) {\n-                    verifyBeanPathParam(p.getType(), paramMap);\n-                }\n-            }\n-\n-            if (allVariables.size() != paramMap.size()) {\n-                throw new RestClientDefinitionException(\"Parameters and variables don't match on \" + typeDef + \"::\" + method.getName());\n-            }\n-\n-            try {\n-                template.resolveTemplates(paramMap, false).build();\n-            } catch (IllegalArgumentException ex) {\n-                throw new RestClientDefinitionException(\"Parameter names don't match variable names on \" + typeDef + \"::\" + method.getName(), ex);\n-            }\n-\n-        }\n-    }\n-\n-    @Override\n-    public Configuration getConfiguration() {\n-        return getConfigurationWrapper();\n-    }\n-\n-    @Override\n-    public RestClientBuilder property(String name, Object value) {\n-        if (name.startsWith(RESTEASY_PROPERTY_PREFIX)) {\n-            // Makes it possible to configure some of the ResteasyClientBuilder delegate properties\n-            String builderMethodName = name.substring(RESTEASY_PROPERTY_PREFIX.length());\n-            Method builderMethod = Arrays.stream(ResteasyClientBuilder.class.getMethods())\n-                    .filter(m -> builderMethodName.equals(m.getName()) && m.getParameterTypes().length >= 1)\n-                    .findFirst()\n-                    .orElse(null);\n-            if (builderMethod == null) {\n-                throw new IllegalArgumentException(\"ResteasyClientBuilder setter method not found: \" + builderMethodName);\n-            }\n-            Object[] arguments;\n-            if (builderMethod.getParameterTypes().length > 1) {\n-                if (value instanceof List) {\n-                    arguments = ((List<?>) value).toArray();\n-                } else {\n-                    throw new IllegalArgumentException(\"Value must be an instance of List<> for ResteasyClientBuilder setter method: \" + builderMethodName);\n-                }\n-            } else {\n-                arguments = new Object[] { value };\n-            }\n-            try {\n-                builderMethod.invoke(builderDelegate, arguments);\n-            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-                throw new IllegalStateException(\"Unable to invoke ResteasyClientBuilder method: \" + builderMethodName, e);\n-            }\n-        }\n-        builderDelegate.property(name, value);\n-        return this;\n-    }\n-\n-    private Object newInstanceOf(Class<?> clazz) {\n-        if (PROVIDER_FACTORY != null) {\n-            return PROVIDER_FACTORY.injectedInstance(clazz);\n-        }\n-        return this.getBuilderDelegate().getProviderFactory().injectedInstance(clazz);\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Class<?> aClass) {\n-        register(newInstanceOf(aClass));\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Class<?> aClass, int i) {\n-\n-        register(newInstanceOf(aClass), i);\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Class<?> aClass, Class<?>[] classes) {\n-        register(newInstanceOf(aClass), classes);\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Class<?> aClass, Map<Class<?>, Integer> map) {\n-        register(newInstanceOf(aClass), map);\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Object o) {\n-        if (o instanceof ResponseExceptionMapper) {\n-            ResponseExceptionMapper mapper = (ResponseExceptionMapper) o;\n-            register(mapper, mapper.getPriority());\n-        } else if (o instanceof ParamConverterProvider) {\n-            register(o, Priorities.USER);\n-        } else if (o instanceof AsyncInvocationInterceptorFactory) {\n-            builderDelegate.asyncInterceptorFactories.add((AsyncInvocationInterceptorFactory) o);\n-        } else {\n-            builderDelegate.register(o);\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Object o, int i) {\n-        if (o instanceof ResponseExceptionMapper) {\n-\n-            // local\n-            ResponseExceptionMapper mapper = (ResponseExceptionMapper) o;\n-            HashMap<Class<?>, Integer> contracts = new HashMap<>();\n-            contracts.put(ResponseExceptionMapper.class, i);\n-            registerLocalProviderInstance(mapper, contracts);\n-\n-            // delegate\n-            builderDelegate.register(mapper, i);\n-\n-        } else if (o instanceof ParamConverterProvider) {\n-\n-            // local\n-            ParamConverterProvider converter = (ParamConverterProvider) o;\n-            HashMap<Class<?>, Integer> contracts = new HashMap<>();\n-            contracts.put(ParamConverterProvider.class, i);\n-            registerLocalProviderInstance(converter, contracts);\n-\n-            // delegate\n-            builderDelegate.register(converter, i);\n-\n-        } else if (o instanceof AsyncInvocationInterceptorFactory) {\n-            builderDelegate.asyncInterceptorFactories.add((AsyncInvocationInterceptorFactory) o);\n-        } else {\n-            builderDelegate.register(o, i);\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Object o, Class<?>[] classes) {\n-\n-        // local\n-        for (Class<?> aClass : classes) {\n-            if (aClass.isAssignableFrom(ResponseExceptionMapper.class)) {\n-                register(o);\n-            }\n-        }\n-\n-        // other\n-        builderDelegate.register(o, classes);\n-        return this;\n-    }\n-\n-    @Override\n-    public RestClientBuilder register(Object o, Map<Class<?>, Integer> map) {\n-\n-        if (o instanceof ResponseExceptionMapper) {\n-\n-            // local\n-            ResponseExceptionMapper mapper = (ResponseExceptionMapper) o;\n-            HashMap<Class<?>, Integer> contracts = new HashMap<>();\n-            contracts.put(ResponseExceptionMapper.class, map.get(ResponseExceptionMapper.class));\n-            registerLocalProviderInstance(mapper, contracts);\n-\n-            // other\n-            builderDelegate.register(o, map);\n-\n-        } else {\n-            builderDelegate.register(o, map);\n-        }\n-\n-        return this;\n-    }\n-\n-    public Set<Object> getLocalProviderInstances() {\n-        return localProviderInstances;\n-    }\n-\n-    public void registerLocalProviderInstance(Object provider, Map<Class<?>, Integer> contracts) {\n-        for (Object registered : getLocalProviderInstances()) {\n-            if (registered == provider) {\n-                // System.out.println(\"Provider already registered \" + provider.getClass().getName());\n-                return;\n-            }\n-        }\n-\n-        localProviderInstances.add(provider);\n-        configurationWrapper.registerLocalContract(provider.getClass(), contracts);\n-    }\n-\n-    ResteasyClientBuilder getBuilderDelegate() {\n-        return builderDelegate;\n-    }\n-    private static BeanManager getBeanManager() {\n-        try {\n-            CDI<Object> current = CDI.current();\n-            return current != null ? current.getBeanManager() : null;\n-        } catch (IllegalStateException e) {\n-            LOGGER.warnf(\"CDI container is not available\");\n-            return null;\n-        }\n-    }\n-    private String getSystemProperty(String key, String def) {\n-        if (System.getSecurityManager() == null) {\n-            return System.getProperty(key, def);\n-        }\n-        return AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(key, def));\n-    }\n-\n-    private final MpClientBuilderImpl builderDelegate;\n-\n-    private final ConfigurationWrapper configurationWrapper;\n-\n-    private Config config;\n-\n-    private ExecutorService executorService;\n-\n-    private URI baseURI;\n-\n-    private Long connectTimeout;\n-    private TimeUnit connectTimeoutUnit;\n-\n-    private Long readTimeout;\n-    private TimeUnit readTimeoutUnit;\n-\n-    private String proxyHost;\n-    private Integer proxyPort = null;\n-\n-    private SSLContext sslContext;\n-    private KeyStore trustStore;\n-    private KeyStore keyStore;\n-    private String keystorePassword;\n-    private HostnameVerifier hostnameVerifier;\n-    private Boolean useURLConnection;\n-    private boolean followRedirect;\n-    private QueryParamStyle queryParamStyle = null;\n-\n-    private Set<Object> localProviderInstances = new HashSet<>();\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "1cad12e3c0e99f1013218f262ca363a1d6cf1cfe", "message": "Merge commit", "committedDate": null}, {"oid": "0fa5ac422bf358cf36ea0ded87e50d9d1ecd5c2c", "committedDate": "2020-10-22 01:42:28 +0200", "message": "Ensure that multiple impls of UriBuilder don't cause a CCE"}, {"oid": "f2edf08aa72ba551438578a5a561da408cb3073f", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[RESTEASY-2615] MP-rest-client 2.0 added feature followRedirects and related tests"}, {"oid": "8bc56ed4967bdfcf39eae0a51eafe6f00f2d314b", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[Resteasy 2618] mp rest client query param style and tests"}, {"oid": "16340a3a181a247e82ae39cdc259204a29c0a375", "committedDate": "2020-10-27 14:18:32 +0100", "message": "fixed merge conflicts"}, {"oid": "2fcbc90b60cd9e31296e550436ae7a52f4f9d0b6", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[Resteasy 2618] mp rest client query param style and tests"}, {"oid": "14dd70204caecba2ece85b5db4fdfeeae5993b2a", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[RESTEASY-2641] expanded algorithm checking nonProxyHost parameter"}, {"oid": "cde42b2d23d814397f688a677ec9407df904a24b", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[RESTEASY-2705] changed qualified class name used"}, {"oid": "099515d3b60cd08b075710512de823e8bb7cb4f0", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[RESTEASY-2706] added use of CDIInjectorfactory to create provider"}, {"oid": "93fa2dc081b2b95d86e7200acd868ec4c117aef7", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[RESTEASY-2708] added code for proxy server"}, {"oid": "eea6c4118d2a65e82209526c6f084643a0b14521", "committedDate": "2020-10-27 14:18:32 +0100", "message": "[RESTEASY-2620]:MP-rest-client 2.0 Server Sent Event Support"}, {"oid": "67aa3ba88e86df0f3d0a672ad9b1eabddc70ff4d", "committedDate": "2020-10-27 14:18:32 +0100", "message": "Add executor to SSEPublisher;Refactor test"}, {"oid": "6c78ed47e7b5a5fd34f685d5671032a3b0bb7ace", "committedDate": "2021-01-25 23:17:54 -0500", "message": "[RESTEASY-2801] Reset template in RestClientBuilderImpl.verifyInterface() (#2656)"}, {"oid": "eec52b4f6b6086d83eaea4152af6e0209c401a6c", "committedDate": "2021-03-11 11:59:29 -0500", "message": "[RESTEASY-2834] Do not use a static BeanManager. Use the one, where applicable, from the client builder. (#2688)"}, {"oid": "b910728177b6791814a836549f2589945628c28d", "committedDate": "2021-06-24 18:06:13 -0400", "message": "[RESTEASY-2882] Changed the processing of ResponseExceptionMapper to meet spec requirements"}, {"oid": "6b42079f2566b9825825fb8a1bbace7fc3dadd88", "committedDate": "2021-08-11 14:02:45 -0700", "message": "[RESTEASY-2975] Remove MicroProfile REST Client and various other MicroProfile stuff. This will be migrated to a new project."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw==", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511824017", "body": "should it handle rejection?", "bodyText": "should it handle rejection?", "bodyHTML": "<p dir=\"auto\">should it handle rejection?</p>", "author": "cescoffier", "createdAt": "2020-10-26T09:32:14Z", "path": "resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java", "diffHunk": "@@ -0,0 +1,290 @@\n+package org.jboss.resteasy.microprofile.client.publisher;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.core.ResteasyContext;\n+import org.jboss.resteasy.plugins.providers.sse.SseEventInputImpl;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import javax.ws.rs.ext.Providers;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Publisher implementation emitting server-sent-event downstream.\n+ *\n+ * @param <T> the type of event.\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")\n+public class SSEPublisher<T> implements Publisher<T> {\n+\n+    private static final Runnable CLEARED = () -> {\n+        // sentinel indicating we are done.\n+    };\n+\n+    private final SseEventInputImpl input;\n+    private final Type genericType;\n+    private final Providers providers;\n+    private final ExecutorService executor;\n+\n+    private static final Logger LOGGER = Logger.getLogger(SSEPublisher.class);\n+\n+    public SSEPublisher(final Type genericType, final Providers providers, final SseEventInputImpl input, final ExecutorService es) {\n+        this.genericType = genericType;\n+        this.input = input;\n+        this.providers = providers;\n+        this.executor = es;\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> downstream) {\n+        SSEProcessor<? super T> processor = new SSEProcessor<>(downstream,\n+                Integer.getInteger(\"resteasy.microprofile.sseclient.buffersize\", 512));\n+        downstream.onSubscribe(processor);\n+        pump(processor, input);\n+    }\n+\n+    /**\n+     * Reads the server-sent event from the {@code input} and pass them to the processor.\n+     * The processor handles the downstream requests and buffer/drop items according to them.\n+     *\n+     * @param processor the stream\n+     * @param input     the SSE input\n+     */\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n+        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n+        executor.execute(() -> {", "originalCommit": "d0b6049a4a9fbb8fd00dcad646c4c3a1acd99a4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0MTE5Mg==", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511841192", "bodyText": "Do you mean handle executor injection ?", "author": "jimma", "createdAt": "2020-10-26T10:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzY5Mw==", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r511857693", "bodyText": "if the executor is stopped (for whatever reason), you cannot submit another task. You will receive a RejectedExecutionException. What should we do in this case? Log and return a failed publisher? Log and return a Publisher just emitting the completion signal?", "author": "cescoffier", "createdAt": "2020-10-26T10:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNzA0Mw==", "url": "https://github.com/resteasy/resteasy/pull/2582#discussion_r512027043", "bodyText": "@cescoffier Thanks for pointing out this issue.  I modified to this to create a new thread to run this if there is RejectedExecutionException thrown.", "author": "jimma", "createdAt": "2020-10-26T14:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDAxNw=="}], "type": "inlineReview", "revised_code": {"commit": "ee2dd61705623ae6f1ed448a82fe67ebe2c6a0d2", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\nindex 36f310879a..095a44f8ef 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n", "chunk": "@@ -63,35 +64,44 @@ public class SSEPublisher<T> implements Publisher<T> {\n     @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n         Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n-        executor.execute(() -> {\n-            ResteasyContext.pushContextDataMap(contextDataMap);\n-            Type typeArgument;\n-            InboundSseEvent event;\n-            if (genericType instanceof ParameterizedType) {\n-                typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n-                if (typeArgument.equals(InboundSseEvent.class)) {\n-                    try {\n-                        while ((event = input.read(providers)) != null) {\n-                            processor.emit(event);\n+        Runnable readEventTask = new Runnable() {\n+            @Override\n+            public void run() {\n+                ResteasyContext.pushContextDataMap(contextDataMap);\n+                Type typeArgument;\n+                InboundSseEvent event;\n+                if (genericType instanceof ParameterizedType) {\n+                    typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n+                    if (typeArgument.equals(InboundSseEvent.class)) {\n+                        try {\n+                            while ((event = input.read(providers)) != null) {\n+                                processor.emit(event);\n+                            }\n+                        } catch (Exception e) {\n+                            processor.onError(e);\n+                            return;\n                         }\n-                    } catch (Exception e) {\n-                        processor.onError(e);\n-                        return;\n-                    }\n-                processor.onCompletion();\n-                } else {\n-                    try {\n-                        while ((event = input.read(providers)) != null) {\n-                            processor.emit(event.readData((Class) typeArgument));\n+                    processor.onCompletion();\n+                    } else {\n+                        try {\n+                            while ((event = input.read(providers)) != null) {\n+                                processor.emit(event.readData((Class) typeArgument));\n+                            }\n+                        } catch (Exception e) {\n+                            processor.onError(e);\n+                            return;\n                         }\n-                    } catch (Exception e) {\n-                        processor.onError(e);\n-                        return;\n                     }\n+                    processor.onCompletion();\n                 }\n-                processor.onCompletion();\n             }\n-        });\n+        };\n+        try {\n+            executor.execute(readEventTask);\n+        } catch (RejectedExecutionException e) {\n+            LOGGER.warnf(\"Executor %s rejected emit event task\", executor);\n+            new Thread(readEventTask, \"SseClientPublisherNewThread\").start();\n+        }\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1cad12e3c0e99f1013218f262ca363a1d6cf1cfe", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\nindex 36f310879a..095a44f8ef 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n", "chunk": "@@ -63,35 +64,44 @@ public class SSEPublisher<T> implements Publisher<T> {\n     @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n         Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n-        executor.execute(() -> {\n-            ResteasyContext.pushContextDataMap(contextDataMap);\n-            Type typeArgument;\n-            InboundSseEvent event;\n-            if (genericType instanceof ParameterizedType) {\n-                typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n-                if (typeArgument.equals(InboundSseEvent.class)) {\n-                    try {\n-                        while ((event = input.read(providers)) != null) {\n-                            processor.emit(event);\n+        Runnable readEventTask = new Runnable() {\n+            @Override\n+            public void run() {\n+                ResteasyContext.pushContextDataMap(contextDataMap);\n+                Type typeArgument;\n+                InboundSseEvent event;\n+                if (genericType instanceof ParameterizedType) {\n+                    typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n+                    if (typeArgument.equals(InboundSseEvent.class)) {\n+                        try {\n+                            while ((event = input.read(providers)) != null) {\n+                                processor.emit(event);\n+                            }\n+                        } catch (Exception e) {\n+                            processor.onError(e);\n+                            return;\n                         }\n-                    } catch (Exception e) {\n-                        processor.onError(e);\n-                        return;\n-                    }\n-                processor.onCompletion();\n-                } else {\n-                    try {\n-                        while ((event = input.read(providers)) != null) {\n-                            processor.emit(event.readData((Class) typeArgument));\n+                    processor.onCompletion();\n+                    } else {\n+                        try {\n+                            while ((event = input.read(providers)) != null) {\n+                                processor.emit(event.readData((Class) typeArgument));\n+                            }\n+                        } catch (Exception e) {\n+                            processor.onError(e);\n+                            return;\n                         }\n-                    } catch (Exception e) {\n-                        processor.onError(e);\n-                        return;\n                     }\n+                    processor.onCompletion();\n                 }\n-                processor.onCompletion();\n             }\n-        });\n+        };\n+        try {\n+            executor.execute(readEventTask);\n+        } catch (RejectedExecutionException e) {\n+            LOGGER.warnf(\"Executor %s rejected emit event task\", executor);\n+            new Thread(readEventTask, \"SseClientPublisherNewThread\").start();\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "9fea1653b826c32f4e938431878df2ea1fc44031", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\nindex 095a44f8ef..f7a68827d2 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n", "chunk": "@@ -63,44 +56,31 @@ public class SSEPublisher<T> implements Publisher<T> {\n      */\n     @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n-        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n-        Runnable readEventTask = new Runnable() {\n-            @Override\n-            public void run() {\n-                ResteasyContext.pushContextDataMap(contextDataMap);\n-                Type typeArgument;\n-                InboundSseEvent event;\n-                if (genericType instanceof ParameterizedType) {\n-                    typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n-                    if (typeArgument.equals(InboundSseEvent.class)) {\n-                        try {\n-                            while ((event = input.read(providers)) != null) {\n-                                processor.emit(event);\n-                            }\n-                        } catch (Exception e) {\n-                            processor.onError(e);\n-                            return;\n-                        }\n-                    processor.onCompletion();\n-                    } else {\n-                        try {\n-                            while ((event = input.read(providers)) != null) {\n-                                processor.emit(event.readData((Class) typeArgument));\n-                            }\n-                        } catch (Exception e) {\n-                            processor.onError(e);\n-                            return;\n-                        }\n+        Type typeArgument;\n+        InboundSseEvent event;\n+        if (genericType instanceof ParameterizedType) {\n+            typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n+            if (typeArgument.equals(InboundSseEvent.class)) {\n+                try {\n+                    while ((event = input.read(providers)) != null) {\n+                        processor.emit(event);\n+                    }\n+                } catch (Exception e) {\n+                    processor.onError(e);\n+                    return;\n+                }\n+                processor.onCompletion();\n+            } else {\n+                try {\n+                    while ((event = input.read(providers)) != null) {\n+                        processor.emit(event.readData((Class) typeArgument));\n                     }\n-                    processor.onCompletion();\n+                } catch (Exception e) {\n+                    processor.onError(e);\n+                    return;\n                 }\n+                processor.onCompletion();\n             }\n-        };\n-        try {\n-            executor.execute(readEventTask);\n-        } catch (RejectedExecutionException e) {\n-            LOGGER.warnf(\"Executor %s rejected emit event task\", executor);\n-            new Thread(readEventTask, \"SseClientPublisherNewThread\").start();\n         }\n     }\n \n", "next_change": {"commit": "67aa3ba88e86df0f3d0a672ad9b1eabddc70ff4d", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\nindex f7a68827d2..36f310879a 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n", "chunk": "@@ -56,32 +62,36 @@ public class SSEPublisher<T> implements Publisher<T> {\n      */\n     @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n-        Type typeArgument;\n-        InboundSseEvent event;\n-        if (genericType instanceof ParameterizedType) {\n-            typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n-            if (typeArgument.equals(InboundSseEvent.class)) {\n-                try {\n-                    while ((event = input.read(providers)) != null) {\n-                        processor.emit(event);\n+        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n+        executor.execute(() -> {\n+            ResteasyContext.pushContextDataMap(contextDataMap);\n+            Type typeArgument;\n+            InboundSseEvent event;\n+            if (genericType instanceof ParameterizedType) {\n+                typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n+                if (typeArgument.equals(InboundSseEvent.class)) {\n+                    try {\n+                        while ((event = input.read(providers)) != null) {\n+                            processor.emit(event);\n+                        }\n+                    } catch (Exception e) {\n+                        processor.onError(e);\n+                        return;\n                     }\n-                } catch (Exception e) {\n-                    processor.onError(e);\n-                    return;\n-                }\n                 processor.onCompletion();\n-            } else {\n-                try {\n-                    while ((event = input.read(providers)) != null) {\n-                        processor.emit(event.readData((Class) typeArgument));\n+                } else {\n+                    try {\n+                        while ((event = input.read(providers)) != null) {\n+                            processor.emit(event.readData((Class) typeArgument));\n+                        }\n+                    } catch (Exception e) {\n+                        processor.onError(e);\n+                        return;\n                     }\n-                } catch (Exception e) {\n-                    processor.onError(e);\n-                    return;\n                 }\n                 processor.onCompletion();\n             }\n-        }\n+        });\n     }\n \n     /**\n", "next_change": {"commit": "0254830b74860b02cc523390e7a892ad302b5ae0", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\nindex 36f310879a..095a44f8ef 100644\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n+++ b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n", "chunk": "@@ -63,35 +64,44 @@ public class SSEPublisher<T> implements Publisher<T> {\n     @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n         Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n-        executor.execute(() -> {\n-            ResteasyContext.pushContextDataMap(contextDataMap);\n-            Type typeArgument;\n-            InboundSseEvent event;\n-            if (genericType instanceof ParameterizedType) {\n-                typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n-                if (typeArgument.equals(InboundSseEvent.class)) {\n-                    try {\n-                        while ((event = input.read(providers)) != null) {\n-                            processor.emit(event);\n+        Runnable readEventTask = new Runnable() {\n+            @Override\n+            public void run() {\n+                ResteasyContext.pushContextDataMap(contextDataMap);\n+                Type typeArgument;\n+                InboundSseEvent event;\n+                if (genericType instanceof ParameterizedType) {\n+                    typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n+                    if (typeArgument.equals(InboundSseEvent.class)) {\n+                        try {\n+                            while ((event = input.read(providers)) != null) {\n+                                processor.emit(event);\n+                            }\n+                        } catch (Exception e) {\n+                            processor.onError(e);\n+                            return;\n                         }\n-                    } catch (Exception e) {\n-                        processor.onError(e);\n-                        return;\n-                    }\n-                processor.onCompletion();\n-                } else {\n-                    try {\n-                        while ((event = input.read(providers)) != null) {\n-                            processor.emit(event.readData((Class) typeArgument));\n+                    processor.onCompletion();\n+                    } else {\n+                        try {\n+                            while ((event = input.read(providers)) != null) {\n+                                processor.emit(event.readData((Class) typeArgument));\n+                            }\n+                        } catch (Exception e) {\n+                            processor.onError(e);\n+                            return;\n                         }\n-                    } catch (Exception e) {\n-                        processor.onError(e);\n-                        return;\n                     }\n+                    processor.onCompletion();\n                 }\n-                processor.onCompletion();\n             }\n-        });\n+        };\n+        try {\n+            executor.execute(readEventTask);\n+        } catch (RejectedExecutionException e) {\n+            LOGGER.warnf(\"Executor %s rejected emit event task\", executor);\n+            new Thread(readEventTask, \"SseClientPublisherNewThread\").start();\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "6b42079f2566b9825825fb8a1bbace7fc3dadd88", "changed_code": [{"header": "diff --git a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java b/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\ndeleted file mode 100644\nindex 095a44f8ef..0000000000\n--- a/resteasy-client-microprofile-base/src/main/java/org/jboss/resteasy/microprofile/client/publisher/SSEPublisher.java\n+++ /dev/null\n", "chunk": "@@ -1,300 +0,0 @@\n-package org.jboss.resteasy.microprofile.client.publisher;\n-\n-import org.jboss.logging.Logger;\n-import org.jboss.resteasy.core.ResteasyContext;\n-import org.jboss.resteasy.plugins.providers.sse.SseEventInputImpl;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-\n-import javax.ws.rs.ext.Providers;\n-import javax.ws.rs.sse.InboundSseEvent;\n-\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.util.Map;\n-import java.util.Queue;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-/**\n- * Publisher implementation emitting server-sent-event downstream.\n- *\n- * @param <T> the type of event.\n- */\n-@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")\n-public class SSEPublisher<T> implements Publisher<T> {\n-\n-    private static final Runnable CLEARED = () -> {\n-        // sentinel indicating we are done.\n-    };\n-\n-    private final SseEventInputImpl input;\n-    private final Type genericType;\n-    private final Providers providers;\n-    private final ExecutorService executor;\n-\n-    private static final Logger LOGGER = Logger.getLogger(SSEPublisher.class);\n-\n-    public SSEPublisher(final Type genericType, final Providers providers, final SseEventInputImpl input, final ExecutorService es) {\n-        this.genericType = genericType;\n-        this.input = input;\n-        this.providers = providers;\n-        this.executor = es;\n-    }\n-\n-    @Override\n-    public void subscribe(final Subscriber<? super T> downstream) {\n-        SSEProcessor<? super T> processor = new SSEProcessor<>(downstream,\n-                Integer.getInteger(\"resteasy.microprofile.sseclient.buffersize\", 512));\n-        downstream.onSubscribe(processor);\n-        pump(processor, input);\n-    }\n-\n-    /**\n-     * Reads the server-sent event from the {@code input} and pass them to the processor.\n-     * The processor handles the downstream requests and buffer/drop items according to them.\n-     *\n-     * @param processor the stream\n-     * @param input     the SSE input\n-     */\n-    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n-    private void pump(final SSEProcessor processor, final SseEventInputImpl input) {\n-        Map<Class<?>, Object> contextDataMap = ResteasyContext.getContextDataMap();\n-        Runnable readEventTask = new Runnable() {\n-            @Override\n-            public void run() {\n-                ResteasyContext.pushContextDataMap(contextDataMap);\n-                Type typeArgument;\n-                InboundSseEvent event;\n-                if (genericType instanceof ParameterizedType) {\n-                    typeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n-                    if (typeArgument.equals(InboundSseEvent.class)) {\n-                        try {\n-                            while ((event = input.read(providers)) != null) {\n-                                processor.emit(event);\n-                            }\n-                        } catch (Exception e) {\n-                            processor.onError(e);\n-                            return;\n-                        }\n-                    processor.onCompletion();\n-                    } else {\n-                        try {\n-                            while ((event = input.read(providers)) != null) {\n-                                processor.emit(event.readData((Class) typeArgument));\n-                            }\n-                        } catch (Exception e) {\n-                            processor.onError(e);\n-                            return;\n-                        }\n-                    }\n-                    processor.onCompletion();\n-                }\n-            }\n-        };\n-        try {\n-            executor.execute(readEventTask);\n-        } catch (RejectedExecutionException e) {\n-            LOGGER.warnf(\"Executor %s rejected emit event task\", executor);\n-            new Thread(readEventTask, \"SseClientPublisherNewThread\").start();\n-        }\n-    }\n-\n-    /**\n-     * Processor receiving SSE items from the source and dealing with downstream requests.\n-     * The items are buffers, and older events are dropped if the buffer is full.\n-     *\n-     * @param <T> the type of event\n-     */\n-    private static class SSEProcessor<T> implements Subscription {\n-        private final AtomicLong requested = new AtomicLong();\n-        private final Subscriber<T> downstream;\n-\n-        private final Queue<T> queue;\n-        private final int bufferSize;\n-        private Throwable failure;\n-        private volatile boolean done;\n-        private final AtomicInteger wip = new AtomicInteger();\n-        private final AtomicReference<Runnable> onTermination;\n-\n-        SSEProcessor(final Subscriber<T> downstream, final int bufferSize) {\n-            this.downstream = downstream;\n-            this.bufferSize = bufferSize;\n-            this.queue = new SpscLinkedArrayQueue<>(bufferSize);\n-            this.onTermination = new AtomicReference<>();\n-        }\n-\n-        public void emit(T t) {\n-            if (done || isCancelled()) {\n-                return;\n-            }\n-\n-            if (t == null) {\n-                throw new NullPointerException(\"Reactive Streams Rule 2.13 violated: The received item is `null`\");\n-            }\n-\n-            if (queue.size() == bufferSize) {\n-                T item = queue.poll();\n-                LOGGER.debugf(\"Dropping server-sent-event '%s' due to lack of downstream requests\", item);\n-            }\n-            queue.offer(t);\n-\n-            drain();\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n > 0) {\n-                Subscriptions.add(requested, n);\n-                drain();\n-            } else {\n-                cancel();\n-                downstream.onError(new IllegalArgumentException(\n-                        \"Reactive Streams Rule 3.9 violated: request must be positive, but was \" + n));\n-            }\n-        }\n-\n-        @Override\n-        public final void cancel() {\n-            cleanup();\n-        }\n-\n-        public boolean isCancelled() {\n-            return onTermination.get() == CLEARED;\n-        }\n-\n-        void drain() {\n-            if (wip.getAndIncrement() != 0) {\n-                return;\n-            }\n-\n-            int missed = 1;\n-            final Queue<T> q = queue;\n-\n-            do {\n-                long requests = requested.get();\n-                long emitted = 0L;\n-\n-                while (emitted != requests) {\n-                    // Be sure to clear the queue after cancellation or termination.\n-                    if (isCancelled()) {\n-                        q.clear();\n-                        return;\n-                    }\n-\n-                    boolean d = done;\n-                    T event = q.poll();\n-                    boolean empty = event == null;\n-\n-                    // No event and done - completing.\n-                    if (d && empty) {\n-                        if (failure != null) {\n-                            sendErrorToDownstream(failure);\n-                        } else {\n-                            sendCompletionToDownstream();\n-                        }\n-                        return;\n-                    }\n-\n-                    if (empty) {\n-                        break;\n-                    }\n-\n-                    // Passing the item downstream, and incrementing the emitted counter.\n-                    try {\n-                        downstream.onNext(event);\n-                    } catch (Throwable x) {\n-                        cancel();\n-                    }\n-                    emitted++;\n-                }\n-\n-                // We have emitted all the items we could possibly do without violating the protocol.\n-                if (emitted == requests) {\n-                    // Be sure to clear the queue after cancellation or termination.\n-                    if (isCancelled()) {\n-                        q.clear();\n-                        return;\n-                    }\n-\n-                    // Re-check for completion.\n-                    boolean d = done;\n-                    boolean empty = q.isEmpty();\n-                    if (d && empty) {\n-                        if (failure != null) {\n-                            sendErrorToDownstream(failure);\n-                        } else {\n-                            sendCompletionToDownstream();\n-                        }\n-                        return;\n-                    }\n-                }\n-\n-                // Update `requested`\n-                if (emitted != 0) {\n-                    Subscriptions.produced(requested, emitted);\n-                }\n-\n-                missed = wip.addAndGet(-missed);\n-            } while (missed != 0);\n-        }\n-\n-        protected void onCompletion() {\n-            done = true;\n-            drain();\n-        }\n-\n-        protected void onError(Throwable e) {\n-            if (done || isCancelled()) {\n-                return;\n-            }\n-\n-            if (e == null) {\n-                throw new NullPointerException(\"Reactive Streams Rule 2.13 violated: The received error is `null`\");\n-            }\n-\n-            this.failure = e;\n-            done = true;\n-\n-            drain();\n-        }\n-\n-        private void cleanup() {\n-            Runnable action = onTermination.getAndSet(CLEARED);\n-            if (action != null && action != CLEARED) {\n-                action.run();\n-            }\n-        }\n-\n-        private void sendCompletionToDownstream() {\n-            if (isCancelled()) {\n-                return;\n-            }\n-\n-            try {\n-                downstream.onComplete();\n-            } finally {\n-                cleanup();\n-            }\n-        }\n-\n-        private void sendErrorToDownstream(Throwable e) {\n-            if (e == null) {\n-                e = new NullPointerException(\"Reactive Streams Rule 2.13 violated: The received error is `null`\");\n-            }\n-            if (isCancelled()) {\n-                return;\n-            }\n-            try {\n-                downstream.onError(e);\n-            } finally {\n-                cleanup();\n-            }\n-        }\n-    }\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "1cad12e3c0e99f1013218f262ca363a1d6cf1cfe", "message": "Merge commit", "committedDate": null}, {"oid": "9fea1653b826c32f4e938431878df2ea1fc44031", "committedDate": "2020-10-27 14:18:32 +0100", "message": "Dependency-free implementation of the SSE Publisher"}, {"oid": "67aa3ba88e86df0f3d0a672ad9b1eabddc70ff4d", "committedDate": "2020-10-27 14:18:32 +0100", "message": "Add executor to SSEPublisher;Refactor test"}, {"oid": "0254830b74860b02cc523390e7a892ad302b5ae0", "committedDate": "2020-10-27 14:18:32 +0100", "message": "Handle RejectedExecutionException"}, {"oid": "6b42079f2566b9825825fb8a1bbace7fc3dadd88", "committedDate": "2021-08-11 14:02:45 -0700", "message": "[RESTEASY-2975] Remove MicroProfile REST Client and various other MicroProfile stuff. This will be migrated to a new project."}]}, {"oid": "7db7d440f8d0ed9ae0855134edbe1236b48f2be9", "url": "https://github.com/resteasy/resteasy/commit/7db7d440f8d0ed9ae0855134edbe1236b48f2be9", "message": "Minor change : clean up", "committedDate": "2020-10-26T09:52:28Z", "type": "commit"}, {"oid": "ee2dd61705623ae6f1ed448a82fe67ebe2c6a0d2", "url": "https://github.com/resteasy/resteasy/commit/ee2dd61705623ae6f1ed448a82fe67ebe2c6a0d2", "message": "Handle RejectedExecutionException", "committedDate": "2020-10-26T14:54:11Z", "type": "commit"}]}