{"pr_number": 2501, "pr_title": "[RESTEASY-2683] NPE in ApacheHttpClient43Test because cache is null in MediaTypeMap", "pr_author": "rmartinc", "pr_createdAt": "2020-08-31T09:49:01Z", "pr_url": "https://github.com/resteasy/resteasy/pull/2501", "merge_commit": "fed55666e9ef5c6e7366912742331de4de3688f4", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAxOTQ3OA==", "url": "https://github.com/resteasy/resteasy/pull/2501#discussion_r481019478", "body": "Why is this line moved out of check block ?", "bodyText": "Why is this line moved out of check block ?", "bodyHTML": "<p dir=\"auto\">Why is this line moved out of check block ?</p>", "author": "jimma", "createdAt": "2020-09-01T10:02:05Z", "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java", "diffHunk": "@@ -550,8 +551,8 @@ private void mergeEverything(Entry<T> entry) {\n       CachedMediaTypeAndClass cacheEntry = null;\r\n       if (useCache)\r\n       {\r\n+         cacheEntry = new CachedMediaTypeAndClass(type, accept);\r", "originalCommit": "77a67bcd2ae67442ed49dd7d7083609f0c89db34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzMTE2MA==", "url": "https://github.com/resteasy/resteasy/pull/2501#discussion_r481031160", "bodyText": "This is just because the first time when the classCache is null the cacheEntry is not initialized, it remains null, and therefore the put at the end is done with cacheEntry=null, so nothing is cached the first time (indeed it's cached wrong, with a wrong key). I just fixed this minor issue too. This change is minor, as this is just executed differently the first time when classCache is null, all the rest of times is exactly the same.", "author": "rmartinc", "createdAt": "2020-09-01T10:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAxOTQ3OA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "5d60f62c67eec6dbdf9ecd10db7473614750c35d", "changed_code": [{"header": "diff --git a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\nindex d2194370e6..c7cf5c366e 100644\n--- a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n+++ b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n", "chunk": "@@ -1,596 +1,551 @@\n-package org.jboss.resteasy.core;\n-\n-import org.jboss.resteasy.plugins.delegates.MediaTypeHeaderDelegate;\n-import org.jboss.resteasy.util.MediaTypeHelper;\n-\n-import javax.ws.rs.core.MediaType;\n-import java.io.Serializable;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-/**\n- * A copy-on-write MediaType index of T.\n- *\n- * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n- * @version $Revision: 1 $\n- */\n-public class MediaTypeMap<T>\n-{\n-   public interface Typed\n-   {\n-      Class<?> getType();\n-   }\n-\n-   private static class TypedEntryComparator implements Comparator<Entry<?>>, Serializable\n-   {\n-      private static final long serialVersionUID = -8815419198743440920L;\n-      private Class<?> type;\n-\n-      TypedEntryComparator(final Class<?> type)\n-      {\n-         this.type = type;\n-      }\n-\n-      private boolean isAssignableFrom(Typed typed)\n-      {\n-         if (typed.getType() == null) return false;\n-         return typed.getType().isAssignableFrom(type);\n-      }\n-\n-      private int compareTypes(Entry<?> entry, Entry<?> entry1)\n-      {\n-         int val = 0;\n-         if (entry.object instanceof Typed && entry1.object instanceof Typed && type != null)\n-         {\n-            Typed one = (Typed) entry.object;\n-            Typed two = (Typed) entry1.object;\n-\n-\n-            boolean oneTyped = isAssignableFrom(one);\n-            boolean twoTyped = isAssignableFrom(two);\n-            if (oneTyped == twoTyped && (!oneTyped && !twoTyped))\n-            {\n-               // both are false\n-               val = 0;\n-            }\n-            else if (oneTyped == twoTyped)\n-            {\n-               // both are true.\n-               // test for better assignability\n-               if (one.getType().equals(two.getType()))\n-               {\n-                  val = 0;\n-               }\n-               else if (one.getType().isAssignableFrom(two.getType()))\n-               {\n-                  val = 1;\n-               }\n-               else\n-               {\n-                  val = -1;\n-               }\n-            }\n-            else if (oneTyped) val = -1;\n-            else val = 1;\n-         }\n-         return val;\n-\n-      }\n-\n-      public int compare(Entry<?> entry, Entry<?> entry1)\n-      {\n-         int val = compareTypes(entry, entry1);\n-         if (val == 0) val = entry.compareTo(entry1);\n-         return val;\n-      }\n-   }\n-\n-   private static class Entry<T> implements Comparable<Entry<?>>\n-   {\n-      public MediaType mediaType;\n-      public T object;\n-\n-      private Entry(final MediaType mediaType, final T object)\n-      {\n-         this.mediaType = mediaType;\n-         this.object = object;\n-      }\n-\n-      @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-      public int compareTo(Entry<?> entry)\n-      {\n-         int val = MediaTypeHelper.compareWeight(mediaType, entry.mediaType);\n-         if (val == 0 && object instanceof Comparable && entry.object instanceof Comparable)\n-         {\n-            return ((Comparable) object).compareTo(entry.object);\n-         }\n-         return val;\n-      }\n-   }\n-\n-   private static final Pattern COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+(.+)\");\n-\n-   // Composite subtypes are of the pattern *+subtype i.e. *+xml, *+json\n-   public static final Pattern COMPOSITE_SUBTYPE_WILDCARD_PATTERN = Pattern.compile(\"\\\\*\\\\+(.+)\");\n-\n-\n-   // This composite is subtype+*  i.e. atom+* rss+*\n-   public static final Pattern WILD_SUBTYPE_COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+\\\\*\");\n-\n-   public static String compositeWildSubtype(String subtype) {\n-      final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(subtype);\n-      if (matcher.matches()) {\n-         return matcher.group(1);\n-      }\n-      return null;\n-   }\n-\n-   public static String wildCompositeSubtype(String subtype) {\n-      final Matcher matcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(subtype);\n-      if (matcher.matches()) {\n-         return matcher.group(1);\n-      }\n-      return null;\n-   }\n-\n-   private class SubtypeMap<T>\n-   {\n-      private volatile Map<String, List<Entry<T>>> index;\n-      private volatile Map<String, List<Entry<T>>> compositeIndex;\n-      private volatile Map<String, List<Entry<T>>> wildCompositeIndex;\n-      private volatile List<Entry<T>> wildcards;\n-      private volatile List<Entry<T>> all;\n-\n-      private SubtypeMap() {\n-         index = new HashMap<>();\n-         compositeIndex = new HashMap<>();\n-         wildCompositeIndex = new HashMap<>();\n-         wildcards = new ArrayList<>();\n-         all = new ArrayList<>();\n-      }\n-\n-      private SubtypeMap(final SubtypeMap<T> subtypeMap) {\n-         index = subtypeMap.index;\n-         compositeIndex = subtypeMap.compositeIndex;\n-         wildCompositeIndex = subtypeMap.wildCompositeIndex;\n-         wildcards = subtypeMap.wildcards;\n-         all = subtypeMap.all;\n-      }\n-\n-\n-      private void add(Entry<T> entry)\n-      {\n-         final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(entry.mediaType.getSubtype());\n-         final Matcher wildCompositeMatcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(entry.mediaType.getSubtype());\n-\n-\n-         if (entry.mediaType.isWildcardSubtype()) {\n-            addWildcard(entry);\n-         }\n-         else if (matcher.matches())\n-         {\n-            String baseSubType = matcher.group(1);\n-            addCompositeWild(entry, baseSubType);\n-         }\n-         else if (wildCompositeMatcher.matches())\n-         {\n-            String base = wildCompositeMatcher.group(1);\n-            addWildComposite(entry, base);\n-         }\n-         else\n-         {\n-            addRegular(entry);\n-         }\n-      }\n-\n-      private void addRegular(Entry<T> entry) {\n-         Map<String, List<Entry<T>>> newIndex = index;\n-         if (lockSnapshots) newIndex = copy(index);\n-         add(newIndex, entry.mediaType.getSubtype(), entry);\n-         index = newIndex;\n-         merge(entry);\n-      }\n-\n-      private void addWildComposite(Entry<T> entry, String base) {\n-         Map<String, List<Entry<T>>> newWildCompositeIndex = wildCompositeIndex;\n-         if (lockSnapshots) newWildCompositeIndex = (wildCompositeIndex);\n-         add(newWildCompositeIndex, base, entry);\n-         wildCompositeIndex = newWildCompositeIndex;\n-         merge(entry);\n-      }\n-\n-      private void addCompositeWild(Entry<T> entry, String baseSubType) {\n-         Map<String, List<Entry<T>>> newCompositeIndex = compositeIndex;\n-         if (lockSnapshots) newCompositeIndex = copy(compositeIndex);\n-         add(newCompositeIndex, baseSubType, entry);\n-         compositeIndex = newCompositeIndex;\n-         merge(entry);\n-      }\n-\n-      private void addWildcard(Entry<T> entry) {\n-         if (lockSnapshots) wildcards = copyAndAdd(wildcards, entry);\n-         else wildcards.add(entry);\n-         merge(entry);\n-      }\n-\n-      private void merge(Entry<T> entry) {\n-         if (lockSnapshots) {\n-            all = copyAndAdd(all, entry);\n-         } else {\n-            all.add(entry);\n-         }\n-      }\n-\n-      private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) {\n-         final Map<String, List<Entry<T>>> copy = new HashMap<>(original.size());\n-         original.forEach((key, value) -> copy.put(key, new ArrayList<>(value)));\n-         return copy;\n-      }\n-\n-      private void add(final Map<String, List<Entry<T>>> map,\n-                       final String key,\n-                       final Entry<T> entry) {\n-         map.putIfAbsent(key, new CopyOnWriteArrayList<>());\n-         map.get(key).add(entry);\n-      }\n-\n-      private List<Entry<T>> getPossible(MediaType accept)\n-      {\n-         if (accept.isWildcardSubtype())\n-         {\n-            return all;\n-         }\n-         else\n-         {\n-            List<Entry<T>> matches = new ArrayList<Entry<T>>();\n-\n-            List<Entry<T>> indexed = index.get(accept.getSubtype());\n-            if (indexed != null) matches.addAll(indexed);\n-\n-            Matcher matcher = COMPOSITE_PATTERN.matcher(accept.getSubtype());\n-            String compositeKey = accept.getSubtype();\n-            if (matcher.matches())\n-            {\n-               String wildCompositeKey = matcher.group(1);\n-               List<Entry<T>> windex = wildCompositeIndex.get(wildCompositeKey);\n-               if (windex != null) matches.addAll(windex);\n-               compositeKey = matcher.group(2);\n-            }\n-            List<Entry<T>> indexed2 = compositeIndex.get(compositeKey);\n-            if (indexed2 != null) matches.addAll(indexed2);\n-            matches.addAll(wildcards);\n-            return matches;\n-         }\n-      }\n-   }\n-\n-   static <A> List<A> copyAndAdd(List<A> a, A entry) {\n-      // reduce internal array copying\n-      ArrayList<A> newList = new ArrayList<A>(a.size() + 1);\n-      newList.add(entry);\n-      newList.addAll(0, a);\n-      return newList;\n-   }\n-\n-   private static class CachedMediaTypeAndClass\n-   {\n-      // we need a weak reference because of possible hot deployment\n-      // Although, these reference should get cleared up with any add() invocation\n-      private WeakReference<Class<?>> clazz;\n-      private MediaType mediaType;\n-      private final int hash;\n-\n-      @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-      private CachedMediaTypeAndClass(final Class clazz, final MediaType mediaType)\n-      {\n-         this.clazz = new WeakReference(clazz);\n-         this.mediaType = mediaType;\n-         int result = clazz.hashCode();\n-         result = 31 * result + (mediaType.getType() != null ? mediaType.getType().hashCode() : 0) +  (mediaType.getSubtype() != null ? mediaType.getSubtype().hashCode() : 0);\n-         hash = result;\n-      }\n-\n-      private Class<?> getClazz()\n-      {\n-         return clazz.get();\n-      }\n-\n-      @Override\n-      public boolean equals(Object o)\n-      {\n-         if (this == o) return true;\n-         if (o == null || getClass() != o.getClass()) return false;\n-\n-         CachedMediaTypeAndClass that = (CachedMediaTypeAndClass) o;\n-\n-         // WeakReference may have GC'd\n-         Class<?> clazz = getClazz();\n-         if (clazz == null || that.getClazz() == null) return false;\n-\n-         if (!clazz.equals(that.getClazz())) return false;\n-\n-         if (mediaType.getType() != null)\n-         {\n-            if (!mediaType.getType().equals(that.mediaType.getType())) return false;\n-         }\n-         else if ((mediaType.getType() != that.mediaType.getType())) return false;\n-\n-         if (mediaType.getSubtype() != null)\n-         {\n-            if (!mediaType.getSubtype().equals(that.mediaType.getSubtype())) return false;\n-         }\n-         else if ((mediaType.getSubtype() != that.mediaType.getSubtype())) return false;\n-\n-         return true;\n-      }\n-\n-      @Override\n-      public int hashCode()\n-      {\n-         return hash;\n-      }\n-   }\n-\n-   private volatile Map<String, SubtypeMap<T>> index;\n-   private volatile Map<CachedMediaTypeAndClass, List<T>> classCache;\n-   private volatile List<Entry<T>> wildcards;\n-   private volatile List<Entry<T>> everything;\n-   private boolean lockSnapshots;\n-\n-   public MediaTypeMap() {\n-      index = new HashMap<>();\n-      wildcards = new ArrayList<>();\n-      everything = new ArrayList<>();\n-   }\n-\n-   /**\n-    * Shallow copy, any additional adds will deep copy\n-    *\n-    * @param mediaTypeMap\n-    */\n-   public MediaTypeMap(final MediaTypeMap<T> mediaTypeMap) {\n-      lockSnapshots = true;\n-      index      = mediaTypeMap.index;\n-      wildcards  = mediaTypeMap.wildcards;\n-      everything        = mediaTypeMap.everything;\n-      classCache = mediaTypeMap.classCache;\n-   }\n-\n-   /**\n-    * After this is called, all new adds will deep copy itself.\n-    *\n-    */\n-   public void lockSnapshots() {\n-      //if (!lockSnapshots) Collections.sort(everything);\n-      lockSnapshots = true;\n-   }\n-\n-   /**\n-    * Add an object to the media type map.  This is synchronized to serialize adds.\n-    *\n-    * @param type media type\n-    * @param obj object\n-    */\n-   public synchronized void add(final MediaType type, final T obj)\n-   {\n-      final MediaType newType =\n-              new MediaType(type.getType().toLowerCase(), type.getSubtype().toLowerCase(), type.getParameters());\n-      final Entry<T> entry = new Entry<>(newType, obj);\n-\n-      add(entry);\n-   }\n-\n-   /**\n-    * Add an object to the media type map.  This is synchronized to serialize adds.\n-    *\n-    * @param mediaType media type\n-    * @param obj object\n-    */\n-   public synchronized void add(String mediaType, final T obj)\n-   {\n-      final MediaType newType = MediaTypeHeaderDelegate.parse(mediaType.toLowerCase());\n-      final Entry<T> entry = new Entry<>(newType, obj);\n-      add(entry);\n-   }\n-\n-   public synchronized void addWildcard(final T obj) {\n-      final Entry<T> entry = new Entry<>(MediaType.WILDCARD_TYPE, obj);\n-      addWildcard(entry);\n-   }\n-\n-\n-   protected void add(Entry<T> entry) {\n-      if (entry.mediaType.isWildcardType())\n-      {\n-         addWildcard(entry);\n-      }\n-      else\n-      {\n-         Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-         newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-         newIndex.get(entry.mediaType.getType()).add(entry);\n-         index = newIndex;\n-         mergeEverything(entry);\n-      }\n-   }\n-\n-   private Map<String, SubtypeMap<T>> copyIndex() {\n-      Map<String, SubtypeMap<T>> newIndex = index;\n-      if (lockSnapshots) {\n-         Map<String, SubtypeMap<T>> finalIndex = new HashMap<>();\n-         newIndex = finalIndex;\n-         index.forEach((key, value) -> finalIndex.put(key, new SubtypeMap<>(value)));\n-      }\n-      return newIndex;\n-   }\n-\n-   private void addWildcard(Entry<T> entry) {\n-      if (lockSnapshots) wildcards = copyAndAdd(wildcards, entry);\n-      else wildcards.add(entry);\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addRegular(MediaType mediaType, T obj) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-      subtypeMap.addRegular(entry);\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addCompositeWild(MediaType mediaType, T obj, String baseSubtype) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-\n-      subtypeMap.addCompositeWild(entry, baseSubtype);\n-\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addWildComposite(MediaType mediaType, T obj, String baseSubtype) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-\n-      subtypeMap.addWildComposite(entry, baseSubtype);\n-\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addWildSubtype(MediaType mediaType, T obj) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-\n-      subtypeMap.addWildcard(entry);\n-\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   private void mergeEverything(Entry<T> entry) {\n-      List<Entry<T>> newAll = everything;\n-      if (lockSnapshots) {\n-         newAll = copyAndAdd(everything, entry);\n-         Collections.sort(newAll);\n-         everything = newAll;\n-      } else {\n-         everything.add(entry);\n-         Collections.sort(everything);\n-      }\n-      classCache = null;\n-   }\n-\n-\n-   private static <T> List<T> convert(List<Entry<T>> list)\n-   {\n-      List<T> newList = new ArrayList<T>(list.size());\n-      for (Entry<T> entry : list)\n-      {\n-         newList.add(entry.object);\n-      }\n-      return newList;\n-\n-   }\n-\n-   /**\n-    * Returns a list of objects sorted based on their media type where the first in the list\n-    * is the best match\n-    *\n-    * @param accept mime to match\n-    * @return list of objects\n-    */\n-   public List<T> getPossible(MediaType accept)\n-   {\n-      accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n-      List<Entry<T>> matches = new ArrayList<Entry<T>>();\n-      if (accept.isWildcardType())\n-      {\n-         return convert(everything);\n-      }\n-      else\n-      {\n-         SubtypeMap<T> indexed = index.get(accept.getType());\n-         if (indexed != null)\n-         {\n-            matches.addAll(indexed.getPossible(accept));\n-         }\n-         matches.addAll(wildcards);\n-      }\n-      Collections.sort(matches);\n-      return convert(matches);\n-   }\n-\n-   /**\n-    * By default, MediaTypeMap will cache possible MediaType/Class matches.  Set this to false to turn off\n-    * caching\n-    *\n-    */\n-   public static boolean useCache = true;\n-\n-   public List<T> getPossible(MediaType accept, Class<?> type)\n-   {\n-      List<T> cached = null;\n-      CachedMediaTypeAndClass cacheEntry = null;\n-      if (useCache)\n-      {\n-         cacheEntry = new CachedMediaTypeAndClass(type, accept);\n-         if (classCache != null) {\n-            cached = classCache.get(cacheEntry);\n-            if (cached != null) return cached;\n-         }\n-      }\n-\n-      accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n-      List<Entry<T>> matches = new ArrayList<Entry<T>>();\n-      if (accept.isWildcardType())\n-      {\n-         matches.addAll(everything);\n-      }\n-      else\n-      {\n-         SubtypeMap<T> indexed = index.get(accept.getType());\n-         if (indexed != null)\n-         {\n-            matches.addAll(indexed.getPossible(accept));\n-         }\n-         matches.addAll(wildcards);\n-      }\n-      Collections.sort(matches, new TypedEntryComparator(type));\n-      cached = convert(matches);\n-      if (useCache) {\n-         Map<CachedMediaTypeAndClass, List<T>> cache = classCache;\n-         if (cache == null) {\n-            synchronized (this)\n-            {\n-               if (classCache == null)\n-               {\n-                  classCache = new ConcurrentHashMap<>();\n-               }\n-               cache = classCache;\n-            }\n-         }\n-         cache.put(cacheEntry, cached);\n-      }\n-      return cached;\n-\n-   }\n-\n-}\n+package org.jboss.resteasy.core;\n+\n+import java.io.Serializable;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jakarta.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.plugins.delegates.MediaTypeHeaderDelegate;\n+import org.jboss.resteasy.util.MediaTypeHelper;\n+\n+/**\n+ * A copy-on-write MediaType index of T.\n+ *\n+ * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n+ * @version $Revision: 1 $\n+ */\n+public class MediaTypeMap<T> {\n+    public interface Typed {\n+        Class<?> getType();\n+    }\n+\n+    private static class TypedEntryComparator implements Comparator<Entry<?>>, Serializable {\n+        private static final long serialVersionUID = -8815419198743440920L;\n+        private Class<?> type;\n+\n+        TypedEntryComparator(final Class<?> type) {\n+            this.type = type;\n+        }\n+\n+        private boolean isAssignableFrom(Typed typed) {\n+            if (typed.getType() == null)\n+                return false;\n+            return typed.getType().isAssignableFrom(type);\n+        }\n+\n+        private int compareTypes(Entry<?> entry, Entry<?> entry1) {\n+            int val = 0;\n+            if (entry.object instanceof Typed && entry1.object instanceof Typed && type != null) {\n+                Typed one = (Typed) entry.object;\n+                Typed two = (Typed) entry1.object;\n+\n+                boolean oneTyped = isAssignableFrom(one);\n+                boolean twoTyped = isAssignableFrom(two);\n+                if (oneTyped == twoTyped && (!oneTyped && !twoTyped)) {\n+                    // both are false\n+                    val = 0;\n+                } else if (oneTyped == twoTyped) {\n+                    // both are true.\n+                    // test for better assignability\n+                    if (one.getType().equals(two.getType())) {\n+                        val = 0;\n+                    } else if (one.getType().isAssignableFrom(two.getType())) {\n+                        val = 1;\n+                    } else {\n+                        val = -1;\n+                    }\n+                } else if (oneTyped)\n+                    val = -1;\n+                else\n+                    val = 1;\n+            }\n+            return val;\n+\n+        }\n+\n+        public int compare(Entry<?> entry, Entry<?> entry1) {\n+            int val = compareTypes(entry, entry1);\n+            if (val == 0)\n+                val = entry.compareTo(entry1);\n+            return val;\n+        }\n+    }\n+\n+    private static class Entry<T> implements Comparable<Entry<?>> {\n+        public MediaType mediaType;\n+        public T object;\n+\n+        private Entry(final MediaType mediaType, final T object) {\n+            this.mediaType = mediaType;\n+            this.object = object;\n+        }\n+\n+        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+        public int compareTo(Entry<?> entry) {\n+            int val = MediaTypeHelper.compareWeight(mediaType, entry.mediaType);\n+            if (val == 0 && object instanceof Comparable && entry.object instanceof Comparable) {\n+                return ((Comparable) object).compareTo(entry.object);\n+            }\n+            return val;\n+        }\n+    }\n+\n+    private static final Pattern COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+(.+)\");\n+\n+    // Composite subtypes are of the pattern *+subtype i.e. *+xml, *+json\n+    public static final Pattern COMPOSITE_SUBTYPE_WILDCARD_PATTERN = Pattern.compile(\"\\\\*\\\\+(.+)\");\n+\n+    // This composite is subtype+*  i.e. atom+* rss+*\n+    public static final Pattern WILD_SUBTYPE_COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+\\\\*\");\n+\n+    public static String compositeWildSubtype(String subtype) {\n+        final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(subtype);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+\n+    public static String wildCompositeSubtype(String subtype) {\n+        final Matcher matcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(subtype);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+\n+    private class SubtypeMap<T> {\n+        private volatile Map<String, List<Entry<T>>> index;\n+        private volatile Map<String, List<Entry<T>>> compositeIndex;\n+        private volatile Map<String, List<Entry<T>>> wildCompositeIndex;\n+        private volatile List<Entry<T>> wildcards;\n+        private volatile List<Entry<T>> all;\n+\n+        private SubtypeMap() {\n+            index = new HashMap<>();\n+            compositeIndex = new HashMap<>();\n+            wildCompositeIndex = new HashMap<>();\n+            wildcards = new ArrayList<>();\n+            all = new ArrayList<>();\n+        }\n+\n+        private SubtypeMap(final SubtypeMap<T> subtypeMap) {\n+            index = subtypeMap.index;\n+            compositeIndex = subtypeMap.compositeIndex;\n+            wildCompositeIndex = subtypeMap.wildCompositeIndex;\n+            wildcards = subtypeMap.wildcards;\n+            all = subtypeMap.all;\n+        }\n+\n+        private void add(Entry<T> entry) {\n+            final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(entry.mediaType.getSubtype());\n+            final Matcher wildCompositeMatcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(entry.mediaType.getSubtype());\n+\n+            if (entry.mediaType.isWildcardSubtype()) {\n+                addWildcard(entry);\n+            } else if (matcher.matches()) {\n+                String baseSubType = matcher.group(1);\n+                addCompositeWild(entry, baseSubType);\n+            } else if (wildCompositeMatcher.matches()) {\n+                String base = wildCompositeMatcher.group(1);\n+                addWildComposite(entry, base);\n+            } else {\n+                addRegular(entry);\n+            }\n+        }\n+\n+        private void addRegular(Entry<T> entry) {\n+            Map<String, List<Entry<T>>> newIndex = index;\n+            if (lockSnapshots)\n+                newIndex = copy(index);\n+            add(newIndex, entry.mediaType.getSubtype(), entry);\n+            index = newIndex;\n+            merge(entry);\n+        }\n+\n+        private void addWildComposite(Entry<T> entry, String base) {\n+            Map<String, List<Entry<T>>> newWildCompositeIndex = wildCompositeIndex;\n+            if (lockSnapshots)\n+                newWildCompositeIndex = (wildCompositeIndex);\n+            add(newWildCompositeIndex, base, entry);\n+            wildCompositeIndex = newWildCompositeIndex;\n+            merge(entry);\n+        }\n+\n+        private void addCompositeWild(Entry<T> entry, String baseSubType) {\n+            Map<String, List<Entry<T>>> newCompositeIndex = compositeIndex;\n+            if (lockSnapshots)\n+                newCompositeIndex = copy(compositeIndex);\n+            add(newCompositeIndex, baseSubType, entry);\n+            compositeIndex = newCompositeIndex;\n+            merge(entry);\n+        }\n+\n+        private void addWildcard(Entry<T> entry) {\n+            if (lockSnapshots)\n+                wildcards = copyAndAdd(wildcards, entry);\n+            else\n+                wildcards.add(entry);\n+            merge(entry);\n+        }\n+\n+        private void merge(Entry<T> entry) {\n+            if (lockSnapshots) {\n+                all = copyAndAdd(all, entry);\n+            } else {\n+                all.add(entry);\n+            }\n+        }\n+\n+        private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) {\n+            final Map<String, List<Entry<T>>> copy = new HashMap<>(original.size());\n+            original.forEach((key, value) -> copy.put(key, new ArrayList<>(value)));\n+            return copy;\n+        }\n+\n+        private void add(final Map<String, List<Entry<T>>> map,\n+                final String key,\n+                final Entry<T> entry) {\n+            map.putIfAbsent(key, new CopyOnWriteArrayList<>());\n+            map.get(key).add(entry);\n+        }\n+\n+        private List<Entry<T>> getPossible(MediaType accept) {\n+            if (accept.isWildcardSubtype()) {\n+                return all;\n+            } else {\n+                List<Entry<T>> matches = new ArrayList<Entry<T>>();\n+\n+                List<Entry<T>> indexed = index.get(accept.getSubtype());\n+                if (indexed != null)\n+                    matches.addAll(indexed);\n+\n+                Matcher matcher = COMPOSITE_PATTERN.matcher(accept.getSubtype());\n+                String compositeKey = accept.getSubtype();\n+                if (matcher.matches()) {\n+                    String wildCompositeKey = matcher.group(1);\n+                    List<Entry<T>> windex = wildCompositeIndex.get(wildCompositeKey);\n+                    if (windex != null)\n+                        matches.addAll(windex);\n+                    compositeKey = matcher.group(2);\n+                }\n+                List<Entry<T>> indexed2 = compositeIndex.get(compositeKey);\n+                if (indexed2 != null)\n+                    matches.addAll(indexed2);\n+                matches.addAll(wildcards);\n+                return matches;\n+            }\n+        }\n+    }\n+\n+    static <A> List<A> copyAndAdd(List<A> a, A entry) {\n+        // reduce internal array copying\n+        ArrayList<A> newList = new ArrayList<A>(a.size() + 1);\n+        newList.add(entry);\n+        newList.addAll(0, a);\n+        return newList;\n+    }\n+\n+    private static class CachedMediaTypeAndClass {\n+        // we need a weak reference because of possible hot deployment\n+        // Although, these reference should get cleared up with any add() invocation\n+        private WeakReference<Class<?>> clazz;\n+        private MediaType mediaType;\n+        private final int hash;\n+\n+        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+        private CachedMediaTypeAndClass(final Class clazz, final MediaType mediaType) {\n+            this.clazz = new WeakReference(clazz);\n+            this.mediaType = mediaType;\n+            int result = clazz.hashCode();\n+            result = 31 * result + (mediaType.getType() != null ? mediaType.getType().hashCode() : 0)\n+                    + (mediaType.getSubtype() != null ? mediaType.getSubtype().hashCode() : 0);\n+            hash = result;\n+        }\n+\n+        private Class<?> getClazz() {\n+            return clazz.get();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+\n+            CachedMediaTypeAndClass that = (CachedMediaTypeAndClass) o;\n+\n+            // WeakReference may have GC'd\n+            Class<?> clazz = getClazz();\n+            if (clazz == null || that.getClazz() == null)\n+                return false;\n+\n+            if (!clazz.equals(that.getClazz()))\n+                return false;\n+\n+            if (mediaType.getType() != null) {\n+                if (!mediaType.getType().equals(that.mediaType.getType()))\n+                    return false;\n+            } else if ((mediaType.getType() != that.mediaType.getType()))\n+                return false;\n+\n+            if (mediaType.getSubtype() != null) {\n+                if (!mediaType.getSubtype().equals(that.mediaType.getSubtype()))\n+                    return false;\n+            } else if ((mediaType.getSubtype() != that.mediaType.getSubtype()))\n+                return false;\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+    private volatile Map<String, SubtypeMap<T>> index;\n+    private volatile Map<CachedMediaTypeAndClass, List<T>> classCache;\n+    private volatile List<Entry<T>> wildcards;\n+    private volatile List<Entry<T>> everything;\n+    private boolean lockSnapshots;\n+\n+    public MediaTypeMap() {\n+        index = new HashMap<>();\n+        wildcards = new ArrayList<>();\n+        everything = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Shallow copy, any additional adds will deep copy\n+     *\n+     * @param mediaTypeMap\n+     */\n+    public MediaTypeMap(final MediaTypeMap<T> mediaTypeMap) {\n+        lockSnapshots = true;\n+        index = mediaTypeMap.index;\n+        wildcards = mediaTypeMap.wildcards;\n+        everything = mediaTypeMap.everything;\n+        classCache = mediaTypeMap.classCache;\n+    }\n+\n+    /**\n+     * After this is called, all new adds will deep copy itself.\n+     *\n+     */\n+    public void lockSnapshots() {\n+        //if (!lockSnapshots) Collections.sort(everything);\n+        lockSnapshots = true;\n+    }\n+\n+    /**\n+     * Add an object to the media type map. This is synchronized to serialize adds.\n+     *\n+     * @param type media type\n+     * @param obj  object\n+     */\n+    public synchronized void add(final MediaType type, final T obj) {\n+        final MediaType newType = new MediaType(type.getType().toLowerCase(), type.getSubtype().toLowerCase(),\n+                type.getParameters());\n+        final Entry<T> entry = new Entry<>(newType, obj);\n+\n+        add(entry);\n+    }\n+\n+    /**\n+     * Add an object to the media type map. This is synchronized to serialize adds.\n+     *\n+     * @param mediaType media type\n+     * @param obj       object\n+     */\n+    public synchronized void add(String mediaType, final T obj) {\n+        final MediaType newType = MediaTypeHeaderDelegate.parse(mediaType.toLowerCase());\n+        final Entry<T> entry = new Entry<>(newType, obj);\n+        add(entry);\n+    }\n+\n+    public synchronized void addWildcard(final T obj) {\n+        final Entry<T> entry = new Entry<>(MediaType.WILDCARD_TYPE, obj);\n+        addWildcard(entry);\n+    }\n+\n+    protected void add(Entry<T> entry) {\n+        if (entry.mediaType.isWildcardType()) {\n+            addWildcard(entry);\n+        } else {\n+            Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+            newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+            newIndex.get(entry.mediaType.getType()).add(entry);\n+            index = newIndex;\n+            mergeEverything(entry);\n+        }\n+    }\n+\n+    private Map<String, SubtypeMap<T>> copyIndex() {\n+        Map<String, SubtypeMap<T>> newIndex = index;\n+        if (lockSnapshots) {\n+            Map<String, SubtypeMap<T>> finalIndex = new HashMap<>();\n+            newIndex = finalIndex;\n+            index.forEach((key, value) -> finalIndex.put(key, new SubtypeMap<>(value)));\n+        }\n+        return newIndex;\n+    }\n+\n+    private void addWildcard(Entry<T> entry) {\n+        if (lockSnapshots)\n+            wildcards = copyAndAdd(wildcards, entry);\n+        else\n+            wildcards.add(entry);\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addRegular(MediaType mediaType, T obj) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+        subtypeMap.addRegular(entry);\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addCompositeWild(MediaType mediaType, T obj, String baseSubtype) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+\n+        subtypeMap.addCompositeWild(entry, baseSubtype);\n+\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addWildComposite(MediaType mediaType, T obj, String baseSubtype) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+\n+        subtypeMap.addWildComposite(entry, baseSubtype);\n+\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addWildSubtype(MediaType mediaType, T obj) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+\n+        subtypeMap.addWildcard(entry);\n+\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    private void mergeEverything(Entry<T> entry) {\n+        List<Entry<T>> newAll = everything;\n+        if (lockSnapshots) {\n+            newAll = copyAndAdd(everything, entry);\n+            Collections.sort(newAll);\n+            everything = newAll;\n+        } else {\n+            everything.add(entry);\n+            Collections.sort(everything);\n+        }\n+        classCache = null;\n+    }\n+\n+    private static <T> List<T> convert(List<Entry<T>> list) {\n+        List<T> newList = new ArrayList<T>(list.size());\n+        for (Entry<T> entry : list) {\n+            newList.add(entry.object);\n+        }\n+        return newList;\n+\n+    }\n+\n+    /**\n+     * Returns a list of objects sorted based on their media type where the first in the list\n+     * is the best match\n+     *\n+     * @param accept mime to match\n+     * @return list of objects\n+     */\n+    public List<T> getPossible(MediaType accept) {\n+        accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n+        List<Entry<T>> matches = new ArrayList<Entry<T>>();\n+        if (accept.isWildcardType()) {\n+            return convert(everything);\n+        } else {\n+            SubtypeMap<T> indexed = index.get(accept.getType());\n+            if (indexed != null) {\n+                matches.addAll(indexed.getPossible(accept));\n+            }\n+            matches.addAll(wildcards);\n+        }\n+        Collections.sort(matches);\n+        return convert(matches);\n+    }\n+\n+    /**\n+     * By default, MediaTypeMap will cache possible MediaType/Class matches. Set this to false to turn off\n+     * caching\n+     *\n+     */\n+    public static boolean useCache = true;\n+\n+    public List<T> getPossible(MediaType accept, Class<?> type) {\n+        List<T> cached = null;\n+        CachedMediaTypeAndClass cacheEntry = null;\n+        if (useCache) {\n+            cacheEntry = new CachedMediaTypeAndClass(type, accept);\n+            if (classCache != null) {\n+                cached = classCache.get(cacheEntry);\n+                if (cached != null)\n+                    return cached;\n+            }\n+        }\n+\n+        accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n+        List<Entry<T>> matches = new ArrayList<Entry<T>>();\n+        if (accept.isWildcardType()) {\n+            matches.addAll(everything);\n+        } else {\n+            SubtypeMap<T> indexed = index.get(accept.getType());\n+            if (indexed != null) {\n+                matches.addAll(indexed.getPossible(accept));\n+            }\n+            matches.addAll(wildcards);\n+        }\n+        Collections.sort(matches, new TypedEntryComparator(type));\n+        cached = convert(matches);\n+        if (useCache) {\n+            Map<CachedMediaTypeAndClass, List<T>> cache = classCache;\n+            if (cache == null) {\n+                synchronized (this) {\n+                    if (classCache == null) {\n+                        classCache = new HashMap<>();\n+                    }\n+                    cache = classCache;\n+                }\n+            }\n+            cache.put(cacheEntry, cached);\n+        }\n+        return cached;\n+\n+    }\n+\n+}\n", "next_change": null}]}, "commits_in_main": [{"oid": "fed55666e9ef5c6e7366912742331de4de3688f4", "message": "Merge commit", "committedDate": null}, {"oid": "1ba8cedf5ed7e30e1106ede5b622535b75fa3dd0", "committedDate": "2021-11-09 09:47:49 -0800", "message": "[RESTEASY-3007] Initial conversion for Jakarta REST 3.0"}, {"oid": "5d60f62c67eec6dbdf9ecd10db7473614750c35d", "committedDate": "2022-12-14 07:51:48 -0800", "message": "[RESTEASY-3264] Re-format all sources and resources."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAyMDI5OQ==", "url": "https://github.com/resteasy/resteasy/pull/2501#discussion_r481020299", "body": "if (cache== null) check again here ?", "bodyText": "if (cache== null) check again here ?", "bodyHTML": "<p dir=\"auto\">if (cache== null) check again here ?</p>", "author": "jimma", "createdAt": "2020-09-01T10:03:35Z", "path": "resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java", "diffHunk": "@@ -576,14 +577,14 @@ private void mergeEverything(Entry<T> entry) {\n       cached = convert(matches);\r\n       if (useCache) {\r\n          Map<CachedMediaTypeAndClass, List<T>> cache = classCache;\r\n-         if (classCache == null) {\r\n+         if (cache == null) {\r\n             synchronized (this)\r\n             {\r\n                if (classCache == null)\r", "originalCommit": "77a67bcd2ae67442ed49dd7d7083609f0c89db34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0MTk3NQ==", "url": "https://github.com/resteasy/resteasy/pull/2501#discussion_r481041975", "bodyText": "I think that it's not needed to repeat the check for the cache var, cache is local to the method, so if it was null then it's null now. Only classCache can be initialized by other threads.", "author": "rmartinc", "createdAt": "2020-09-01T10:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAyMDI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "49e4c8f2f1bca480a1e696552081aa2275b86ece", "changed_code": [{"header": "diff --git a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\nindex d2194370e6..e6900b5b23 100644\n--- a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n+++ b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n", "chunk": "@@ -582,7 +581,7 @@ public class MediaTypeMap<T>\n             {\n                if (classCache == null)\n                {\n-                  classCache = new ConcurrentHashMap<>();\n+                  classCache = new HashMap<>();\n                }\n                cache = classCache;\n             }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "fed55666e9ef5c6e7366912742331de4de3688f4", "changed_code": [{"header": "diff --git a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\nindex d2194370e6..e6900b5b23 100644\n--- a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n+++ b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n", "chunk": "@@ -582,7 +581,7 @@ public class MediaTypeMap<T>\n             {\n                if (classCache == null)\n                {\n-                  classCache = new ConcurrentHashMap<>();\n+                  classCache = new HashMap<>();\n                }\n                cache = classCache;\n             }\n", "next_change": {"commit": "5d60f62c67eec6dbdf9ecd10db7473614750c35d", "changed_code": [{"header": "diff --git a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\nindex e6900b5b23..c7cf5c366e 100644\n--- a/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n+++ b/resteasy-core/src/main/java/org/jboss/resteasy/core/MediaTypeMap.java\n", "chunk": "@@ -1,595 +1,551 @@\n-package org.jboss.resteasy.core;\n-\n-import org.jboss.resteasy.plugins.delegates.MediaTypeHeaderDelegate;\n-import org.jboss.resteasy.util.MediaTypeHelper;\n-\n-import javax.ws.rs.core.MediaType;\n-import java.io.Serializable;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-/**\n- * A copy-on-write MediaType index of T.\n- *\n- * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n- * @version $Revision: 1 $\n- */\n-public class MediaTypeMap<T>\n-{\n-   public interface Typed\n-   {\n-      Class<?> getType();\n-   }\n-\n-   private static class TypedEntryComparator implements Comparator<Entry<?>>, Serializable\n-   {\n-      private static final long serialVersionUID = -8815419198743440920L;\n-      private Class<?> type;\n-\n-      TypedEntryComparator(final Class<?> type)\n-      {\n-         this.type = type;\n-      }\n-\n-      private boolean isAssignableFrom(Typed typed)\n-      {\n-         if (typed.getType() == null) return false;\n-         return typed.getType().isAssignableFrom(type);\n-      }\n-\n-      private int compareTypes(Entry<?> entry, Entry<?> entry1)\n-      {\n-         int val = 0;\n-         if (entry.object instanceof Typed && entry1.object instanceof Typed && type != null)\n-         {\n-            Typed one = (Typed) entry.object;\n-            Typed two = (Typed) entry1.object;\n-\n-\n-            boolean oneTyped = isAssignableFrom(one);\n-            boolean twoTyped = isAssignableFrom(two);\n-            if (oneTyped == twoTyped && (!oneTyped && !twoTyped))\n-            {\n-               // both are false\n-               val = 0;\n-            }\n-            else if (oneTyped == twoTyped)\n-            {\n-               // both are true.\n-               // test for better assignability\n-               if (one.getType().equals(two.getType()))\n-               {\n-                  val = 0;\n-               }\n-               else if (one.getType().isAssignableFrom(two.getType()))\n-               {\n-                  val = 1;\n-               }\n-               else\n-               {\n-                  val = -1;\n-               }\n-            }\n-            else if (oneTyped) val = -1;\n-            else val = 1;\n-         }\n-         return val;\n-\n-      }\n-\n-      public int compare(Entry<?> entry, Entry<?> entry1)\n-      {\n-         int val = compareTypes(entry, entry1);\n-         if (val == 0) val = entry.compareTo(entry1);\n-         return val;\n-      }\n-   }\n-\n-   private static class Entry<T> implements Comparable<Entry<?>>\n-   {\n-      public MediaType mediaType;\n-      public T object;\n-\n-      private Entry(final MediaType mediaType, final T object)\n-      {\n-         this.mediaType = mediaType;\n-         this.object = object;\n-      }\n-\n-      @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-      public int compareTo(Entry<?> entry)\n-      {\n-         int val = MediaTypeHelper.compareWeight(mediaType, entry.mediaType);\n-         if (val == 0 && object instanceof Comparable && entry.object instanceof Comparable)\n-         {\n-            return ((Comparable) object).compareTo(entry.object);\n-         }\n-         return val;\n-      }\n-   }\n-\n-   private static final Pattern COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+(.+)\");\n-\n-   // Composite subtypes are of the pattern *+subtype i.e. *+xml, *+json\n-   public static final Pattern COMPOSITE_SUBTYPE_WILDCARD_PATTERN = Pattern.compile(\"\\\\*\\\\+(.+)\");\n-\n-\n-   // This composite is subtype+*  i.e. atom+* rss+*\n-   public static final Pattern WILD_SUBTYPE_COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+\\\\*\");\n-\n-   public static String compositeWildSubtype(String subtype) {\n-      final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(subtype);\n-      if (matcher.matches()) {\n-         return matcher.group(1);\n-      }\n-      return null;\n-   }\n-\n-   public static String wildCompositeSubtype(String subtype) {\n-      final Matcher matcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(subtype);\n-      if (matcher.matches()) {\n-         return matcher.group(1);\n-      }\n-      return null;\n-   }\n-\n-   private class SubtypeMap<T>\n-   {\n-      private volatile Map<String, List<Entry<T>>> index;\n-      private volatile Map<String, List<Entry<T>>> compositeIndex;\n-      private volatile Map<String, List<Entry<T>>> wildCompositeIndex;\n-      private volatile List<Entry<T>> wildcards;\n-      private volatile List<Entry<T>> all;\n-\n-      private SubtypeMap() {\n-         index = new HashMap<>();\n-         compositeIndex = new HashMap<>();\n-         wildCompositeIndex = new HashMap<>();\n-         wildcards = new ArrayList<>();\n-         all = new ArrayList<>();\n-      }\n-\n-      private SubtypeMap(final SubtypeMap<T> subtypeMap) {\n-         index = subtypeMap.index;\n-         compositeIndex = subtypeMap.compositeIndex;\n-         wildCompositeIndex = subtypeMap.wildCompositeIndex;\n-         wildcards = subtypeMap.wildcards;\n-         all = subtypeMap.all;\n-      }\n-\n-\n-      private void add(Entry<T> entry)\n-      {\n-         final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(entry.mediaType.getSubtype());\n-         final Matcher wildCompositeMatcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(entry.mediaType.getSubtype());\n-\n-\n-         if (entry.mediaType.isWildcardSubtype()) {\n-            addWildcard(entry);\n-         }\n-         else if (matcher.matches())\n-         {\n-            String baseSubType = matcher.group(1);\n-            addCompositeWild(entry, baseSubType);\n-         }\n-         else if (wildCompositeMatcher.matches())\n-         {\n-            String base = wildCompositeMatcher.group(1);\n-            addWildComposite(entry, base);\n-         }\n-         else\n-         {\n-            addRegular(entry);\n-         }\n-      }\n-\n-      private void addRegular(Entry<T> entry) {\n-         Map<String, List<Entry<T>>> newIndex = index;\n-         if (lockSnapshots) newIndex = copy(index);\n-         add(newIndex, entry.mediaType.getSubtype(), entry);\n-         index = newIndex;\n-         merge(entry);\n-      }\n-\n-      private void addWildComposite(Entry<T> entry, String base) {\n-         Map<String, List<Entry<T>>> newWildCompositeIndex = wildCompositeIndex;\n-         if (lockSnapshots) newWildCompositeIndex = (wildCompositeIndex);\n-         add(newWildCompositeIndex, base, entry);\n-         wildCompositeIndex = newWildCompositeIndex;\n-         merge(entry);\n-      }\n-\n-      private void addCompositeWild(Entry<T> entry, String baseSubType) {\n-         Map<String, List<Entry<T>>> newCompositeIndex = compositeIndex;\n-         if (lockSnapshots) newCompositeIndex = copy(compositeIndex);\n-         add(newCompositeIndex, baseSubType, entry);\n-         compositeIndex = newCompositeIndex;\n-         merge(entry);\n-      }\n-\n-      private void addWildcard(Entry<T> entry) {\n-         if (lockSnapshots) wildcards = copyAndAdd(wildcards, entry);\n-         else wildcards.add(entry);\n-         merge(entry);\n-      }\n-\n-      private void merge(Entry<T> entry) {\n-         if (lockSnapshots) {\n-            all = copyAndAdd(all, entry);\n-         } else {\n-            all.add(entry);\n-         }\n-      }\n-\n-      private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) {\n-         final Map<String, List<Entry<T>>> copy = new HashMap<>(original.size());\n-         original.forEach((key, value) -> copy.put(key, new ArrayList<>(value)));\n-         return copy;\n-      }\n-\n-      private void add(final Map<String, List<Entry<T>>> map,\n-                       final String key,\n-                       final Entry<T> entry) {\n-         map.putIfAbsent(key, new CopyOnWriteArrayList<>());\n-         map.get(key).add(entry);\n-      }\n-\n-      private List<Entry<T>> getPossible(MediaType accept)\n-      {\n-         if (accept.isWildcardSubtype())\n-         {\n-            return all;\n-         }\n-         else\n-         {\n-            List<Entry<T>> matches = new ArrayList<Entry<T>>();\n-\n-            List<Entry<T>> indexed = index.get(accept.getSubtype());\n-            if (indexed != null) matches.addAll(indexed);\n-\n-            Matcher matcher = COMPOSITE_PATTERN.matcher(accept.getSubtype());\n-            String compositeKey = accept.getSubtype();\n-            if (matcher.matches())\n-            {\n-               String wildCompositeKey = matcher.group(1);\n-               List<Entry<T>> windex = wildCompositeIndex.get(wildCompositeKey);\n-               if (windex != null) matches.addAll(windex);\n-               compositeKey = matcher.group(2);\n-            }\n-            List<Entry<T>> indexed2 = compositeIndex.get(compositeKey);\n-            if (indexed2 != null) matches.addAll(indexed2);\n-            matches.addAll(wildcards);\n-            return matches;\n-         }\n-      }\n-   }\n-\n-   static <A> List<A> copyAndAdd(List<A> a, A entry) {\n-      // reduce internal array copying\n-      ArrayList<A> newList = new ArrayList<A>(a.size() + 1);\n-      newList.add(entry);\n-      newList.addAll(0, a);\n-      return newList;\n-   }\n-\n-   private static class CachedMediaTypeAndClass\n-   {\n-      // we need a weak reference because of possible hot deployment\n-      // Although, these reference should get cleared up with any add() invocation\n-      private WeakReference<Class<?>> clazz;\n-      private MediaType mediaType;\n-      private final int hash;\n-\n-      @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-      private CachedMediaTypeAndClass(final Class clazz, final MediaType mediaType)\n-      {\n-         this.clazz = new WeakReference(clazz);\n-         this.mediaType = mediaType;\n-         int result = clazz.hashCode();\n-         result = 31 * result + (mediaType.getType() != null ? mediaType.getType().hashCode() : 0) +  (mediaType.getSubtype() != null ? mediaType.getSubtype().hashCode() : 0);\n-         hash = result;\n-      }\n-\n-      private Class<?> getClazz()\n-      {\n-         return clazz.get();\n-      }\n-\n-      @Override\n-      public boolean equals(Object o)\n-      {\n-         if (this == o) return true;\n-         if (o == null || getClass() != o.getClass()) return false;\n-\n-         CachedMediaTypeAndClass that = (CachedMediaTypeAndClass) o;\n-\n-         // WeakReference may have GC'd\n-         Class<?> clazz = getClazz();\n-         if (clazz == null || that.getClazz() == null) return false;\n-\n-         if (!clazz.equals(that.getClazz())) return false;\n-\n-         if (mediaType.getType() != null)\n-         {\n-            if (!mediaType.getType().equals(that.mediaType.getType())) return false;\n-         }\n-         else if ((mediaType.getType() != that.mediaType.getType())) return false;\n-\n-         if (mediaType.getSubtype() != null)\n-         {\n-            if (!mediaType.getSubtype().equals(that.mediaType.getSubtype())) return false;\n-         }\n-         else if ((mediaType.getSubtype() != that.mediaType.getSubtype())) return false;\n-\n-         return true;\n-      }\n-\n-      @Override\n-      public int hashCode()\n-      {\n-         return hash;\n-      }\n-   }\n-\n-   private volatile Map<String, SubtypeMap<T>> index;\n-   private volatile Map<CachedMediaTypeAndClass, List<T>> classCache;\n-   private volatile List<Entry<T>> wildcards;\n-   private volatile List<Entry<T>> everything;\n-   private boolean lockSnapshots;\n-\n-   public MediaTypeMap() {\n-      index = new HashMap<>();\n-      wildcards = new ArrayList<>();\n-      everything = new ArrayList<>();\n-   }\n-\n-   /**\n-    * Shallow copy, any additional adds will deep copy\n-    *\n-    * @param mediaTypeMap\n-    */\n-   public MediaTypeMap(final MediaTypeMap<T> mediaTypeMap) {\n-      lockSnapshots = true;\n-      index      = mediaTypeMap.index;\n-      wildcards  = mediaTypeMap.wildcards;\n-      everything        = mediaTypeMap.everything;\n-      classCache = mediaTypeMap.classCache;\n-   }\n-\n-   /**\n-    * After this is called, all new adds will deep copy itself.\n-    *\n-    */\n-   public void lockSnapshots() {\n-      //if (!lockSnapshots) Collections.sort(everything);\n-      lockSnapshots = true;\n-   }\n-\n-   /**\n-    * Add an object to the media type map.  This is synchronized to serialize adds.\n-    *\n-    * @param type media type\n-    * @param obj object\n-    */\n-   public synchronized void add(final MediaType type, final T obj)\n-   {\n-      final MediaType newType =\n-              new MediaType(type.getType().toLowerCase(), type.getSubtype().toLowerCase(), type.getParameters());\n-      final Entry<T> entry = new Entry<>(newType, obj);\n-\n-      add(entry);\n-   }\n-\n-   /**\n-    * Add an object to the media type map.  This is synchronized to serialize adds.\n-    *\n-    * @param mediaType media type\n-    * @param obj object\n-    */\n-   public synchronized void add(String mediaType, final T obj)\n-   {\n-      final MediaType newType = MediaTypeHeaderDelegate.parse(mediaType.toLowerCase());\n-      final Entry<T> entry = new Entry<>(newType, obj);\n-      add(entry);\n-   }\n-\n-   public synchronized void addWildcard(final T obj) {\n-      final Entry<T> entry = new Entry<>(MediaType.WILDCARD_TYPE, obj);\n-      addWildcard(entry);\n-   }\n-\n-\n-   protected void add(Entry<T> entry) {\n-      if (entry.mediaType.isWildcardType())\n-      {\n-         addWildcard(entry);\n-      }\n-      else\n-      {\n-         Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-         newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-         newIndex.get(entry.mediaType.getType()).add(entry);\n-         index = newIndex;\n-         mergeEverything(entry);\n-      }\n-   }\n-\n-   private Map<String, SubtypeMap<T>> copyIndex() {\n-      Map<String, SubtypeMap<T>> newIndex = index;\n-      if (lockSnapshots) {\n-         Map<String, SubtypeMap<T>> finalIndex = new HashMap<>();\n-         newIndex = finalIndex;\n-         index.forEach((key, value) -> finalIndex.put(key, new SubtypeMap<>(value)));\n-      }\n-      return newIndex;\n-   }\n-\n-   private void addWildcard(Entry<T> entry) {\n-      if (lockSnapshots) wildcards = copyAndAdd(wildcards, entry);\n-      else wildcards.add(entry);\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addRegular(MediaType mediaType, T obj) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-      subtypeMap.addRegular(entry);\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addCompositeWild(MediaType mediaType, T obj, String baseSubtype) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-\n-      subtypeMap.addCompositeWild(entry, baseSubtype);\n-\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addWildComposite(MediaType mediaType, T obj, String baseSubtype) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-\n-      subtypeMap.addWildComposite(entry, baseSubtype);\n-\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   public synchronized void addWildSubtype(MediaType mediaType, T obj) {\n-      final Entry<T> entry = new Entry<>(mediaType, obj);\n-      Map<String, SubtypeMap<T>> newIndex = copyIndex();\n-      newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n-      SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n-\n-      subtypeMap.addWildcard(entry);\n-\n-      index = newIndex;\n-      mergeEverything(entry);\n-   }\n-\n-   private void mergeEverything(Entry<T> entry) {\n-      List<Entry<T>> newAll = everything;\n-      if (lockSnapshots) {\n-         newAll = copyAndAdd(everything, entry);\n-         Collections.sort(newAll);\n-         everything = newAll;\n-      } else {\n-         everything.add(entry);\n-         Collections.sort(everything);\n-      }\n-      classCache = null;\n-   }\n-\n-\n-   private static <T> List<T> convert(List<Entry<T>> list)\n-   {\n-      List<T> newList = new ArrayList<T>(list.size());\n-      for (Entry<T> entry : list)\n-      {\n-         newList.add(entry.object);\n-      }\n-      return newList;\n-\n-   }\n-\n-   /**\n-    * Returns a list of objects sorted based on their media type where the first in the list\n-    * is the best match\n-    *\n-    * @param accept mime to match\n-    * @return list of objects\n-    */\n-   public List<T> getPossible(MediaType accept)\n-   {\n-      accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n-      List<Entry<T>> matches = new ArrayList<Entry<T>>();\n-      if (accept.isWildcardType())\n-      {\n-         return convert(everything);\n-      }\n-      else\n-      {\n-         SubtypeMap<T> indexed = index.get(accept.getType());\n-         if (indexed != null)\n-         {\n-            matches.addAll(indexed.getPossible(accept));\n-         }\n-         matches.addAll(wildcards);\n-      }\n-      Collections.sort(matches);\n-      return convert(matches);\n-   }\n-\n-   /**\n-    * By default, MediaTypeMap will cache possible MediaType/Class matches.  Set this to false to turn off\n-    * caching\n-    *\n-    */\n-   public static boolean useCache = true;\n-\n-   public List<T> getPossible(MediaType accept, Class<?> type)\n-   {\n-      List<T> cached = null;\n-      CachedMediaTypeAndClass cacheEntry = null;\n-      if (useCache)\n-      {\n-         cacheEntry = new CachedMediaTypeAndClass(type, accept);\n-         if (classCache != null) {\n-            cached = classCache.get(cacheEntry);\n-            if (cached != null) return cached;\n-         }\n-      }\n-\n-      accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n-      List<Entry<T>> matches = new ArrayList<Entry<T>>();\n-      if (accept.isWildcardType())\n-      {\n-         matches.addAll(everything);\n-      }\n-      else\n-      {\n-         SubtypeMap<T> indexed = index.get(accept.getType());\n-         if (indexed != null)\n-         {\n-            matches.addAll(indexed.getPossible(accept));\n-         }\n-         matches.addAll(wildcards);\n-      }\n-      Collections.sort(matches, new TypedEntryComparator(type));\n-      cached = convert(matches);\n-      if (useCache) {\n-         Map<CachedMediaTypeAndClass, List<T>> cache = classCache;\n-         if (cache == null) {\n-            synchronized (this)\n-            {\n-               if (classCache == null)\n-               {\n-                  classCache = new HashMap<>();\n-               }\n-               cache = classCache;\n-            }\n-         }\n-         cache.put(cacheEntry, cached);\n-      }\n-      return cached;\n-\n-   }\n-\n-}\n+package org.jboss.resteasy.core;\n+\n+import java.io.Serializable;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jakarta.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.plugins.delegates.MediaTypeHeaderDelegate;\n+import org.jboss.resteasy.util.MediaTypeHelper;\n+\n+/**\n+ * A copy-on-write MediaType index of T.\n+ *\n+ * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n+ * @version $Revision: 1 $\n+ */\n+public class MediaTypeMap<T> {\n+    public interface Typed {\n+        Class<?> getType();\n+    }\n+\n+    private static class TypedEntryComparator implements Comparator<Entry<?>>, Serializable {\n+        private static final long serialVersionUID = -8815419198743440920L;\n+        private Class<?> type;\n+\n+        TypedEntryComparator(final Class<?> type) {\n+            this.type = type;\n+        }\n+\n+        private boolean isAssignableFrom(Typed typed) {\n+            if (typed.getType() == null)\n+                return false;\n+            return typed.getType().isAssignableFrom(type);\n+        }\n+\n+        private int compareTypes(Entry<?> entry, Entry<?> entry1) {\n+            int val = 0;\n+            if (entry.object instanceof Typed && entry1.object instanceof Typed && type != null) {\n+                Typed one = (Typed) entry.object;\n+                Typed two = (Typed) entry1.object;\n+\n+                boolean oneTyped = isAssignableFrom(one);\n+                boolean twoTyped = isAssignableFrom(two);\n+                if (oneTyped == twoTyped && (!oneTyped && !twoTyped)) {\n+                    // both are false\n+                    val = 0;\n+                } else if (oneTyped == twoTyped) {\n+                    // both are true.\n+                    // test for better assignability\n+                    if (one.getType().equals(two.getType())) {\n+                        val = 0;\n+                    } else if (one.getType().isAssignableFrom(two.getType())) {\n+                        val = 1;\n+                    } else {\n+                        val = -1;\n+                    }\n+                } else if (oneTyped)\n+                    val = -1;\n+                else\n+                    val = 1;\n+            }\n+            return val;\n+\n+        }\n+\n+        public int compare(Entry<?> entry, Entry<?> entry1) {\n+            int val = compareTypes(entry, entry1);\n+            if (val == 0)\n+                val = entry.compareTo(entry1);\n+            return val;\n+        }\n+    }\n+\n+    private static class Entry<T> implements Comparable<Entry<?>> {\n+        public MediaType mediaType;\n+        public T object;\n+\n+        private Entry(final MediaType mediaType, final T object) {\n+            this.mediaType = mediaType;\n+            this.object = object;\n+        }\n+\n+        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+        public int compareTo(Entry<?> entry) {\n+            int val = MediaTypeHelper.compareWeight(mediaType, entry.mediaType);\n+            if (val == 0 && object instanceof Comparable && entry.object instanceof Comparable) {\n+                return ((Comparable) object).compareTo(entry.object);\n+            }\n+            return val;\n+        }\n+    }\n+\n+    private static final Pattern COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+(.+)\");\n+\n+    // Composite subtypes are of the pattern *+subtype i.e. *+xml, *+json\n+    public static final Pattern COMPOSITE_SUBTYPE_WILDCARD_PATTERN = Pattern.compile(\"\\\\*\\\\+(.+)\");\n+\n+    // This composite is subtype+*  i.e. atom+* rss+*\n+    public static final Pattern WILD_SUBTYPE_COMPOSITE_PATTERN = Pattern.compile(\"([^\\\\+]+)\\\\+\\\\*\");\n+\n+    public static String compositeWildSubtype(String subtype) {\n+        final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(subtype);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+\n+    public static String wildCompositeSubtype(String subtype) {\n+        final Matcher matcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(subtype);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        }\n+        return null;\n+    }\n+\n+    private class SubtypeMap<T> {\n+        private volatile Map<String, List<Entry<T>>> index;\n+        private volatile Map<String, List<Entry<T>>> compositeIndex;\n+        private volatile Map<String, List<Entry<T>>> wildCompositeIndex;\n+        private volatile List<Entry<T>> wildcards;\n+        private volatile List<Entry<T>> all;\n+\n+        private SubtypeMap() {\n+            index = new HashMap<>();\n+            compositeIndex = new HashMap<>();\n+            wildCompositeIndex = new HashMap<>();\n+            wildcards = new ArrayList<>();\n+            all = new ArrayList<>();\n+        }\n+\n+        private SubtypeMap(final SubtypeMap<T> subtypeMap) {\n+            index = subtypeMap.index;\n+            compositeIndex = subtypeMap.compositeIndex;\n+            wildCompositeIndex = subtypeMap.wildCompositeIndex;\n+            wildcards = subtypeMap.wildcards;\n+            all = subtypeMap.all;\n+        }\n+\n+        private void add(Entry<T> entry) {\n+            final Matcher matcher = COMPOSITE_SUBTYPE_WILDCARD_PATTERN.matcher(entry.mediaType.getSubtype());\n+            final Matcher wildCompositeMatcher = WILD_SUBTYPE_COMPOSITE_PATTERN.matcher(entry.mediaType.getSubtype());\n+\n+            if (entry.mediaType.isWildcardSubtype()) {\n+                addWildcard(entry);\n+            } else if (matcher.matches()) {\n+                String baseSubType = matcher.group(1);\n+                addCompositeWild(entry, baseSubType);\n+            } else if (wildCompositeMatcher.matches()) {\n+                String base = wildCompositeMatcher.group(1);\n+                addWildComposite(entry, base);\n+            } else {\n+                addRegular(entry);\n+            }\n+        }\n+\n+        private void addRegular(Entry<T> entry) {\n+            Map<String, List<Entry<T>>> newIndex = index;\n+            if (lockSnapshots)\n+                newIndex = copy(index);\n+            add(newIndex, entry.mediaType.getSubtype(), entry);\n+            index = newIndex;\n+            merge(entry);\n+        }\n+\n+        private void addWildComposite(Entry<T> entry, String base) {\n+            Map<String, List<Entry<T>>> newWildCompositeIndex = wildCompositeIndex;\n+            if (lockSnapshots)\n+                newWildCompositeIndex = (wildCompositeIndex);\n+            add(newWildCompositeIndex, base, entry);\n+            wildCompositeIndex = newWildCompositeIndex;\n+            merge(entry);\n+        }\n+\n+        private void addCompositeWild(Entry<T> entry, String baseSubType) {\n+            Map<String, List<Entry<T>>> newCompositeIndex = compositeIndex;\n+            if (lockSnapshots)\n+                newCompositeIndex = copy(compositeIndex);\n+            add(newCompositeIndex, baseSubType, entry);\n+            compositeIndex = newCompositeIndex;\n+            merge(entry);\n+        }\n+\n+        private void addWildcard(Entry<T> entry) {\n+            if (lockSnapshots)\n+                wildcards = copyAndAdd(wildcards, entry);\n+            else\n+                wildcards.add(entry);\n+            merge(entry);\n+        }\n+\n+        private void merge(Entry<T> entry) {\n+            if (lockSnapshots) {\n+                all = copyAndAdd(all, entry);\n+            } else {\n+                all.add(entry);\n+            }\n+        }\n+\n+        private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) {\n+            final Map<String, List<Entry<T>>> copy = new HashMap<>(original.size());\n+            original.forEach((key, value) -> copy.put(key, new ArrayList<>(value)));\n+            return copy;\n+        }\n+\n+        private void add(final Map<String, List<Entry<T>>> map,\n+                final String key,\n+                final Entry<T> entry) {\n+            map.putIfAbsent(key, new CopyOnWriteArrayList<>());\n+            map.get(key).add(entry);\n+        }\n+\n+        private List<Entry<T>> getPossible(MediaType accept) {\n+            if (accept.isWildcardSubtype()) {\n+                return all;\n+            } else {\n+                List<Entry<T>> matches = new ArrayList<Entry<T>>();\n+\n+                List<Entry<T>> indexed = index.get(accept.getSubtype());\n+                if (indexed != null)\n+                    matches.addAll(indexed);\n+\n+                Matcher matcher = COMPOSITE_PATTERN.matcher(accept.getSubtype());\n+                String compositeKey = accept.getSubtype();\n+                if (matcher.matches()) {\n+                    String wildCompositeKey = matcher.group(1);\n+                    List<Entry<T>> windex = wildCompositeIndex.get(wildCompositeKey);\n+                    if (windex != null)\n+                        matches.addAll(windex);\n+                    compositeKey = matcher.group(2);\n+                }\n+                List<Entry<T>> indexed2 = compositeIndex.get(compositeKey);\n+                if (indexed2 != null)\n+                    matches.addAll(indexed2);\n+                matches.addAll(wildcards);\n+                return matches;\n+            }\n+        }\n+    }\n+\n+    static <A> List<A> copyAndAdd(List<A> a, A entry) {\n+        // reduce internal array copying\n+        ArrayList<A> newList = new ArrayList<A>(a.size() + 1);\n+        newList.add(entry);\n+        newList.addAll(0, a);\n+        return newList;\n+    }\n+\n+    private static class CachedMediaTypeAndClass {\n+        // we need a weak reference because of possible hot deployment\n+        // Although, these reference should get cleared up with any add() invocation\n+        private WeakReference<Class<?>> clazz;\n+        private MediaType mediaType;\n+        private final int hash;\n+\n+        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+        private CachedMediaTypeAndClass(final Class clazz, final MediaType mediaType) {\n+            this.clazz = new WeakReference(clazz);\n+            this.mediaType = mediaType;\n+            int result = clazz.hashCode();\n+            result = 31 * result + (mediaType.getType() != null ? mediaType.getType().hashCode() : 0)\n+                    + (mediaType.getSubtype() != null ? mediaType.getSubtype().hashCode() : 0);\n+            hash = result;\n+        }\n+\n+        private Class<?> getClazz() {\n+            return clazz.get();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o)\n+                return true;\n+            if (o == null || getClass() != o.getClass())\n+                return false;\n+\n+            CachedMediaTypeAndClass that = (CachedMediaTypeAndClass) o;\n+\n+            // WeakReference may have GC'd\n+            Class<?> clazz = getClazz();\n+            if (clazz == null || that.getClazz() == null)\n+                return false;\n+\n+            if (!clazz.equals(that.getClazz()))\n+                return false;\n+\n+            if (mediaType.getType() != null) {\n+                if (!mediaType.getType().equals(that.mediaType.getType()))\n+                    return false;\n+            } else if ((mediaType.getType() != that.mediaType.getType()))\n+                return false;\n+\n+            if (mediaType.getSubtype() != null) {\n+                if (!mediaType.getSubtype().equals(that.mediaType.getSubtype()))\n+                    return false;\n+            } else if ((mediaType.getSubtype() != that.mediaType.getSubtype()))\n+                return false;\n+\n+            return true;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+    private volatile Map<String, SubtypeMap<T>> index;\n+    private volatile Map<CachedMediaTypeAndClass, List<T>> classCache;\n+    private volatile List<Entry<T>> wildcards;\n+    private volatile List<Entry<T>> everything;\n+    private boolean lockSnapshots;\n+\n+    public MediaTypeMap() {\n+        index = new HashMap<>();\n+        wildcards = new ArrayList<>();\n+        everything = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Shallow copy, any additional adds will deep copy\n+     *\n+     * @param mediaTypeMap\n+     */\n+    public MediaTypeMap(final MediaTypeMap<T> mediaTypeMap) {\n+        lockSnapshots = true;\n+        index = mediaTypeMap.index;\n+        wildcards = mediaTypeMap.wildcards;\n+        everything = mediaTypeMap.everything;\n+        classCache = mediaTypeMap.classCache;\n+    }\n+\n+    /**\n+     * After this is called, all new adds will deep copy itself.\n+     *\n+     */\n+    public void lockSnapshots() {\n+        //if (!lockSnapshots) Collections.sort(everything);\n+        lockSnapshots = true;\n+    }\n+\n+    /**\n+     * Add an object to the media type map. This is synchronized to serialize adds.\n+     *\n+     * @param type media type\n+     * @param obj  object\n+     */\n+    public synchronized void add(final MediaType type, final T obj) {\n+        final MediaType newType = new MediaType(type.getType().toLowerCase(), type.getSubtype().toLowerCase(),\n+                type.getParameters());\n+        final Entry<T> entry = new Entry<>(newType, obj);\n+\n+        add(entry);\n+    }\n+\n+    /**\n+     * Add an object to the media type map. This is synchronized to serialize adds.\n+     *\n+     * @param mediaType media type\n+     * @param obj       object\n+     */\n+    public synchronized void add(String mediaType, final T obj) {\n+        final MediaType newType = MediaTypeHeaderDelegate.parse(mediaType.toLowerCase());\n+        final Entry<T> entry = new Entry<>(newType, obj);\n+        add(entry);\n+    }\n+\n+    public synchronized void addWildcard(final T obj) {\n+        final Entry<T> entry = new Entry<>(MediaType.WILDCARD_TYPE, obj);\n+        addWildcard(entry);\n+    }\n+\n+    protected void add(Entry<T> entry) {\n+        if (entry.mediaType.isWildcardType()) {\n+            addWildcard(entry);\n+        } else {\n+            Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+            newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+            newIndex.get(entry.mediaType.getType()).add(entry);\n+            index = newIndex;\n+            mergeEverything(entry);\n+        }\n+    }\n+\n+    private Map<String, SubtypeMap<T>> copyIndex() {\n+        Map<String, SubtypeMap<T>> newIndex = index;\n+        if (lockSnapshots) {\n+            Map<String, SubtypeMap<T>> finalIndex = new HashMap<>();\n+            newIndex = finalIndex;\n+            index.forEach((key, value) -> finalIndex.put(key, new SubtypeMap<>(value)));\n+        }\n+        return newIndex;\n+    }\n+\n+    private void addWildcard(Entry<T> entry) {\n+        if (lockSnapshots)\n+            wildcards = copyAndAdd(wildcards, entry);\n+        else\n+            wildcards.add(entry);\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addRegular(MediaType mediaType, T obj) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+        subtypeMap.addRegular(entry);\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addCompositeWild(MediaType mediaType, T obj, String baseSubtype) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+\n+        subtypeMap.addCompositeWild(entry, baseSubtype);\n+\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addWildComposite(MediaType mediaType, T obj, String baseSubtype) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+\n+        subtypeMap.addWildComposite(entry, baseSubtype);\n+\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    public synchronized void addWildSubtype(MediaType mediaType, T obj) {\n+        final Entry<T> entry = new Entry<>(mediaType, obj);\n+        Map<String, SubtypeMap<T>> newIndex = copyIndex();\n+        newIndex.putIfAbsent(entry.mediaType.getType(), new SubtypeMap<>());\n+        SubtypeMap<T> subtypeMap = newIndex.get(entry.mediaType.getType());\n+\n+        subtypeMap.addWildcard(entry);\n+\n+        index = newIndex;\n+        mergeEverything(entry);\n+    }\n+\n+    private void mergeEverything(Entry<T> entry) {\n+        List<Entry<T>> newAll = everything;\n+        if (lockSnapshots) {\n+            newAll = copyAndAdd(everything, entry);\n+            Collections.sort(newAll);\n+            everything = newAll;\n+        } else {\n+            everything.add(entry);\n+            Collections.sort(everything);\n+        }\n+        classCache = null;\n+    }\n+\n+    private static <T> List<T> convert(List<Entry<T>> list) {\n+        List<T> newList = new ArrayList<T>(list.size());\n+        for (Entry<T> entry : list) {\n+            newList.add(entry.object);\n+        }\n+        return newList;\n+\n+    }\n+\n+    /**\n+     * Returns a list of objects sorted based on their media type where the first in the list\n+     * is the best match\n+     *\n+     * @param accept mime to match\n+     * @return list of objects\n+     */\n+    public List<T> getPossible(MediaType accept) {\n+        accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n+        List<Entry<T>> matches = new ArrayList<Entry<T>>();\n+        if (accept.isWildcardType()) {\n+            return convert(everything);\n+        } else {\n+            SubtypeMap<T> indexed = index.get(accept.getType());\n+            if (indexed != null) {\n+                matches.addAll(indexed.getPossible(accept));\n+            }\n+            matches.addAll(wildcards);\n+        }\n+        Collections.sort(matches);\n+        return convert(matches);\n+    }\n+\n+    /**\n+     * By default, MediaTypeMap will cache possible MediaType/Class matches. Set this to false to turn off\n+     * caching\n+     *\n+     */\n+    public static boolean useCache = true;\n+\n+    public List<T> getPossible(MediaType accept, Class<?> type) {\n+        List<T> cached = null;\n+        CachedMediaTypeAndClass cacheEntry = null;\n+        if (useCache) {\n+            cacheEntry = new CachedMediaTypeAndClass(type, accept);\n+            if (classCache != null) {\n+                cached = classCache.get(cacheEntry);\n+                if (cached != null)\n+                    return cached;\n+            }\n+        }\n+\n+        accept = new MediaType(accept.getType().toLowerCase(), accept.getSubtype().toLowerCase(), accept.getParameters());\n+        List<Entry<T>> matches = new ArrayList<Entry<T>>();\n+        if (accept.isWildcardType()) {\n+            matches.addAll(everything);\n+        } else {\n+            SubtypeMap<T> indexed = index.get(accept.getType());\n+            if (indexed != null) {\n+                matches.addAll(indexed.getPossible(accept));\n+            }\n+            matches.addAll(wildcards);\n+        }\n+        Collections.sort(matches, new TypedEntryComparator(type));\n+        cached = convert(matches);\n+        if (useCache) {\n+            Map<CachedMediaTypeAndClass, List<T>> cache = classCache;\n+            if (cache == null) {\n+                synchronized (this) {\n+                    if (classCache == null) {\n+                        classCache = new HashMap<>();\n+                    }\n+                    cache = classCache;\n+                }\n+            }\n+            cache.put(cacheEntry, cached);\n+        }\n+        return cached;\n+\n+    }\n+\n+}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "fed55666e9ef5c6e7366912742331de4de3688f4", "message": "Merge commit", "committedDate": null}, {"oid": "1ba8cedf5ed7e30e1106ede5b622535b75fa3dd0", "committedDate": "2021-11-09 09:47:49 -0800", "message": "[RESTEASY-3007] Initial conversion for Jakarta REST 3.0"}, {"oid": "5d60f62c67eec6dbdf9ecd10db7473614750c35d", "committedDate": "2022-12-14 07:51:48 -0800", "message": "[RESTEASY-3264] Re-format all sources and resources."}]}, {"oid": "49e4c8f2f1bca480a1e696552081aa2275b86ece", "url": "https://github.com/resteasy/resteasy/commit/49e4c8f2f1bca480a1e696552081aa2275b86ece", "message": "[RESTEASY-2683] NPE in ApacheHttpClient43Test because cache is null in MediaTypeMap", "committedDate": "2020-09-01T12:27:33Z", "type": "commit"}, {"oid": "49e4c8f2f1bca480a1e696552081aa2275b86ece", "url": "https://github.com/resteasy/resteasy/commit/49e4c8f2f1bca480a1e696552081aa2275b86ece", "message": "[RESTEASY-2683] NPE in ApacheHttpClient43Test because cache is null in MediaTypeMap", "committedDate": "2020-09-01T12:27:33Z", "type": "forcePushed"}]}