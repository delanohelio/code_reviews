{"pr_number": 8293, "pr_title": "Added workflowExecutors for ApprovalWorkflowExecutor and two rest APIs.", "pr_createdAt": "2020-03-03T06:05:30Z", "pr_url": "https://github.com/wso2/carbon-apimgt/pull/8293", "merge_commit": "8f4619855f84b58847bd9b1bae181401f0a81961", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMjU5OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386822598", "body": "remove extra whitespace", "bodyText": "remove extra whitespace", "bodyHTML": "<p dir=\"auto\">remove extra whitespace</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T06:35:32Z", "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java", "diffHunk": "@@ -200,4 +201,9 @@ void updateMonetizationUsagePublishInfo(MonetizationUsagePublishInfo monetizatio\n      * @return Timestamp in long format\n      */\n     long getTimestamp(String date);\n+\n+    Workflow[] getworkflows(String workflowType, String status, String tenantDomain) throws APIManagementException;\n+\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java\nindex 2df63b3ebcd..13ec35859ae 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java\n", "chunk": "@@ -204,6 +204,5 @@ public interface APIAdmin  {\n \n     Workflow[] getworkflows(String workflowType, String status, String tenantDomain) throws APIManagementException;\n \n-\n     Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status, String tenantDomain) throws APIManagementException;\n }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java\nindex 13ec35859ae..3aba00877df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/APIAdmin.java\n", "chunk": "@@ -202,7 +202,26 @@ public interface APIAdmin  {\n      */\n     long getTimestamp(String date);\n \n+    /**\n+     * The method get all the pending workflow requests\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow[]\n+     * @throws APIManagementException\n+     */\n     Workflow[] getworkflows(String workflowType, String status, String tenantDomain) throws APIManagementException;\n \n-    Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status, String tenantDomain) throws APIManagementException;\n+    /**\n+     * The method get all the pending workflow requests\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow\n+     * @throws APIManagementException\n+     */\n+    Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status, String tenantDomain)\n+            throws APIManagementException;\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyNTc3MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386825770", "body": "format this section. { should be after () . need space between =", "bodyText": "format this section. { should be after () . need space between =", "bodyHTML": "<p dir=\"auto\">format this section. { should be after () . need space between =</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T06:47:12Z", "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.wso2.carbon.apimgt.api.model;\n+\n+import org.json.simple.JSONObject;\n+import org.wso2.carbon.apimgt.api.WorkflowStatus;\n+\n+public class Workflow {\n+\n+    private String workflowReference;\n+\n+    private String workflowType;\n+\n+    private WorkflowStatus status;\n+\n+    private String createdTime;\n+\n+    private String updatedTime;\n+\n+    private String workflowDescription;\n+\n+    private int tenantId;\n+\n+    private String tenantDomain;\n+\n+    private String externalWorkflowReference;\n+\n+    private String callbackUrl;\n+\n+    private int workflowId;\n+\n+    private String workflowStatusDesc;\n+\n+    private JSONObject metadata;\n+\n+    private JSONObject properties;\n+\n+    public Workflow()\n+    {\n+        metadata=new JSONObject();", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\nindex c6370dda62d..36dedcda1ef 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n", "chunk": "@@ -33,10 +33,9 @@ public class Workflow {\n \n     private JSONObject properties;\n \n-    public Workflow()\n-    {\n-        metadata=new JSONObject();\n-        properties=new JSONObject();\n+    public Workflow() {\n+        metadata = new JSONObject();\n+        properties = new JSONObject();\n     }\n \n     public String getWorkflowReference() {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyNzAwNg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386827006", "body": "format the method. lenght should be 120 characters ", "bodyText": "format the method. lenght should be 120 characters", "bodyHTML": "<p dir=\"auto\">format the method. lenght should be 120 characters</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T06:51:31Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java", "diffHunk": "@@ -349,4 +346,21 @@ private int isCategoryAttached(APICategory category, String username) throws API\n         int length = (Integer) result.get(\"length\");\n         return length;\n     }\n+\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n+\n+        return apiMgtDAO.getworkflows(workflowType, status , tenantDomain );\n+    }\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status, String tenantDomain) throws APIManagementException {\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5ODU1Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r387598557", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-03-04T11:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyNzAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\nindex 8ce9950a56b..9ddab09bfa4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n", "chunk": "@@ -352,7 +352,8 @@ public class APIAdminImpl implements APIAdmin {\n         return apiMgtDAO.getworkflows(workflowType, status , tenantDomain );\n     }\n \n-    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status, String tenantDomain) throws APIManagementException {\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status,\n+                                                                      String tenantDomain) throws APIManagementException {\n \n         Workflow workflow=apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef, status ,tenantDomain );\n \n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\nindex 9ddab09bfa4..bbaddc0a067 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n", "chunk": "@@ -347,21 +347,37 @@ public class APIAdminImpl implements APIAdmin {\n         return length;\n     }\n \n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow[]\n+     * @throws APIManagementException\n+     */\n     public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n-\n-        return apiMgtDAO.getworkflows(workflowType, status , tenantDomain );\n+        return apiMgtDAO.getworkflows(workflowType, status, tenantDomain);\n     }\n \n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow\n+     * @throws APIManagementException\n+     */\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status,\n                                                                       String tenantDomain) throws APIManagementException {\n \n         Workflow workflow=apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef, status ,tenantDomain );\n \n         if (workflow == null) {\n-            String msg=\"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n+            String msg = \"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n             throw new APIMgtResourceNotFoundException(msg);\n         }\n-\n         return workflow;\n     }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgzNDcwNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386834705", "body": "better to cast to string instead of using toString() . ", "bodyText": "better to cast to string instead of using toString() .", "bodyHTML": "<p dir=\"auto\">better to cast to string instead of using toString() .</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T07:17:43Z", "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.wso2.carbon.apimgt.api.model;\n+\n+import org.json.simple.JSONObject;\n+import org.wso2.carbon.apimgt.api.WorkflowStatus;\n+\n+public class Workflow {\n+\n+    private String workflowReference;\n+\n+    private String workflowType;\n+\n+    private WorkflowStatus status;\n+\n+    private String createdTime;\n+\n+    private String updatedTime;\n+\n+    private String workflowDescription;\n+\n+    private int tenantId;\n+\n+    private String tenantDomain;\n+\n+    private String externalWorkflowReference;\n+\n+    private String callbackUrl;\n+\n+    private int workflowId;\n+\n+    private String workflowStatusDesc;\n+\n+    private JSONObject metadata;\n+\n+    private JSONObject properties;\n+\n+    public Workflow()\n+    {\n+        metadata=new JSONObject();\n+        properties=new JSONObject();\n+    }\n+\n+    public String getWorkflowReference() {\n+        return workflowReference;\n+    }\n+\n+    public void setWorkflowReference(String workflowReference) {\n+        this.workflowReference = workflowReference;\n+    }\n+\n+    public String getWorkflowType() {\n+        return workflowType;\n+    }\n+\n+    public void setWorkflowType(String workflowType) {\n+        this.workflowType = workflowType;\n+    }\n+\n+    public WorkflowStatus getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(WorkflowStatus status) {\n+        this.status = status;\n+    }\n+\n+    public String getCreatedTime() {\n+        return createdTime;\n+    }\n+\n+    public void setCreatedTime(String createdTime) {\n+        this.createdTime = createdTime;\n+    }\n+\n+    public String getUpdatedTime() {\n+        return updatedTime;\n+    }\n+\n+    public void setUpdatedTime(String updatedTime) {\n+        this.updatedTime = updatedTime;\n+    }\n+\n+    public String getWorkflowDescription() {\n+        return workflowDescription;\n+    }\n+\n+    public void setWorkflowDescription(String workflowDescription) {\n+        this.workflowDescription = workflowDescription;\n+    }\n+\n+    public int getTenantId() {\n+        return tenantId;\n+    }\n+\n+    public void setTenantId(int tenantId) {\n+        this.tenantId = tenantId;\n+    }\n+\n+    public String getTenantDomain() {\n+        return tenantDomain;\n+    }\n+\n+    public void setTenantDomain(String tenantDomain) {\n+        this.tenantDomain = tenantDomain;\n+    }\n+\n+    public String getExternalWorkflowReference() {\n+        return externalWorkflowReference;\n+    }\n+\n+    public void setExternalWorkflowReference(String externalWorkflowReference) {\n+        this.externalWorkflowReference = externalWorkflowReference;\n+    }\n+\n+    public String getCallbackUrl() {\n+        return callbackUrl;\n+    }\n+\n+    public void setCallbackUrl(String callbackUrl) {\n+        this.callbackUrl = callbackUrl;\n+    }\n+\n+    public int getWorkflowId() {\n+        return workflowId;\n+    }\n+\n+    public void setWorkflowId(int workflowId) {\n+        this.workflowId = workflowId;\n+    }\n+\n+    public String getWorkflowStatusDesc() {\n+        return workflowStatusDesc;\n+    }\n+\n+    public void setWorkflowStatusDesc(String workflowStatusDesc) {\n+        this.workflowStatusDesc = workflowStatusDesc;\n+    }\n+\n+    public String getMetadata(String key) {\n+        return metadata.get(key).toString();\n+    }\n+\n+    public void setMetadata(String key, String value) {\n+        metadata.put(key, value);\n+    }\n+\n+    public String getProperties(String key) {\n+        return properties.get(key).toString();", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\nindex c6370dda62d..36dedcda1ef 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n", "chunk": "@@ -136,7 +135,7 @@ public class Workflow {\n     }\n \n     public String getMetadata(String key) {\n-        return metadata.get(key).toString();\n+        return (String)metadata.get(key);\n     }\n \n     public void setMetadata(String key, String value) {\n", "next_change": null}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\nindex c6370dda62d..36dedcda1ef 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n", "chunk": "@@ -144,7 +143,7 @@ public class Workflow {\n     }\n \n     public String getProperties(String key) {\n-        return properties.get(key).toString();\n+        return (String)properties.get(key);\n     }\n \n     public void setProperties(String key, String value) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgzNDgzNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386834835", "body": "better to cast to string instead of using toString() ", "bodyText": "better to cast to string instead of using toString()", "bodyHTML": "<p dir=\"auto\">better to cast to string instead of using toString()</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T07:18:09Z", "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.wso2.carbon.apimgt.api.model;\n+\n+import org.json.simple.JSONObject;\n+import org.wso2.carbon.apimgt.api.WorkflowStatus;\n+\n+public class Workflow {\n+\n+    private String workflowReference;\n+\n+    private String workflowType;\n+\n+    private WorkflowStatus status;\n+\n+    private String createdTime;\n+\n+    private String updatedTime;\n+\n+    private String workflowDescription;\n+\n+    private int tenantId;\n+\n+    private String tenantDomain;\n+\n+    private String externalWorkflowReference;\n+\n+    private String callbackUrl;\n+\n+    private int workflowId;\n+\n+    private String workflowStatusDesc;\n+\n+    private JSONObject metadata;\n+\n+    private JSONObject properties;\n+\n+    public Workflow()\n+    {\n+        metadata=new JSONObject();\n+        properties=new JSONObject();\n+    }\n+\n+    public String getWorkflowReference() {\n+        return workflowReference;\n+    }\n+\n+    public void setWorkflowReference(String workflowReference) {\n+        this.workflowReference = workflowReference;\n+    }\n+\n+    public String getWorkflowType() {\n+        return workflowType;\n+    }\n+\n+    public void setWorkflowType(String workflowType) {\n+        this.workflowType = workflowType;\n+    }\n+\n+    public WorkflowStatus getStatus() {\n+        return status;\n+    }\n+\n+    public void setStatus(WorkflowStatus status) {\n+        this.status = status;\n+    }\n+\n+    public String getCreatedTime() {\n+        return createdTime;\n+    }\n+\n+    public void setCreatedTime(String createdTime) {\n+        this.createdTime = createdTime;\n+    }\n+\n+    public String getUpdatedTime() {\n+        return updatedTime;\n+    }\n+\n+    public void setUpdatedTime(String updatedTime) {\n+        this.updatedTime = updatedTime;\n+    }\n+\n+    public String getWorkflowDescription() {\n+        return workflowDescription;\n+    }\n+\n+    public void setWorkflowDescription(String workflowDescription) {\n+        this.workflowDescription = workflowDescription;\n+    }\n+\n+    public int getTenantId() {\n+        return tenantId;\n+    }\n+\n+    public void setTenantId(int tenantId) {\n+        this.tenantId = tenantId;\n+    }\n+\n+    public String getTenantDomain() {\n+        return tenantDomain;\n+    }\n+\n+    public void setTenantDomain(String tenantDomain) {\n+        this.tenantDomain = tenantDomain;\n+    }\n+\n+    public String getExternalWorkflowReference() {\n+        return externalWorkflowReference;\n+    }\n+\n+    public void setExternalWorkflowReference(String externalWorkflowReference) {\n+        this.externalWorkflowReference = externalWorkflowReference;\n+    }\n+\n+    public String getCallbackUrl() {\n+        return callbackUrl;\n+    }\n+\n+    public void setCallbackUrl(String callbackUrl) {\n+        this.callbackUrl = callbackUrl;\n+    }\n+\n+    public int getWorkflowId() {\n+        return workflowId;\n+    }\n+\n+    public void setWorkflowId(int workflowId) {\n+        this.workflowId = workflowId;\n+    }\n+\n+    public String getWorkflowStatusDesc() {\n+        return workflowStatusDesc;\n+    }\n+\n+    public void setWorkflowStatusDesc(String workflowStatusDesc) {\n+        this.workflowStatusDesc = workflowStatusDesc;\n+    }\n+\n+    public String getMetadata(String key) {\n+        return metadata.get(key).toString();", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\nindex c6370dda62d..36dedcda1ef 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n", "chunk": "@@ -136,7 +135,7 @@ public class Workflow {\n     }\n \n     public String getMetadata(String key) {\n-        return metadata.get(key).toString();\n+        return (String)metadata.get(key);\n     }\n \n     public void setMetadata(String key, String value) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1NjgwOQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386856809", "body": "do a null check before converting to toJSONString(). otherwise if these properties are not set, NPE will be thrown", "bodyText": "do a null check before converting to toJSONString(). otherwise if these properties are not set, NPE will be thrown", "bodyHTML": "<p dir=\"auto\">do a null check before converting to toJSONString(). otherwise if these properties are not set, NPE will be thrown</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:17:36Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -5936,10 +5933,17 @@ public void addWorkflowEntry(WorkflowDTO workflow) throws APIManagementException\n             prepStmt.setString(7, workflow.getTenantDomain());\n             prepStmt.setString(8, workflow.getExternalWorkflowReference());\n \n+            byte[] byteData1 = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");\n+            byte[] byteData2 = workflow.getProperties().toJSONString().getBytes(\"UTF-8\");\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -5933,16 +5934,23 @@ public class ApiMgtDAO {\n             prepStmt.setString(7, workflow.getTenantDomain());\n             prepStmt.setString(8, workflow.getExternalWorkflowReference());\n \n-            byte[] byteData1 = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");\n-            byte[] byteData2 = workflow.getProperties().toJSONString().getBytes(\"UTF-8\");\n-\n-            prepStmt.setBlob(9, new ByteArrayInputStream(byteData1) );\n-            prepStmt.setBlob(10, new ByteArrayInputStream(byteData2) );\n+            if(workflow.getMetadata()!=null){\n+                byte[] metadataByte = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");\n+                prepStmt.setBlob(9, new ByteArrayInputStream(metadataByte) );\n+            } else {\n+                prepStmt.setNull(9, java.sql.Types.BLOB);\n+            }\n \n+            if(workflow.getProperties() != null) {\n+                byte[] propertiesByte = workflow.getProperties().toJSONString().getBytes(\"UTF-8\");\n+                prepStmt.setBlob(10, new ByteArrayInputStream(propertiesByte));\n+            } else {\n+                prepStmt.setNull(10, java.sql.Types.BLOB);\n+            }\n \n             prepStmt.execute();\n-\n             connection.commit();\n+\n         } catch (SQLException | UnsupportedEncodingException e) {\n             handleException(\"Error while adding Workflow : \" + workflow.getExternalWorkflowReference() + \" to the \" +\n                     \"database\", e);\n", "next_change": {"commit": "31f6f67b8a13bf657c46f4e2f9730d7b472c9b72", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..b2a7ba61a62 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -5934,24 +5934,10 @@ public class ApiMgtDAO {\n             prepStmt.setString(7, workflow.getTenantDomain());\n             prepStmt.setString(8, workflow.getExternalWorkflowReference());\n \n-            if(workflow.getMetadata()!=null){\n-                byte[] metadataByte = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");\n-                prepStmt.setBlob(9, new ByteArrayInputStream(metadataByte) );\n-            } else {\n-                prepStmt.setNull(9, java.sql.Types.BLOB);\n-            }\n-\n-            if(workflow.getProperties() != null) {\n-                byte[] propertiesByte = workflow.getProperties().toJSONString().getBytes(\"UTF-8\");\n-                prepStmt.setBlob(10, new ByteArrayInputStream(propertiesByte));\n-            } else {\n-                prepStmt.setNull(10, java.sql.Types.BLOB);\n-            }\n-\n             prepStmt.execute();\n-            connection.commit();\n \n-        } catch (SQLException | UnsupportedEncodingException e) {\n+            connection.commit();\n+        } catch (SQLException e) {\n             handleException(\"Error while adding Workflow : \" + workflow.getExternalWorkflowReference() + \" to the \" +\n                     \"database\", e);\n         } finally {\n", "next_change": {"commit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b2a7ba61a62..be9b41b3956 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -5934,10 +5934,24 @@ public class ApiMgtDAO {\n             prepStmt.setString(7, workflow.getTenantDomain());\n             prepStmt.setString(8, workflow.getExternalWorkflowReference());\n \n+            if(workflow.getMetadata()!=null){\n+                byte[] metadataByte = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");\n+                prepStmt.setBlob(9, new ByteArrayInputStream(metadataByte) );\n+            } else {\n+                prepStmt.setNull(9, java.sql.Types.BLOB);\n+            }\n+\n+            if(workflow.getProperties() != null) {\n+                byte[] propertiesByte = workflow.getProperties().toJSONString().getBytes(\"UTF-8\");\n+                prepStmt.setBlob(10, new ByteArrayInputStream(propertiesByte));\n+            } else {\n+                prepStmt.setNull(10, java.sql.Types.BLOB);\n+            }\n+\n             prepStmt.execute();\n \n             connection.commit();\n-        } catch (SQLException e) {\n+        } catch (SQLException | UnsupportedEncodingException e) {\n             handleException(\"Error while adding Workflow : \" + workflow.getExternalWorkflowReference() + \" to the \" +\n                     \"database\", e);\n         } finally {\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -5934,22 +5934,21 @@ public class ApiMgtDAO {\n             prepStmt.setString(7, workflow.getTenantDomain());\n             prepStmt.setString(8, workflow.getExternalWorkflowReference());\n \n-            if(workflow.getMetadata()!=null){\n+            if(workflow.getMetadata() != null) {\n                 byte[] metadataByte = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");\n                 prepStmt.setBlob(9, new ByteArrayInputStream(metadataByte) );\n             } else {\n-                prepStmt.setNull(9, java.sql.Types.BLOB);\n+                prepStmt.setBlob(9, (Blob)null);\n             }\n \n             if(workflow.getProperties() != null) {\n                 byte[] propertiesByte = workflow.getProperties().toJSONString().getBytes(\"UTF-8\");\n                 prepStmt.setBlob(10, new ByteArrayInputStream(propertiesByte));\n             } else {\n-                prepStmt.setNull(10, java.sql.Types.BLOB);\n+                //prepStmt.setNull(10, java.sql.Types.BLOB);\n+                prepStmt.setBlob(10, (Blob)null);\n             }\n-\n             prepStmt.execute();\n-\n             connection.commit();\n         } catch (SQLException | UnsupportedEncodingException e) {\n             handleException(\"Error while adding Workflow : \" + workflow.getExternalWorkflowReference() + \" to the \" +\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1Njk4MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386856981", "body": "add method description", "bodyText": "add method description", "bodyHTML": "<p dir=\"auto\">add method description</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:18:02Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5ODkxNA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r387598914", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-03-04T11:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1Njk4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "63aac0ce60d89723bf51b15c7f9f35b420b3e7cc", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..a6cb88653ec 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14580,6 +14586,35 @@ public class ApiMgtDAO {\n         }\n         return userID;\n     }\n+<<<<<<< HEAD\n+    \n+    /**\n+     * Get names of the tiers which has bandwidth as the quota type\n+     * @param tenantId id of the tenant\n+     * @return list of names\n+     * @throws APIManagementException\n+     */\n+    public List<String> getNamesOfTierWithBandwidthQuotaType(int tenantId) throws APIManagementException {\n+        Connection conn = null;\n+        ResultSet resultSet = null;\n+        PreparedStatement ps = null;\n+        List<String> list = new ArrayList<String>();\n+        try {\n+            String sqlQuery = ThrottleSQLConstants.GET_TIERS_WITH_BANDWIDTH_QUOTA_TYPE_SQL;\n+            conn = APIMgtDBUtil.getConnection();\n+            ps = conn.prepareStatement(sqlQuery);\n+            ps.setInt(1, tenantId);\n+            resultSet = ps.executeQuery();\n+            while (resultSet.next()) {\n+                list.add(resultSet.getString(1));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to retrieve tiers with bandwidth QuotaType \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n+        }\n+        return list;\n+=======\n \n \n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n", "next_change": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex a6cb88653ec..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14616,6 +14623,12 @@ public class ApiMgtDAO {\n         return list;\n =======\n \n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n \n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14621,70 +14619,59 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n         }\n         return list;\n-=======\n+    }\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex a6cb88653ec..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14623,11 +14636,9 @@ public class ApiMgtDAO {\n \n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n-\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n \n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14621,70 +14619,59 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n         }\n         return list;\n-=======\n+    }\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1NzEwMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386857100", "body": "remove unnecessary white space", "bodyText": "remove unnecessary white space", "bodyHTML": "<p dir=\"auto\">remove unnecessary white space</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:18:20Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14588,11 +14636,9 @@ public class ApiMgtDAO {\n \n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n-\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n \n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14621,70 +14619,59 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n         }\n         return list;\n-=======\n+    }\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1NzY1Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386857653", "body": "- format the method\r\n- add a self-explanatory method name (no idea what this EWR means)\r\n- add method description", "bodyText": "format the method\nadd a self-explanatory method name (no idea what this EWR means)\nadd method description", "bodyHTML": "<ul dir=\"auto\">\n<li>format the method</li>\n<li>add a self-explanatory method name (no idea what this EWR means)</li>\n<li>add method description</li>\n</ul>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:19:41Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5OTEzMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r387599133", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-03-04T11:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1NzY1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14600,17 +14646,22 @@ public class ApiMgtDAO {\n         }\n         catch (SQLException e) {\n             handleException(\"Failed to delete the workflow request \", e);\n-\n         }\n     }\n \n-    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n \n-\n         Workflow workflow=new Workflow();\n \n         String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14621,70 +14619,59 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n         }\n         return list;\n-=======\n+    }\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1Nzc4NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386857784", "body": "remove all unnecessary white spaces", "bodyText": "remove all unnecessary white spaces", "bodyHTML": "<p dir=\"auto\">remove all unnecessary white spaces</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:20:03Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14620,12 +14671,8 @@ public class ApiMgtDAO {\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n \n-\n             rs = prepStmt.executeQuery();\n \n-\n-\n-\n             while (rs.next()) {\n \n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14621,70 +14619,59 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n         }\n         return list;\n-=======\n+    }\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1ODI5Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386858293", "body": "remove whitespace and format", "bodyText": "remove whitespace and format", "bodyHTML": "<p dir=\"auto\">remove whitespace and format</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:21:18Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14698,15 +14747,11 @@ public class ApiMgtDAO {\n                 prepStmt.setString( 2, status);\n                 prepStmt.setString( 3, tenantDomain);\n \n-            }\n-            else{\n+            } else {\n                 prepStmt.setString( 1, status);\n                 prepStmt.setString( 2, tenantDomain);\n             }\n \n-\n-\n-\n             rs = prepStmt.executeQuery();\n \n             ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14746,12 +14727,10 @@ public class ApiMgtDAO {\n                 prepStmt.setString(1, workflowType);\n                 prepStmt.setString( 2, status);\n                 prepStmt.setString( 3, tenantDomain);\n-\n             } else {\n                 prepStmt.setString( 1, status);\n                 prepStmt.setString( 2, tenantDomain);\n             }\n-\n             rs = prepStmt.executeQuery();\n \n             ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1OTE4NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386859184", "body": "use a self descriptive variable names (ex: metadataBlob)", "bodyText": "use a self descriptive variable names (ex: metadataBlob)", "bodyHTML": "<p dir=\"auto\">use a self descriptive variable names (ex: metadataBlob)</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:23:31Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14728,38 +14773,35 @@ public class ApiMgtDAO {\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n+                byte[] metadataByte;\n \n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n                     workflow.setMetadata(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setMetadata(json);\n                 }\n \n-                byte[] byteData1;\n+                byte[] propertiesByte;\n \n-                if(blob1 != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n                     workflow.setProperties(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setProperties(json);\n                 }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14777,40 +14753,35 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setProperties(json);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n                 workflowsList.add(workflow);\n             }\n             workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n         } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details\" , e);\n+            handleException(\"Error when retrieve all the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1OTM3Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386859377", "body": "same here", "bodyText": "same here", "bodyHTML": "<p dir=\"auto\">same here</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:23:59Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14728,38 +14773,35 @@ public class ApiMgtDAO {\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n+                byte[] metadataByte;\n \n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n                     workflow.setMetadata(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setMetadata(json);\n                 }\n \n-                byte[] byteData1;\n+                byte[] propertiesByte;\n \n-                if(blob1 != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n                     workflow.setProperties(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setProperties(json);\n                 }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14777,40 +14753,35 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setProperties(json);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n                 workflowsList.add(workflow);\n             }\n             workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n         } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details\" , e);\n+            handleException(\"Error when retrieve all the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1OTUzNw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386859537", "body": "add meaningful variable name", "bodyText": "add meaningful variable name", "bodyHTML": "<p dir=\"auto\">add meaningful variable name</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:24:25Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14728,38 +14773,35 @@ public class ApiMgtDAO {\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n+                byte[] metadataByte;\n \n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n                     workflow.setMetadata(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setMetadata(json);\n                 }\n \n-                byte[] byteData1;\n+                byte[] propertiesByte;\n \n-                if(blob1 != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n                     workflow.setProperties(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setProperties(json);\n                 }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14777,40 +14753,35 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setProperties(json);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n                 workflowsList.add(workflow);\n             }\n             workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n         } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details\" , e);\n+            handleException(\"Error when retrieve all the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1OTU5OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386859599", "body": "add meaningful variable name", "bodyText": "add meaningful variable name", "bodyHTML": "<p dir=\"auto\">add meaningful variable name</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:24:36Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] byteData1;", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14728,38 +14773,35 @@ public class ApiMgtDAO {\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n+                byte[] metadataByte;\n \n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n                     workflow.setMetadata(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setMetadata(json);\n                 }\n \n-                byte[] byteData1;\n+                byte[] propertiesByte;\n \n-                if(blob1 != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n                     workflow.setProperties(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setProperties(json);\n                 }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14777,40 +14753,35 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setProperties(json);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n                 workflowsList.add(workflow);\n             }\n             workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n         } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details\" , e);\n+            handleException(\"Error when retrieve all the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1OTg2NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386859865", "body": "add meaningful variable name", "bodyText": "add meaningful variable name", "bodyHTML": "<p dir=\"auto\">add meaningful variable name</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:25:09Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] byteData1;\n+\n+                if(blob1 != null) {\n+                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n+                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                    Gson g = new Gson();", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14728,38 +14773,35 @@ public class ApiMgtDAO {\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n+                byte[] metadataByte;\n \n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n                     workflow.setMetadata(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setMetadata(json);\n                 }\n \n-                byte[] byteData1;\n+                byte[] propertiesByte;\n \n-                if(blob1 != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n                     workflow.setProperties(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setProperties(json);\n                 }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14777,40 +14753,35 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setProperties(json);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n                 workflowsList.add(workflow);\n             }\n             workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n         } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details\" , e);\n+            handleException(\"Error when retrieve all the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1OTkyMg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386859922", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:25:16Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] byteData1;\n+\n+                if(blob1 != null) {\n+                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n+                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    workflow.setProperties(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14728,38 +14773,35 @@ public class ApiMgtDAO {\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n+                byte[] metadataByte;\n \n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n                     workflow.setMetadata(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setMetadata(json);\n                 }\n \n-                byte[] byteData1;\n+                byte[] propertiesByte;\n \n-                if(blob1 != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n                     workflow.setProperties(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json = new JSONObject();\n                     workflow.setProperties(json);\n                 }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14777,40 +14753,35 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json = new JSONObject();\n-                    workflow.setProperties(json);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n                 workflowsList.add(workflow);\n             }\n             workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n         } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details\" , e);\n+            handleException(\"Error when retrieve all the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MDE4Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386860183", "body": "- format\r\n-add method description", "bodyText": "format\n-add method description", "bodyHTML": "<ul dir=\"auto\">\n<li>format<br>\n-add method description</li>\n</ul>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:25:51Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] byteData1;\n+\n+                if(blob1 != null) {\n+                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n+                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    workflow.setProperties(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);\n+                }\n+\n+                workflowsList.add(workflow);\n+            }\n+            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n+        } catch (SQLException e) {\n+            handleException(\"Error when retrieve all the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflows;\n+\n+    }\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status , String tenantDomain) throws APIManagementException {\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MTE0Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410791143", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-04-19T01:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MDE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14773,10 +14815,19 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflows;\n-\n     }\n \n-    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status , String tenantDomain) throws APIManagementException {\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n+                                                                      String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14819,45 +14790,35 @@ public class ApiMgtDAO {\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n-     *\n-     * @param externelWorkflowRef\n-     * @param status\n-     * @param tenantDomain\n-     * @return\n+     * @param externelWorkflowRef of pending workflow request\n+     * @param status workflow status of workflow pending process\n+     * @param tenantDomain tenant domain of user\n+     * @return workflow pending request\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n                                                                       String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n+        Workflow workflow = new Workflow();\n         String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n-\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externelWorkflowRef);\n             prepStmt.setString(2, status);\n             prepStmt.setString(3, tenantDomain);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n-                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                String workflowstatus = rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "8f4619855f84b58847bd9b1bae181401f0a81961", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14716,145 +14740,120 @@ public class ApiMgtDAO {\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n-                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                String workflowstatus = rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n-\n-\n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n-                    workflow.setMetadata(json);\n-                }\n-                else{\n-                    JSONObject json = new JSONObject();\n-                    workflow.setMetadata(json);\n-                }\n-\n-                byte[] byteData1;\n-\n-                if(blob1 != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(data1, JSONObject.class);\n-                    workflow.setProperties(json);\n-                }\n-                else{\n-                    JSONObject json = new JSONObject();\n-                    workflow.setProperties(json);\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n+\n+                byte[] metadataByte;\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n+                } else {\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n+                }\n+\n+                byte[] propertiesByte;\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n+                } else {\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n                 workflowsList.add(workflow);\n             }\n             workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n         } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details\" , e);\n+            handleException(\"Error when retrieve all the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflows;\n-\n     }\n \n-    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status , String tenantDomain) throws APIManagementException {\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n+     * @param externelWorkflowRef of pending workflow request\n+     * @param status workflow status of workflow pending process\n+     * @param tenantDomain tenant domain of user\n+     * @return workflow pending request\n+     */\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n+                                                                      String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAIL_REFER_BY_EXTERNALWORKFLOWREFERENCE;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externelWorkflowRef);\n             prepStmt.setString(2, status);\n             prepStmt.setString(3, tenantDomain);\n-\n-\n             rs = prepStmt.executeQuery();\n \n-\n-\n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n-                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                String workflowstatus = rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n-\n-                byte[] byteData;\n-\n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n-                    workflow.setMetadata(json);\n-                }\n-                else{\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n-                }\n-\n-                byte[] byteData1;\n-\n-                if(blob != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json1 = g.fromJson(data1, JSONObject.class);\n-                    workflow.setProperties(json1);\n-                }\n-                else{\n-                    JSONObject json1=new JSONObject();\n-                    workflow.setProperties(json1);\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n+\n+                byte[] metadataByte;\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n+                } else {\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n+                }\n+\n+                byte[] propertiesByte;\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n+                } else {\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n-\n-\n-\n             }\n-\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \", e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": {"commit": "c7d3d00674fe6a5b9062190d1bcdfdfca6fcd723", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex c19a17b31df..673415b302f 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14400,463 +14249,4 @@ public class ApiMgtDAO {\n             handleException(\"Error while deleting expired JWTs from revoke table.\", e);\n         }\n     }\n-\n-    /**\n-     * Adds an API category\n-     *\n-     * @param tenantID     Logged in user's tenant ID\n-     * @param category     Category\n-     * @return Category\n-     */\n-    public APICategory addCategory(int tenantID, APICategory category) throws APIManagementException {\n-        String uuid = UUID.randomUUID().toString();\n-        category.setId(uuid);\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-            PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_CATEGORY_SQL)) {\n-            statement.setString(1, uuid);\n-            statement.setString(2, category.getName());\n-            statement.setString(3, category.getDescription());\n-            statement.setInt(4, tenantID);\n-            statement.executeUpdate();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add Category: \" + uuid, e);\n-        }\n-        return category;\n-    }\n-\n-    /**\n-     * Update API Category\n-     *\n-     * @param apiCategory API category object with updated details\n-     * @throws APIManagementException\n-     */\n-    public void updateCategory(APICategory apiCategory) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_CATEGORY)) {\n-            statement.setString(1, apiCategory.getDescription());\n-            statement.setString(2, apiCategory.getName());\n-            statement.setString(3, apiCategory.getId());\n-            statement.execute();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to update API Category : \" + apiCategory.getName() + \" of tenant \" +\n-                    APIUtil.getTenantDomainFromTenantId(apiCategory.getTenantID()), e);\n-        }\n-    }\n-\n-    /**\n-     * Get all available API categories of the tenant\n-     *\n-     * @param tenantID\n-     * @return API Categories List\n-     */\n-    public List<APICategory> getAllCategories(int tenantID) throws APIManagementException {\n-        List<APICategory> categoriesList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-            PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_CATEGORIES_BY_TENANT_ID_SQL)) {\n-            statement.setInt(1, tenantID);\n-\n-            ResultSet rs = statement.executeQuery();\n-            while(rs.next()) {\n-                String id = rs.getString(\"UUID\");\n-                String name = rs.getString(\"NAME\");\n-                String description = rs.getString(\"DESCRIPTION\");\n-\n-                APICategory category = new APICategory();\n-                category.setId(id);\n-                category.setName(name);\n-                category.setDescription(description);\n-                category.setTenantID(tenantID);\n-\n-                categoriesList.add(category);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to retrieve API categories for tenant \" + tenantID, e);\n-        }\n-        return categoriesList;\n-    }\n-\n-    /**\n-     * Checks whether the given category name is already available under given tenant domain with any UUID other than the given UUID\n-     *\n-     * @param categoryName\n-     * @param uuid\n-     * @param tenantID\n-     * @return\n-     */\n-    public boolean isAPICategoryNameExists(String categoryName, String uuid, int tenantID) throws APIManagementException {\n-        String sql = SQLConstants.IS_API_CATEGORY_NAME_EXISTS;\n-        if (uuid != null) {\n-            sql = SQLConstants.IS_API_CATEGORY_NAME_EXISTS_FOR_ANOTHER_UUID;\n-        }\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(sql)) {\n-            statement.setString(1, categoryName);\n-            statement.setInt(2, tenantID);\n-            if (uuid != null) {\n-                statement.setString(3, uuid);\n-            }\n-\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                int count = rs.getInt(\"API_CATEGORY_COUNT\");\n-                if (count > 0) {\n-                    return true;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check whether API category name : \" + categoryName + \" exists\", e);\n-        }\n-        return false;\n-    }\n-\n-\n-    public APICategory getAPICategoryByID(String apiCategoryID) throws APIManagementException {\n-        APICategory apiCategory = null;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-            PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_CATEGORY_BY_ID)) {\n-            statement.setString(1, apiCategoryID);\n-\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                apiCategory = new APICategory();\n-                apiCategory.setName(rs.getString(\"NAME\"));\n-                apiCategory.setDescription(rs.getString(\"DESCRIPTION\"));\n-                apiCategory.setTenantID(rs.getInt(\"TENANT_ID\"));\n-                apiCategory.setId(apiCategoryID);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to fetch API category : \" + apiCategoryID, e);\n-        }\n-        return apiCategory;\n-    }\n-\n-    public APICategory getAPICategoryByName(String apiCategoryName, String tenantDomain) throws APIManagementException {\n-        APICategory apiCategory = null;\n-        int tenantID = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_CATEGORY_BY_NAME)) {\n-            statement.setString(1, apiCategoryName);\n-            statement.setInt(2, tenantID);\n-\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                apiCategory = new APICategory();\n-                apiCategory.setName(rs.getString(\"NAME\"));\n-                apiCategory.setDescription(rs.getString(\"DESCRIPTION\"));\n-                apiCategory.setTenantID(rs.getInt(\"TENANT_ID\"));\n-                apiCategory.setId(rs.getString(\"UUID\"));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to fetch API category : \" + apiCategoryName + \" of tenant \" + tenantDomain, e);\n-        }\n-        return apiCategory;\n-    }\n-\n-    public void deleteCategory(String categoryID) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_CATEGORY)) {\n-            statement.setString(1, categoryID);\n-            statement.executeUpdate();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API category : \" + categoryID, e);\n-        }\n-    }\n-\n-    public String addUserID(String userID, String userName) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_USER_ID)) {\n-            statement.setString(1, userID);\n-            statement.setString(2, userName);\n-            statement.executeUpdate();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add userID for \" + userName , e);\n-        }\n-        return userID;\n-    }\n-\n-    public String getUserID(String userName) throws APIManagementException {\n-        String userID = null;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_USER_ID)) {\n-            statement.setString(1, userName);\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                userID = rs.getString(\"USER_ID\");\n-            }\n-            if (userID == null) {\n-                userID = UUID.randomUUID().toString();\n-                addUserID(userID, userName);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to fetch user ID for \" + userName , e);\n-        }\n-        return userID;\n-    }\n-    \n-    /**\n-     * Get names of the tiers which has bandwidth as the quota type\n-     * @param tenantId id of the tenant\n-     * @return list of names\n-     * @throws APIManagementException\n-     */\n-    public List<String> getNamesOfTierWithBandwidthQuotaType(int tenantId) throws APIManagementException {\n-        Connection conn = null;\n-        ResultSet resultSet = null;\n-        PreparedStatement ps = null;\n-        List<String> list = new ArrayList<String>();\n-        try {\n-            String sqlQuery = ThrottleSQLConstants.GET_TIERS_WITH_BANDWIDTH_QUOTA_TYPE_SQL;\n-            conn = APIMgtDBUtil.getConnection();\n-            ps = conn.prepareStatement(sqlQuery);\n-            ps.setInt(1, tenantId);\n-            resultSet = ps.executeQuery();\n-            while (resultSet.next()) {\n-                list.add(resultSet.getString(1));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to retrieve tiers with bandwidth QuotaType \", e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n-     * @throws APIManagementException\n-     */\n-    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n-        Connection connection = null;\n-        PreparedStatement prepStmt = null;\n-        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n-        try {\n-            connection = APIMgtDBUtil.getConnection();\n-            connection.setAutoCommit(false);\n-            prepStmt = connection.prepareStatement(query);\n-            prepStmt.setString(1, workflowExtRef);\n-            prepStmt.executeUpdate();\n-            connection.commit();\n-        }\n-        catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request. \", e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n-        }\n-    }\n-\n-    /**\n-     * Get the Pending workflow Request using ExternalWorkflowReference\n-     * @param externalWorkflowRef\n-     * @return workflow pending request\n-     * @throws APIManagementException\n-     */\n-    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n-\n-        Connection connection = null;\n-        PreparedStatement prepStmt = null;\n-        ResultSet rs = null;\n-        Workflow workflow = new Workflow();\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n-        try {\n-            connection = APIMgtDBUtil.getConnection();\n-            prepStmt = connection.prepareStatement(sqlQuery);\n-            prepStmt.setString(1, externalWorkflowRef);\n-            rs = prepStmt.executeQuery();\n-\n-            while (rs.next()) {\n-                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n-                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n-                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-                String workflowstatus =rs.getString(\"WF_STATUS\");\n-                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n-                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n-                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n-                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n-                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n-                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n-\n-                byte[] metadataByte;\n-                if(metadatablob != null) {\n-                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n-                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson metadataGson = new Gson();\n-                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(metadataJson);\n-                } else {\n-                    JSONObject metadataJson = new JSONObject();\n-                    workflow.setMetadata(metadataJson);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details. \" , e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n-        }\n-        return workflow;\n-    }\n-\n-    /**\n-     * Get the Pending workflow Requests using WorkflowType for a particular tenant\n-     * @param workflowType Type of the workflow pending request\n-     * @param status workflow status of workflow pending request\n-     * @param tenantDomain tenantDomain of the user\n-     * @return List of workflow pending request\n-     * @throws APIManagementException\n-     */\n-    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain) throws APIManagementException {\n-\n-        Connection connection = null;\n-        PreparedStatement prepStmt = null;\n-        ResultSet rs = null;\n-        Workflow[] workflows = null;\n-        String sqlQuery;\n-        if (workflowType != null) {\n-            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE;\n-        } else {\n-            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n-        }\n-        try {\n-            connection = APIMgtDBUtil.getConnection();\n-            prepStmt = connection.prepareStatement(sqlQuery);\n-\n-            if (workflowType != null){\n-                prepStmt.setString(1, workflowType);\n-                prepStmt.setString( 2, status);\n-                prepStmt.setString( 3, tenantDomain);\n-            } else {\n-                prepStmt.setString( 1, status);\n-                prepStmt.setString( 2, tenantDomain);\n-            }\n-            rs = prepStmt.executeQuery();\n-\n-            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n-            Workflow workflow;\n-            while (rs.next()) {\n-                workflow = new Workflow();\n-                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n-                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n-                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-                String workflowstatus = rs.getString(\"WF_STATUS\");\n-                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n-                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n-                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n-                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n-                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n-                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n-                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n-\n-                byte[] metadataByte;\n-                if(metadataBlob != null) {\n-                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n-                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson metadataGson = new Gson();\n-                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(metadataJson);\n-                } else {\n-                    JSONObject metadataJson = new JSONObject();\n-                    workflow.setMetadata(metadataJson);\n-                }\n-\n-                byte[] propertiesByte;\n-                if(propertiesBlob != null) {\n-                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n-                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n-                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson propertiesGson = new Gson();\n-                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(propertiesJson);\n-                } else {\n-                    JSONObject propertiesJson = new JSONObject();\n-                    workflow.setProperties(propertiesJson);\n-                }\n-                workflowsList.add(workflow);\n-            }\n-            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n-        } catch (SQLException e) {\n-            handleException(\"Error when retrieve all the workflow details. \" , e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n-        }\n-        return workflows;\n-    }\n-\n-    /**\n-     * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n-     * @param externelWorkflowRef of pending workflow request\n-     * @param status workflow status of workflow pending process\n-     * @param tenantDomain tenant domain of user\n-     * @return workflow pending request\n-     */\n-    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n-                                                                      String tenantDomain) throws APIManagementException {\n-\n-        Connection connection = null;\n-        PreparedStatement prepStmt = null;\n-        ResultSet rs = null;\n-        Workflow workflow = new Workflow();\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n-        try {\n-            connection = APIMgtDBUtil.getConnection();\n-            prepStmt = connection.prepareStatement(sqlQuery);\n-            prepStmt.setString(1, externelWorkflowRef);\n-            prepStmt.setString(2, status);\n-            prepStmt.setString(3, tenantDomain);\n-            rs = prepStmt.executeQuery();\n-\n-            while (rs.next()) {\n-                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n-                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n-                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-                String workflowstatus = rs.getString(\"WF_STATUS\");\n-                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n-                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n-                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n-                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n-                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n-                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n-                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n-\n-                byte[] metadataByte;\n-                if(metadataBlob != null) {\n-                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n-                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson metadataGson = new Gson();\n-                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(metadataJson);\n-                } else {\n-                    JSONObject metadataJson = new JSONObject();\n-                    workflow.setMetadata(metadataJson);\n-                }\n-\n-                byte[] propertiesByte;\n-                if(propertiesBlob != null) {\n-                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n-                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n-                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson propertiesGson = new Gson();\n-                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(propertiesJson);\n-                } else {\n-                    JSONObject propertiesJson = new JSONObject();\n-                    workflow.setProperties(propertiesJson);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details. \", e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n-        }\n-        return workflow;\n-    }\n }\n", "next_change": {"commit": "e4447a376c42fee44e49de2a244512a8ae9ef6ef", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 673415b302f..1e166ba2556 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14249,4 +14900,166 @@ public class ApiMgtDAO {\n             handleException(\"Error while deleting expired JWTs from revoke table.\", e);\n         }\n     }\n+\n+    /**\n+     * Adds an API category\n+     *\n+     * @param tenantID     Logged in user's tenant ID\n+     * @param category     Category\n+     * @return Category\n+     */\n+    public APICategory addCategory(int tenantID, APICategory category) throws APIManagementException {\n+        String uuid = UUID.randomUUID().toString();\n+        category.setId(uuid);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_CATEGORY_SQL)) {\n+            statement.setString(1, uuid);\n+            statement.setString(2, category.getName());\n+            statement.setString(3, category.getDescription());\n+            statement.setInt(4, tenantID);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add Category: \" + uuid, e);\n+        }\n+        return category;\n+    }\n+\n+    /**\n+     * Update API Category\n+     *\n+     * @param apiCategory API category object with updated details\n+     * @throws APIManagementException\n+     */\n+    public void updateCategory(APICategory apiCategory) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_CATEGORY)) {\n+            statement.setString(1, apiCategory.getDescription());\n+            statement.setString(2, apiCategory.getName());\n+            statement.setString(3, apiCategory.getId());\n+            statement.execute();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to update API Category : \" + apiCategory.getName() + \" of tenant \" +\n+                    APIUtil.getTenantDomainFromTenantId(apiCategory.getTenantID()), e);\n+        }\n+    }\n+\n+    /**\n+     * Get all available API categories of the tenant\n+     *\n+     * @param tenantID\n+     * @return API Categories List\n+     */\n+    public List<APICategory> getAllCategories(int tenantID) throws APIManagementException {\n+        List<APICategory> categoriesList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_CATEGORIES_BY_TENANT_ID_SQL)) {\n+            statement.setInt(1, tenantID);\n+\n+            ResultSet rs = statement.executeQuery();\n+            while(rs.next()) {\n+                String id = rs.getString(\"UUID\");\n+                String name = rs.getString(\"NAME\");\n+                String description = rs.getString(\"DESCRIPTION\");\n+\n+                APICategory category = new APICategory();\n+                category.setId(id);\n+                category.setName(name);\n+                category.setDescription(description);\n+                category.setTenantID(tenantID);\n+\n+                categoriesList.add(category);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to retrieve API categories for tenant \" + tenantID, e);\n+        }\n+        return categoriesList;\n+    }\n+\n+    /**\n+     * Checks whether the given category name is already available under given tenant domain with any UUID other than the given UUID\n+     *\n+     * @param categoryName\n+     * @param uuid\n+     * @param tenantID\n+     * @return\n+     */\n+    public boolean isAPICategoryNameExists(String categoryName, String uuid, int tenantID) throws APIManagementException {\n+        String sql = SQLConstants.IS_API_CATEGORY_NAME_EXISTS;\n+        if (uuid != null) {\n+            sql = SQLConstants.IS_API_CATEGORY_NAME_EXISTS_FOR_ANOTHER_UUID;\n+        }\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(sql)) {\n+            statement.setString(1, categoryName);\n+            statement.setInt(2, tenantID);\n+            if (uuid != null) {\n+                statement.setString(3, uuid);\n+            }\n+\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                int count = rs.getInt(\"API_CATEGORY_COUNT\");\n+                if (count > 0) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check whether API category name : \" + categoryName + \" exists\", e);\n+        }\n+        return false;\n+    }\n+\n+\n+    public APICategory getAPICategoryByID(String apiCategoryID) throws APIManagementException {\n+        APICategory apiCategory = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_CATEGORY_BY_ID)) {\n+            statement.setString(1, apiCategoryID);\n+\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                apiCategory = new APICategory();\n+                apiCategory.setName(rs.getString(\"NAME\"));\n+                apiCategory.setDescription(rs.getString(\"DESCRIPTION\"));\n+                apiCategory.setTenantID(rs.getInt(\"TENANT_ID\"));\n+                apiCategory.setId(apiCategoryID);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to fetch API category : \" + apiCategoryID, e);\n+        }\n+        return apiCategory;\n+    }\n+\n+    public APICategory getAPICategoryByName(String apiCategoryName, String tenantDomain) throws APIManagementException {\n+        APICategory apiCategory = null;\n+        int tenantID = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_CATEGORY_BY_NAME)) {\n+            statement.setString(1, apiCategoryName);\n+            statement.setInt(2, tenantID);\n+\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                apiCategory = new APICategory();\n+                apiCategory.setName(rs.getString(\"NAME\"));\n+                apiCategory.setDescription(rs.getString(\"DESCRIPTION\"));\n+                apiCategory.setTenantID(rs.getInt(\"TENANT_ID\"));\n+                apiCategory.setId(rs.getString(\"UUID\"));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to fetch API category : \" + apiCategoryName + \" of tenant \" + tenantDomain, e);\n+        }\n+        return apiCategory;\n+    }\n+\n+    public void deleteCategory(String categoryID) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_CATEGORY)) {\n+            statement.setString(1, categoryID);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API category : \" + categoryID, e);\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "ab0e0792d4705f3b680580f2a282c7c338d1518c", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 1e166ba2556..6f14f7d164e 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15062,4 +14552,62 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    public String addUserID(String userID, String userName) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_USER_ID)) {\n+            statement.setString(1, userID);\n+            statement.setString(2, userName);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add userID for \" + userName , e);\n+        }\n+        return userID;\n+    }\n+\n+    public String getUserID(String userName) throws APIManagementException {\n+        String userID = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_USER_ID)) {\n+            statement.setString(1, userName);\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                userID = rs.getString(\"USER_ID\");\n+            }\n+            if (userID == null) {\n+                userID = UUID.randomUUID().toString();\n+                addUserID(userID, userName);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to fetch user ID for \" + userName , e);\n+        }\n+        return userID;\n+    }\n+    \n+    /**\n+     * Get names of the tiers which has bandwidth as the quota type\n+     * @param tenantId id of the tenant\n+     * @return list of names\n+     * @throws APIManagementException\n+     */\n+    public List<String> getNamesOfTierWithBandwidthQuotaType(int tenantId) throws APIManagementException {\n+        Connection conn = null;\n+        ResultSet resultSet = null;\n+        PreparedStatement ps = null;\n+        List<String> list = new ArrayList<String>();\n+        try {\n+            String sqlQuery = ThrottleSQLConstants.GET_TIERS_WITH_BANDWIDTH_QUOTA_TYPE_SQL;\n+            conn = APIMgtDBUtil.getConnection();\n+            ps = conn.prepareStatement(sqlQuery);\n+            ps.setInt(1, tenantId);\n+            resultSet = ps.executeQuery();\n+            while (resultSet.next()) {\n+                list.add(resultSet.getString(1));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to retrieve tiers with bandwidth QuotaType \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n+        }\n+        return list;\n+    }\n }\n", "next_change": {"commit": "c472ea9a5f94f1f5fffd4533274fb9f40b42596c", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 6f14f7d164e..4d5a3f53681 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14552,62 +14919,4 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    public String addUserID(String userID, String userName) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_USER_ID)) {\n-            statement.setString(1, userID);\n-            statement.setString(2, userName);\n-            statement.executeUpdate();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add userID for \" + userName , e);\n-        }\n-        return userID;\n-    }\n-\n-    public String getUserID(String userName) throws APIManagementException {\n-        String userID = null;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_USER_ID)) {\n-            statement.setString(1, userName);\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                userID = rs.getString(\"USER_ID\");\n-            }\n-            if (userID == null) {\n-                userID = UUID.randomUUID().toString();\n-                addUserID(userID, userName);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to fetch user ID for \" + userName , e);\n-        }\n-        return userID;\n-    }\n-    \n-    /**\n-     * Get names of the tiers which has bandwidth as the quota type\n-     * @param tenantId id of the tenant\n-     * @return list of names\n-     * @throws APIManagementException\n-     */\n-    public List<String> getNamesOfTierWithBandwidthQuotaType(int tenantId) throws APIManagementException {\n-        Connection conn = null;\n-        ResultSet resultSet = null;\n-        PreparedStatement ps = null;\n-        List<String> list = new ArrayList<String>();\n-        try {\n-            String sqlQuery = ThrottleSQLConstants.GET_TIERS_WITH_BANDWIDTH_QUOTA_TYPE_SQL;\n-            conn = APIMgtDBUtil.getConnection();\n-            ps = conn.prepareStatement(sqlQuery);\n-            ps.setInt(1, tenantId);\n-            resultSet = ps.executeQuery();\n-            while (resultSet.next()) {\n-                list.add(resultSet.getString(1));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to retrieve tiers with bandwidth QuotaType \", e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n-        }\n-        return list;\n-    }\n }\n", "next_change": {"commit": "23c93a808b75c28e5bf577b0e0c83803c5db055b", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 4d5a3f53681..f35b0bf9bfa 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14919,4 +14939,62 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    public String addUserID(String userID, String userName) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_USER_ID)) {\n+            statement.setString(1, userID);\n+            statement.setString(2, userName);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add userID for \" + userName , e);\n+        }\n+        return userID;\n+    }\n+\n+    public String getUserID(String userName) throws APIManagementException {\n+        String userID = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_USER_ID)) {\n+            statement.setString(1, userName);\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                userID = rs.getString(\"USER_ID\");\n+            }\n+            if (userID == null) {\n+                userID = UUID.randomUUID().toString();\n+                addUserID(userID, userName);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to fetch user ID for \" + userName , e);\n+        }\n+        return userID;\n+    }\n+    \n+    /**\n+     * Get names of the tiers which has bandwidth as the quota type\n+     * @param tenantId id of the tenant\n+     * @return list of names\n+     * @throws APIManagementException\n+     */\n+    public List<String> getNamesOfTierWithBandwidthQuotaType(int tenantId) throws APIManagementException {\n+        Connection conn = null;\n+        ResultSet resultSet = null;\n+        PreparedStatement ps = null;\n+        List<String> list = new ArrayList<String>();\n+        try {\n+            String sqlQuery = ThrottleSQLConstants.GET_TIERS_WITH_BANDWIDTH_QUOTA_TYPE_SQL;\n+            conn = APIMgtDBUtil.getConnection();\n+            ps = conn.prepareStatement(sqlQuery);\n+            ps.setInt(1, tenantId);\n+            resultSet = ps.executeQuery();\n+            while (resultSet.next()) {\n+                list.add(resultSet.getString(1));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to retrieve tiers with bandwidth QuotaType \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n+        }\n+        return list;\n+    }\n }\n", "next_change": {"commit": "e05c5d48319fe068a471b7469fb1069531222bd2", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex f35b0bf9bfa..6df6d3430a8 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14997,4 +14724,87 @@ public class ApiMgtDAO {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Add a new endpoint registry\n+     *\n+     * @param endpointRegistry EndpointRegistry\n+     * @param tenantID  ID of the owner's tenant\n+     * @return registryId\n+     */\n+    public String addEndpointRegistry(EndpointRegistry endpointRegistry, int tenantID) throws APIManagementException {\n+        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_SQL;\n+        String uuid = UUID.randomUUID().toString();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, uuid);\n+            ps.setString(2, endpointRegistry.getName());\n+            ps.setString(3, endpointRegistry.getType());\n+            ps.setString(4, endpointRegistry.getMode());\n+            ps.setInt(5, tenantID);\n+            ps.setString(6, endpointRegistry.getOwner());\n+            ps.setString(7, \"\");\n+            ps.setString(8, \"\");\n+            ps.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Error while adding new endpoint registry: \" + endpointRegistry.getName(), e);\n+        }\n+        return uuid;\n+    }\n+\n+    /**\n+     * Return the details of an Endpoint Registry\n+     *\n+     * @param regsitryId Endpoint Registry Identifier\n+     * @return Endpoint Registry Object\n+     * @throws APIManagementException\n+     */\n+    public EndpointRegistry getEndpointRegistryByUUID(String regsitryId) throws APIManagementException {\n+        String query = SQLConstants.GET_ENDPOINT_REGISTRY_BY_UUID;\n+        EndpointRegistry endpointRegistry = new EndpointRegistry();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, regsitryId);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                if (rs.next()) {\n+                    endpointRegistry.setUuid(rs.getString(\"UUID\"));\n+                    endpointRegistry.setName(rs.getString(\"REG_NAME\"));\n+                    endpointRegistry.setType(rs.getString(\"REG_TYPE\"));\n+                    endpointRegistry.setMode(rs.getString(\"MODE\"));\n+                    endpointRegistry.setOwner(rs.getString(\"REG_OWNER\"));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n+                    + regsitryId, e);\n+        }\n+        return endpointRegistry;\n+    }\n+\n+    /**\n+     * Checks whether the given endpoint registry name is already available under given tenant domain\n+     *\n+     * @param registryName\n+     * @param tenantID\n+     * @return boolean\n+     */\n+    public boolean isEndpointRegistryNameExists(String registryName, int tenantID) throws APIManagementException {\n+        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_NAME_EXISTS;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(sql)) {\n+            statement.setString(1, registryName);\n+            statement.setInt(2, tenantID);\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                int count = rs.getInt(\"ENDPOINT_REGISTRY_COUNT\");\n+                if (count > 0) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check the existence of Endpoint Registry: \" + registryName + \" exists\", e);\n+        }\n+        return false;\n+    }\n }\n", "next_change": {"commit": "db2628efa03380158193c72b58c1b46338b66191", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 6df6d3430a8..df1903b75e7 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14807,4 +14811,35 @@ public class ApiMgtDAO {\n         }\n         return false;\n     }\n+\n+    /**\n+     * Returns details of all Endpoint Registries belong to a given tenant\n+     *\n+     * @param tenantID\n+     * @return A list of EndpointRegistryInfo object\n+     * @throws APIManagementException if failed get details of an Endpoint Registries\n+     */\n+    public List<EndpointRegistryInfo> getEndpointRegistries(int tenantID) throws APIManagementException {\n+        List<EndpointRegistryInfo> endpointRegistryInfoList = new ArrayList<>();\n+        String query = SQLConstants.GET_ALL_ENDPOINT_REGISTRIES_OF_TENANT;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setInt(1, tenantID);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    EndpointRegistryInfo endpointRegistry = new EndpointRegistryInfo();\n+                    endpointRegistry.setUuid(rs.getString(\"UUID\"));\n+                    endpointRegistry.setName(rs.getString(\"REG_NAME\"));\n+                    endpointRegistry.setType(rs.getString(\"REG_TYPE\"));\n+                    endpointRegistry.setMode(rs.getString(\"MODE\"));\n+                    endpointRegistry.setOwner(rs.getString(\"REG_OWNER\"));\n+                    endpointRegistryInfoList.add(endpointRegistry);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving details of endpoint registries\", e);\n+        }\n+        return endpointRegistryInfoList;\n+    }\n }\n", "next_change": {"commit": "20bcc3585d9a367bdb71230f7710420c3e21b222", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex df1903b75e7..36068fce000 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14842,4 +14843,37 @@ public class ApiMgtDAO {\n         }\n         return endpointRegistryInfoList;\n     }\n+\n+    /**\n+     * Returns all entries belong to a given endpoint registry\n+     *\n+     * @param registryId UUID of the endpoint registry\n+     * @return A list of EndpointRegistryEntry objects\n+     * @throws APIManagementException if failed to get entries of an Endpoint Registry\n+     */\n+    public List<EndpointRegistryEntry> getEndpointRegistryEntries(String registryId) throws APIManagementException {\n+        List<EndpointRegistryEntry> endpointRegistryEntryList = new ArrayList<>();\n+        String query = SQLConstants.GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, registryId);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n+                    endpointRegistryEntry.setEntryId(rs.getString(\"UUID\"));\n+                    endpointRegistryEntry.setName(rs.getString(\"ENTRY_NAME\"));\n+                    endpointRegistryEntry.setServiceURL(rs.getString(\"SERVICE_URL\"));\n+                    endpointRegistryEntry.setDefinitionType(rs.getString(\"DEFINITION_TYPE\"));\n+                    endpointRegistryEntry.setDefinitionURL(rs.getString(\"DEFINITION_URL\"));\n+                    endpointRegistryEntry.setServiceType(rs.getString(\"SERVICE_TYPE\"));\n+                    endpointRegistryEntry.setMetaData(rs.getString(\"METADATA\"));\n+                    endpointRegistryEntryList.add(endpointRegistryEntry);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving entries of endpoint registry\", e);\n+        }\n+        return endpointRegistryEntryList;\n+    }\n }\n", "next_change": {"commit": "e1a039ddf7a6b9dc073e4214a59f1b7dadbf6ffd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 36068fce000..4760102fa49 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14845,35 +14845,31 @@ public class ApiMgtDAO {\n     }\n \n     /**\n-     * Returns all entries belong to a given endpoint registry\n+     * Add a new endpoint registry entry\n      *\n-     * @param registryId UUID of the endpoint registry\n-     * @return A list of EndpointRegistryEntry objects\n-     * @throws APIManagementException if failed to get entries of an Endpoint Registry\n+     * @param registryEntry EndpointRegistryEntry\n+     * @param tenantID  ID of the owner's tenant\n+     * @return registryId\n      */\n-    public List<EndpointRegistryEntry> getEndpointRegistryEntries(String registryId) throws APIManagementException {\n-        List<EndpointRegistryEntry> endpointRegistryEntryList = new ArrayList<>();\n-        String query = SQLConstants.GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY;\n+    public String addEndpointRegistryEntry(EndpointRegistryEntry registryEntry, int tenantID) throws\n+            APIManagementException {\n+        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_SQL;\n+        String uuid = UUID.randomUUID().toString();\n         try (Connection connection = APIMgtDBUtil.getConnection();\n              PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryId);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n-                    endpointRegistryEntry.setEntryId(rs.getString(\"UUID\"));\n-                    endpointRegistryEntry.setName(rs.getString(\"ENTRY_NAME\"));\n-                    endpointRegistryEntry.setServiceURL(rs.getString(\"SERVICE_URL\"));\n-                    endpointRegistryEntry.setDefinitionType(rs.getString(\"DEFINITION_TYPE\"));\n-                    endpointRegistryEntry.setDefinitionURL(rs.getString(\"DEFINITION_URL\"));\n-                    endpointRegistryEntry.setServiceType(rs.getString(\"SERVICE_TYPE\"));\n-                    endpointRegistryEntry.setMetaData(rs.getString(\"METADATA\"));\n-                    endpointRegistryEntryList.add(endpointRegistryEntry);\n-                }\n-            }\n+            connection.setAutoCommit(false);\n+            ps.setString(1, uuid);\n+            ps.setString(2, registryEntry.getName());\n+            ps.setString(3, registryEntry.getServiceURL());\n+            ps.setString(4, registryEntry.getDefinitionType());\n+            ps.setString(5, registryEntry.getDefinitionURL());\n+            ps.setString(6, registryEntry.getMetaData());\n+            ps.setString(7, registryEntry.getServiceType());\n+            ps.setBlob(8, registryEntry.getEndpointDefinition().getContent());\n+            ps.setInt(9, registryEntry.getRegistryId());\n         } catch (SQLException e) {\n-            handleException(\"Error while retrieving entries of endpoint registry\", e);\n+            handleException(\"Error while adding new endpoint registry entry: \" + registryEntry.getName(), e);\n         }\n-        return endpointRegistryEntryList;\n+        return uuid;\n     }\n }\n", "next_change": {"commit": "4fa06ad511c80776ea0b2ef7fffce3732695acf6", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 4760102fa49..6c0792d9add 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14867,9 +14935,36 @@ public class ApiMgtDAO {\n             ps.setString(7, registryEntry.getServiceType());\n             ps.setBlob(8, registryEntry.getEndpointDefinition().getContent());\n             ps.setInt(9, registryEntry.getRegistryId());\n+            ps.executeUpdate();\n+            connection.commit();\n         } catch (SQLException e) {\n             handleException(\"Error while adding new endpoint registry entry: \" + registryEntry.getName(), e);\n         }\n         return uuid;\n     }\n+\n+    /**\n+     * Checks whether the given endpoint registry entry name is already available under given registry\n+     *\n+     * @param registryEntry\n+     * @return boolean\n+     */\n+    public boolean isRegistryEntryNameExists(EndpointRegistryEntry registryEntry) throws APIManagementException {\n+        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_EXISTS;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(sql)) {\n+            statement.setString(1, registryEntry.getName());\n+            statement.setInt(2, registryEntry.getRegistryId());\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n+                if (count > 0) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n+        }\n+        return false;\n+    }\n }\n", "next_change": {"commit": "41d4c57c9fb8ab7347137fac535121381688f639", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 6c0792d9add..9519ff8c190 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14726,245 +14826,4 @@ public class ApiMgtDAO {\n         }\n         return list;\n     }\n-\n-    /**\n-     * Add a new endpoint registry\n-     *\n-     * @param endpointRegistry EndpointRegistryInfo\n-     * @param tenantID  ID of the owner's tenant\n-     * @return registryId\n-     */\n-    public String addEndpointRegistry(EndpointRegistryInfo endpointRegistry, int tenantID) throws APIManagementException {\n-        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_SQL;\n-        String uuid = UUID.randomUUID().toString();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            connection.setAutoCommit(false);\n-            ps.setString(1, uuid);\n-            ps.setString(2, endpointRegistry.getName());\n-            ps.setString(3, endpointRegistry.getType());\n-            ps.setString(4, endpointRegistry.getMode());\n-            ps.setInt(5, tenantID);\n-            ps.setString(6, endpointRegistry.getOwner());\n-            // Need to update the role names\n-            ps.setString(7, \"\");\n-            ps.setString(8, \"\");\n-            ps.executeUpdate();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Error while adding new endpoint registry: \" + endpointRegistry.getName(), e);\n-        }\n-        return uuid;\n-    }\n-\n-    /**\n-     * Return the details of an Endpoint Registry\n-     *\n-     * @param registryId Endpoint Registry Identifier\n-     * @return Endpoint Registry Object\n-     * @throws APIManagementException\n-     */\n-    public EndpointRegistryInfo getEndpointRegistryByUUID(String registryId) throws APIManagementException {\n-        String query = SQLConstants.GET_ENDPOINT_REGISTRY_BY_UUID;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryId);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                if (rs.next()) {\n-                    EndpointRegistryInfo endpointRegistry = new EndpointRegistryInfo();\n-                    endpointRegistry.setUuid(rs.getString(\"UUID\"));\n-                    endpointRegistry.setName(rs.getString(\"REG_NAME\"));\n-                    endpointRegistry.setType(rs.getString(\"REG_TYPE\"));\n-                    endpointRegistry.setMode(rs.getString(\"MODE\"));\n-                    endpointRegistry.setOwner(rs.getString(\"REG_OWNER\"));\n-                    endpointRegistry.setRegistryId(rs.getInt(\"ID\"));\n-                    return endpointRegistry;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n-                    + registryId, e);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Checks whether the given endpoint registry name is already available under given tenant domain\n-     *\n-     * @param registryName\n-     * @param tenantID\n-     * @return boolean\n-     */\n-    public boolean isEndpointRegistryNameExists(String registryName, int tenantID) throws APIManagementException {\n-        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_NAME_EXISTS;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(sql)) {\n-            statement.setString(1, registryName);\n-            statement.setInt(2, tenantID);\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                int count = rs.getInt(\"ENDPOINT_REGISTRY_COUNT\");\n-                if (count > 0) {\n-                    return true;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check the existence of Endpoint Registry: \" + registryName, e);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Returns details of all Endpoint Registries belong to a given tenant\n-     *\n-     * @param tenantID\n-     * @return A list of EndpointRegistryInfo objects\n-     * @throws APIManagementException if failed to get details of Endpoint Registries\n-     */\n-    public List<EndpointRegistryInfo> getEndpointRegistries(int tenantID) throws APIManagementException {\n-        List<EndpointRegistryInfo> endpointRegistryInfoList = new ArrayList<>();\n-        String query = SQLConstants.GET_ALL_ENDPOINT_REGISTRIES_OF_TENANT;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setInt(1, tenantID);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    EndpointRegistryInfo endpointRegistry = new EndpointRegistryInfo();\n-                    endpointRegistry.setUuid(rs.getString(\"UUID\"));\n-                    endpointRegistry.setName(rs.getString(\"REG_NAME\"));\n-                    endpointRegistry.setType(rs.getString(\"REG_TYPE\"));\n-                    endpointRegistry.setMode(rs.getString(\"MODE\"));\n-                    endpointRegistry.setOwner(rs.getString(\"REG_OWNER\"));\n-                    endpointRegistryInfoList.add(endpointRegistry);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving details of endpoint registries\", e);\n-        }\n-        return endpointRegistryInfoList;\n-    }\n-\n-    /**\n-     * Returns the details of an endpoint registry entry.\n-     * @param registryEntryUuid endpoint registry entry identifier.\n-     * @return EndpointRegistryEntry object.\n-     * @throws APIManagementException\n-     */\n-    public EndpointRegistryEntry getEndpointRegistryEntryByUUID(String registryEntryUuid) throws APIManagementException\n-    {\n-\n-        String query = SQLConstants.GET_ENDPOINT_REGISTRY_ENTRY_BY_UUID;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryEntryUuid);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                if (rs.next()) {\n-                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n-                    endpointRegistryEntry.setEntryId(rs.getString(\"UUID\"));\n-                    endpointRegistryEntry.setName(rs.getString(\"ENTRY_NAME\"));\n-                    endpointRegistryEntry.setDefinitionType(rs.getString(\"DEFINITION_TYPE\"));\n-                    endpointRegistryEntry.setDefinitionURL(rs.getString(\"DEFINITION_URL\"));\n-                    endpointRegistryEntry.setServiceType(rs.getString(\"SERVICE_TYPE\"));\n-                    endpointRegistryEntry.setServiceURL(rs.getString(\"SERVICE_URL\"));\n-                    endpointRegistryEntry.setMetaData(rs.getString(\"METADATA\"));\n-                    return endpointRegistryEntry;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n-                    + registryEntryUuid, e);\n-        }\n-        return null;\n-\n-    }\n-\n-    /**\n-     * Returns all entries belong to a given endpoint registry\n-     *\n-     * @param registryId UUID of the endpoint registry\n-     * @return A list of EndpointRegistryEntry objects\n-     * @throws APIManagementException if failed to get entries of an Endpoint Registry\n-     */\n-    public List<EndpointRegistryEntry> getEndpointRegistryEntries(String registryId) throws APIManagementException {\n-        List<EndpointRegistryEntry> endpointRegistryEntryList = new ArrayList<>();\n-        String query = SQLConstants.GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryId);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n-                    endpointRegistryEntry.setEntryId(rs.getString(\"UUID\"));\n-                    endpointRegistryEntry.setName(rs.getString(\"ENTRY_NAME\"));\n-                    endpointRegistryEntry.setServiceURL(rs.getString(\"SERVICE_URL\"));\n-                    endpointRegistryEntry.setDefinitionType(rs.getString(\"DEFINITION_TYPE\"));\n-                    endpointRegistryEntry.setDefinitionURL(rs.getString(\"DEFINITION_URL\"));\n-                    endpointRegistryEntry.setServiceType(rs.getString(\"SERVICE_TYPE\"));\n-                    endpointRegistryEntry.setMetaData(rs.getString(\"METADATA\"));\n-                    endpointRegistryEntryList.add(endpointRegistryEntry);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving entries of endpoint registry\", e);\n-        }\n-        return endpointRegistryEntryList;\n-    }\n-\n-    /**\n-     * Add a new endpoint registry entry\n-     *\n-     * @param registryEntry EndpointRegistryEntry\n-     * @return registryId\n-     */\n-    public String addEndpointRegistryEntry(EndpointRegistryEntry registryEntry) throws APIManagementException {\n-        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_ENTRY_SQL;\n-        String uuid = UUID.randomUUID().toString();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            connection.setAutoCommit(false);\n-            ps.setString(1, uuid);\n-            ps.setString(2, registryEntry.getName());\n-            ps.setString(3, registryEntry.getServiceURL());\n-            ps.setString(4, registryEntry.getDefinitionType());\n-            ps.setString(5, registryEntry.getDefinitionURL());\n-            ps.setString(6, registryEntry.getMetaData());\n-            ps.setString(7, registryEntry.getServiceType());\n-            ps.setBlob(8, registryEntry.getEndpointDefinition().getContent());\n-            ps.setInt(9, registryEntry.getRegistryId());\n-            ps.executeUpdate();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Error while adding new endpoint registry entry: \" + registryEntry.getName(), e);\n-        }\n-        return uuid;\n-    }\n-\n-    /**\n-     * Checks whether the given endpoint registry entry name is already available under given registry\n-     *\n-     * @param registryEntry\n-     * @return boolean\n-     */\n-    public boolean isRegistryEntryNameExists(EndpointRegistryEntry registryEntry) throws APIManagementException {\n-        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_EXISTS;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(sql)) {\n-            statement.setString(1, registryEntry.getName());\n-            statement.setInt(2, registryEntry.getRegistryId());\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n-                if (count > 0) {\n-                    return true;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n-        }\n-        return false;\n-    }\n }\n", "next_change": {"commit": "d6a4aaa1d444685b3fd05a17281632441f86f49f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 9519ff8c190..f982abf8870 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14826,4 +14789,714 @@ public class ApiMgtDAO {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Add a new endpoint registry\n+     *\n+     * @param endpointRegistry EndpointRegistryInfo\n+     * @param tenantID         ID of the owner's tenant\n+     * @return registryId\n+     */\n+    public String addEndpointRegistry(EndpointRegistryInfo endpointRegistry, int tenantID) throws APIManagementException {\n+        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_SQL;\n+        String uuid = UUID.randomUUID().toString();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            connection.setAutoCommit(false);\n+            ps.setString(1, uuid);\n+            ps.setString(2, endpointRegistry.getName());\n+            ps.setString(3, endpointRegistry.getType());\n+            ps.setString(4, endpointRegistry.getMode());\n+            ps.setInt(5, tenantID);\n+            // Need to update the role names\n+            ps.setString(6, \"\");\n+            ps.setString(7, \"\");\n+            ps.setString(8, endpointRegistry.getOwner());\n+            ps.setString(9, endpointRegistry.getOwner());\n+            Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n+            ps.setTimestamp(10, timestamp);\n+            ps.setTimestamp(11, timestamp);\n+\n+            ps.executeUpdate();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Error while adding new endpoint registry: \" + endpointRegistry.getName(), e);\n+        }\n+        return uuid;\n+    }\n+\n+    /**\n+     * Update an existing endpoint registry.\n+     *\n+     * @param registryId       uuid of the endpoint registry\n+     * @param endpointRegistry EndpointRegistryInfo object with updated details\n+     * @param username         logged in username\n+     * @throws APIManagementException if unable to update the endpoint registry\n+     */\n+    public void updateEndpointRegistry(String registryId, EndpointRegistryInfo endpointRegistry, String username)\n+            throws APIManagementException {\n+\n+        String query = SQLConstants.UPDATE_ENDPOINT_REGISTRY_SQL;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            connection.setAutoCommit(false);\n+            ps.setString(1, endpointRegistry.getName());\n+            ps.setString(2, endpointRegistry.getType());\n+            ps.setString(3, endpointRegistry.getMode());\n+            // Need to update the role names\n+            ps.setString(4, \"\");\n+            ps.setString(5, \"\");\n+            ps.setString(6, username);\n+            ps.setTimestamp(7, new Timestamp(System.currentTimeMillis()));\n+            ps.setString(8, registryId);\n+            ps.executeUpdate();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Error while updating endpoint registry: \" + endpointRegistry.getName(), e);\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Return the details of an Endpoint Registry\n+     *\n+     * @param registryId Endpoint Registry Identifier\n+     * @param tenantID   ID of the owner's tenant\n+     * @return Endpoint Registry Object\n+     * @throws APIManagementException\n+     */\n+    public EndpointRegistryInfo getEndpointRegistryByUUID(String registryId, int tenantID)\n+            throws APIManagementException {\n+        String query = SQLConstants.GET_ENDPOINT_REGISTRY_BY_UUID;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, registryId);\n+            ps.setInt(2, tenantID);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                if (rs.next()) {\n+                    EndpointRegistryInfo endpointRegistry = new EndpointRegistryInfo();\n+                    endpointRegistry.setUuid(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n+                    endpointRegistry.setName(rs.getString(EndpointRegistryConstants.COLUMN_REG_NAME));\n+                    endpointRegistry.setType(rs.getString(EndpointRegistryConstants.COLUMN_REG_TYPE));\n+                    endpointRegistry.setMode(rs.getString(EndpointRegistryConstants.COLUMN_REG_MODE));\n+                    endpointRegistry.setRegistryId(rs.getInt(EndpointRegistryConstants.COLUMN_ID));\n+                    endpointRegistry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n+                    endpointRegistry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n+\n+                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n+                    endpointRegistry.setCreatedTime(\n+                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n+\n+                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n+                    endpointRegistry.setLastUpdatedTime(\n+                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n+\n+                    return endpointRegistry;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n+                    + registryId, e);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Deletes an Endpoint Registry\n+     *\n+     * @param registryUUID Registry Identifier(UUID)\n+     * @throws APIManagementException if failed to delete the Endpoint Registry\n+     */\n+    public void deleteEndpointRegistry(String registryUUID) throws APIManagementException {\n+        String deleteRegQuery = SQLConstants.DELETE_ENDPOINT_REGISTRY_SQL;\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statementDeleteRegistry = connection.prepareStatement(deleteRegQuery)\n+             ) {\n+            connection.setAutoCommit(false);\n+            statementDeleteRegistry.setString(1, registryUUID);\n+            statementDeleteRegistry.execute();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete Endpoint Registry with the id: \" + registryUUID, e);\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the given endpoint registry name is already available under given tenant domain\n+     *\n+     * @param registryName\n+     * @param tenantID\n+     * @return boolean\n+     */\n+    public boolean isEndpointRegistryNameExists(String registryName, int tenantID) throws APIManagementException {\n+        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_NAME_EXISTS;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(sql)) {\n+            statement.setString(1, registryName);\n+            statement.setInt(2, tenantID);\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                int count = rs.getInt(\"ENDPOINT_REGISTRY_COUNT\");\n+                if (count > 0) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check the existence of Endpoint Registry: \" + registryName, e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Add shared scope.\n+     *\n+     * @param scope        Scope Object to add\n+     * @param tenantDomain Tenant domain\n+     * @return UUID of the shared scope\n+     * @throws APIManagementException if an error occurs while adding shared scope\n+     */\n+    public String addSharedScope(Scope scope, String tenantDomain) throws APIManagementException {\n+\n+        String uuid = UUID.randomUUID().toString();\n+        String scopeName = scope.getKey();\n+        int tenantId = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_SHARED_SCOPE)) {\n+            try {\n+                connection.setAutoCommit(false);\n+                statement.setString(1, scopeName);\n+                statement.setString(2, uuid);\n+                statement.setInt(3, tenantId);\n+                statement.executeUpdate();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add Shared Scope : \" + scopeName, e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add Shared Scope: \" + scopeName, e);\n+        }\n+        return uuid;\n+    }\n+\n+    /**\n+     * Delete shared scope.\n+     *\n+     * @param scopeName    shared scope name\n+     * @param tenantDomain tenant domain\n+     * @throws APIManagementException if an error occurs while removing shared scope\n+     */\n+    public void deleteSharedScope(String scopeName, String tenantDomain) throws APIManagementException {\n+\n+        int tenantId = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_SHARED_SCOPE)) {\n+            try {\n+                connection.setAutoCommit(false);\n+                statement.setString(1, scopeName);\n+                statement.setInt(2, tenantId);\n+                statement.executeUpdate();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete Shared Scope : \" + scopeName + \" from tenant: \" + tenantDomain, e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete Shared Scope : \" + scopeName + \" from tenant: \" + tenantDomain, e);\n+        }\n+    }\n+\n+    /**\n+     * Get shared scope key by uuid.\n+     *\n+     * @param uuid UUID of shared scope\n+     * @return Shared scope key\n+     * @throws APIManagementException if an error occurs while getting shared scope\n+     */\n+    public String getSharedScopeKeyByUUID(String uuid) throws APIManagementException {\n+\n+        String scopeKey = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_SHARED_SCOPE_BY_UUID)) {\n+            statement.setString(1, uuid);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    scopeKey = rs.getString(\"NAME\");\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get Shared Scope : \" + uuid, e);\n+        }\n+        return scopeKey;\n+    }\n+\n+\n+    /**\n+     * Returns details of all Endpoint Registries belong to a given tenant\n+     *\n+     * @param sortBy    Name of the sorting field\n+     * @param sortOrder Order of sorting (asc or desc)\n+     * @param limit     Limit\n+     * @param offset    Offset\n+     * @param tenantID\n+     * @return A list of EndpointRegistryInfo objects\n+     * @throws APIManagementException if failed to get details of Endpoint Registries\n+     */\n+    public List<EndpointRegistryInfo> getEndpointRegistries(String sortBy, String sortOrder, int limit, int offset,\n+                                                            int tenantID) throws APIManagementException {\n+\n+        List<EndpointRegistryInfo> endpointRegistryInfoList = new ArrayList<>();\n+\n+        String query = SQLConstantManagerFactory.getSQlString(\"GET_ALL_ENDPOINT_REGISTRIES_OF_TENANT\");\n+        query = query.replace(\"$1\", sortBy);\n+        query = query.replace(\"$2\", sortOrder);\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setInt(1, tenantID);\n+            ps.setInt(2, offset);\n+            ps.setInt(3, limit);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    EndpointRegistryInfo endpointRegistry = new EndpointRegistryInfo();\n+                    endpointRegistry.setUuid(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n+                    endpointRegistry.setName(rs.getString(EndpointRegistryConstants.COLUMN_REG_NAME));\n+                    endpointRegistry.setType(rs.getString(EndpointRegistryConstants.COLUMN_REG_TYPE));\n+                    endpointRegistry.setMode(rs.getString(EndpointRegistryConstants.COLUMN_REG_MODE));\n+                    endpointRegistry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n+                    endpointRegistry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n+\n+                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n+                    endpointRegistry.setCreatedTime(\n+                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n+\n+                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n+                    endpointRegistry.setLastUpdatedTime(\n+                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n+\n+                    endpointRegistryInfoList.add(endpointRegistry);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving details of endpoint registries\", e);\n+        }\n+        return endpointRegistryInfoList;\n+    }\n+    /**\n+     * Checks whether the given shared scope name is already available under given tenant domain.\n+     *\n+     * @param scopeName Scope Name\n+     * @param tenantId  Tenant ID\n+     * @return scope name availability\n+     * @throws APIManagementException If an error occurs while checking the availability\n+     */\n+    public boolean isSharedScopeExists(String scopeName, int tenantId) throws APIManagementException {\n+\n+        boolean isExist = false;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.IS_SHARED_SCOPE_NAME_EXISTS)) {\n+            statement.setInt(1, tenantId);\n+            statement.setString(2, scopeName);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                if (rs.next()) {\n+                    isExist = true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check is exists Shared Scope : \" + scopeName + \"-\" + tenantId, e);\n+        }\n+        return isExist;\n+    }\n+\n+    /**\n+     * Get all shared scope keys for tenant.\n+     *\n+     * @param tenantDomain Tenant Domain\n+     * @return shared scope list\n+     * @throws APIManagementException if an error occurs while getting all shared scopes for tenant\n+     */\n+    public Set<String> getAllSharedScopeKeys(String tenantDomain) throws APIManagementException {\n+\n+        Set<String> scopeKeys = null;\n+        int tenantId = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.GET_ALL_SHARED_SCOPE_KEYS_BY_TENANT)) {\n+            statement.setInt(1, tenantId);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                scopeKeys = new HashSet<>();\n+                while (rs.next()) {\n+                    scopeKeys.add(rs.getString(\"NAME\"));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get all Shared Scope Keys for tenant: \" + tenantDomain, e);\n+        }\n+        return scopeKeys;\n+    }\n+\n+    /**\n+     * Get all shared scopes for tenant.\n+     *\n+     * @param tenantDomain Tenant Domain\n+     * @return shared scope list\n+     * @throws APIManagementException if an error occurs while getting all shared scopes for tenant\n+     */\n+    public List<Scope> getAllSharedScopes(String tenantDomain) throws APIManagementException {\n+\n+        List<Scope> scopeList = null;\n+        int tenantId = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_ALL_SHARED_SCOPES_BY_TENANT)) {\n+            statement.setInt(1, tenantId);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                scopeList = new ArrayList<>();\n+                while (rs.next()) {\n+                    Scope scope = new Scope();\n+                    scope.setId(rs.getString(\"UUID\"));\n+                    scope.setKey(rs.getString(\"NAME\"));\n+                    scopeList.add(scope);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get all Shared Scopes for tenant: \" + tenantDomain, e);\n+        }\n+        return scopeList;\n+    }\n+\n+    /**\n+     * Add resource scope to IDN OAuth2 table\n+     * TODO:// Remove after scope validation from swagger completes\n+     * @param api\n+     * @param uriTemplates\n+     * @param tenantDomain\n+     *\n+     * @throws APIManagementException if an error occurs while adding resource scope to IDN table\n+     */\n+    public void addResourceScopes(API api, Set<URITemplate> uriTemplates, String tenantDomain)\n+            throws APIManagementException {\n+\n+        int tenantId = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement addScopeStmt = connection.prepareStatement(SQLConstants.ADD_OAUTH2_RESOURCE_SCOPE_SQL)) {\n+            try {\n+                connection.setAutoCommit(false);\n+                for (URITemplate uriTemplate : uriTemplates) {\n+                    String resourceKey = APIUtil.getResourceKey(api, uriTemplate);\n+                    for (Scope scope : uriTemplate.retrieveAllScopes()) {\n+                        int scopeId = getOAuthScopeIdByName(scope.getKey(), tenantId, connection);\n+                        addScopeStmt.setString(1, resourceKey);\n+                        addScopeStmt.setInt(2, scopeId);\n+                        addScopeStmt.setInt(3, tenantId);\n+                        addScopeStmt.addBatch();\n+                    }\n+                }\n+                addScopeStmt.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add resource scopes for API: \" + api.getId(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add resource scopes for API: \" + api.getId(), e);\n+        }\n+    }\n+\n+    /**\n+     * Get resource scope Id by scope name. KM operation. //TODO: remove after KM seperation\n+     */\n+    public int getOAuthScopeIdByName(String scopeName, int tenantId, Connection connection) throws SQLException,\n+            APIManagementException {\n+\n+        int scopeId = -1;\n+        try (PreparedStatement getScopeIdStmt =\n+                     connection.prepareStatement(SQLConstants.GET_OAUTH2_SCOPE_ID_BY_NAME_SQL)) {\n+            getScopeIdStmt.setString(1, scopeName);\n+            getScopeIdStmt.setInt(2, tenantId);\n+            try (ResultSet rs = getScopeIdStmt.executeQuery()) {\n+                if (rs.next()) {\n+                    scopeId = rs.getInt(1);\n+                }\n+            }\n+        }\n+        if (scopeId == -1) {\n+            throw new APIManagementException(\"Unable to find the Scope: \" + scopeName + \" in the database\");\n+        }\n+        return scopeId;\n+    }\n+\n+    /**\n+     * Remove resource scope from KM database.\n+     * //TODO:remove once scope validation from swagger is fixed.\n+     *\n+     * @throws APIManagementException\n+     */\n+    public void removeResourceScopes(APIIdentifier apiIdentifier, String context, Set<URITemplate> uriTemplates,\n+                                     String tenantDomain) throws APIManagementException {\n+\n+        int tenantId = APIUtil.getTenantIdFromTenantDomain(tenantDomain);\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.REMOVE_OAUTH2_RESOURCE_SCOPE_SQL)) {\n+            try {\n+                connection.setAutoCommit(false);\n+                for (URITemplate uriTemplate : uriTemplates) {\n+                    String resourceKey = APIUtil.getResourceKey(apiIdentifier, context, uriTemplate);\n+                    for (Scope scope : uriTemplate.retrieveAllScopes()) {\n+                        statement.setString(1, scope.getKey());\n+                        statement.setInt(2, tenantId);\n+                        statement.setString(3, resourceKey);\n+                        statement.addBatch();\n+                    }\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to remove resource scopes for: \" + apiIdentifier, e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to remove resource scopes for: \" + apiIdentifier, e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the details of an endpoint registry entry.\n+     *\n+     * @param registryEntryUuid endpoint registry entry identifier.\n+     * @return EndpointRegistryEntry object.\n+     * @throws APIManagementException\n+     */\n+    public EndpointRegistryEntry getEndpointRegistryEntryByUUID(String registryEntryUuid) throws APIManagementException\n+    {\n+\n+        String query = SQLConstants.GET_ENDPOINT_REGISTRY_ENTRY_BY_UUID;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, registryEntryUuid);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                if (rs.next()) {\n+                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n+                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n+                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n+                    endpointRegistryEntry.setDefinitionType(\n+                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_TYPE));\n+                    endpointRegistryEntry.setDefinitionURL(\n+                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_URL));\n+                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n+                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_SERVICE_CATEGORY));\n+                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_PRODUCTION_SERVICE_URL));\n+                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_SANDBOX_SERVICE_URL));\n+                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n+                    endpointRegistryEntry.setEndpointDefinition(\n+                            rs.getBinaryStream(EndpointRegistryConstants.COLUMN_ENDPOINT_DEFINITION));\n+                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n+                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n+\n+                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n+                    endpointRegistryEntry.setCreatedTime(\n+                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n+\n+                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n+                    endpointRegistryEntry.setLastUpdatedTime(\n+                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n+                    return endpointRegistryEntry;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n+                    + registryEntryUuid, e);\n+        }\n+        return null;\n+\n+    }\n+\n+    /**\n+     * Returns all entries belong to a given endpoint registry\n+     *\n+     * @param sortBy     Name of the sorting field\n+     * @param sortOrder  Order of sorting (asc or desc)\n+     * @param limit      Limit\n+     * @param offset     Offset\n+     * @param registryId UUID of the endpoint registry\n+     * @return A list of EndpointRegistryEntry objects\n+     * @throws APIManagementException if failed to get entries of an Endpoint Registry\n+     */\n+    public List<EndpointRegistryEntry> getEndpointRegistryEntries(String sortBy, String sortOrder, int limit,\n+                                                                  int offset, String registryId, String serviceType,\n+                                                                  String definitionType, String entryName,\n+                                                                  String serviceCategory)\n+            throws APIManagementException {\n+        List<EndpointRegistryEntry> endpointRegistryEntryList = new ArrayList<>();\n+        String query = SQLConstantManagerFactory.getSQlString(\"GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY\");\n+        query = query.replace(\"$1\", sortBy);\n+        query = query.replace(\"$2\", sortOrder);\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, registryId);\n+            ps.setString(2, \"%\" + entryName + \"%\");\n+            ps.setString(3, \"%\" + definitionType + \"%\");\n+            ps.setString(4, \"%\" + serviceType + \"%\");\n+            ps.setString(5, \"%\" + serviceCategory + \"%\");\n+            ps.setInt(6, offset);\n+            ps.setInt(7, limit);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n+                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n+                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n+                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_PRODUCTION_SERVICE_URL));\n+                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_SANDBOX_SERVICE_URL));\n+                    endpointRegistryEntry.setDefinitionType(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_DEFINITION_TYPE));\n+                    endpointRegistryEntry.setDefinitionURL(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_DEFINITION_URL));\n+                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n+                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants\n+                            .COLUMN_SERVICE_CATEGORY));\n+                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n+                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n+                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n+\n+                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n+                    endpointRegistryEntry.setCreatedTime(\n+                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n+\n+                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n+                    endpointRegistryEntry.setLastUpdatedTime(\n+                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n+                    endpointRegistryEntryList.add(endpointRegistryEntry);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving entries of endpoint registry\", e);\n+        }\n+        return endpointRegistryEntryList;\n+    }\n+\n+    /**\n+     * Add a new endpoint registry entry\n+     *\n+     * @param registryEntry EndpointRegistryEntry\n+     * @param username      logged in username\n+     * @return registryId\n+     */\n+    public String addEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n+            throws APIManagementException {\n+        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_ENTRY_SQL;\n+        String uuid = UUID.randomUUID().toString();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            connection.setAutoCommit(false);\n+            ps.setString(1, uuid);\n+            ps.setString(2, registryEntry.getName());\n+            ps.setString(3, registryEntry.getProductionServiceURL());\n+            ps.setString(4, registryEntry.getSandboxServiceUrl());\n+            ps.setString(5, registryEntry.getDefinitionType());\n+            ps.setString(6, registryEntry.getDefinitionURL());\n+            ps.setString(7, registryEntry.getMetaData());\n+            ps.setString(8, registryEntry.getServiceType());\n+            ps.setString(9, registryEntry.getServiceCategory());\n+            ps.setBlob(10, registryEntry.getEndpointDefinition());\n+            ps.setInt(11, registryEntry.getRegistryId());\n+            ps.setString(12, username);\n+            ps.setString(13, username);\n+            Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n+            ps.setTimestamp(14, timestamp);\n+            ps.setTimestamp(15, timestamp);\n+            ps.executeUpdate();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Error while adding new endpoint registry entry: \" + registryEntry.getName(), e);\n+        }\n+        return uuid;\n+    }\n+\n+    /**\n+     * Updates Registry Entry\n+     *\n+     * @param registryEntry EndpointRegistryEntry\n+     * @param username      logged in username\n+     * @throws APIManagementException if failed to update EndpointRegistryEntry\n+     */\n+    public void updateEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n+            throws APIManagementException {\n+        String query = SQLConstants.UPDATE_ENDPOINT_REGISTRY_ENTRY_SQL;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            connection.setAutoCommit(false);\n+            ps.setString(1, registryEntry.getName());\n+            ps.setString(2, registryEntry.getProductionServiceURL());\n+            ps.setString(3, registryEntry.getSandboxServiceUrl());\n+            ps.setString(4, registryEntry.getDefinitionType());\n+            ps.setString(5, registryEntry.getDefinitionURL());\n+            ps.setString(6, registryEntry.getMetaData());\n+            ps.setString(7, registryEntry.getServiceType());\n+            ps.setString(8, registryEntry.getServiceCategory());\n+            ps.setBlob(9, registryEntry.getEndpointDefinition());\n+            ps.setString(10, username);\n+            ps.setTimestamp(11, new Timestamp(System.currentTimeMillis()));\n+            ps.setString(12, registryEntry.getEntryId());\n+            ps.executeUpdate();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Error while updating endpoint registry entry with id: \" + registryEntry.getEntryId(), e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an Endpoint Registry Entry\n+     *\n+     * @param entryId Registry Entry Identifier(UUID)\n+     * @throws APIManagementException if failed to delete the Endpoint Registry Entry\n+     */\n+    public void deleteEndpointRegistryEntry(String entryId) throws APIManagementException {\n+        String query = SQLConstants.DELETE_ENDPOINT_REGISTRY_ENTRY_SQL;\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(query)\n+        ) {\n+            connection.setAutoCommit(false);\n+            statement.setString(1, entryId);\n+            statement.execute();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete Endpoint Registry Entry with the id: \" + entryId, e);\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the given endpoint registry entry name is already available under given registry\n+     *\n+     * @param registryEntry\n+     * @return boolean\n+     */\n+    public boolean isRegistryEntryNameExists(EndpointRegistryEntry registryEntry) throws APIManagementException {\n+        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_EXISTS;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(sql)) {\n+            statement.setString(1, registryEntry.getName());\n+            statement.setInt(2, registryEntry.getRegistryId());\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n+                if (count > 0) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n+        }\n+        return false;\n+    }\n }\n", "next_change": {"commit": "21ce9862c39260ad9cbbb2db321ccea865c0a971", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex f982abf8870..24d93acac84 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15499,4 +15382,31 @@ public class ApiMgtDAO {\n         }\n         return false;\n     }\n+\n+    /**\n+     * Checks whether the given endpoint registry entry name and version is already available under given registry\n+     *\n+     * @param registryEntry EndpointRegistryEntry\n+     * @return boolean\n+     */\n+    public boolean isRegistryEntryNameAndVersionExists(EndpointRegistryEntry registryEntry)\n+            throws APIManagementException {\n+        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_AND_VERSION_EXISTS;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(sql)) {\n+            statement.setString(1, registryEntry.getName());\n+            statement.setString(2, registryEntry.getVersion());\n+            statement.setInt(3, registryEntry.getRegistryId());\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n+                if (count > 0) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n+        }\n+        return false;\n+    }\n }\n", "next_change": {"commit": "2e4fc3359a12761f8fd1c33a63865ea894d24406", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 24d93acac84..65a3888a09c 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15126,287 +14921,4 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Returns the details of an endpoint registry entry.\n-     *\n-     * @param registryEntryUuid endpoint registry entry identifier.\n-     * @return EndpointRegistryEntry object.\n-     * @throws APIManagementException\n-     */\n-    public EndpointRegistryEntry getEndpointRegistryEntryByUUID(String registryEntryUuid) throws APIManagementException\n-    {\n-\n-        String query = SQLConstants.GET_ENDPOINT_REGISTRY_ENTRY_BY_UUID;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryEntryUuid);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                if (rs.next()) {\n-                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n-                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n-                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n-                    endpointRegistryEntry.setVersion(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_VERSION));\n-                    endpointRegistryEntry.setDefinitionType(\n-                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_TYPE));\n-                    endpointRegistryEntry.setDefinitionURL(\n-                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_URL));\n-                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n-                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_SERVICE_CATEGORY));\n-                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_PRODUCTION_SERVICE_URL));\n-                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_SANDBOX_SERVICE_URL));\n-                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n-                    endpointRegistryEntry.setEndpointDefinition(\n-                            rs.getBinaryStream(EndpointRegistryConstants.COLUMN_ENDPOINT_DEFINITION));\n-                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n-                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n-\n-                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n-                    endpointRegistryEntry.setCreatedTime(\n-                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n-\n-                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n-                    endpointRegistryEntry.setLastUpdatedTime(\n-                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n-\n-                    endpointRegistryEntry.setRegistryId(rs.getInt(EndpointRegistryConstants.COLUMN_REG_ID));\n-                    return endpointRegistryEntry;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n-                    + registryEntryUuid, e);\n-        }\n-        return null;\n-\n-    }\n-\n-    /**\n-     * Returns all entries belong to a given endpoint registry\n-     *\n-     * @param sortBy         Name of the sorting field\n-     * @param sortOrder      Order of sorting (asc or desc)\n-     * @param limit          Limit\n-     * @param offset         Offset\n-     * @param registryId     UUID of the endpoint registry\n-     * @param version        The version of registry entry\n-     * @param exactNameMatch Whether to perform exact search on name\n-     * @return A list of EndpointRegistryEntry objects\n-     * @throws APIManagementException if failed to get entries of an Endpoint Registry\n-     */\n-    public List<EndpointRegistryEntry> getEndpointRegistryEntries(String sortBy, String sortOrder, int limit,\n-                                                                  int offset, String registryId, String serviceType,\n-                                                                  String definitionType, String entryName,\n-                                                                  String serviceCategory, String version,\n-                                                                  boolean exactNameMatch)\n-            throws APIManagementException {\n-        List<EndpointRegistryEntry> endpointRegistryEntryList = new ArrayList<>();\n-        String query;\n-        if (exactNameMatch) {\n-            query = SQLConstantManagerFactory.getSQlString(\"GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY_WITH_EXACT_NAME\");\n-        } else {\n-            query = SQLConstantManagerFactory.getSQlString(\"GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY\");\n-        }\n-        query = query.replace(\"$1\", sortBy);\n-        query = query.replace(\"$2\", sortOrder);\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryId);\n-            if (exactNameMatch) {\n-                ps.setString(2, entryName);\n-            } else {\n-                ps.setString(2, \"%\" + entryName + \"%\");\n-            }\n-            ps.setString(3, \"%\" + definitionType + \"%\");\n-            ps.setString(4, \"%\" + serviceType + \"%\");\n-            ps.setString(5, \"%\" + serviceCategory + \"%\");\n-            ps.setString(6, \"%\" + version + \"%\");\n-            ps.setInt(7, offset);\n-            ps.setInt(8, limit);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n-                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n-                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n-                    endpointRegistryEntry.setVersion(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_VERSION));\n-                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_PRODUCTION_SERVICE_URL));\n-                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_SANDBOX_SERVICE_URL));\n-                    endpointRegistryEntry.setDefinitionType(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_DEFINITION_TYPE));\n-                    endpointRegistryEntry.setDefinitionURL(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_DEFINITION_URL));\n-                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n-                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants\n-                            .COLUMN_SERVICE_CATEGORY));\n-                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n-                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n-                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n-\n-                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n-                    endpointRegistryEntry.setCreatedTime(\n-                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n-\n-                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n-                    endpointRegistryEntry.setLastUpdatedTime(\n-                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n-                    endpointRegistryEntryList.add(endpointRegistryEntry);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving entries of endpoint registry\", e);\n-        }\n-        return endpointRegistryEntryList;\n-    }\n-\n-    /**\n-     * Add a new endpoint registry entry\n-     *\n-     * @param registryEntry EndpointRegistryEntry\n-     * @param username      logged in username\n-     * @return registryId\n-     */\n-    public String addEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n-            throws APIManagementException {\n-        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_ENTRY_SQL;\n-        String uuid = UUID.randomUUID().toString();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            connection.setAutoCommit(false);\n-            ps.setString(1, uuid);\n-            ps.setString(2, registryEntry.getName());\n-            ps.setString(3, registryEntry.getVersion());\n-            ps.setString(4, registryEntry.getProductionServiceURL());\n-            ps.setString(5, registryEntry.getSandboxServiceUrl());\n-            ps.setString(6, registryEntry.getDefinitionType());\n-            ps.setString(7, registryEntry.getDefinitionURL());\n-            ps.setString(8, registryEntry.getMetaData());\n-            ps.setString(9, registryEntry.getServiceType());\n-            ps.setString(10, registryEntry.getServiceCategory());\n-            ps.setBlob(11, registryEntry.getEndpointDefinition());\n-            ps.setInt(12, registryEntry.getRegistryId());\n-            ps.setString(13, username);\n-            ps.setString(14, username);\n-            Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n-            ps.setTimestamp(15, timestamp);\n-            ps.setTimestamp(16, timestamp);\n-            ps.executeUpdate();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Error while adding new endpoint registry entry: \" + registryEntry.getName(), e);\n-        }\n-        return uuid;\n-    }\n-\n-    /**\n-     * Updates Registry Entry\n-     *\n-     * @param registryEntry EndpointRegistryEntry\n-     * @param username      logged in username\n-     * @throws APIManagementException if failed to update EndpointRegistryEntry\n-     */\n-    public void updateEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n-            throws APIManagementException {\n-        String query = SQLConstants.UPDATE_ENDPOINT_REGISTRY_ENTRY_SQL;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            connection.setAutoCommit(false);\n-            ps.setString(1, registryEntry.getName());\n-            ps.setString(2, registryEntry.getVersion());\n-            ps.setString(3, registryEntry.getProductionServiceURL());\n-            ps.setString(4, registryEntry.getSandboxServiceUrl());\n-            ps.setString(5, registryEntry.getDefinitionType());\n-            ps.setString(6, registryEntry.getDefinitionURL());\n-            ps.setString(7, registryEntry.getMetaData());\n-            ps.setString(8, registryEntry.getServiceType());\n-            ps.setString(9, registryEntry.getServiceCategory());\n-            ps.setBlob(10, registryEntry.getEndpointDefinition());\n-            ps.setString(11, username);\n-            ps.setTimestamp(12, new Timestamp(System.currentTimeMillis()));\n-            ps.setString(13, registryEntry.getEntryId());\n-            ps.executeUpdate();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Error while updating endpoint registry entry with id: \" + registryEntry.getEntryId(), e);\n-        }\n-    }\n-\n-    /**\n-     * Deletes an Endpoint Registry Entry\n-     *\n-     * @param entryId Registry Entry Identifier(UUID)\n-     * @throws APIManagementException if failed to delete the Endpoint Registry Entry\n-     */\n-    public void deleteEndpointRegistryEntry(String entryId) throws APIManagementException {\n-        String query = SQLConstants.DELETE_ENDPOINT_REGISTRY_ENTRY_SQL;\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(query)\n-        ) {\n-            connection.setAutoCommit(false);\n-            statement.setString(1, entryId);\n-            statement.execute();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete Endpoint Registry Entry with the id: \" + entryId, e);\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the given endpoint registry entry name is already available under given registry\n-     *\n-     * @param registryEntry\n-     * @return boolean\n-     */\n-    public boolean isRegistryEntryNameExists(EndpointRegistryEntry registryEntry) throws APIManagementException {\n-        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_EXISTS;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(sql)) {\n-            statement.setString(1, registryEntry.getName());\n-            statement.setInt(2, registryEntry.getRegistryId());\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n-                if (count > 0) {\n-                    return true;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Checks whether the given endpoint registry entry name and version is already available under given registry\n-     *\n-     * @param registryEntry EndpointRegistryEntry\n-     * @return boolean\n-     */\n-    public boolean isRegistryEntryNameAndVersionExists(EndpointRegistryEntry registryEntry)\n-            throws APIManagementException {\n-        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_AND_VERSION_EXISTS;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(sql)) {\n-            statement.setString(1, registryEntry.getName());\n-            statement.setString(2, registryEntry.getVersion());\n-            statement.setInt(3, registryEntry.getRegistryId());\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n-                if (count > 0) {\n-                    return true;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n-        }\n-        return false;\n-    }\n }\n", "next_change": {"commit": "95ff64947dcd54c260a0867c3c314fae064d6a85", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 65a3888a09c..d946d2f22e3 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14921,4 +15238,241 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Returns the details of an endpoint registry entry.\n+     *\n+     * @param registryEntryUuid endpoint registry entry identifier.\n+     * @return EndpointRegistryEntry object.\n+     * @throws APIManagementException\n+     */\n+    public EndpointRegistryEntry getEndpointRegistryEntryByUUID(String registryEntryUuid) throws APIManagementException\n+    {\n+\n+        String query = SQLConstants.GET_ENDPOINT_REGISTRY_ENTRY_BY_UUID;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, registryEntryUuid);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                if (rs.next()) {\n+                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n+                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n+                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n+                    endpointRegistryEntry.setDefinitionType(\n+                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_TYPE));\n+                    endpointRegistryEntry.setDefinitionURL(\n+                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_URL));\n+                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n+                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_SERVICE_CATEGORY));\n+                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_PRODUCTION_SERVICE_URL));\n+                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_SANDBOX_SERVICE_URL));\n+                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n+                    endpointRegistryEntry.setEndpointDefinition(\n+                            rs.getBinaryStream(EndpointRegistryConstants.COLUMN_ENDPOINT_DEFINITION));\n+                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n+                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n+\n+                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n+                    endpointRegistryEntry.setCreatedTime(\n+                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n+\n+                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n+                    endpointRegistryEntry.setLastUpdatedTime(\n+                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n+                    return endpointRegistryEntry;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n+                    + registryEntryUuid, e);\n+        }\n+        return null;\n+\n+    }\n+\n+    /**\n+     * Returns all entries belong to a given endpoint registry\n+     *\n+     * @param sortBy     Name of the sorting field\n+     * @param sortOrder  Order of sorting (asc or desc)\n+     * @param limit      Limit\n+     * @param offset     Offset\n+     * @param registryId UUID of the endpoint registry\n+     * @return A list of EndpointRegistryEntry objects\n+     * @throws APIManagementException if failed to get entries of an Endpoint Registry\n+     */\n+    public List<EndpointRegistryEntry> getEndpointRegistryEntries(String sortBy, String sortOrder, int limit,\n+                                                                  int offset, String registryId, String serviceType,\n+                                                                  String definitionType, String entryName,\n+                                                                  String serviceCategory)\n+            throws APIManagementException {\n+        List<EndpointRegistryEntry> endpointRegistryEntryList = new ArrayList<>();\n+        String query = SQLConstantManagerFactory.getSQlString(\"GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY\");\n+        query = query.replace(\"$1\", sortBy);\n+        query = query.replace(\"$2\", sortOrder);\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            ps.setString(1, registryId);\n+            ps.setString(2, \"%\" + entryName + \"%\");\n+            ps.setString(3, \"%\" + definitionType + \"%\");\n+            ps.setString(4, \"%\" + serviceType + \"%\");\n+            ps.setString(5, \"%\" + serviceCategory + \"%\");\n+            ps.setInt(6, offset);\n+            ps.setInt(7, limit);\n+            ps.executeQuery();\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n+                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n+                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n+                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_PRODUCTION_SERVICE_URL));\n+                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_SANDBOX_SERVICE_URL));\n+                    endpointRegistryEntry.setDefinitionType(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_DEFINITION_TYPE));\n+                    endpointRegistryEntry.setDefinitionURL(rs.getString(EndpointRegistryConstants.\n+                            COLUMN_DEFINITION_URL));\n+                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n+                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants\n+                            .COLUMN_SERVICE_CATEGORY));\n+                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n+                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n+                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n+\n+                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n+                    endpointRegistryEntry.setCreatedTime(\n+                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n+\n+                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n+                    endpointRegistryEntry.setLastUpdatedTime(\n+                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n+                    endpointRegistryEntryList.add(endpointRegistryEntry);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving entries of endpoint registry\", e);\n+        }\n+        return endpointRegistryEntryList;\n+    }\n+\n+    /**\n+     * Add a new endpoint registry entry\n+     *\n+     * @param registryEntry EndpointRegistryEntry\n+     * @param username      logged in username\n+     * @return registryId\n+     */\n+    public String addEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n+            throws APIManagementException {\n+        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_ENTRY_SQL;\n+        String uuid = UUID.randomUUID().toString();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            connection.setAutoCommit(false);\n+            ps.setString(1, uuid);\n+            ps.setString(2, registryEntry.getName());\n+            ps.setString(3, registryEntry.getProductionServiceURL());\n+            ps.setString(4, registryEntry.getSandboxServiceUrl());\n+            ps.setString(5, registryEntry.getDefinitionType());\n+            ps.setString(6, registryEntry.getDefinitionURL());\n+            ps.setString(7, registryEntry.getMetaData());\n+            ps.setString(8, registryEntry.getServiceType());\n+            ps.setString(9, registryEntry.getServiceCategory());\n+            ps.setBlob(10, registryEntry.getEndpointDefinition());\n+            ps.setInt(11, registryEntry.getRegistryId());\n+            ps.setString(12, username);\n+            ps.setString(13, username);\n+            Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n+            ps.setTimestamp(14, timestamp);\n+            ps.setTimestamp(15, timestamp);\n+            ps.executeUpdate();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Error while adding new endpoint registry entry: \" + registryEntry.getName(), e);\n+        }\n+        return uuid;\n+    }\n+\n+    /**\n+     * Updates Registry Entry\n+     *\n+     * @param registryEntry EndpointRegistryEntry\n+     * @param username      logged in username\n+     * @throws APIManagementException if failed to update EndpointRegistryEntry\n+     */\n+    public void updateEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n+            throws APIManagementException {\n+        String query = SQLConstants.UPDATE_ENDPOINT_REGISTRY_ENTRY_SQL;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = connection.prepareStatement(query)) {\n+            connection.setAutoCommit(false);\n+            ps.setString(1, registryEntry.getName());\n+            ps.setString(2, registryEntry.getProductionServiceURL());\n+            ps.setString(3, registryEntry.getSandboxServiceUrl());\n+            ps.setString(4, registryEntry.getDefinitionType());\n+            ps.setString(5, registryEntry.getDefinitionURL());\n+            ps.setString(6, registryEntry.getMetaData());\n+            ps.setString(7, registryEntry.getServiceType());\n+            ps.setString(8, registryEntry.getServiceCategory());\n+            ps.setBlob(9, registryEntry.getEndpointDefinition());\n+            ps.setString(10, username);\n+            ps.setTimestamp(11, new Timestamp(System.currentTimeMillis()));\n+            ps.setString(12, registryEntry.getEntryId());\n+            ps.executeUpdate();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Error while updating endpoint registry entry with id: \" + registryEntry.getEntryId(), e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an Endpoint Registry Entry\n+     *\n+     * @param entryId Registry Entry Identifier(UUID)\n+     * @throws APIManagementException if failed to delete the Endpoint Registry Entry\n+     */\n+    public void deleteEndpointRegistryEntry(String entryId) throws APIManagementException {\n+        String query = SQLConstants.DELETE_ENDPOINT_REGISTRY_ENTRY_SQL;\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(query)\n+        ) {\n+            connection.setAutoCommit(false);\n+            statement.setString(1, entryId);\n+            statement.execute();\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete Endpoint Registry Entry with the id: \" + entryId, e);\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the given endpoint registry entry name is already available under given registry\n+     *\n+     * @param registryEntry\n+     * @return boolean\n+     */\n+    public boolean isRegistryEntryNameExists(EndpointRegistryEntry registryEntry) throws APIManagementException {\n+        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_EXISTS;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(sql)) {\n+            statement.setString(1, registryEntry.getName());\n+            statement.setInt(2, registryEntry.getRegistryId());\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n+                if (count > 0) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n+        }\n+        return false;\n+    }\n }\n", "next_change": {"commit": "b83d05cbc5af0df3b51aba83c26c2b5abce1f1da", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d946d2f22e3..816c3fcb68a 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15238,241 +15114,4 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Returns the details of an endpoint registry entry.\n-     *\n-     * @param registryEntryUuid endpoint registry entry identifier.\n-     * @return EndpointRegistryEntry object.\n-     * @throws APIManagementException\n-     */\n-    public EndpointRegistryEntry getEndpointRegistryEntryByUUID(String registryEntryUuid) throws APIManagementException\n-    {\n-\n-        String query = SQLConstants.GET_ENDPOINT_REGISTRY_ENTRY_BY_UUID;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryEntryUuid);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                if (rs.next()) {\n-                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n-                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n-                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n-                    endpointRegistryEntry.setDefinitionType(\n-                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_TYPE));\n-                    endpointRegistryEntry.setDefinitionURL(\n-                            rs.getString(EndpointRegistryConstants.COLUMN_DEFINITION_URL));\n-                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n-                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_SERVICE_CATEGORY));\n-                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_PRODUCTION_SERVICE_URL));\n-                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_SANDBOX_SERVICE_URL));\n-                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n-                    endpointRegistryEntry.setEndpointDefinition(\n-                            rs.getBinaryStream(EndpointRegistryConstants.COLUMN_ENDPOINT_DEFINITION));\n-                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n-                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n-\n-                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n-                    endpointRegistryEntry.setCreatedTime(\n-                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n-\n-                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n-                    endpointRegistryEntry.setLastUpdatedTime(\n-                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n-                    return endpointRegistryEntry;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving details of endpoint registry with Id: \"\n-                    + registryEntryUuid, e);\n-        }\n-        return null;\n-\n-    }\n-\n-    /**\n-     * Returns all entries belong to a given endpoint registry\n-     *\n-     * @param sortBy     Name of the sorting field\n-     * @param sortOrder  Order of sorting (asc or desc)\n-     * @param limit      Limit\n-     * @param offset     Offset\n-     * @param registryId UUID of the endpoint registry\n-     * @return A list of EndpointRegistryEntry objects\n-     * @throws APIManagementException if failed to get entries of an Endpoint Registry\n-     */\n-    public List<EndpointRegistryEntry> getEndpointRegistryEntries(String sortBy, String sortOrder, int limit,\n-                                                                  int offset, String registryId, String serviceType,\n-                                                                  String definitionType, String entryName,\n-                                                                  String serviceCategory)\n-            throws APIManagementException {\n-        List<EndpointRegistryEntry> endpointRegistryEntryList = new ArrayList<>();\n-        String query = SQLConstantManagerFactory.getSQlString(\"GET_ALL_ENTRIES_OF_ENDPOINT_REGISTRY\");\n-        query = query.replace(\"$1\", sortBy);\n-        query = query.replace(\"$2\", sortOrder);\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            ps.setString(1, registryId);\n-            ps.setString(2, \"%\" + entryName + \"%\");\n-            ps.setString(3, \"%\" + definitionType + \"%\");\n-            ps.setString(4, \"%\" + serviceType + \"%\");\n-            ps.setString(5, \"%\" + serviceCategory + \"%\");\n-            ps.setInt(6, offset);\n-            ps.setInt(7, limit);\n-            ps.executeQuery();\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    EndpointRegistryEntry endpointRegistryEntry = new EndpointRegistryEntry();\n-                    endpointRegistryEntry.setEntryId(rs.getString(EndpointRegistryConstants.COLUMN_UUID));\n-                    endpointRegistryEntry.setName(rs.getString(EndpointRegistryConstants.COLUMN_ENTRY_NAME));\n-                    endpointRegistryEntry.setProductionServiceURL(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_PRODUCTION_SERVICE_URL));\n-                    endpointRegistryEntry.setSandboxServiceUrl(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_SANDBOX_SERVICE_URL));\n-                    endpointRegistryEntry.setDefinitionType(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_DEFINITION_TYPE));\n-                    endpointRegistryEntry.setDefinitionURL(rs.getString(EndpointRegistryConstants.\n-                            COLUMN_DEFINITION_URL));\n-                    endpointRegistryEntry.setServiceType(rs.getString(EndpointRegistryConstants.COLUMN_SERVICE_TYPE));\n-                    endpointRegistryEntry.setServiceCategory(rs.getString(EndpointRegistryConstants\n-                            .COLUMN_SERVICE_CATEGORY));\n-                    endpointRegistryEntry.setMetaData(rs.getString(EndpointRegistryConstants.COLUMN_METADATA));\n-                    endpointRegistryEntry.setOwner(rs.getString(EndpointRegistryConstants.COLUMN_CREATED_BY));\n-                    endpointRegistryEntry.setUpdatedBy(rs.getString(EndpointRegistryConstants.COLUMN_UPDATED_BY));\n-\n-                    Timestamp createdTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_CREATED_TIME);\n-                    endpointRegistryEntry.setCreatedTime(\n-                            createdTime == null ? null : String.valueOf(createdTime.getTime()));\n-\n-                    Timestamp updatedTime = rs.getTimestamp(EndpointRegistryConstants.COLUMN_UPDATED_TIME);\n-                    endpointRegistryEntry.setLastUpdatedTime(\n-                            updatedTime == null ? null : String.valueOf(updatedTime.getTime()));\n-                    endpointRegistryEntryList.add(endpointRegistryEntry);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving entries of endpoint registry\", e);\n-        }\n-        return endpointRegistryEntryList;\n-    }\n-\n-    /**\n-     * Add a new endpoint registry entry\n-     *\n-     * @param registryEntry EndpointRegistryEntry\n-     * @param username      logged in username\n-     * @return registryId\n-     */\n-    public String addEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n-            throws APIManagementException {\n-        String query = SQLConstants.ADD_ENDPOINT_REGISTRY_ENTRY_SQL;\n-        String uuid = UUID.randomUUID().toString();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            connection.setAutoCommit(false);\n-            ps.setString(1, uuid);\n-            ps.setString(2, registryEntry.getName());\n-            ps.setString(3, registryEntry.getProductionServiceURL());\n-            ps.setString(4, registryEntry.getSandboxServiceUrl());\n-            ps.setString(5, registryEntry.getDefinitionType());\n-            ps.setString(6, registryEntry.getDefinitionURL());\n-            ps.setString(7, registryEntry.getMetaData());\n-            ps.setString(8, registryEntry.getServiceType());\n-            ps.setString(9, registryEntry.getServiceCategory());\n-            ps.setBlob(10, registryEntry.getEndpointDefinition());\n-            ps.setInt(11, registryEntry.getRegistryId());\n-            ps.setString(12, username);\n-            ps.setString(13, username);\n-            Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n-            ps.setTimestamp(14, timestamp);\n-            ps.setTimestamp(15, timestamp);\n-            ps.executeUpdate();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Error while adding new endpoint registry entry: \" + registryEntry.getName(), e);\n-        }\n-        return uuid;\n-    }\n-\n-    /**\n-     * Updates Registry Entry\n-     *\n-     * @param registryEntry EndpointRegistryEntry\n-     * @param username      logged in username\n-     * @throws APIManagementException if failed to update EndpointRegistryEntry\n-     */\n-    public void updateEndpointRegistryEntry(EndpointRegistryEntry registryEntry, String username)\n-            throws APIManagementException {\n-        String query = SQLConstants.UPDATE_ENDPOINT_REGISTRY_ENTRY_SQL;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = connection.prepareStatement(query)) {\n-            connection.setAutoCommit(false);\n-            ps.setString(1, registryEntry.getName());\n-            ps.setString(2, registryEntry.getProductionServiceURL());\n-            ps.setString(3, registryEntry.getSandboxServiceUrl());\n-            ps.setString(4, registryEntry.getDefinitionType());\n-            ps.setString(5, registryEntry.getDefinitionURL());\n-            ps.setString(6, registryEntry.getMetaData());\n-            ps.setString(7, registryEntry.getServiceType());\n-            ps.setString(8, registryEntry.getServiceCategory());\n-            ps.setBlob(9, registryEntry.getEndpointDefinition());\n-            ps.setString(10, username);\n-            ps.setTimestamp(11, new Timestamp(System.currentTimeMillis()));\n-            ps.setString(12, registryEntry.getEntryId());\n-            ps.executeUpdate();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Error while updating endpoint registry entry with id: \" + registryEntry.getEntryId(), e);\n-        }\n-    }\n-\n-    /**\n-     * Deletes an Endpoint Registry Entry\n-     *\n-     * @param entryId Registry Entry Identifier(UUID)\n-     * @throws APIManagementException if failed to delete the Endpoint Registry Entry\n-     */\n-    public void deleteEndpointRegistryEntry(String entryId) throws APIManagementException {\n-        String query = SQLConstants.DELETE_ENDPOINT_REGISTRY_ENTRY_SQL;\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(query)\n-        ) {\n-            connection.setAutoCommit(false);\n-            statement.setString(1, entryId);\n-            statement.execute();\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete Endpoint Registry Entry with the id: \" + entryId, e);\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the given endpoint registry entry name is already available under given registry\n-     *\n-     * @param registryEntry\n-     * @return boolean\n-     */\n-    public boolean isRegistryEntryNameExists(EndpointRegistryEntry registryEntry) throws APIManagementException {\n-        String sql = SQLConstants.IS_ENDPOINT_REGISTRY_ENTRY_NAME_EXISTS;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(sql)) {\n-            statement.setString(1, registryEntry.getName());\n-            statement.setInt(2, registryEntry.getRegistryId());\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                int count = rs.getInt(\"REGISTRY_ENTRY_COUNT\");\n-                if (count > 0) {\n-                    return true;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check the existence of Registry Entry: \" + registryEntry.getName(), e);\n-        }\n-        return false;\n-    }\n }\n", "next_change": {"commit": "fbd081f232dc8ae337f60f24abe3832816cf4212", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 816c3fcb68a..1dfa43648a0 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15114,4 +15450,37 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    public void addAPIBlob(String APIId, String APIName, String gatewayLabel, ByteArrayInputStream bais,\n+                           int streamLength) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_API_BLOB)) {\n+            statement.setString(1, APIId);\n+            statement.setString(2, APIName);\n+            statement.setString(3, gatewayLabel);\n+            statement.setBinaryStream(4, bais, streamLength);\n+            statement.setBinaryStream(5, bais, streamLength);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add blob for \" + APIName , e);\n+        }\n+    }\n+\n+    public ByteArrayInputStream getAPIBlob(String APIId, String APIName, String label) throws APIManagementException {\n+        ByteArrayInputStream baip = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_BLOB)) {\n+            statement.setString(1, APIId);\n+            statement.setString(2, APIName);\n+            statement.setString(3, label);\n+            ResultSet rs = statement.executeQuery();\n+            while (rs.next()) {\n+                byte[] st = (byte[]) rs.getObject(1);\n+                baip = new ByteArrayInputStream(st);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Blob user ID for \" + APIName , e);\n+        }\n+        return baip;\n+    }\n+\n }\n", "next_change": {"commit": "153387abded97189ea48e1ebd41731edf450ecca", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 1dfa43648a0..43acec4096b 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15478,9 +15490,20 @@ public class ApiMgtDAO {\n                 baip = new ByteArrayInputStream(st);\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get API Blob user ID for \" + APIName , e);\n+            handleException(\"Failed to get API Blob user ID for \" + APIName, e);\n         }\n         return baip;\n     }\n \n+    public void deleteAPIBlob(String APIId, String gatewayLabel) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_API_BLOB)) {\n+            statement.setString(1, APIId);\n+            statement.setString(2, gatewayLabel);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete blob of API with ID \" + APIId, e);\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "30a18a39c99a55ef9cf01db195254e894f26a9e9", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 43acec4096b..d446cc79460 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15506,4 +15506,19 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    public boolean isAPIBlobExists(String APIId, String APIName, String label) throws APIManagementException {\n+        boolean status = false;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_BLOB)) {\n+            statement.setString(1, APIId);\n+            statement.setString(2, APIName);\n+            statement.setString(3, label);\n+            ResultSet rs = statement.executeQuery();\n+            status = rs.next();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Blob user ID for \" + APIName, e);\n+        }\n+        return status;\n+    }\n+\n }\n", "next_change": {"commit": "0694cd2ffdd85d5445606583f3f23754a5d37ebb", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d446cc79460..d3ef66c7a3c 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15450,73 +15451,74 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    public void addAPIBlob(String APIId, String APIName, String gatewayLabel, ByteArrayInputStream bais,\n+    public void addAPIBlob(GatewayAPIDTO gatewayAPIDTO, ByteArrayInputStream bais,\n                            int streamLength) throws APIManagementException {\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_API_BLOB)) {\n-            statement.setString(1, APIId);\n-            statement.setString(2, APIName);\n-            statement.setString(3, gatewayLabel);\n-            statement.setBinaryStream(4, bais, streamLength);\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_API_ARTIFACT)) {\n+            statement.setString(1, gatewayAPIDTO.getApiId());\n+            statement.setString(2, gatewayAPIDTO.getName());\n+            statement.setString(3, gatewayAPIDTO.getVersion());\n+            statement.setString(4, gatewayAPIDTO.getTenantDomain());\n+            statement.setString(5, gatewayAPIDTO.getProvider());\n+            statement.setString(6, gatewayAPIDTO.getGatewayLabel());\n+            statement.setBinaryStream(7, bais, streamLength);\n             statement.executeUpdate();\n         } catch (SQLException e) {\n-            handleException(\"Failed to add blob for \" + APIName, e);\n+            handleException(\"Failed to add artifacts for \" + gatewayAPIDTO.getName(), e);\n         }\n     }\n \n     public void updateAPIBlob(String APIId, String gatewayLabel, ByteArrayInputStream bais,\n                            int streamLength) throws APIManagementException {\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_BLOB)) {\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_ARTIFACT)) {\n             statement.setBinaryStream(1, bais, streamLength);\n             statement.setString(2, APIId);\n             statement.setString(3, gatewayLabel);\n             statement.executeUpdate();\n         } catch (SQLException e) {\n-            handleException(\"Failed to update blob for API with ID \" + APIId, e);\n+            handleException(\"Failed to update artifacts of API with ID \" + APIId, e);\n         }\n     }\n \n-    public ByteArrayInputStream getAPIBlob(String APIId, String APIName, String label) throws APIManagementException {\n+    public ByteArrayInputStream getAPIBlob(String APIId, String label) throws APIManagementException {\n         ByteArrayInputStream baip = null;\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_BLOB)) {\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_ARTIFACT)) {\n             statement.setString(1, APIId);\n-            statement.setString(2, APIName);\n-            statement.setString(3, label);\n+            statement.setString(2, label);\n             ResultSet rs = statement.executeQuery();\n             while (rs.next()) {\n                 byte[] st = (byte[]) rs.getObject(1);\n                 baip = new ByteArrayInputStream(st);\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get API Blob user ID for \" + APIName, e);\n+            handleException(\"Failed to get artifacts of API with ID \" + APIId, e);\n         }\n         return baip;\n     }\n \n     public void deleteAPIBlob(String APIId, String gatewayLabel) throws APIManagementException {\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_BLOB)) {\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_ARTIFACT)) {\n             statement.setString(1, APIId);\n             statement.setString(2, gatewayLabel);\n             statement.executeUpdate();\n         } catch (SQLException e) {\n-            handleException(\"Failed to delete blob of API with ID \" + APIId, e);\n+            handleException(\"Failed to delete artifacts of API with ID \" + APIId, e);\n         }\n     }\n \n-    public boolean isAPIBlobExists(String APIId, String APIName, String label) throws APIManagementException {\n+    public boolean isAPIBlobExists(String APIId, String label) throws APIManagementException {\n         boolean status = false;\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_BLOB)) {\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_ARTIFACT)) {\n             statement.setString(1, APIId);\n-            statement.setString(2, APIName);\n-            statement.setString(3, label);\n+            statement.setString(2, label);\n             ResultSet rs = statement.executeQuery();\n             status = rs.next();\n         } catch (SQLException e) {\n-            handleException(\"Failed to get API Blob user ID for \" + APIName, e);\n+            handleException(\"Failed to get artifacts of API with ID \" + APIId, e);\n         }\n         return status;\n     }\n", "next_change": {"commit": "578850aa17ba64ebac7c4d41de94b0e93080022a", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d3ef66c7a3c..0815ff765db 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15509,18 +15537,19 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    public boolean isAPIBlobExists(String APIId, String label) throws APIManagementException {\n-        boolean status = false;\n+    public Set<String> getExistingLabelsForAPI (String APIId) throws APIManagementException {\n+        Set<String> labels = new HashSet<>();\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_ARTIFACT)) {\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_EXISTING_LABELS_FOR_API)) {\n             statement.setString(1, APIId);\n-            statement.setString(2, label);\n             ResultSet rs = statement.executeQuery();\n-            status = rs.next();\n+            while (rs.next()) {\n+                labels.add ((String) rs.getObject(1));\n+            }\n         } catch (SQLException e) {\n             handleException(\"Failed to get artifacts of API with ID \" + APIId, e);\n         }\n-        return status;\n+        return labels;\n     }\n \n }\n", "next_change": {"commit": "b62f4f934e566477dbca89cd1387b0fbf3b43359", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 0815ff765db..d3b70b3d0a9 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15552,4 +15552,18 @@ public class ApiMgtDAO {\n         return labels;\n     }\n \n+    public boolean isAPIPublished (String APIId) throws APIManagementException {\n+        boolean status = false;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.CHECK_API_PUBLISHED_STATUS)) {\n+            statement.setString(1, APIId);\n+            statement.setString(2, APIConstants.GatewayArtifactSynchronizer.ARTIFACT_STATUS_PUBLISH);\n+            ResultSet rs = statement.executeQuery();\n+            status = rs.next();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get artifacts of API with ID \" + APIId, e);\n+        }\n+        return status;\n+    }\n+\n }\n", "next_change": {"commit": "8220100a7947dc2da69e41f4dfc2e265a45a410c", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d3b70b3d0a9..fe31af0d948 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15552,18 +15567,4 @@ public class ApiMgtDAO {\n         return labels;\n     }\n \n-    public boolean isAPIPublished (String APIId) throws APIManagementException {\n-        boolean status = false;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.CHECK_API_PUBLISHED_STATUS)) {\n-            statement.setString(1, APIId);\n-            statement.setString(2, APIConstants.GatewayArtifactSynchronizer.ARTIFACT_STATUS_PUBLISH);\n-            ResultSet rs = statement.executeQuery();\n-            status = rs.next();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get artifacts of API with ID \" + APIId, e);\n-        }\n-        return status;\n-    }\n-\n }\n", "next_change": {"commit": "6383363e86f907118804e12368398b9861529e99", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex fe31af0d948..337be9c566a 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15567,4 +15572,23 @@ public class ApiMgtDAO {\n         return labels;\n     }\n \n+    /**\n+     * Check whether the API details exists in the db\n+     *\n+     * @param APIId - UUID of the API\n+     * @throws APIManagementException  if an error occurs\n+     */\n+    public boolean isAPIDetailsExists(String APIId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_GATEWAY_PUBLISHED_API_DETAILS)) {\n+            statement.setString(1, APIId);\n+            ResultSet rs = statement.executeQuery();\n+            return rs.next();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API details status of API with ID \" + APIId, e);\n+        }\n+        return false;\n+    }\n+\n }\n", "next_change": {"commit": "c9a85d7cac9219e967db29a44a87bf054fba5471", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 337be9c566a..7198bfffd35 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15550,45 +15528,70 @@ public class ApiMgtDAO {\n     }\n \n     /**\n-     * Get all the valid labels for an API with the gateway instruction 'publish'\n+     * Check whether the API is published in any of the Gateways\n      *\n      * @param APIId - UUID of the API\n-     * @throws APIManagementException  if an error occurs\n+     * @throws APIManagementException if an error occurs\n      */\n-    public Set<String> getExistingLabelsForAPI(String APIId) throws APIManagementException {\n+    public boolean isAPIPublishedInAnyGateway(String APIId) throws APIManagementException {\n \n-        Set<String> labels = new HashSet<>();\n+        int count = 0;\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_EXISTING_LABELS_FOR_API)) {\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_PUBLISHED_GATEWAYS_FOR_API)) {\n             statement.setString(1, APIId);\n             statement.setString(2, APIConstants.GatewayArtifactSynchronizer.GATEWAY_INSTRUCTION_PUBLISH);\n             ResultSet rs = statement.executeQuery();\n             while (rs.next()) {\n-                labels.add((String) rs.getObject(1));\n+                count = rs.getInt(\"COUNT\");\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get artifacts of API with ID \" + APIId, e);\n+            handleException(\"Failed check whether API is published in any gateway \" + APIId, e);\n         }\n-        return labels;\n+        return count != 0;\n     }\n \n     /**\n      * Check whether the API details exists in the db\n      *\n      * @param APIId - UUID of the API\n-     * @throws APIManagementException  if an error occurs\n+     * @throws APIManagementException if an error occurs\n      */\n     public boolean isAPIDetailsExists(String APIId) throws APIManagementException {\n \n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_GATEWAY_PUBLISHED_API_DETAILS)) {\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.GET_GATEWAY_PUBLISHED_API_DETAILS)) {\n             statement.setString(1, APIId);\n             ResultSet rs = statement.executeQuery();\n             return rs.next();\n         } catch (SQLException e) {\n-            handleException(\"Failed to get API details status of API with ID \" + APIId, e);\n+            handleException(\"Failed to check API details status of API with ID \" + APIId, e);\n         }\n         return false;\n     }\n \n+    /**\n+     * Check whether the API artifact for given label exists in the db\n+     *\n+     * @param APIId - UUID of the API\n+     * @throws APIManagementException if an error occurs\n+     */\n+    public boolean isAPIArtifactExists(String APIId, String gatewayLabel) throws APIManagementException {\n+\n+        int count = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.CHECK_ARTIFACT_EXISTS)) {\n+            statement.setString(1, APIId);\n+            statement.setString(2, gatewayLabel);\n+            ResultSet rs = statement.executeQuery();\n+            while (rs.next()) {\n+                count = rs.getInt(\"COUNT\");\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check API artifact status of API with ID \" + APIId + \" for label \"\n+                    + gatewayLabel, e);\n+        }\n+        return count != 0;\n+    }\n+\n }\n", "next_change": {"commit": "85481f6982117165f23bb143d9fe0179bcd5284c", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 7198bfffd35..73183f9c053 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15449,149 +15502,4 @@ public class ApiMgtDAO {\n             handleException(\"Failed to remove resource scopes for: \" + apiIdentifier, e);\n         }\n     }\n-\n-    /**\n-     * Add details of the APIs published in the Gateway\n-     *\n-     * @param APIId        - UUID of the API\n-     * @param APIName      - Name of the API\n-     * @param version      - Version of the API\n-     * @param tenantDomain - Tenant domain of the API\n-     * @throws APIManagementException if an error occurs\n-     */\n-    public void addGatewayPublishedAPIDetails(String APIId, String APIName, String version, String tenantDomain)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.ADD_GW_PUBLISHED_API_DETAILS)) {\n-            statement.setString(1, APIId);\n-            statement.setString(2, APIName);\n-            statement.setString(3, version);\n-            statement.setString(4, tenantDomain);\n-            statement.executeUpdate();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API details for \" + APIName, e);\n-        }\n-    }\n-\n-    /**\n-     * Add or update details of the APIs published in the Gateway\n-     *\n-     * @param APIId        - UUID of the API\n-     * @param gatewayLabel - Published gateway's label\n-     * @param bais         - Byte array Input stream of the serializide gatewayAPIDTO\n-     * @param streamLength - Length of the stream\n-     * @throws APIManagementException if an error occurs\n-     */\n-    public void addGatewayPublishedAPIArtifacts(String APIId, String gatewayLabel, ByteArrayInputStream bais,\n-                                                int streamLength, String gatewayInstruction, String query)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(query)) {\n-            statement.setBinaryStream(1, bais, streamLength);\n-            statement.setString(2, gatewayInstruction);\n-            statement.setString(3, APIId);\n-            statement.setString(4, gatewayLabel);\n-            statement.executeUpdate();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add artifacts for \" + APIId, e);\n-        }\n-    }\n-\n-    /**\n-     * Retrieve the blob of the API\n-     *\n-     * @param APIId        - UUID of the API\n-     * @param gatewayLabel - Gateway label of the API\n-     * @throws APIManagementException if an error occurs\n-     */\n-    public ByteArrayInputStream getGatewayPublishedAPIArtifacts(String APIId, String gatewayLabel,\n-                                                                String gatewayInstruction)\n-            throws APIManagementException {\n-\n-        ByteArrayInputStream baip = null;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_ARTIFACT)) {\n-            statement.setString(1, APIId);\n-            statement.setString(2, gatewayLabel);\n-            statement.setString(3, gatewayInstruction);\n-            ResultSet rs = statement.executeQuery();\n-            while (rs.next()) {\n-                byte[] st = (byte[]) rs.getObject(1);\n-                baip = new ByteArrayInputStream(st);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get artifacts of API with ID \" + APIId, e);\n-        }\n-        return baip;\n-    }\n-\n-    /**\n-     * Check whether the API is published in any of the Gateways\n-     *\n-     * @param APIId - UUID of the API\n-     * @throws APIManagementException if an error occurs\n-     */\n-    public boolean isAPIPublishedInAnyGateway(String APIId) throws APIManagementException {\n-\n-        int count = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_PUBLISHED_GATEWAYS_FOR_API)) {\n-            statement.setString(1, APIId);\n-            statement.setString(2, APIConstants.GatewayArtifactSynchronizer.GATEWAY_INSTRUCTION_PUBLISH);\n-            ResultSet rs = statement.executeQuery();\n-            while (rs.next()) {\n-                count = rs.getInt(\"COUNT\");\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed check whether API is published in any gateway \" + APIId, e);\n-        }\n-        return count != 0;\n-    }\n-\n-    /**\n-     * Check whether the API details exists in the db\n-     *\n-     * @param APIId - UUID of the API\n-     * @throws APIManagementException if an error occurs\n-     */\n-    public boolean isAPIDetailsExists(String APIId) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.GET_GATEWAY_PUBLISHED_API_DETAILS)) {\n-            statement.setString(1, APIId);\n-            ResultSet rs = statement.executeQuery();\n-            return rs.next();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check API details status of API with ID \" + APIId, e);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Check whether the API artifact for given label exists in the db\n-     *\n-     * @param APIId - UUID of the API\n-     * @throws APIManagementException if an error occurs\n-     */\n-    public boolean isAPIArtifactExists(String APIId, String gatewayLabel) throws APIManagementException {\n-\n-        int count = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.CHECK_ARTIFACT_EXISTS)) {\n-            statement.setString(1, APIId);\n-            statement.setString(2, gatewayLabel);\n-            ResultSet rs = statement.executeQuery();\n-            while (rs.next()) {\n-                count = rs.getInt(\"COUNT\");\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check API artifact status of API with ID \" + APIId + \" for label \"\n-                    + gatewayLabel, e);\n-        }\n-        return count != 0;\n-    }\n-\n }\n", "next_change": {"commit": "d1b6216beac2821a59488028705d0b1088e31fdb", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 73183f9c053..eff214a41f3 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15502,4 +15519,86 @@ public class ApiMgtDAO {\n             handleException(\"Failed to remove resource scopes for: \" + apiIdentifier, e);\n         }\n     }\n+\n+    /**\n+     * Adds a tenant theme to the database\n+     *\n+     * @param tenantId     tenant ID of user\n+     * @param themeContent content of the tenant theme\n+     */\n+    public void addTenantTheme(int tenantId, InputStream themeContent) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.ADD_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+            if (connection.getMetaData().getDriverName().contains(\"PostgreSQL\") || connection.getMetaData()\n+                    .getDatabaseProductName().contains(\"DB2\")) {\n+                statement.setBinaryStream(2, themeContent, IOUtils.toByteArray(themeContent).length);\n+            } else {\n+                statement.setBinaryStream(2, themeContent);\n+            }\n+            statement.executeUpdate();\n+        } catch (SQLException | IOException e) {\n+            handleException(\"Failed to add tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+    }\n+\n+    /**\n+     * Updates a tenant theme in the database\n+     *\n+     * @param tenantId     tenant ID of user\n+     * @param themeContent content of the tenant theme\n+     */\n+    public void updateTenantTheme(int tenantId, InputStream themeContent) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement =\n+                     connection.prepareStatement(SQLConstants.TenantThemeConstants.UPDATE_TENANT_THEME)) {\n+\n+            if (connection.getMetaData().getDriverName().contains(\"PostgreSQL\") || connection.getMetaData()\n+                    .getDatabaseProductName().contains(\"DB2\")) {\n+                statement.setBinaryStream(1, themeContent, IOUtils.toByteArray(themeContent).length);\n+            } else {\n+                statement.setBinaryStream(1, themeContent);\n+            }\n+            statement.setInt(2, tenantId);\n+            statement.executeUpdate();\n+        } catch (SQLException | IOException e) {\n+            handleException(\"Failed to update tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieves a tenant theme from the database\n+     *\n+     * @param tenantId tenant ID of user\n+     * @return content of the tenant theme\n+     */\n+    public InputStream getTenantTheme(int tenantId) throws APIManagementException {\n+\n+        InputStream tenantThemeContent = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.GET_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+\n+            ResultSet resultSet = statement.executeQuery();\n+            if (resultSet.next()) {\n+                //Postgres bytea data doesn't support getBlob operation\n+                if (connection.getMetaData().getDriverName().contains(\"PostgreSQL\")) {\n+                    tenantThemeContent = resultSet.getBinaryStream(\"THEME\");\n+                } else {\n+                    Blob content = resultSet.getBlob(\"THEME\");\n+                    tenantThemeContent = content.getBinaryStream();\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to fetch tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+        return tenantThemeContent;\n+    }\n }\n", "next_change": {"commit": "948fb62038d82906651cc2bbce5b2394c035025f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex eff214a41f3..48511170043 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15601,4 +15602,26 @@ public class ApiMgtDAO {\n         }\n         return tenantThemeContent;\n     }\n+\n+    /**\n+     * Checks whether a tenant theme exist for a particular tenant\n+     *\n+     * @param tenantId tenant ID of user\n+     * @return true if a tenant theme exist for a particular tenant ID, false otherwise\n+     * @throws APIManagementException\n+     */\n+    public boolean isTenantThemeExist(int tenantId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.GET_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+            ResultSet resultSet = statement.executeQuery();\n+            return resultSet.next();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check whether tenant theme exist for tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+        return false;\n+    }\n }\n", "next_change": {"commit": "c5b80643a4273c328e312b53f321cd79db495265", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 48511170043..ada07bc69e0 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15624,4 +15618,25 @@ public class ApiMgtDAO {\n         }\n         return false;\n     }\n+\n+    /**\n+     * Deletes a tenant theme from the database\n+     *\n+     * @param tenantId tenant ID of user\n+     * @throws APIManagementException if an error occurs when deleting a tenant theme\n+     */\n+    public boolean deleteTenantTheme(int tenantId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.DELETE_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+            ResultSet resultSet = statement.executeQuery();\n+            return resultSet.next();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+        return false;\n+    }\n }\n", "next_change": {"commit": "f32af04bfed6d8781ad41fb9030d2438ab3eac2b", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex ada07bc69e0..b7ce95ac174 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15625,18 +15625,16 @@ public class ApiMgtDAO {\n      * @param tenantId tenant ID of user\n      * @throws APIManagementException if an error occurs when deleting a tenant theme\n      */\n-    public boolean deleteTenantTheme(int tenantId) throws APIManagementException {\n+    public void deleteTenantTheme(int tenantId) throws APIManagementException {\n \n         try (Connection connection = APIMgtDBUtil.getConnection();\n              PreparedStatement statement = connection\n                      .prepareStatement(SQLConstants.TenantThemeConstants.DELETE_TENANT_THEME)) {\n             statement.setInt(1, tenantId);\n-            ResultSet resultSet = statement.executeQuery();\n-            return resultSet.next();\n+            statement.executeUpdate();\n         } catch (SQLException e) {\n             handleException(\"Failed to delete tenant theme of tenant \"\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n-        return false;\n     }\n }\n", "next_change": {"commit": "0b0ed544da530b1f2f0140694df94c4639320ae9", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b7ce95ac174..d36217ee6d4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15519,122 +15519,4 @@ public class ApiMgtDAO {\n             handleException(\"Failed to remove resource scopes for: \" + apiIdentifier, e);\n         }\n     }\n-\n-    /**\n-     * Adds a tenant theme to the database\n-     *\n-     * @param tenantId     tenant ID of user\n-     * @param themeContent content of the tenant theme\n-     * @throws APIManagementException\n-     */\n-    public void addTenantTheme(int tenantId, InputStream themeContent) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.TenantThemeConstants.ADD_TENANT_THEME)) {\n-            statement.setInt(1, tenantId);\n-            if (connection.getMetaData().getDriverName().contains(\"PostgreSQL\") || connection.getMetaData()\n-                    .getDatabaseProductName().contains(\"DB2\")) {\n-                statement.setBinaryStream(2, themeContent, IOUtils.toByteArray(themeContent).length);\n-            } else {\n-                statement.setBinaryStream(2, themeContent);\n-            }\n-            statement.executeUpdate();\n-        } catch (SQLException | IOException e) {\n-            handleException(\"Failed to add tenant theme of tenant \"\n-                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n-        }\n-    }\n-\n-    /**\n-     * Updates a tenant theme in the database\n-     *\n-     * @param tenantId     tenant ID of user\n-     * @param themeContent content of the tenant theme\n-     * @throws APIManagementException\n-     */\n-    public void updateTenantTheme(int tenantId, InputStream themeContent) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement =\n-                     connection.prepareStatement(SQLConstants.TenantThemeConstants.UPDATE_TENANT_THEME)) {\n-            if (connection.getMetaData().getDriverName().contains(\"PostgreSQL\") || connection.getMetaData()\n-                    .getDatabaseProductName().contains(\"DB2\")) {\n-                statement.setBinaryStream(1, themeContent, IOUtils.toByteArray(themeContent).length);\n-            } else {\n-                statement.setBinaryStream(1, themeContent);\n-            }\n-            statement.setInt(2, tenantId);\n-            statement.executeUpdate();\n-        } catch (SQLException | IOException e) {\n-            handleException(\"Failed to update tenant theme of tenant \"\n-                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n-        }\n-    }\n-\n-    /**\n-     * Retrieves a tenant theme from the database\n-     *\n-     * @param tenantId tenant ID of user\n-     * @return content of the tenant theme\n-     * @throws APIManagementException\n-     */\n-    public InputStream getTenantTheme(int tenantId) throws APIManagementException {\n-\n-        InputStream tenantThemeContent = null;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.TenantThemeConstants.GET_TENANT_THEME)) {\n-            statement.setInt(1, tenantId);\n-            ResultSet resultSet = statement.executeQuery();\n-            if (resultSet.next()) {\n-                tenantThemeContent = resultSet.getBinaryStream(\"THEME\");\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to fetch tenant theme of tenant \"\n-                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n-        }\n-        return tenantThemeContent;\n-    }\n-\n-    /**\n-     * Checks whether a tenant theme exist for a particular tenant\n-     *\n-     * @param tenantId tenant ID of user\n-     * @return true if a tenant theme exist for a particular tenant ID, false otherwise\n-     * @throws APIManagementException\n-     */\n-    public boolean isTenantThemeExist(int tenantId) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.TenantThemeConstants.GET_TENANT_THEME)) {\n-            statement.setInt(1, tenantId);\n-            ResultSet resultSet = statement.executeQuery();\n-            return resultSet.next();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to check whether tenant theme exist for tenant \"\n-                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Deletes a tenant theme from the database\n-     *\n-     * @param tenantId tenant ID of user\n-     * @throws APIManagementException if an error occurs when deleting a tenant theme\n-     */\n-    public void deleteTenantTheme(int tenantId) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.TenantThemeConstants.DELETE_TENANT_THEME)) {\n-            statement.setInt(1, tenantId);\n-            statement.executeUpdate();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete tenant theme of tenant \"\n-                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n-        }\n-    }\n }\n", "next_change": {"commit": "89a921cdfa36bb8c1eb54e8d6e7a29e1dd4805f5", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d36217ee6d4..2468dbd7076 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15519,4 +15547,113 @@ public class ApiMgtDAO {\n             handleException(\"Failed to remove resource scopes for: \" + apiIdentifier, e);\n         }\n     }\n+\n+    /**\n+     * Adds a tenant theme to the database\n+     *\n+     * @param tenantId     tenant ID of user\n+     * @param themeContent content of the tenant theme\n+     * @throws APIManagementException if an error occurs when adding a tenant theme to the database\n+     */\n+    public void addTenantTheme(int tenantId, InputStream themeContent) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.ADD_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+            statement.setBinaryStream(2, themeContent);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+    }\n+\n+    /**\n+     * Updates an existing tenant theme in the database\n+     *\n+     * @param tenantId     tenant ID of user\n+     * @param themeContent content of the tenant theme\n+     * @throws APIManagementException if an error occurs when updating an existing tenant theme in the database\n+     */\n+    public void updateTenantTheme(int tenantId, InputStream themeContent) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement =\n+                     connection.prepareStatement(SQLConstants.TenantThemeConstants.UPDATE_TENANT_THEME)) {\n+            statement.setBinaryStream(1, themeContent);\n+            statement.setInt(2, tenantId);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to update tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+    }\n+\n+    /**\n+     * Retrieves a tenant theme from the database\n+     *\n+     * @param tenantId tenant ID of user\n+     * @return content of the tenant theme\n+     * @throws APIManagementException if an error occurs when retrieving a tenant theme from the database\n+     */\n+    public InputStream getTenantTheme(int tenantId) throws APIManagementException {\n+\n+        InputStream tenantThemeContent = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.GET_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+            ResultSet resultSet = statement.executeQuery();\n+            if (resultSet.next()) {\n+                tenantThemeContent = resultSet.getBinaryStream(\"THEME\");\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to fetch tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+        return tenantThemeContent;\n+    }\n+\n+    /**\n+     * Checks whether a tenant theme exist for a particular tenant\n+     *\n+     * @param tenantId tenant ID of user\n+     * @return true if a tenant theme exist for a particular tenant ID, false otherwise\n+     * @throws APIManagementException if an error occurs when determining whether a tenant theme exists for a given\n+     *                                tenant ID\n+     */\n+    public boolean isTenantThemeExist(int tenantId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.GET_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+            ResultSet resultSet = statement.executeQuery();\n+            return resultSet.next();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to check whether tenant theme exist for tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Deletes a tenant theme from the database\n+     *\n+     * @param tenantId tenant ID of user\n+     * @throws APIManagementException if an error occurs when deleting a tenant theme from the database\n+     */\n+    public void deleteTenantTheme(int tenantId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.TenantThemeConstants.DELETE_TENANT_THEME)) {\n+            statement.setInt(1, tenantId);\n+            statement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete tenant theme of tenant \"\n+                    + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n+        }\n+    }\n }\n", "next_change": {"commit": "90c485345e50aef950a396a8645b6b930bc7ee2e", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 2468dbd7076..5b90e89a6ae 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15656,4 +15259,29 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n+    \n+    /**\n+     * Return the existing versions for the given api name for the provider\n+     * @param apiName api name\n+     * @param apiProvider provider\n+     * @return set version\n+     * @throws APIManagementException\n+     */\n+    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n+        Set<String> versions = new HashSet<String>();\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n+            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n+            statement.setString(2, apiName);\n+            ResultSet resultSet = statement.executeQuery();\n+            while (resultSet.next()) {\n+                versions.add(resultSet.getString(\"API_VERSION\"));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n+                    e);\n+        }\n+        return versions;\n+    }\n }\n", "next_change": {"commit": "a0b1f3bab1310a1d2ce24042819364ca0103929d", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 5b90e89a6ae..111f35faef3 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15259,29 +15454,4 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n-    \n-    /**\n-     * Return the existing versions for the given api name for the provider\n-     * @param apiName api name\n-     * @param apiProvider provider\n-     * @return set version\n-     * @throws APIManagementException\n-     */\n-    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n-        Set<String> versions = new HashSet<String>();\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n-            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n-            statement.setString(2, apiName);\n-            ResultSet resultSet = statement.executeQuery();\n-            while (resultSet.next()) {\n-                versions.add(resultSet.getString(\"API_VERSION\"));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n-                    e);\n-        }\n-        return versions;\n-    }\n }\n", "next_change": {"commit": "5ee1c9db916fbfea6df7dff3b7120adcd91d9b21", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 111f35faef3..c345883d817 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15454,4 +15431,273 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n+\n+    /**\n+     * Get most recent revision id of the revisions created for a particular API.\n+     *\n+     * @return revision id\n+     * @throws APIManagementException if an error occurs while retrieving revision id\n+     */\n+    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n+        int revisionId = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    revisionId = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionId;\n+    }\n+\n+    /**\n+     * Adds an API revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getRevisionedURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * To get the input stream from string.\n+     *\n+     * @param value : Relevant string that need to be converted to input stream.\n+     * @return input stream.\n+     */\n+    private InputStream getInputStream(String value) {\n+\n+        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n+        return new ByteArrayInputStream(cert);\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revision object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revisions List object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n+\n+        List<APIRevision> revisionList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevision apiRevision = new APIRevision();\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                    revisionList.add(apiRevision);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionList;\n+    }\n }\n", "next_change": {"commit": "c5f0dce495bd0bd70b2868910c01b755d2ae428f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex c345883d817..911cc7bcbf3 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15700,4 +15704,29 @@ public class ApiMgtDAO {\n         }\n         return revisionList;\n     }\n+\n+    /**\n+     * Get a provided api uuid is in the revision db table\n+     *\n+     * @return String apiUUID\n+     * @throws APIManagementException if an error occurs while checking revision table\n+     */\n+    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setApiUUID(rs.getString(1));\n+                    apiRevision.setId(rs.getInt(2));\n+                    apiRevision.setRevisionUUID(apiUUID);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n+        }\n+        return apiRevision;\n+    }\n }\n", "next_change": {"commit": "551e8005cf73bc23547da10360e07c23ca635342", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 911cc7bcbf3..e263e95ca31 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15729,4 +15730,105 @@ public class ApiMgtDAO {\n         }\n         return apiRevision;\n     }\n+\n+    /**\n+     * Adds an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n+                    statement.setString(4, apiRevisionDeployment.getType());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing deployment name and type\n+     *\n+     * @return APIRevisionDeployment object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevisionDeployment getAPIRevisionDeploymentByNameAndType(String name, String type) throws APIManagementException {\n+        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n+            statement.setString(1, name);\n+            statement.setString(2, type);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setType(rs.getString(4));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" +\n+                    name +\" and type: \" + type, e);\n+        }\n+        return apiRevisionDeployment;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing revision uuid\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setType(rs.getString(4));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n+                    revisionUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+\n+\n }\n", "next_change": {"commit": "a9ed9f2065b948c187b1d854505ef37d2d21090b", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex e263e95ca31..460f0994925 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15830,5 +15830,42 @@ public class ApiMgtDAO {\n         return apiRevisionDeploymentList;\n     }\n \n+    /**\n+     * Remove an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setString(3, apiRevisionDeployment.getType());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n \n }\n", "next_change": {"commit": "6212e0d1a79974db6cef329b6e32719d2d21b66f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 460f0994925..3fe883b9b36 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15867,5 +15867,248 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_URL_MAPPING table\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_URL_MAPPING table\n+                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n \n }\n", "next_change": {"commit": "2809e66ce7558218fa0dd2ac5e74a4e82ff5fb83", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 3fe883b9b36..1cad2a34777 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15432,683 +15426,4 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n-\n-    /**\n-     * Get most recent revision id of the revisions created for a particular API.\n-     *\n-     * @return revision id\n-     * @throws APIManagementException if an error occurs while retrieving revision id\n-     */\n-    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n-        int revisionId = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    revisionId = rs.getInt(1);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionId;\n-    }\n-\n-    /**\n-     * Adds an API revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getRevisionedURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * To get the input stream from string.\n-     *\n-     * @param value : Relevant string that need to be converted to input stream.\n-     * @return input stream.\n-     */\n-    private InputStream getInputStream(String value) {\n-\n-        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n-        return new ByteArrayInputStream(cert);\n-    }\n-\n-    /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revision object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revisions List object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n-\n-        List<APIRevision> revisionList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevision apiRevision = new APIRevision();\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                    revisionList.add(apiRevision);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionList;\n-    }\n-\n-    /**\n-     * Get a provided api uuid is in the revision db table\n-     *\n-     * @return String apiUUID\n-     * @throws APIManagementException if an error occurs while checking revision table\n-     */\n-    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setApiUUID(rs.getString(1));\n-                    apiRevision.setId(rs.getInt(2));\n-                    apiRevision.setRevisionUUID(apiUUID);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Adds an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n-                    statement.setString(4, apiRevisionDeployment.getType());\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n-                    + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing deployment name and type\n-     *\n-     * @return APIRevisionDeployment object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevisionDeployment getAPIRevisionDeploymentByNameAndType(String name, String type) throws APIManagementException {\n-        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n-            statement.setString(1, name);\n-            statement.setString(2, type);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setType(rs.getString(4));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" +\n-                    name +\" and type: \" + type, e);\n-        }\n-        return apiRevisionDeployment;\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing revision uuid\n-     *\n-     * @return List<APIRevisionDeployment> object\n-     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n-     */\n-    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setType(rs.getString(4));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n-                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n-                    revisionUUID, e);\n-        }\n-        return apiRevisionDeploymentList;\n-    }\n-\n-    /**\n-     * Remove an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.setString(3, apiRevisionDeployment.getType());\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                    + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_URL_MAPPING table\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_URL_MAPPING table\n-                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n }\n", "next_change": {"commit": "d56d577f622bd982dbd9b5eed0c16e9418bd594e", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 1cad2a34777..68a09ffef28 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15426,4 +15433,715 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n+\n+    /**\n+     * Get count of the revisions created for a particular API.\n+     *\n+     * @return revision count\n+     * @throws APIManagementException if an error occurs while retrieving revision count\n+     */\n+    public int getRevisionCountByAPI(String apiUUID) throws APIManagementException {\n+        int count = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_COUNT_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    count = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revisions count for API UUID: \" + apiUUID, e);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Get most recent revision id of the revisions created for a particular API.\n+     *\n+     * @return revision id\n+     * @throws APIManagementException if an error occurs while retrieving revision id\n+     */\n+    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n+        int revisionId = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    revisionId = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionId;\n+    }\n+\n+    /**\n+     * Adds an API revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getRevisionedURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * To get the input stream from string.\n+     *\n+     * @param value : Relevant string that need to be converted to input stream.\n+     * @return input stream.\n+     */\n+    private InputStream getInputStream(String value) {\n+\n+        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n+        return new ByteArrayInputStream(cert);\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revision object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revisions List object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n+\n+        List<APIRevision> revisionList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevision apiRevision = new APIRevision();\n+                    List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    for (APIRevision apiRevisionObject : revisionList) {\n+                        if (apiRevisionObject.getId() == rs.getInt(1)) {\n+                            apiRevisionDeploymentList = apiRevisionObject.getApiRevisionDeploymentList();\n+                            revisionList.remove(apiRevisionObject);\n+                        }\n+                    }\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                    if (!StringUtils.isEmpty(rs.getString(7))) {\n+                        apiRevisionDeployment.setDeployment(rs.getString(7));\n+                        apiRevisionDeployment.setRevisionUUID(rs.getString(8));\n+                        apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(9));\n+                        apiRevisionDeployment.setDeployedTime(rs.getString(10));\n+                        apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                    }\n+                    apiRevision.setApiRevisionDeploymentList(apiRevisionDeploymentList);\n+                    revisionList.add(apiRevision);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionList;\n+    }\n+\n+    /**\n+     * Get a provided api uuid is in the revision db table\n+     *\n+     * @return String apiUUID\n+     * @throws APIManagementException if an error occurs while checking revision table\n+     */\n+    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setApiUUID(rs.getString(1));\n+                    apiRevision.setId(rs.getInt(2));\n+                    apiRevision.setRevisionUUID(apiUUID);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Adds an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \" + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing deployment name\n+     *\n+     * @return APIRevisionDeployment object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevisionDeployment getAPIRevisionDeploymentByName(String name) throws APIManagementException {\n+        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n+            statement.setString(1, name);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" + name, e);\n+        }\n+        return apiRevisionDeployment;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing revision uuid\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n+                    revisionUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+\n+    /**\n+     * Remove an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_URL_MAPPING table\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_URL_MAPPING table\n+                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "10c140890f72638b1c497e5c33008a32a97b219a", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 68a09ffef28..ccd0e675049 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15433,715 +15426,53 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n-\n-    /**\n-     * Get count of the revisions created for a particular API.\n-     *\n-     * @return revision count\n-     * @throws APIManagementException if an error occurs while retrieving revision count\n-     */\n-    public int getRevisionCountByAPI(String apiUUID) throws APIManagementException {\n-        int count = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_COUNT_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    count = rs.getInt(1);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revisions count for API UUID: \" + apiUUID, e);\n-        }\n-        return count;\n-    }\n-\n-    /**\n-     * Get most recent revision id of the revisions created for a particular API.\n-     *\n-     * @return revision id\n-     * @throws APIManagementException if an error occurs while retrieving revision id\n-     */\n-    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n-        int revisionId = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    revisionId = rs.getInt(1);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionId;\n-    }\n-\n-    /**\n-     * Adds an API revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getRevisionedURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * To get the input stream from string.\n-     *\n-     * @param value : Relevant string that need to be converted to input stream.\n-     * @return input stream.\n-     */\n-    private InputStream getInputStream(String value) {\n-\n-        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n-        return new ByteArrayInputStream(cert);\n-    }\n-\n-    /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revision object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n-        }\n-        return apiRevision;\n-    }\n-\n+    \n     /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revisions List object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n+     * Return the existing versions for the given api name for the provider\n+     * @param apiName api name\n+     * @param apiProvider provider\n+     * @return set version\n+     * @throws APIManagementException\n      */\n-    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n+    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n+        Set<String> versions = new HashSet<String>();\n \n-        List<APIRevision> revisionList = new ArrayList<>();\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevision apiRevision = new APIRevision();\n-                    List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    for (APIRevision apiRevisionObject : revisionList) {\n-                        if (apiRevisionObject.getId() == rs.getInt(1)) {\n-                            apiRevisionDeploymentList = apiRevisionObject.getApiRevisionDeploymentList();\n-                            revisionList.remove(apiRevisionObject);\n-                        }\n-                    }\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                    if (!StringUtils.isEmpty(rs.getString(7))) {\n-                        apiRevisionDeployment.setDeployment(rs.getString(7));\n-                        apiRevisionDeployment.setRevisionUUID(rs.getString(8));\n-                        apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(9));\n-                        apiRevisionDeployment.setDeployedTime(rs.getString(10));\n-                        apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                    }\n-                    apiRevision.setApiRevisionDeploymentList(apiRevisionDeploymentList);\n-                    revisionList.add(apiRevision);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionList;\n-    }\n-\n-    /**\n-     * Get a provided api uuid is in the revision db table\n-     *\n-     * @return String apiUUID\n-     * @throws APIManagementException if an error occurs while checking revision table\n-     */\n-    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setApiUUID(rs.getString(1));\n-                    apiRevision.setId(rs.getInt(2));\n-                    apiRevision.setRevisionUUID(apiUUID);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Adds an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n+            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n+            statement.setString(2, apiName);\n+            ResultSet resultSet = statement.executeQuery();\n+            while (resultSet.next()) {\n+                versions.add(resultSet.getString(\"API_VERSION\"));\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \" + apiRevisionId, e);\n+            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n+                    e);\n         }\n+        return versions;\n     }\n-\n     /**\n-     * Get APIRevisionDeployment details by providing deployment name\n-     *\n-     * @return APIRevisionDeployment object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n+     * Return ids of the versions for the given name for the given provider\n+     * @param apiName api name\n+     * @param apiProvider provider\n+     * @return set ids\n+     * @throws APIManagementException\n      */\n-    public APIRevisionDeployment getAPIRevisionDeploymentByName(String name) throws APIManagementException {\n-        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n-            statement.setString(1, name);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" + name, e);\n-        }\n-        return apiRevisionDeployment;\n-    }\n+    public Set<String> getUUIDsOfAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n+        Set<String> versions = new HashSet<String>();\n \n-    /**\n-     * Get APIRevisionDeployment details by providing revision uuid\n-     *\n-     * @return List<APIRevisionDeployment> object\n-     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n-     */\n-    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n-                    revisionUUID, e);\n-        }\n-        return apiRevisionDeploymentList;\n-    }\n-\n-    /**\n-     * Remove an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                    + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_URL_MAPPING table\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_URL_MAPPING table\n-                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS_UUID)) {\n+            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n+            statement.setString(2, apiName);\n+            ResultSet resultSet = statement.executeQuery();\n+            while (resultSet.next()) {\n+                versions.add(resultSet.getString(\"API_UUID\"));\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n+            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n+                    e);\n         }\n+        return versions;\n     }\n-\n }\n", "next_change": {"commit": "fd8d3dc4ada8100a745c41795a894da514315544", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex ccd0e675049..c803921a19d 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15426,53 +15478,4 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n-    \n-    /**\n-     * Return the existing versions for the given api name for the provider\n-     * @param apiName api name\n-     * @param apiProvider provider\n-     * @return set version\n-     * @throws APIManagementException\n-     */\n-    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n-        Set<String> versions = new HashSet<String>();\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n-            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n-            statement.setString(2, apiName);\n-            ResultSet resultSet = statement.executeQuery();\n-            while (resultSet.next()) {\n-                versions.add(resultSet.getString(\"API_VERSION\"));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n-                    e);\n-        }\n-        return versions;\n-    }\n-    /**\n-     * Return ids of the versions for the given name for the given provider\n-     * @param apiName api name\n-     * @param apiProvider provider\n-     * @return set ids\n-     * @throws APIManagementException\n-     */\n-    public Set<String> getUUIDsOfAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n-        Set<String> versions = new HashSet<String>();\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS_UUID)) {\n-            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n-            statement.setString(2, apiName);\n-            ResultSet resultSet = statement.executeQuery();\n-            while (resultSet.next()) {\n-                versions.add(resultSet.getString(\"API_UUID\"));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n-                    e);\n-        }\n-        return versions;\n-    }\n }\n", "next_change": {"commit": "086073a1a7dccb9ea8875cd81d5e6f351ad750b1", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex c803921a19d..045ddb207fc 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15478,4 +15427,53 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n+    \n+    /**\n+     * Return the existing versions for the given api name for the provider\n+     * @param apiName api name\n+     * @param apiProvider provider\n+     * @return set version\n+     * @throws APIManagementException\n+     */\n+    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n+        Set<String> versions = new HashSet<String>();\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n+            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n+            statement.setString(2, apiName);\n+            ResultSet resultSet = statement.executeQuery();\n+            while (resultSet.next()) {\n+                versions.add(resultSet.getString(\"API_VERSION\"));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n+                    e);\n+        }\n+        return versions;\n+    }\n+    /**\n+     * Return ids of the versions for the given name for the given provider\n+     * @param apiName api name\n+     * @param apiProvider provider\n+     * @return set ids\n+     * @throws APIManagementException\n+     */\n+    public Set<String> getUUIDsOfAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n+        Set<String> versions = new HashSet<String>();\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS_UUID)) {\n+            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n+            statement.setString(2, apiName);\n+            ResultSet resultSet = statement.executeQuery();\n+            while (resultSet.next()) {\n+                versions.add(resultSet.getString(\"API_UUID\"));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n+                    e);\n+        }\n+        return versions;\n+    }\n }\n", "next_change": {"commit": "47f711d60c3a92f7318346b6260c2396c8c6a6b0", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 045ddb207fc..26e6b290425 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15427,53 +15433,744 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n-    \n+\n     /**\n-     * Return the existing versions for the given api name for the provider\n-     * @param apiName api name\n-     * @param apiProvider provider\n-     * @return set version\n-     * @throws APIManagementException\n+     * Get count of the revisions created for a particular API.\n+     *\n+     * @return revision count\n+     * @throws APIManagementException if an error occurs while retrieving revision count\n      */\n-    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n-        Set<String> versions = new HashSet<String>();\n+    public int getRevisionCountByAPI(String apiUUID) throws APIManagementException {\n+        int count = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_COUNT_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    count = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revisions count for API UUID: \" + apiUUID, e);\n+        }\n+        return count;\n+    }\n \n+    /**\n+     * Get most recent revision id of the revisions created for a particular API.\n+     *\n+     * @return revision id\n+     * @throws APIManagementException if an error occurs while retrieving revision id\n+     */\n+    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n+        int revisionId = 0;\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n-            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n-            statement.setString(2, apiName);\n-            ResultSet resultSet = statement.executeQuery();\n-            while (resultSet.next()) {\n-                versions.add(resultSet.getString(\"API_VERSION\"));\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    revisionId = rs.getInt(1);\n+                }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n-                    e);\n+            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n         }\n-        return versions;\n+        return revisionId;\n     }\n+\n     /**\n-     * Return ids of the versions for the given name for the given provider\n-     * @param apiName api name\n-     * @param apiProvider provider\n-     * @return set ids\n-     * @throws APIManagementException\n+     * Adds an API revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getRevisionedURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * To get the input stream from string.\n+     *\n+     * @param value : Relevant string that need to be converted to input stream.\n+     * @return input stream.\n      */\n-    public Set<String> getUUIDsOfAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n-        Set<String> versions = new HashSet<String>();\n+    private InputStream getInputStream(String value) {\n+\n+        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n+        return new ByteArrayInputStream(cert);\n+    }\n \n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revision object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n         try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS_UUID)) {\n-            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n-            statement.setString(2, apiName);\n-            ResultSet resultSet = statement.executeQuery();\n-            while (resultSet.next()) {\n-                versions.add(resultSet.getString(\"API_UUID\"));\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n-                    e);\n+            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n         }\n-        return versions;\n+        return apiRevision;\n     }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revisions List object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n+\n+        List<APIRevision> revisionList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevision apiRevision = new APIRevision();\n+                    List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    for (APIRevision apiRevisionObject : revisionList) {\n+                        if (apiRevisionObject.getId() == rs.getInt(1)) {\n+                            apiRevisionDeploymentList = apiRevisionObject.getApiRevisionDeploymentList();\n+                            revisionList.remove(apiRevisionObject);\n+                        }\n+                    }\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                    if (!StringUtils.isEmpty(rs.getString(7))) {\n+                        apiRevisionDeployment.setDeployment(rs.getString(7));\n+                        //apiRevisionDeployment.setRevisionUUID(rs.getString(8));\n+                        apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(9));\n+                        apiRevisionDeployment.setDeployedTime(rs.getString(10));\n+                        apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                    }\n+                    apiRevision.setApiRevisionDeploymentList(apiRevisionDeploymentList);\n+                    revisionList.add(apiRevision);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionList;\n+    }\n+\n+    /**\n+     * Get a provided api uuid is in the revision db table\n+     *\n+     * @return String apiUUID\n+     * @throws APIManagementException if an error occurs while checking revision table\n+     */\n+    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setApiUUID(rs.getString(1));\n+                    apiRevision.setId(rs.getInt(2));\n+                    apiRevision.setRevisionUUID(apiUUID);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Adds an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \" + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing deployment name\n+     *\n+     * @return APIRevisionDeployment object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevisionDeployment getAPIRevisionDeploymentByName(String name) throws APIManagementException {\n+        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n+            statement.setString(1, name);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" + name, e);\n+        }\n+        return apiRevisionDeployment;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing revision uuid\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n+                    revisionUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing ApiUUID\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentsByApiUUID(String apiUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for api uuid: \" +\n+                    apiUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+    /**\n+     * Remove an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_URL_MAPPING table\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_URL_MAPPING table\n+                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "c7998c8b8ace9b82a97793eda9fc4a86f4388532", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 26e6b290425..ec866c0a33c 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15433,744 +15478,4 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n-\n-    /**\n-     * Get count of the revisions created for a particular API.\n-     *\n-     * @return revision count\n-     * @throws APIManagementException if an error occurs while retrieving revision count\n-     */\n-    public int getRevisionCountByAPI(String apiUUID) throws APIManagementException {\n-        int count = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_COUNT_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    count = rs.getInt(1);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revisions count for API UUID: \" + apiUUID, e);\n-        }\n-        return count;\n-    }\n-\n-    /**\n-     * Get most recent revision id of the revisions created for a particular API.\n-     *\n-     * @return revision id\n-     * @throws APIManagementException if an error occurs while retrieving revision id\n-     */\n-    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n-        int revisionId = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    revisionId = rs.getInt(1);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionId;\n-    }\n-\n-    /**\n-     * Adds an API revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getRevisionedURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * To get the input stream from string.\n-     *\n-     * @param value : Relevant string that need to be converted to input stream.\n-     * @return input stream.\n-     */\n-    private InputStream getInputStream(String value) {\n-\n-        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n-        return new ByteArrayInputStream(cert);\n-    }\n-\n-    /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revision object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revisions List object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n-\n-        List<APIRevision> revisionList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevision apiRevision = new APIRevision();\n-                    List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    for (APIRevision apiRevisionObject : revisionList) {\n-                        if (apiRevisionObject.getId() == rs.getInt(1)) {\n-                            apiRevisionDeploymentList = apiRevisionObject.getApiRevisionDeploymentList();\n-                            revisionList.remove(apiRevisionObject);\n-                        }\n-                    }\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                    if (!StringUtils.isEmpty(rs.getString(7))) {\n-                        apiRevisionDeployment.setDeployment(rs.getString(7));\n-                        //apiRevisionDeployment.setRevisionUUID(rs.getString(8));\n-                        apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(9));\n-                        apiRevisionDeployment.setDeployedTime(rs.getString(10));\n-                        apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                    }\n-                    apiRevision.setApiRevisionDeploymentList(apiRevisionDeploymentList);\n-                    revisionList.add(apiRevision);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionList;\n-    }\n-\n-    /**\n-     * Get a provided api uuid is in the revision db table\n-     *\n-     * @return String apiUUID\n-     * @throws APIManagementException if an error occurs while checking revision table\n-     */\n-    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setApiUUID(rs.getString(1));\n-                    apiRevision.setId(rs.getInt(2));\n-                    apiRevision.setRevisionUUID(apiUUID);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Adds an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \" + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing deployment name\n-     *\n-     * @return APIRevisionDeployment object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevisionDeployment getAPIRevisionDeploymentByName(String name) throws APIManagementException {\n-        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n-            statement.setString(1, name);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" + name, e);\n-        }\n-        return apiRevisionDeployment;\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing revision uuid\n-     *\n-     * @return List<APIRevisionDeployment> object\n-     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n-     */\n-    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n-                    revisionUUID, e);\n-        }\n-        return apiRevisionDeploymentList;\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing ApiUUID\n-     *\n-     * @return List<APIRevisionDeployment> object\n-     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n-     */\n-    public List<APIRevisionDeployment> getAPIRevisionDeploymentsByApiUUID(String apiUUID) throws APIManagementException {\n-        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for api uuid: \" +\n-                    apiUUID, e);\n-        }\n-        return apiRevisionDeploymentList;\n-    }\n-    /**\n-     * Remove an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                    + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_URL_MAPPING table\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_URL_MAPPING table\n-                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n }\n", "next_change": {"commit": "330961ad0ba118c67d745425169fab00775af54f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex ec866c0a33c..e78ce19519e 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15478,4 +15479,53 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n+    \n+    /**\n+     * Return the existing versions for the given api name for the provider\n+     * @param apiName api name\n+     * @param apiProvider provider\n+     * @return set version\n+     * @throws APIManagementException\n+     */\n+    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n+        Set<String> versions = new HashSet<String>();\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n+            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n+            statement.setString(2, apiName);\n+            ResultSet resultSet = statement.executeQuery();\n+            while (resultSet.next()) {\n+                versions.add(resultSet.getString(\"API_VERSION\"));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n+                    e);\n+        }\n+        return versions;\n+    }\n+    /**\n+     * Return ids of the versions for the given name for the given provider\n+     * @param apiName api name\n+     * @param apiProvider provider\n+     * @return set ids\n+     * @throws APIManagementException\n+     */\n+    public Set<String> getUUIDsOfAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n+        Set<String> versions = new HashSet<String>();\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS_UUID)) {\n+            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n+            statement.setString(2, apiName);\n+            ResultSet resultSet = statement.executeQuery();\n+            while (resultSet.next()) {\n+                versions.add(resultSet.getString(\"API_UUID\"));\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n+                    e);\n+        }\n+        return versions;\n+    }\n }\n", "next_change": {"commit": "8cdef9ecd5233ee32b13a1abbe3f7be09f7ea0b3", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex e78ce19519e..ded140006b6 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15479,53 +15543,4 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n-    \n-    /**\n-     * Return the existing versions for the given api name for the provider\n-     * @param apiName api name\n-     * @param apiProvider provider\n-     * @return set version\n-     * @throws APIManagementException\n-     */\n-    public Set<String> getAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n-        Set<String> versions = new HashSet<String>();\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS)) {\n-            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n-            statement.setString(2, apiName);\n-            ResultSet resultSet = statement.executeQuery();\n-            while (resultSet.next()) {\n-                versions.add(resultSet.getString(\"API_VERSION\"));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n-                    e);\n-        }\n-        return versions;\n-    }\n-    /**\n-     * Return ids of the versions for the given name for the given provider\n-     * @param apiName api name\n-     * @param apiProvider provider\n-     * @return set ids\n-     * @throws APIManagementException\n-     */\n-    public Set<String> getUUIDsOfAPIVersions(String apiName, String apiProvider) throws APIManagementException {\n-        Set<String> versions = new HashSet<String>();\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-                PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_API_VERSIONS_UUID)) {\n-            statement.setString(1, APIUtil.replaceEmailDomainBack(apiProvider));\n-            statement.setString(2, apiName);\n-            ResultSet resultSet = statement.executeQuery();\n-            while (resultSet.next()) {\n-                versions.add(resultSet.getString(\"API_UUID\"));\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving versions for api \" + apiName + \" for the provider \" + apiProvider,\n-                    e);\n-        }\n-        return versions;\n-    }\n }\n", "next_change": {"commit": "ba626a226b085de62a2a542e207759f77042cbf4", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex ded140006b6..05712b15ade 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15543,4 +15493,744 @@ public class ApiMgtDAO {\n                     + APIUtil.getTenantDomainFromTenantId(tenantId), e);\n         }\n     }\n+\n+    /**\n+     * Get count of the revisions created for a particular API.\n+     *\n+     * @return revision count\n+     * @throws APIManagementException if an error occurs while retrieving revision count\n+     */\n+    public int getRevisionCountByAPI(String apiUUID) throws APIManagementException {\n+        int count = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_COUNT_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    count = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revisions count for API UUID: \" + apiUUID, e);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Get most recent revision id of the revisions created for a particular API.\n+     *\n+     * @return revision id\n+     * @throws APIManagementException if an error occurs while retrieving revision id\n+     */\n+    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n+        int revisionId = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    revisionId = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionId;\n+    }\n+\n+    /**\n+     * Adds an API revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getRevisionedURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * To get the input stream from string.\n+     *\n+     * @param value : Relevant string that need to be converted to input stream.\n+     * @return input stream.\n+     */\n+    private InputStream getInputStream(String value) {\n+\n+        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n+        return new ByteArrayInputStream(cert);\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revision object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revisions List object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n+\n+        List<APIRevision> revisionList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevision apiRevision = new APIRevision();\n+                    List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    for (APIRevision apiRevisionObject : revisionList) {\n+                        if (apiRevisionObject.getId() == rs.getInt(1)) {\n+                            apiRevisionDeploymentList = apiRevisionObject.getApiRevisionDeploymentList();\n+                            revisionList.remove(apiRevisionObject);\n+                        }\n+                    }\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                    if (!StringUtils.isEmpty(rs.getString(7))) {\n+                        apiRevisionDeployment.setDeployment(rs.getString(7));\n+                        //apiRevisionDeployment.setRevisionUUID(rs.getString(8));\n+                        apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(9));\n+                        apiRevisionDeployment.setDeployedTime(rs.getString(10));\n+                        apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                    }\n+                    apiRevision.setApiRevisionDeploymentList(apiRevisionDeploymentList);\n+                    revisionList.add(apiRevision);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionList;\n+    }\n+\n+    /**\n+     * Get a provided api uuid is in the revision db table\n+     *\n+     * @return String apiUUID\n+     * @throws APIManagementException if an error occurs while checking revision table\n+     */\n+    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setApiUUID(rs.getString(1));\n+                    apiRevision.setId(rs.getInt(2));\n+                    apiRevision.setRevisionUUID(apiUUID);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Adds an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \" + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing deployment name\n+     *\n+     * @return APIRevisionDeployment object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevisionDeployment getAPIRevisionDeploymentByName(String name) throws APIManagementException {\n+        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n+            statement.setString(1, name);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" + name, e);\n+        }\n+        return apiRevisionDeployment;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing revision uuid\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n+                    revisionUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing ApiUUID\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentsByApiUUID(String apiUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for api uuid: \" +\n+                    apiUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+    /**\n+     * Remove an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_URL_MAPPING table\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_URL_MAPPING table\n+                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "0ac481c817e84ea23ce8210cd8ad44c93ab2e286", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 05712b15ade..71cca2d8186 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15805,432 +15802,4 @@ public class ApiMgtDAO {\n         }\n         return revisionList;\n     }\n-\n-    /**\n-     * Get a provided api uuid is in the revision db table\n-     *\n-     * @return String apiUUID\n-     * @throws APIManagementException if an error occurs while checking revision table\n-     */\n-    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setApiUUID(rs.getString(1));\n-                    apiRevision.setId(rs.getInt(2));\n-                    apiRevision.setRevisionUUID(apiUUID);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Adds an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \" + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing deployment name\n-     *\n-     * @return APIRevisionDeployment object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevisionDeployment getAPIRevisionDeploymentByName(String name) throws APIManagementException {\n-        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n-            statement.setString(1, name);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" + name, e);\n-        }\n-        return apiRevisionDeployment;\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing revision uuid\n-     *\n-     * @return List<APIRevisionDeployment> object\n-     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n-     */\n-    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n-                    revisionUUID, e);\n-        }\n-        return apiRevisionDeploymentList;\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing ApiUUID\n-     *\n-     * @return List<APIRevisionDeployment> object\n-     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n-     */\n-    public List<APIRevisionDeployment> getAPIRevisionDeploymentsByApiUUID(String apiUUID) throws APIManagementException {\n-        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n-                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for api uuid: \" +\n-                    apiUUID, e);\n-        }\n-        return apiRevisionDeploymentList;\n-    }\n-    /**\n-     * Remove an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                    + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_URL_MAPPING table\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_URL_MAPPING table\n-                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n }\n", "next_change": {"commit": "f4f39620dffa3c496899beeef1be172fdafc364e", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 71cca2d8186..90d3786ee1a 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15802,4 +15806,29 @@ public class ApiMgtDAO {\n         }\n         return revisionList;\n     }\n+\n+    /**\n+     * Get a provided api uuid is in the revision db table\n+     *\n+     * @return String apiUUID\n+     * @throws APIManagementException if an error occurs while checking revision table\n+     */\n+    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setApiUUID(rs.getString(1));\n+                    apiRevision.setId(rs.getInt(2));\n+                    apiRevision.setRevisionUUID(apiUUID);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n+        }\n+        return apiRevision;\n+    }\n }\n", "next_change": {"commit": "543b5603da0e399f3363e8bfea54ca1fec96ed5e", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 90d3786ee1a..f37415b1558 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15831,4 +15832,105 @@ public class ApiMgtDAO {\n         }\n         return apiRevision;\n     }\n+\n+    /**\n+     * Adds an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n+                    statement.setString(4, apiRevisionDeployment.getType());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing deployment name and type\n+     *\n+     * @return APIRevisionDeployment object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevisionDeployment getAPIRevisionDeploymentByNameAndType(String name, String type) throws APIManagementException {\n+        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n+            statement.setString(1, name);\n+            statement.setString(2, type);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setType(rs.getString(4));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" +\n+                    name +\" and type: \" + type, e);\n+        }\n+        return apiRevisionDeployment;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing revision uuid\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setType(rs.getString(4));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n+                    revisionUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+\n+\n }\n", "next_change": {"commit": "7b69a1ada06e4d06321188f8378fedb5fdb8f2ce", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex f37415b1558..44ca384fe92 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15932,5 +15932,42 @@ public class ApiMgtDAO {\n         return apiRevisionDeploymentList;\n     }\n \n+    /**\n+     * Remove an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setString(3, apiRevisionDeployment.getType());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n \n }\n", "next_change": {"commit": "0d912c09c96726bbf0e27ee0e0ed38822624c443", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 44ca384fe92..22cdd38a687 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15968,6 +15968,4 @@ public class ApiMgtDAO {\n                     + apiRevisionId, e);\n         }\n     }\n-\n-\n }\n", "next_change": {"commit": "92d20512a84cc86f69d46eb5e5eac6416a10f5eb", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 22cdd38a687..2c3fe6bf9a4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15968,4 +15969,7 @@ public class ApiMgtDAO {\n                     + apiRevisionId, e);\n         }\n     }\n+=======\n+\n+>>>>>>> adding revision-deploy and revision-deployment mapping implementation\n }\n", "next_change": {"commit": "abd84c9f05339be8cc5666aba87e6917a4ec64b7", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 2c3fe6bf9a4..ed7806f9417 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15969,7 +15967,5 @@ public class ApiMgtDAO {\n                     + apiRevisionId, e);\n         }\n     }\n-=======\n \n->>>>>>> adding revision-deploy and revision-deployment mapping implementation\n }\n", "next_change": {"commit": "95ed74bd63348ffa8f8763b291c37abb6014be01", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex ed7806f9417..34f033ef470 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15968,4 +15968,248 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_URL_MAPPING table\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_URL_MAPPING table\n+                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "6da602b252a0d9ac6b36b0b5f0d300d286ce738f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 34f033ef470..76b6239641b 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15534,682 +15528,4 @@ public class ApiMgtDAO {\n         }\n         return versions;\n     }\n-\n-    /**\n-     * Get most recent revision id of the revisions created for a particular API.\n-     *\n-     * @return revision id\n-     * @throws APIManagementException if an error occurs while retrieving revision id\n-     */\n-    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n-        int revisionId = 0;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    revisionId = rs.getInt(1);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionId;\n-    }\n-\n-    /**\n-     * Adds an API revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getRevisionedURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n-                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * To get the input stream from string.\n-     *\n-     * @param value : Relevant string that need to be converted to input stream.\n-     * @return input stream.\n-     */\n-    private InputStream getInputStream(String value) {\n-\n-        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n-        return new ByteArrayInputStream(cert);\n-    }\n-\n-    /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revision object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Get revision details by providing revision UUID\n-     *\n-     * @return revisions List object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n-\n-        List<APIRevision> revisionList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevision apiRevision = new APIRevision();\n-                    apiRevision.setId(rs.getInt(1));\n-                    apiRevision.setApiUUID(rs.getString(2));\n-                    apiRevision.setRevisionUUID(rs.getString(3));\n-                    apiRevision.setDescription(rs.getString(4));\n-                    apiRevision.setCreatedTime(rs.getString(5));\n-                    apiRevision.setCreatedBy(rs.getString(6));\n-                    revisionList.add(apiRevision);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n-        }\n-        return revisionList;\n-    }\n-\n-    /**\n-     * Get a provided api uuid is in the revision db table\n-     *\n-     * @return String apiUUID\n-     * @throws APIManagementException if an error occurs while checking revision table\n-     */\n-    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n-        APIRevision apiRevision = new APIRevision();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n-            statement.setString(1, apiUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevision.setApiUUID(rs.getString(1));\n-                    apiRevision.setId(rs.getInt(2));\n-                    apiRevision.setRevisionUUID(apiUUID);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n-        }\n-        return apiRevision;\n-    }\n-\n-    /**\n-     * Adds an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n-                    statement.setString(4, apiRevisionDeployment.getType());\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n-                    + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing deployment name and type\n-     *\n-     * @return APIRevisionDeployment object\n-     * @throws APIManagementException if an error occurs while retrieving revision details\n-     */\n-    public APIRevisionDeployment getAPIRevisionDeploymentByNameAndType(String name, String type) throws APIManagementException {\n-        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n-            statement.setString(1, name);\n-            statement.setString(2, type);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setType(rs.getString(4));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" +\n-                    name +\" and type: \" + type, e);\n-        }\n-        return apiRevisionDeployment;\n-    }\n-\n-    /**\n-     * Get APIRevisionDeployment details by providing revision uuid\n-     *\n-     * @return List<APIRevisionDeployment> object\n-     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n-     */\n-    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n-        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection\n-                     .prepareStatement(SQLConstants.\n-                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n-            statement.setString(1, revisionUUID);\n-            try (ResultSet rs = statement.executeQuery()) {\n-                while (rs.next()) {\n-                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n-                    apiRevisionDeployment.setDeployment(rs.getString(1));\n-                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n-                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n-                    apiRevisionDeployment.setType(rs.getString(4));\n-                    apiRevisionDeployment.setDeployedTime(rs.getString(5));\n-                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n-                    revisionUUID, e);\n-        }\n-        return apiRevisionDeploymentList;\n-    }\n-    /**\n-     * Remove an API revision Deployment mapping record to the database\n-     *\n-     * @param apiRevisionId          uuid of the revision\n-     * @param apiRevisionDeployments content of the revision deployment mapping objects\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n-                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n-                    statement.setString(1, apiRevisionDeployment.getDeployment());\n-                    statement.setString(2, apiRevisionId);\n-                    statement.setString(3, apiRevisionDeployment.getType());\n-                    statement.addBatch();\n-                }\n-                statement.executeBatch();\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                        + apiRevisionId, e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n-                    + apiRevisionId, e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_URL_MAPPING table\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding product id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    insertURLMappingsStatement.setInt(1, apiId);\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n-                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                insertScopeResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                    if (urlMapping.getId() != 0) {\n-                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n-                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n-                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                insertProductResourceMappingStatement.addBatch();\n-                            }\n-                        }\n-                    }\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API revision database records as the working copy of an API\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                initialAutoCommit = connection.getAutoCommit();\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_URL_MAPPING table\n-                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n-                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n-                removeURLMappingsStatement.setInt(1, apiId);\n-                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeURLMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            } finally {\n-                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n }\n", "next_change": {"commit": "a6a99e403ac5c2b9088fa80d8a664898d52b2d00", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 76b6239641b..3378caec385 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -15528,4 +15595,748 @@ public class ApiMgtDAO {\n         }\n         return versions;\n     }\n+\n+    /**\n+     * Get count of the revisions created for a particular API.\n+     *\n+     * @return revision count\n+     * @throws APIManagementException if an error occurs while retrieving revision count\n+     */\n+    public int getRevisionCountByAPI(String apiUUID) throws APIManagementException {\n+        int count = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_COUNT_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    count = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revisions count for API UUID: \" + apiUUID, e);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Get most recent revision id of the revisions created for a particular API.\n+     *\n+     * @return revision id\n+     * @throws APIManagementException if an error occurs while retrieving revision id\n+     */\n+    public int getMostRecentRevisionId(String apiUUID) throws APIManagementException {\n+        int revisionId = 0;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_MOST_RECENT_REVISION_ID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    revisionId = rs.getInt(1);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get most recent revision ID for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionId;\n+    }\n+\n+    /**\n+     * Adds an API revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getRevisionedURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getRevisionedURLMappingsStatement.setInt(1, apiId);\n+                        getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * To get the input stream from string.\n+     *\n+     * @param value : Relevant string that need to be converted to input stream.\n+     * @return input stream.\n+     */\n+    private InputStream getInputStream(String value) {\n+\n+        byte[] cert = value.getBytes(StandardCharsets.UTF_8);\n+        return new ByteArrayInputStream(cert);\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revision object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevision getRevisionByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for revision UUID: \" + revisionUUID, e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Get revision details by providing revision UUID\n+     *\n+     * @return revisions List object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public List<APIRevision> getRevisionsListByAPIUUID(String apiUUID) throws APIManagementException {\n+\n+        List<APIRevision> revisionList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONS_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevision apiRevision = new APIRevision();\n+                    List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    APIRevision previousRevision = null;\n+                    for (APIRevision apiRevisionObject : revisionList) {\n+                        if (apiRevisionObject.getId() == rs.getInt(1)) {\n+                            apiRevisionDeploymentList = apiRevisionObject.getApiRevisionDeploymentList();\n+                            previousRevision = apiRevisionObject;\n+                        }\n+                    }\n+                    if (previousRevision != null) {\n+                        revisionList.remove(previousRevision);\n+                    }\n+                    apiRevision.setId(rs.getInt(1));\n+                    apiRevision.setApiUUID(rs.getString(2));\n+                    apiRevision.setRevisionUUID(rs.getString(3));\n+                    apiRevision.setDescription(rs.getString(4));\n+                    apiRevision.setCreatedTime(rs.getString(5));\n+                    apiRevision.setCreatedBy(rs.getString(6));\n+                    if (!StringUtils.isEmpty(rs.getString(7))) {\n+                        apiRevisionDeployment.setDeployment(rs.getString(7));\n+                        //apiRevisionDeployment.setRevisionUUID(rs.getString(8));\n+                        apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(9));\n+                        apiRevisionDeployment.setDeployedTime(rs.getString(10));\n+                        apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                    }\n+                    apiRevision.setApiRevisionDeploymentList(apiRevisionDeploymentList);\n+                    revisionList.add(apiRevision);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get revision details for API UUID: \" + apiUUID, e);\n+        }\n+        return revisionList;\n+    }\n+\n+    /**\n+     * Get a provided api uuid is in the revision db table\n+     *\n+     * @return String apiUUID\n+     * @throws APIManagementException if an error occurs while checking revision table\n+     */\n+    public APIRevision checkAPIUUIDIsARevisionUUID(String apiUUID) throws APIManagementException {\n+        APIRevision apiRevision = new APIRevision();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISION_APIID_BY_REVISION_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevision.setApiUUID(rs.getString(1));\n+                    apiRevision.setId(rs.getInt(2));\n+                    apiRevision.setRevisionUUID(apiUUID);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to search UUID: \" + apiUUID + \" in the revision db table\", e);\n+        }\n+        return apiRevision;\n+    }\n+\n+    /**\n+     * Adds an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Adding to AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.setBoolean(3, apiRevisionDeployment.isDisplayOnDevportal());\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision Deployment Mapping entry for Revision UUID \" + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing deployment name\n+     *\n+     * @return APIRevisionDeployment object\n+     * @throws APIManagementException if an error occurs while retrieving revision details\n+     */\n+    public APIRevisionDeployment getAPIRevisionDeploymentByName(String name) throws APIManagementException {\n+        APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_NAME_AND_TYPE)) {\n+            statement.setString(1, name);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for deployment name: \" + name, e);\n+        }\n+        return apiRevisionDeployment;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing revision uuid\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentByRevisionUUID(String revisionUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_REVISION_UUID)) {\n+            statement.setString(1, revisionUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for revision uuid: \" +\n+                    revisionUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+\n+    /**\n+     * Get APIRevisionDeployment details by providing ApiUUID\n+     *\n+     * @return List<APIRevisionDeployment> object\n+     * @throws APIManagementException if an error occurs while retrieving revision deployment mapping details\n+     */\n+    public List<APIRevisionDeployment> getAPIRevisionDeploymentsByApiUUID(String apiUUID) throws APIManagementException {\n+        List<APIRevisionDeployment> apiRevisionDeploymentList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection\n+                     .prepareStatement(SQLConstants.\n+                             APIRevisionSqlConstants.GET_API_REVISION_DEPLOYMENT_MAPPING_BY_API_UUID)) {\n+            statement.setString(1, apiUUID);\n+            try (ResultSet rs = statement.executeQuery()) {\n+                while (rs.next()) {\n+                    APIRevisionDeployment apiRevisionDeployment = new APIRevisionDeployment();\n+                    apiRevisionDeployment.setDeployment(rs.getString(1));\n+                    apiRevisionDeployment.setRevisionUUID(rs.getString(2));\n+                    apiRevisionDeployment.setDisplayOnDevportal(rs.getBoolean(3));\n+                    apiRevisionDeployment.setDeployedTime(rs.getString(4));\n+                    apiRevisionDeploymentList.add(apiRevisionDeployment);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API Revision deployment mapping details for api uuid: \" +\n+                    apiUUID, e);\n+        }\n+        return apiRevisionDeploymentList;\n+    }\n+    /**\n+     * Remove an API revision Deployment mapping record to the database\n+     *\n+     * @param apiRevisionId          uuid of the revision\n+     * @param apiRevisionDeployments content of the revision deployment mapping objects\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void removeAPIRevisionDeployment(String apiRevisionId, List<APIRevisionDeployment> apiRevisionDeployments)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Remove an entry from AM_DEPLOYMENT_REVISION_MAPPING table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.REMOVE_API_REVISION_DEPLOYMENT_MAPPING);\n+                for (APIRevisionDeployment apiRevisionDeployment : apiRevisionDeployments) {\n+                    statement.setString(1, apiRevisionDeployment.getDeployment());\n+                    statement.setString(2, apiRevisionId);\n+                    statement.addBatch();\n+                }\n+                statement.executeBatch();\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                        + apiRevisionId, e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to remove API Revision Deployment Mapping entry for Revision UUID \"\n+                    + apiRevisionId, e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_URL_MAPPING table\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_URL_MAPPING_BY_API_ID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_REVISION_UUID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                getURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding product id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS_WORKING_COPY);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    insertURLMappingsStatement.setInt(1, apiId);\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getWorkingCopyURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_WORKING_COPY_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertScopeResourceMappingStatement.setString(1, urlMapping.getScope().getKey());\n+                                insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                insertScopeResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                    if (urlMapping.getId() != 0) {\n+                        getWorkingCopyURLMappingsStatement.setInt(1, apiId);\n+                        getWorkingCopyURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                        getWorkingCopyURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                        getWorkingCopyURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                        getWorkingCopyURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                        getWorkingCopyURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                        try (ResultSet rs = getWorkingCopyURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                insertProductResourceMappingStatement.setInt(1, urlMapping.getId());\n+                                insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                insertProductResourceMappingStatement.addBatch();\n+                            }\n+                        }\n+                    }\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_WORKING_COPY);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_WORKING_COPY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API revision database records as the working copy of an API\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                initialAutoCommit = connection.getAutoCommit();\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIIdentifier apiIdentifier = APIUtil.getAPIIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_URL_MAPPING table\n+                // This will cascade remove entries from AM_API_RESOURCE_SCOPE_MAPPING and AM_API_PRODUCT_MAPPING tables\n+                PreparedStatement removeURLMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_URL_MAPPING_BY_REVISION_UUID);\n+                removeURLMappingsStatement.setInt(1, apiId);\n+                removeURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeURLMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            } finally {\n+                APIMgtDBUtil.setAutoCommit(connection, initialAutoCommit);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n }\n", "next_change": {"commit": "c254d66922dd3649955a81bd90eb2a2469b6e75e", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 3378caec385..af1d32663e1 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16339,4 +16471,297 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Adds an API Product revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getProductResourceStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_PRODUCT_RESOURCES);\n+                getProductResourceStatement.setInt(1, apiId);\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductResourceStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API Product revision database records as the working copy of an API Product\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_PRODUCT_MAPPING table\n+                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n+                getProductMappingsStatement.setInt(1, apiId);\n+                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, \"Working Copy\");\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Delete API Product revision database records\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+\n }\n", "next_change": {"commit": "0466513ced0990fd6cf5d4b5cdba6b94e90851f2", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex af1d32663e1..5dc73a6aff2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16471,297 +16546,4 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Adds an API Product revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getProductResourceStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_PRODUCT_RESOURCES);\n-                getProductResourceStatement.setInt(1, apiId);\n-                List<Integer> urlMappingIds = new ArrayList<>();\n-                try (ResultSet rs = getProductResourceStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        urlMappingIds.add(rs.getInt(1));\n-                    }\n-                }\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (int urlMappingId: urlMappingIds) {\n-                    insertProductResourceMappingStatement.setInt(1, apiId);\n-                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n-                    insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n-                    insertProductResourceMappingStatement.addBatch();\n-                }\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API Product revision database records as the working copy of an API Product\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_PRODUCT_MAPPING table\n-                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n-                getProductMappingsStatement.setInt(1, apiId);\n-                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<Integer> urlMappingIds = new ArrayList<>();\n-                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        urlMappingIds.add(rs.getInt(1));\n-                    }\n-                }\n-\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (int urlMappingId: urlMappingIds) {\n-                    insertProductResourceMappingStatement.setInt(1, apiId);\n-                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n-                    insertProductResourceMappingStatement.setString(3, \"Working Copy\");\n-                    insertProductResourceMappingStatement.addBatch();\n-                }\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Delete API Product revision database records\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-\n }\n", "next_change": {"commit": "079a0b5b4e2790827ce39fa6cc74d55b001f9763", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 5dc73a6aff2..3bf30496388 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16546,4 +16471,297 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Adds an API Product revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getProductResourceStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_PRODUCT_RESOURCES);\n+                getProductResourceStatement.setInt(1, apiId);\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductResourceStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API Product revision database records as the working copy of an API Product\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_PRODUCT_MAPPING table\n+                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n+                getProductMappingsStatement.setInt(1, apiId);\n+                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, \"Working Copy\");\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Delete API Product revision database records\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+\n }\n", "next_change": {"commit": "901b1aedb5ecb81731476c8d7fe8e39a4919ef33", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 3bf30496388..850b44fbbbe 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16471,297 +16537,4 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Adds an API Product revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getProductResourceStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_PRODUCT_RESOURCES);\n-                getProductResourceStatement.setInt(1, apiId);\n-                List<Integer> urlMappingIds = new ArrayList<>();\n-                try (ResultSet rs = getProductResourceStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        urlMappingIds.add(rs.getInt(1));\n-                    }\n-                }\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (int urlMappingId: urlMappingIds) {\n-                    insertProductResourceMappingStatement.setInt(1, apiId);\n-                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n-                    insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n-                    insertProductResourceMappingStatement.addBatch();\n-                }\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API Product revision database records as the working copy of an API Product\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_PRODUCT_MAPPING table\n-                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n-                getProductMappingsStatement.setInt(1, apiId);\n-                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<Integer> urlMappingIds = new ArrayList<>();\n-                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        urlMappingIds.add(rs.getInt(1));\n-                    }\n-                }\n-\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (int urlMappingId: urlMappingIds) {\n-                    insertProductResourceMappingStatement.setInt(1, apiId);\n-                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n-                    insertProductResourceMappingStatement.setString(3, \"Working Copy\");\n-                    insertProductResourceMappingStatement.addBatch();\n-                }\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Delete API Product revision database records\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-\n }\n", "next_change": {"commit": "b197d6ceb5aba15be2cf582514c43c00f1d86160", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 850b44fbbbe..d519d7e3730 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16537,4 +16474,89 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    public ServiceEntry retrieveServiceById(String serviceId, int tenantId) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_SERVICE_INFO_BY_SERVICE_UUID)) {\n+            statement.setString(1, serviceId);\n+            statement.setInt(2, tenantId);\n+            try(ResultSet resultSet = statement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    ServiceEntry serviceEntry = new ServiceEntry();\n+                    serviceEntry.setUuid(resultSet.getString(\"UUID\"));\n+                    serviceEntry.setKey(resultSet.getString(\"SERVICE_KEY\"));\n+                    serviceEntry.setMd5(resultSet.getString(\"MD5\"));\n+                    serviceEntry.setDisplayName(resultSet.getString(\"DISPLAY_NAME\"));\n+                    serviceEntry.setVersion(resultSet.getString(\"ENTRY_VERSION\"));\n+                    serviceEntry.setServiceUrl(resultSet.getString(\"SERVICE_URL\"));\n+                    serviceEntry.setDefType(resultSet.getString(\"DEFINITION_TYPE\"));\n+                    serviceEntry.setDefUrl(resultSet.getString(\"DEFINITION_URL\"));\n+                    serviceEntry.setSecurityType(resultSet.getString(\"SECURITY_TYPE\"));\n+                    serviceEntry.setMutualSSLEnabled(Boolean.parseBoolean(resultSet.getString(\"MUTUAL_SSL_ENABLED\")));\n+                    serviceEntry.setCreatedTime(resultSet.getTimestamp(\"CREATED_TIME\"));\n+                    serviceEntry.setLastUpdatedTime(resultSet.getTimestamp(\"LAST_UPDATED_TIME\"));\n+                    serviceEntry.setCreatedBy(\"CREATED_BY\");\n+                    serviceEntry.setUpdatedBy(\"UPDATED_BY\");\n+                    serviceEntry.setEndpointDef(resultSet.getBinaryStream(\"ENDPOINT_DEFINITION\"));\n+                    serviceEntry.setMetadata(resultSet.getBinaryStream(\"METADATA\"));\n+                    return serviceEntry;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the Service Entry with ID \" + serviceId + \" - \" + tenantId,\n+                    e);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Add API Service Mapping in AM_API_SERVICE_MAPPING\n+     * @param apiId\n+     * @param serviceId\n+     * @param md5sum\n+     * @param connection\n+     * @throws APIManagementException\n+     */\n+    public void addAPIServiceMapping(String apiId, String serviceId, String md5sum, Connection connection) throws\n+            APIManagementException {\n+        PreparedStatement preparedStatement = null;\n+        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n+        boolean isNewConnection = false;\n+        try {\n+          if (connection == null) {\n+              connection = APIMgtDBUtil.getConnection();\n+              isNewConnection = true;\n+          }\n+          preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL);\n+          preparedStatement.setString(1, apiId);\n+          preparedStatement.setString(2, serviceId);\n+          preparedStatement.setString(3, md5sum);\n+          preparedStatement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Error while adding API Service Mapping\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(preparedStatement, null, null);\n+            if (isNewConnection) {\n+                APIMgtDBUtil.closeAllConnections(null, connection, null);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+     * @param apiId\n+     * @param serviceId\n+     * @param md5\n+     * @throws APIManagementException\n+     */\n+    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n+            statement.setString(1, apiId);\n+            statement.setString(2, serviceId);\n+            statement.execute();\n+            addAPIServiceMapping(apiId, serviceId, md5, connection);\n+        } catch (SQLException e) {\n+            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+        }\n+    }\n }\n", "next_change": {"commit": "149bbf10978d34160c3597031d6c45848639a9a7", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d519d7e3730..127435df26b 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16502,61 +16509,77 @@ public class ApiMgtDAO {\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error while retrieving the Service Entry with ID \" + serviceId + \" - \" + tenantId,\n+            handleException(\"Error while retrieving the Service Entry with ID \" + servicKey + \" - \" + tenantId,\n                     e);\n         }\n         return null;\n     }\n \n+    public void setServiceStatusInfoToAPI(API api) throws APIManagementException {\n+        try(Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n+                    .GET_MD5_VALUE_OF_SERVICE_SQL)) {\n+            preparedStatement.setString(1, api.getUuid());\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    api.setServiceInfo(\"id\", resultSet.getString(\"SERVICE_KEY\"));\n+                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n+                            .getString(\"API_SERVICE_MD5\"))) {\n+                        api.setServiceInfo(\"outdated\", \"false\");\n+                    } else {\n+                        api.setServiceInfo(\"outdated\", \"true\");\n+                    }\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the service status associated the API with id \" + api.getUuid(), e);\n+        }\n+    }\n+\n     /**\n      * Add API Service Mapping in AM_API_SERVICE_MAPPING\n-     * @param apiId\n-     * @param serviceId\n-     * @param md5sum\n-     * @param connection\n+     * @param apiId Unique Identifier of the API\n+     * @param serviceKey Unique Key of the service\n+     * @param md5sum MD5 SUM of the Service\n+     *\n      * @throws APIManagementException\n      */\n-    public void addAPIServiceMapping(String apiId, String serviceId, String md5sum, Connection connection) throws\n+    public void addAPIServiceMapping(String apiId, String serviceKey, String md5sum) throws\n             APIManagementException {\n-        PreparedStatement preparedStatement = null;\n-        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n-        boolean isNewConnection = false;\n-        try {\n-          if (connection == null) {\n-              connection = APIMgtDBUtil.getConnection();\n-              isNewConnection = true;\n-          }\n-          preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL);\n-          preparedStatement.setString(1, apiId);\n-          preparedStatement.setString(2, serviceId);\n-          preparedStatement.setString(3, md5sum);\n-          preparedStatement.executeUpdate();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            addAPIServiceMapping(apiId, serviceKey, md5sum, connection);\n         } catch (SQLException e) {\n             handleException(\"Error while adding API Service Mapping\" , e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(preparedStatement, null, null);\n-            if (isNewConnection) {\n-                APIMgtDBUtil.closeAllConnections(null, connection, null);\n-            }\n         }\n     }\n \n-    /**\n-     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-     * @param apiId\n-     * @param serviceId\n-     * @param md5\n-     * @throws APIManagementException\n-     */\n-    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n-            statement.setString(1, apiId);\n-            statement.setString(2, serviceId);\n-            statement.execute();\n-            addAPIServiceMapping(apiId, serviceId, md5, connection);\n-        } catch (SQLException e) {\n-            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+    private void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, Connection connection)\n+            throws SQLException {\n+        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n+        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n+          preparedStatement.setString(1, apiId);\n+          preparedStatement.setString(2, serviceKey);\n+          preparedStatement.setString(3, md5sum);\n+          preparedStatement.executeUpdate();\n         }\n     }\n+\n+//    /**\n+//     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+//     * @param apiId\n+//     * @param serviceId\n+//     * @param md5\n+//     * @throws APIManagementException\n+//     */\n+//    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n+//        try (Connection connection = APIMgtDBUtil.getConnection();\n+//             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n+//            statement.setString(1, apiId);\n+//            statement.setString(2, serviceId);\n+//            statement.execute();\n+//            addAPIServiceMapping(apiId, serviceId, md5, connection);\n+//        } catch (SQLException e) {\n+//            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+//        }\n+//    }\n }\n", "next_change": {"commit": "8ee9a0184e32feda8dd68235ec68e670e83b572d", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 127435df26b..80929408a73 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16475,111 +16523,296 @@ public class ApiMgtDAO {\n     }\n \n     /**\n-     * Retrieve Service Information from Service Catalog\n-     * @param servicKey Unique Key of the Service\n-     * @param tenantId Logged in user tenant domain\n-     * @return\n-     * @throws APIManagementException\n+     * Adds an API Product revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n      */\n-    public ServiceEntry retrieveServiceByKey(String servicKey, int tenantId) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_SERVICE_INFO_BY_SERVICE_KEY)) {\n-            statement.setString(1, servicKey);\n-            statement.setInt(2, tenantId);\n-            try(ResultSet resultSet = statement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    ServiceEntry serviceEntry = new ServiceEntry();\n-                    serviceEntry.setUuid(resultSet.getString(\"UUID\"));\n-                    serviceEntry.setKey(resultSet.getString(\"SERVICE_KEY\"));\n-                    serviceEntry.setMd5(resultSet.getString(\"MD5\"));\n-                    serviceEntry.setDisplayName(resultSet.getString(\"DISPLAY_NAME\"));\n-                    serviceEntry.setVersion(resultSet.getString(\"ENTRY_VERSION\"));\n-                    serviceEntry.setServiceUrl(resultSet.getString(\"SERVICE_URL\"));\n-                    serviceEntry.setDefType(resultSet.getString(\"DEFINITION_TYPE\"));\n-                    serviceEntry.setDefUrl(resultSet.getString(\"DEFINITION_URL\"));\n-                    serviceEntry.setSecurityType(resultSet.getString(\"SECURITY_TYPE\"));\n-                    serviceEntry.setMutualSSLEnabled(Boolean.parseBoolean(resultSet.getString(\"MUTUAL_SSL_ENABLED\")));\n-                    serviceEntry.setCreatedTime(resultSet.getTimestamp(\"CREATED_TIME\"));\n-                    serviceEntry.setLastUpdatedTime(resultSet.getTimestamp(\"LAST_UPDATED_TIME\"));\n-                    serviceEntry.setCreatedBy(\"CREATED_BY\");\n-                    serviceEntry.setUpdatedBy(\"UPDATED_BY\");\n-                    serviceEntry.setEndpointDef(resultSet.getBinaryStream(\"ENDPOINT_DEFINITION\"));\n-                    serviceEntry.setMetadata(resultSet.getBinaryStream(\"METADATA\"));\n-                    return serviceEntry;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the Service Entry with ID \" + servicKey + \" - \" + tenantId,\n-                    e);\n+    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getProductResourceStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_PRODUCT_RESOURCES);\n+                getProductResourceStatement.setInt(1, apiId);\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductResourceStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n         }\n-        return null;\n     }\n \n-    public void setServiceStatusInfoToAPI(API api) throws APIManagementException {\n-        try(Connection connection = APIMgtDBUtil.getConnection();\n-            PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n-                    .GET_MD5_VALUE_OF_SERVICE_SQL)) {\n-            preparedStatement.setString(1, api.getUuid());\n-            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    api.setServiceInfo(\"id\", resultSet.getString(\"SERVICE_KEY\"));\n-                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n-                            .getString(\"API_SERVICE_MD5\"))) {\n-                        api.setServiceInfo(\"outdated\", \"false\");\n-                    } else {\n-                        api.setServiceInfo(\"outdated\", \"true\");\n+    /**\n+     * Restore API Product revision database records as the working copy of an API Product\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related working copy entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_PRODUCT_MAPPING table\n+                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n+                getProductMappingsStatement.setInt(1, apiId);\n+                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, \"Working Copy\");\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n                     }\n                 }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error while retrieving the service status associated the API with id \" + api.getUuid(), e);\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n         }\n     }\n \n     /**\n-     * Add API Service Mapping in AM_API_SERVICE_MAPPING\n-     * @param apiId Unique Identifier of the API\n-     * @param serviceKey Unique Key of the service\n-     * @param md5sum MD5 SUM of the Service\n+     * Delete API Product revision database records\n      *\n-     * @throws APIManagementException\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n      */\n-    public void addAPIServiceMapping(String apiId, String serviceKey, String md5sum) throws\n-            APIManagementException {\n+    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n         try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            addAPIServiceMapping(apiId, serviceKey, md5sum, connection);\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n         } catch (SQLException e) {\n-            handleException(\"Error while adding API Service Mapping\" , e);\n+            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n         }\n     }\n \n-    private void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, Connection connection)\n-            throws SQLException {\n-        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n-        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n-          preparedStatement.setString(1, apiId);\n-          preparedStatement.setString(2, serviceKey);\n-          preparedStatement.setString(3, md5sum);\n-          preparedStatement.executeUpdate();\n-        }\n-    }\n-\n-//    /**\n-//     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-//     * @param apiId\n-//     * @param serviceId\n-//     * @param md5\n-//     * @throws APIManagementException\n-//     */\n-//    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n-//        try (Connection connection = APIMgtDBUtil.getConnection();\n-//             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n-//            statement.setString(1, apiId);\n-//            statement.setString(2, serviceId);\n-//            statement.execute();\n-//            addAPIServiceMapping(apiId, serviceId, md5, connection);\n-//        } catch (SQLException e) {\n-//            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n-//        }\n-//    }\n+\n }\n", "next_change": {"commit": "e9d78d34cb1ed8ca8ced8f1c4d92676c2c070465", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 80929408a73..c13fda3d432 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16522,297 +16497,4 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Adds an API Product revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getProductResourceStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_PRODUCT_RESOURCES);\n-                getProductResourceStatement.setInt(1, apiId);\n-                List<Integer> urlMappingIds = new ArrayList<>();\n-                try (ResultSet rs = getProductResourceStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        urlMappingIds.add(rs.getInt(1));\n-                    }\n-                }\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (int urlMappingId: urlMappingIds) {\n-                    insertProductResourceMappingStatement.setInt(1, apiId);\n-                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n-                    insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n-                    insertProductResourceMappingStatement.addBatch();\n-                }\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API Product revision database records as the working copy of an API Product\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related working copy entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_WORKING_COPY_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_PRODUCT_MAPPING table\n-                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n-                getProductMappingsStatement.setInt(1, apiId);\n-                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<Integer> urlMappingIds = new ArrayList<>();\n-                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        urlMappingIds.add(rs.getInt(1));\n-                    }\n-                }\n-\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (int urlMappingId: urlMappingIds) {\n-                    insertProductResourceMappingStatement.setInt(1, apiId);\n-                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n-                    insertProductResourceMappingStatement.setString(3, \"Working Copy\");\n-                    insertProductResourceMappingStatement.addBatch();\n-                }\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Working Copy\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Delete API Product revision database records\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-\n }\n", "next_change": {"commit": "18c3c6d3de9358f6e37a6287fd43d936c26e018f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex c13fda3d432..dd739f9eb09 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16497,4 +16633,383 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Adds an API Product revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API Product ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.\n+                                GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_PRODUCT_ID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding api id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                Map<String, URITemplate> uriTemplateMap = new HashMap<>();\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        URITemplate urlMappingNew = urlMapping;\n+                        URITemplate urlMappingExisting =  uriTemplateMap.get(urlMapping.getUriTemplate()\n+                                + urlMapping.getHTTPVerb());\n+                        if (urlMappingExisting != null && urlMappingExisting.getScopes() != null) {\n+                            if (!urlMappingExisting.getScopes().contains(urlMapping.getScope())) {\n+                                urlMappingExisting.setScopes(urlMapping.getScope());\n+                                uriTemplateMap.put(urlMappingExisting.getUriTemplate() + urlMappingExisting.getHTTPVerb(),\n+                                        urlMappingExisting);\n+                            }\n+                        } else {\n+                            urlMappingNew.setScopes(urlMapping.getScope());\n+                            uriTemplateMap.put(urlMappingNew.getUriTemplate() + urlMappingNew.getHTTPVerb(), urlMappingNew);\n+                        }\n+                    } else if (urlMapping.getId() != 0 ) {\n+                        URITemplate urlMappingExisting =  uriTemplateMap.get(urlMapping.getUriTemplate()\n+                                + urlMapping.getHTTPVerb());\n+                        if (urlMappingExisting == null) {\n+                            uriTemplateMap.put(urlMapping.getUriTemplate() + urlMapping.getHTTPVerb(), urlMapping);\n+                        }\n+                    } else {\n+                        uriTemplateMap.put(urlMapping.getUriTemplate() + urlMapping.getHTTPVerb(), urlMapping);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n+                for (URITemplate urlMapping : uriTemplateMap.values()) {\n+                    insertURLMappingsStatement.setInt(1, urlMapping.getId());\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getRevisionedURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : uriTemplateMap.values()) {\n+                    getRevisionedURLMappingsStatement.setInt(1, urlMapping.getId());\n+                    getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                    getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                    getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                    getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                    getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                    if (urlMapping.getScopes() != null) {\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                for (Scope scope : urlMapping.getScopes()) {\n+                                    insertScopeResourceMappingStatement.setString(1, scope.getKey());\n+                                    insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                    insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                    insertScopeResourceMappingStatement.addBatch();\n+                                }\n+                            }\n+                        }\n+                    }\n+                    try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                        while (rs.next()) {\n+                            insertProductResourceMappingStatement.setInt(1, apiId);\n+                            insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                            insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n+                            insertProductResourceMappingStatement.addBatch();\n+                        }\n+                    }\n+\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API Product revision database records as the Current API Product of an API Product\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related current API product entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_PRODUCT_MAPPING table\n+                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n+                getProductMappingsStatement.setInt(1, apiId);\n+                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, \"Current API\");\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Current API\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Delete API Product revision database records\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+\n }\n", "next_change": {"commit": "41588e822a0097c6c2568999be24d4f72e589b43", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex dd739f9eb09..9a2eb670ff8 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16633,383 +16672,4 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Adds an API Product revision record to the database\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when adding a new API revision\n-     */\n-    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Adding to AM_REVISION table\n-                PreparedStatement statement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n-                statement.setInt(1, apiRevision.getId());\n-                statement.setString(2, apiRevision.getApiUUID());\n-                statement.setString(3, apiRevision.getRevisionUUID());\n-                statement.setString(4, apiRevision.getDescription());\n-                statement.setString(5, apiRevision.getCreatedBy());\n-                statement.executeUpdate();\n-\n-                // Retrieve API Product ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Adding to AM_API_URL_MAPPING table\n-                PreparedStatement getURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.\n-                                GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_PRODUCT_ID);\n-                getURLMappingsStatement.setInt(1, apiId);\n-                List<URITemplate> urlMappingList = new ArrayList<>();\n-                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        URITemplate uriTemplate = new URITemplate();\n-                        uriTemplate.setHTTPVerb(rs.getString(1));\n-                        uriTemplate.setAuthType(rs.getString(2));\n-                        uriTemplate.setUriTemplate(rs.getString(3));\n-                        uriTemplate.setThrottlingTier(rs.getString(4));\n-                        uriTemplate.setMediationScript(rs.getString(5));\n-                        if (!StringUtils.isEmpty(rs.getString(6))) {\n-                            Scope scope = new Scope();\n-                            scope.setKey(rs.getString(6));\n-                            uriTemplate.setScope(scope);\n-                        }\n-                        if (rs.getInt(7) != 0) {\n-                            // Adding api id to uri template id just to store value\n-                            uriTemplate.setId(rs.getInt(7));\n-                        }\n-                        urlMappingList.add(uriTemplate);\n-                    }\n-                }\n-\n-                Map<String, URITemplate> uriTemplateMap = new HashMap<>();\n-                for (URITemplate urlMapping : urlMappingList) {\n-                    if (urlMapping.getScope() != null) {\n-                        URITemplate urlMappingNew = urlMapping;\n-                        URITemplate urlMappingExisting =  uriTemplateMap.get(urlMapping.getUriTemplate()\n-                                + urlMapping.getHTTPVerb());\n-                        if (urlMappingExisting != null && urlMappingExisting.getScopes() != null) {\n-                            if (!urlMappingExisting.getScopes().contains(urlMapping.getScope())) {\n-                                urlMappingExisting.setScopes(urlMapping.getScope());\n-                                uriTemplateMap.put(urlMappingExisting.getUriTemplate() + urlMappingExisting.getHTTPVerb(),\n-                                        urlMappingExisting);\n-                            }\n-                        } else {\n-                            urlMappingNew.setScopes(urlMapping.getScope());\n-                            uriTemplateMap.put(urlMappingNew.getUriTemplate() + urlMappingNew.getHTTPVerb(), urlMappingNew);\n-                        }\n-                    } else if (urlMapping.getId() != 0 ) {\n-                        URITemplate urlMappingExisting =  uriTemplateMap.get(urlMapping.getUriTemplate()\n-                                + urlMapping.getHTTPVerb());\n-                        if (urlMappingExisting == null) {\n-                            uriTemplateMap.put(urlMapping.getUriTemplate() + urlMapping.getHTTPVerb(), urlMapping);\n-                        }\n-                    } else {\n-                        uriTemplateMap.put(urlMapping.getUriTemplate() + urlMapping.getHTTPVerb(), urlMapping);\n-                    }\n-                }\n-\n-                PreparedStatement insertURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n-                for (URITemplate urlMapping : uriTemplateMap.values()) {\n-                    insertURLMappingsStatement.setInt(1, urlMapping.getId());\n-                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n-                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n-                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n-                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n-                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertURLMappingsStatement.addBatch();\n-                }\n-                insertURLMappingsStatement.executeBatch();\n-\n-                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n-                PreparedStatement getRevisionedURLMappingsStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n-                PreparedStatement insertScopeResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (URITemplate urlMapping : uriTemplateMap.values()) {\n-                    getRevisionedURLMappingsStatement.setInt(1, urlMapping.getId());\n-                    getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                    getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n-                    getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n-                    getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n-                    getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n-                    if (urlMapping.getScopes() != null) {\n-                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                            while (rs.next()) {\n-                                for (Scope scope : urlMapping.getScopes()) {\n-                                    insertScopeResourceMappingStatement.setString(1, scope.getKey());\n-                                    insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n-                                    insertScopeResourceMappingStatement.setInt(3, tenantId);\n-                                    insertScopeResourceMappingStatement.addBatch();\n-                                }\n-                            }\n-                        }\n-                    }\n-                    try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n-                        while (rs.next()) {\n-                            insertProductResourceMappingStatement.setInt(1, apiId);\n-                            insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n-                            insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n-                            insertProductResourceMappingStatement.addBatch();\n-                        }\n-                    }\n-\n-                }\n-                insertScopeResourceMappingStatement.executeBatch();\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Adding to AM_API_CLIENT_CERTIFICATE\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Adding to AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e){\n-                connection.rollback();\n-                handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Restore API Product revision database records as the Current API Product of an API Product\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related current API product entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Restoring to AM_API_PRODUCT_MAPPING table\n-                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n-                getProductMappingsStatement.setInt(1, apiId);\n-                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<Integer> urlMappingIds = new ArrayList<>();\n-                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        urlMappingIds.add(rs.getInt(1));\n-                    }\n-                }\n-\n-                PreparedStatement insertProductResourceMappingStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n-                for (int urlMappingId: urlMappingIds) {\n-                    insertProductResourceMappingStatement.setInt(1, apiId);\n-                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n-                    insertProductResourceMappingStatement.setString(3, \"Current API\");\n-                    insertProductResourceMappingStatement.addBatch();\n-                }\n-                insertProductResourceMappingStatement.executeBatch();\n-\n-                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                PreparedStatement getClientCertificatesStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n-                getClientCertificatesStatement.setInt(1, apiId);\n-                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n-                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n-                    while (rs.next()) {\n-                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n-                        clientCertificateDTO.setAlias(rs.getString(1));\n-                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n-                        clientCertificateDTO.setTierName(rs.getString(3));\n-                        clientCertificateDTOS.add(clientCertificateDTO);\n-                    }\n-                }\n-                PreparedStatement insertClientCertificateStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n-                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n-                    insertClientCertificateStatement.setInt(1, tenantId);\n-                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n-                    insertClientCertificateStatement.setInt(3, apiId);\n-                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n-                    insertClientCertificateStatement.setBoolean(5, false);\n-                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n-                    insertClientCertificateStatement.setString(7, \"Current API\");\n-                    insertClientCertificateStatement.addBatch();\n-                }\n-                insertClientCertificateStatement.executeBatch();\n-\n-                // Restoring AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                PreparedStatement getGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n-                getGraphQLComplexityStatement.setInt(1, apiId);\n-                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n-                    while (rs1.next()) {\n-                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n-                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n-                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n-                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n-                        customComplexityDetailsList.add(customComplexityDetails);\n-                    }\n-                }\n-\n-                PreparedStatement insertGraphQLComplexityStatement = connection\n-                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n-                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n-                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n-                    insertGraphQLComplexityStatement.setInt(2, apiId);\n-                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n-                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n-                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n-                    insertGraphQLComplexityStatement.addBatch();\n-                }\n-                insertGraphQLComplexityStatement.executeBatch();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to restore API Revision entry of API UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to restore API Revision entry of API UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-    /**\n-     * Delete API Product revision database records\n-     *\n-     * @param apiRevision content of the revision\n-     * @throws APIManagementException if an error occurs when restoring an API revision\n-     */\n-    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                // Retrieve API ID\n-                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n-                int apiId = getAPIID(apiProductIdentifier, connection);\n-                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n-\n-                // Removing related revision entries from AM_REVISION table\n-                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n-                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n-                removeAMRevisionStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n-                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n-                removeProductMappingsStatement.setInt(1, apiId);\n-                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeProductMappingsStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n-                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n-                removeClientCertificatesStatement.setInt(1, apiId);\n-                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeClientCertificatesStatement.executeUpdate();\n-\n-                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n-                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n-                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n-                removeGraphQLComplexityStatement.setInt(1, apiId);\n-                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n-                removeGraphQLComplexityStatement.executeUpdate();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                        + apiRevision.getApiUUID(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n-                    + apiRevision.getApiUUID(), e);\n-        }\n-    }\n-\n-\n }\n", "next_change": {"commit": "09f103948a1b70d88e701fdcd30c0c1bb24b831b", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 9a2eb670ff8..f42050a91fe 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16672,4 +16948,383 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Adds an API Product revision record to the database\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when adding a new API revision\n+     */\n+    public void addAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Adding to AM_REVISION table\n+                PreparedStatement statement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.ADD_API_REVISION);\n+                statement.setInt(1, apiRevision.getId());\n+                statement.setString(2, apiRevision.getApiUUID());\n+                statement.setString(3, apiRevision.getRevisionUUID());\n+                statement.setString(4, apiRevision.getDescription());\n+                statement.setString(5, apiRevision.getCreatedBy());\n+                statement.executeUpdate();\n+\n+                // Retrieve API Product ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Adding to AM_API_URL_MAPPING table\n+                PreparedStatement getURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.\n+                                GET_URL_MAPPINGS_WITH_SCOPE_AND_PRODUCT_ID_BY_PRODUCT_ID);\n+                getURLMappingsStatement.setInt(1, apiId);\n+                List<URITemplate> urlMappingList = new ArrayList<>();\n+                try (ResultSet rs = getURLMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        URITemplate uriTemplate = new URITemplate();\n+                        uriTemplate.setHTTPVerb(rs.getString(1));\n+                        uriTemplate.setAuthType(rs.getString(2));\n+                        uriTemplate.setUriTemplate(rs.getString(3));\n+                        uriTemplate.setThrottlingTier(rs.getString(4));\n+                        uriTemplate.setMediationScript(rs.getString(5));\n+                        if (!StringUtils.isEmpty(rs.getString(6))) {\n+                            Scope scope = new Scope();\n+                            scope.setKey(rs.getString(6));\n+                            uriTemplate.setScope(scope);\n+                        }\n+                        if (rs.getInt(7) != 0) {\n+                            // Adding api id to uri template id just to store value\n+                            uriTemplate.setId(rs.getInt(7));\n+                        }\n+                        urlMappingList.add(uriTemplate);\n+                    }\n+                }\n+\n+                Map<String, URITemplate> uriTemplateMap = new HashMap<>();\n+                for (URITemplate urlMapping : urlMappingList) {\n+                    if (urlMapping.getScope() != null) {\n+                        URITemplate urlMappingNew = urlMapping;\n+                        URITemplate urlMappingExisting =  uriTemplateMap.get(urlMapping.getUriTemplate()\n+                                + urlMapping.getHTTPVerb());\n+                        if (urlMappingExisting != null && urlMappingExisting.getScopes() != null) {\n+                            if (!urlMappingExisting.getScopes().contains(urlMapping.getScope())) {\n+                                urlMappingExisting.setScopes(urlMapping.getScope());\n+                                uriTemplateMap.put(urlMappingExisting.getUriTemplate() + urlMappingExisting.getHTTPVerb(),\n+                                        urlMappingExisting);\n+                            }\n+                        } else {\n+                            urlMappingNew.setScopes(urlMapping.getScope());\n+                            uriTemplateMap.put(urlMappingNew.getUriTemplate() + urlMappingNew.getHTTPVerb(), urlMappingNew);\n+                        }\n+                    } else if (urlMapping.getId() != 0 ) {\n+                        URITemplate urlMappingExisting =  uriTemplateMap.get(urlMapping.getUriTemplate()\n+                                + urlMapping.getHTTPVerb());\n+                        if (urlMappingExisting == null) {\n+                            uriTemplateMap.put(urlMapping.getUriTemplate() + urlMapping.getHTTPVerb(), urlMapping);\n+                        }\n+                    } else {\n+                        uriTemplateMap.put(urlMapping.getUriTemplate() + urlMapping.getHTTPVerb(), urlMapping);\n+                    }\n+                }\n+\n+                PreparedStatement insertURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_URL_MAPPINGS);\n+                for (URITemplate urlMapping : uriTemplateMap.values()) {\n+                    insertURLMappingsStatement.setInt(1, urlMapping.getId());\n+                    insertURLMappingsStatement.setString(2, urlMapping.getHTTPVerb());\n+                    insertURLMappingsStatement.setString(3, urlMapping.getAuthType());\n+                    insertURLMappingsStatement.setString(4, urlMapping.getUriTemplate());\n+                    insertURLMappingsStatement.setString(5, urlMapping.getThrottlingTier());\n+                    insertURLMappingsStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertURLMappingsStatement.addBatch();\n+                }\n+                insertURLMappingsStatement.executeBatch();\n+\n+                // Add to AM_API_RESOURCE_SCOPE_MAPPING table and to AM_API_PRODUCT_MAPPING\n+                PreparedStatement getRevisionedURLMappingsStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_REVISIONED_URL_MAPPINGS_ID);\n+                PreparedStatement insertScopeResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_SCOPE_RESOURCE_MAPPING);\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (URITemplate urlMapping : uriTemplateMap.values()) {\n+                    getRevisionedURLMappingsStatement.setInt(1, urlMapping.getId());\n+                    getRevisionedURLMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                    getRevisionedURLMappingsStatement.setString(3, urlMapping.getHTTPVerb());\n+                    getRevisionedURLMappingsStatement.setString(4, urlMapping.getAuthType());\n+                    getRevisionedURLMappingsStatement.setString(5, urlMapping.getUriTemplate());\n+                    getRevisionedURLMappingsStatement.setString(6, urlMapping.getThrottlingTier());\n+                    if (urlMapping.getScopes() != null) {\n+                        try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                            while (rs.next()) {\n+                                for (Scope scope : urlMapping.getScopes()) {\n+                                    insertScopeResourceMappingStatement.setString(1, scope.getKey());\n+                                    insertScopeResourceMappingStatement.setInt(2, rs.getInt(1));\n+                                    insertScopeResourceMappingStatement.setInt(3, tenantId);\n+                                    insertScopeResourceMappingStatement.addBatch();\n+                                }\n+                            }\n+                        }\n+                    }\n+                    try (ResultSet rs = getRevisionedURLMappingsStatement.executeQuery()) {\n+                        while (rs.next()) {\n+                            insertProductResourceMappingStatement.setInt(1, apiId);\n+                            insertProductResourceMappingStatement.setInt(2, rs.getInt(1));\n+                            insertProductResourceMappingStatement.setString(3, apiRevision.getRevisionUUID());\n+                            insertProductResourceMappingStatement.addBatch();\n+                        }\n+                    }\n+\n+                }\n+                insertScopeResourceMappingStatement.executeBatch();\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Adding to AM_API_CLIENT_CERTIFICATE\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, apiRevision.getRevisionUUID());\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Adding to AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.setString(6, apiRevision.getRevisionUUID());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e){\n+                connection.rollback();\n+                handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Restore API Product revision database records as the Current API Product of an API Product\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void restoreAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related current API product entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_API_PRODUCT_ID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Restoring to AM_API_PRODUCT_MAPPING table\n+                PreparedStatement getProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.GET_PRODUCT_RESOURCES_BY_REVISION_UUID);\n+                getProductMappingsStatement.setInt(1, apiId);\n+                getProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<Integer> urlMappingIds = new ArrayList<>();\n+                try (ResultSet rs = getProductMappingsStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        urlMappingIds.add(rs.getInt(1));\n+                    }\n+                }\n+\n+                PreparedStatement insertProductResourceMappingStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_PRODUCT_REVISION_RESOURCE_MAPPING);\n+                for (int urlMappingId: urlMappingIds) {\n+                    insertProductResourceMappingStatement.setInt(1, apiId);\n+                    insertProductResourceMappingStatement.setInt(2, urlMappingId);\n+                    insertProductResourceMappingStatement.setString(3, \"Current API\");\n+                    insertProductResourceMappingStatement.addBatch();\n+                }\n+                insertProductResourceMappingStatement.executeBatch();\n+\n+                // Restoring AM_API_CLIENT_CERTIFICATE table entries\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_API_ID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                PreparedStatement getClientCertificatesStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_CLIENT_CERTIFICATES_BY_REVISION_UUID);\n+                getClientCertificatesStatement.setInt(1, apiId);\n+                getClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                List<ClientCertificateDTO> clientCertificateDTOS = new ArrayList<>();\n+                try (ResultSet rs = getClientCertificatesStatement.executeQuery()) {\n+                    while (rs.next()) {\n+                        ClientCertificateDTO clientCertificateDTO = new ClientCertificateDTO();\n+                        clientCertificateDTO.setAlias(rs.getString(1));\n+                        clientCertificateDTO.setCertificate(APIMgtDBUtil.getStringFromInputStream(rs.getBinaryStream(2)));\n+                        clientCertificateDTO.setTierName(rs.getString(3));\n+                        clientCertificateDTOS.add(clientCertificateDTO);\n+                    }\n+                }\n+                PreparedStatement insertClientCertificateStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_CLIENT_CERTIFICATES_AS_CURRENT_API);\n+                for (ClientCertificateDTO clientCertificateDTO : clientCertificateDTOS) {\n+                    insertClientCertificateStatement.setInt(1, tenantId);\n+                    insertClientCertificateStatement.setString(2, clientCertificateDTO.getAlias());\n+                    insertClientCertificateStatement.setInt(3, apiId);\n+                    insertClientCertificateStatement.setBinaryStream(4, getInputStream(clientCertificateDTO.getCertificate()));\n+                    insertClientCertificateStatement.setBoolean(5, false);\n+                    insertClientCertificateStatement.setString(6, clientCertificateDTO.getTierName());\n+                    insertClientCertificateStatement.setString(7, \"Current API\");\n+                    insertClientCertificateStatement.addBatch();\n+                }\n+                insertClientCertificateStatement.executeBatch();\n+\n+                // Restoring AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_CURRENT_API_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_API_ID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                PreparedStatement getGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.GET_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                List<CustomComplexityDetails> customComplexityDetailsList = new ArrayList<>();\n+                getGraphQLComplexityStatement.setInt(1, apiId);\n+                getGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                try (ResultSet rs1 = getGraphQLComplexityStatement.executeQuery()) {\n+                    while (rs1.next()) {\n+                        CustomComplexityDetails customComplexityDetails = new CustomComplexityDetails();\n+                        customComplexityDetails.setType(rs1.getString(\"TYPE\"));\n+                        customComplexityDetails.setField(rs1.getString(\"FIELD\"));\n+                        customComplexityDetails.setComplexityValue(rs1.getInt(\"COMPLEXITY_VALUE\"));\n+                        customComplexityDetailsList.add(customComplexityDetails);\n+                    }\n+                }\n+\n+                PreparedStatement insertGraphQLComplexityStatement = connection\n+                        .prepareStatement(SQLConstants.APIRevisionSqlConstants.INSERT_GRAPHQL_COMPLEXITY_AS_CURRENT_API);\n+                for (CustomComplexityDetails customComplexityDetails : customComplexityDetailsList) {\n+                    insertGraphQLComplexityStatement.setString(1, UUID.randomUUID().toString());\n+                    insertGraphQLComplexityStatement.setInt(2, apiId);\n+                    insertGraphQLComplexityStatement.setString(3, customComplexityDetails.getType());\n+                    insertGraphQLComplexityStatement.setString(4, customComplexityDetails.getField());\n+                    insertGraphQLComplexityStatement.setInt(5, customComplexityDetails.getComplexityValue());\n+                    insertGraphQLComplexityStatement.addBatch();\n+                }\n+                insertGraphQLComplexityStatement.executeBatch();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to restore API Revision entry of API UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to restore API Revision entry of API UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * Delete API Product revision database records\n+     *\n+     * @param apiRevision content of the revision\n+     * @throws APIManagementException if an error occurs when restoring an API revision\n+     */\n+    public void deleteAPIProductRevision(APIRevision apiRevision) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                // Retrieve API ID\n+                APIProductIdentifier apiProductIdentifier = APIUtil.getAPIProductIdentifierFromUUID(apiRevision.getApiUUID());\n+                int apiId = getAPIID(apiProductIdentifier, connection);\n+                int tenantId = APIUtil.getTenantId(APIUtil.replaceEmailDomainBack(apiProductIdentifier.getProviderName()));\n+\n+                // Removing related revision entries from AM_REVISION table\n+                PreparedStatement removeAMRevisionStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.DELETE_API_REVISION);\n+                removeAMRevisionStatement.setString(1, apiRevision.getRevisionUUID());\n+                removeAMRevisionStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_PRODUCT_MAPPING table\n+                PreparedStatement removeProductMappingsStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_PRODUCT_MAPPING_BY_REVISION_UUID);\n+                removeProductMappingsStatement.setInt(1, apiId);\n+                removeProductMappingsStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeProductMappingsStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_API_CLIENT_CERTIFICATE table\n+                PreparedStatement removeClientCertificatesStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_API_CLIENT_CERTIFICATE_BY_REVISION_UUID);\n+                removeClientCertificatesStatement.setInt(1, apiId);\n+                removeClientCertificatesStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeClientCertificatesStatement.executeUpdate();\n+\n+                // Removing related revision entries from AM_GRAPHQL_COMPLEXITY table\n+                PreparedStatement removeGraphQLComplexityStatement = connection.prepareStatement(SQLConstants\n+                        .APIRevisionSqlConstants.REMOVE_REVISION_ENTRIES_IN_AM_GRAPHQL_COMPLEXITY_BY_REVISION_UUID);\n+                removeGraphQLComplexityStatement.setInt(1, apiId);\n+                removeGraphQLComplexityStatement.setString(2, apiRevision.getRevisionUUID());\n+                removeGraphQLComplexityStatement.executeUpdate();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                        + apiRevision.getApiUUID(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete API Revision entry of API Product UUID \"\n+                    + apiRevision.getApiUUID(), e);\n+        }\n+    }\n+\n+\n }\n", "next_change": {"commit": "53847fbbf0177efa97d29ad2318bfa72b6cdc4d2", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex f42050a91fe..7ae41039da2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17327,4 +17056,89 @@ public class ApiMgtDAO {\n     }\n \n \n+    public ServiceEntry retrieveServiceById(String serviceId, int tenantId) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_SERVICE_INFO_BY_SERVICE_UUID)) {\n+            statement.setString(1, serviceId);\n+            statement.setInt(2, tenantId);\n+            try(ResultSet resultSet = statement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    ServiceEntry serviceEntry = new ServiceEntry();\n+                    serviceEntry.setUuid(resultSet.getString(\"UUID\"));\n+                    serviceEntry.setKey(resultSet.getString(\"SERVICE_KEY\"));\n+                    serviceEntry.setMd5(resultSet.getString(\"MD5\"));\n+                    serviceEntry.setDisplayName(resultSet.getString(\"DISPLAY_NAME\"));\n+                    serviceEntry.setVersion(resultSet.getString(\"ENTRY_VERSION\"));\n+                    serviceEntry.setServiceUrl(resultSet.getString(\"SERVICE_URL\"));\n+                    serviceEntry.setDefType(resultSet.getString(\"DEFINITION_TYPE\"));\n+                    serviceEntry.setDefUrl(resultSet.getString(\"DEFINITION_URL\"));\n+                    serviceEntry.setSecurityType(resultSet.getString(\"SECURITY_TYPE\"));\n+                    serviceEntry.setMutualSSLEnabled(Boolean.parseBoolean(resultSet.getString(\"MUTUAL_SSL_ENABLED\")));\n+                    serviceEntry.setCreatedTime(resultSet.getTimestamp(\"CREATED_TIME\"));\n+                    serviceEntry.setLastUpdatedTime(resultSet.getTimestamp(\"LAST_UPDATED_TIME\"));\n+                    serviceEntry.setCreatedBy(\"CREATED_BY\");\n+                    serviceEntry.setUpdatedBy(\"UPDATED_BY\");\n+                    serviceEntry.setEndpointDef(resultSet.getBinaryStream(\"ENDPOINT_DEFINITION\"));\n+                    serviceEntry.setMetadata(resultSet.getBinaryStream(\"METADATA\"));\n+                    return serviceEntry;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the Service Entry with ID \" + serviceId + \" - \" + tenantId,\n+                    e);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Add API Service Mapping in AM_API_SERVICE_MAPPING\n+     * @param apiId\n+     * @param serviceId\n+     * @param md5sum\n+     * @param connection\n+     * @throws APIManagementException\n+     */\n+    public void addAPIServiceMapping(String apiId, String serviceId, String md5sum, Connection connection) throws\n+            APIManagementException {\n+        PreparedStatement preparedStatement = null;\n+        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n+        boolean isNewConnection = false;\n+        try {\n+          if (connection == null) {\n+              connection = APIMgtDBUtil.getConnection();\n+              isNewConnection = true;\n+          }\n+          preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL);\n+          preparedStatement.setString(1, apiId);\n+          preparedStatement.setString(2, serviceId);\n+          preparedStatement.setString(3, md5sum);\n+          preparedStatement.executeUpdate();\n+        } catch (SQLException e) {\n+            handleException(\"Error while adding API Service Mapping\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(preparedStatement, null, null);\n+            if (isNewConnection) {\n+                APIMgtDBUtil.closeAllConnections(null, connection, null);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+     * @param apiId\n+     * @param serviceId\n+     * @param md5\n+     * @throws APIManagementException\n+     */\n+    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n+            statement.setString(1, apiId);\n+            statement.setString(2, serviceId);\n+            statement.execute();\n+            addAPIServiceMapping(apiId, serviceId, md5, connection);\n+        } catch (SQLException e) {\n+            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+        }\n+    }\n }\n", "next_change": {"commit": "7c620ef359348f3ad2464e92c339d93d304a67c5", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 7ae41039da2..18665984bd7 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17084,61 +17092,77 @@ public class ApiMgtDAO {\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error while retrieving the Service Entry with ID \" + serviceId + \" - \" + tenantId,\n+            handleException(\"Error while retrieving the Service Entry with ID \" + servicKey + \" - \" + tenantId,\n                     e);\n         }\n         return null;\n     }\n \n+    public void setServiceStatusInfoToAPI(API api) throws APIManagementException {\n+        try(Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n+                    .GET_MD5_VALUE_OF_SERVICE_SQL)) {\n+            preparedStatement.setString(1, api.getUuid());\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    api.setServiceInfo(\"id\", resultSet.getString(\"SERVICE_KEY\"));\n+                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n+                            .getString(\"API_SERVICE_MD5\"))) {\n+                        api.setServiceInfo(\"outdated\", \"false\");\n+                    } else {\n+                        api.setServiceInfo(\"outdated\", \"true\");\n+                    }\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the service status associated the API with id \" + api.getUuid(), e);\n+        }\n+    }\n+\n     /**\n      * Add API Service Mapping in AM_API_SERVICE_MAPPING\n-     * @param apiId\n-     * @param serviceId\n-     * @param md5sum\n-     * @param connection\n+     * @param apiId Unique Identifier of the API\n+     * @param serviceKey Unique Key of the service\n+     * @param md5sum MD5 SUM of the Service\n+     *\n      * @throws APIManagementException\n      */\n-    public void addAPIServiceMapping(String apiId, String serviceId, String md5sum, Connection connection) throws\n+    public void addAPIServiceMapping(String apiId, String serviceKey, String md5sum) throws\n             APIManagementException {\n-        PreparedStatement preparedStatement = null;\n-        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n-        boolean isNewConnection = false;\n-        try {\n-          if (connection == null) {\n-              connection = APIMgtDBUtil.getConnection();\n-              isNewConnection = true;\n-          }\n-          preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL);\n-          preparedStatement.setString(1, apiId);\n-          preparedStatement.setString(2, serviceId);\n-          preparedStatement.setString(3, md5sum);\n-          preparedStatement.executeUpdate();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            addAPIServiceMapping(apiId, serviceKey, md5sum, connection);\n         } catch (SQLException e) {\n             handleException(\"Error while adding API Service Mapping\" , e);\n-        } finally {\n-            APIMgtDBUtil.closeAllConnections(preparedStatement, null, null);\n-            if (isNewConnection) {\n-                APIMgtDBUtil.closeAllConnections(null, connection, null);\n-            }\n         }\n     }\n \n-    /**\n-     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-     * @param apiId\n-     * @param serviceId\n-     * @param md5\n-     * @throws APIManagementException\n-     */\n-    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n-            statement.setString(1, apiId);\n-            statement.setString(2, serviceId);\n-            statement.execute();\n-            addAPIServiceMapping(apiId, serviceId, md5, connection);\n-        } catch (SQLException e) {\n-            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+    private void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, Connection connection)\n+            throws SQLException {\n+        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n+        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n+          preparedStatement.setString(1, apiId);\n+          preparedStatement.setString(2, serviceKey);\n+          preparedStatement.setString(3, md5sum);\n+          preparedStatement.executeUpdate();\n         }\n     }\n+\n+//    /**\n+//     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+//     * @param apiId\n+//     * @param serviceId\n+//     * @param md5\n+//     * @throws APIManagementException\n+//     */\n+//    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n+//        try (Connection connection = APIMgtDBUtil.getConnection();\n+//             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n+//            statement.setString(1, apiId);\n+//            statement.setString(2, serviceId);\n+//            statement.execute();\n+//            addAPIServiceMapping(apiId, serviceId, md5, connection);\n+//        } catch (SQLException e) {\n+//            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+//        }\n+//    }\n }\n", "next_change": {"commit": "576f442b48d1be5b7f82b1381f10852fcedf1fd3", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 18665984bd7..a196e5ef740 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17119,50 +17130,53 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Add API Service Mapping in AM_API_SERVICE_MAPPING\n-     * @param apiId Unique Identifier of the API\n-     * @param serviceKey Unique Key of the service\n-     * @param md5sum MD5 SUM of the Service\n-     *\n-     * @throws APIManagementException\n-     */\n-    public void addAPIServiceMapping(String apiId, String serviceKey, String md5sum) throws\n-            APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            addAPIServiceMapping(apiId, serviceKey, md5sum, connection);\n-        } catch (SQLException e) {\n-            handleException(\"Error while adding API Service Mapping\" , e);\n-        }\n-    }\n-\n-    private void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, Connection connection)\n-            throws SQLException {\n+    private void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, int tenantId,\n+                                      Connection connection) throws SQLException {\n         String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n         try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n           preparedStatement.setString(1, apiId);\n           preparedStatement.setString(2, serviceKey);\n           preparedStatement.setString(3, md5sum);\n+          preparedStatement.setInt(4, tenantId);\n           preparedStatement.executeUpdate();\n         }\n     }\n \n-//    /**\n-//     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-//     * @param apiId\n-//     * @param serviceId\n-//     * @param md5\n-//     * @throws APIManagementException\n-//     */\n-//    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n-//        try (Connection connection = APIMgtDBUtil.getConnection();\n-//             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n-//            statement.setString(1, apiId);\n-//            statement.setString(2, serviceId);\n-//            statement.execute();\n-//            addAPIServiceMapping(apiId, serviceId, md5, connection);\n-//        } catch (SQLException e) {\n-//            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n-//        }\n-//    }\n+    public String retrieveServiceKeyByApiId(String apiId, int tenantId) throws APIManagementException {\n+        String retrieveServiceKeySQL = SQLConstants.GET_SERVICE_KEY_BY_API_ID_SQL;\n+        String serviceKey = StringUtils.EMPTY;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement preparedStatement = connection.prepareStatement(retrieveServiceKeySQL)) {\n+            preparedStatement.setString(1, apiId);\n+            preparedStatement.setInt(2, tenantId);\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    serviceKey = resultSet.getString(\"SERVICE_KEY\");\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the Service Key associated with API \" + apiId, e);\n+        }\n+        return serviceKey;\n+    }\n+\n+    /**\n+     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+     * @param apiId Unique Identifier of API\n+     * @param serviceKey Unique key of the Service\n+     * @param md5 MD5 value of the Service\n+     * @throws APIManagementException\n+     */\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, int tenantId)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n+            statement.setString(1, apiId);\n+            statement.setString(2, serviceKey);\n+            statement.execute();\n+            addAPIServiceMapping(apiId, serviceKey, md5, tenantId, connection);\n+        } catch (SQLException e) {\n+            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+        }\n+    }\n }\n", "next_change": {"commit": "095de1a413cf19c73aef4e3c98776f0dbbf284b2", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex a196e5ef740..71a9b110d38 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17162,21 +17174,19 @@ public class ApiMgtDAO {\n \n     /**\n      * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-     * @param apiId Unique Identifier of API\n+     *\n+     * @param apiId      Unique Identifier of API\n      * @param serviceKey Unique key of the Service\n-     * @param md5 MD5 value of the Service\n-     * @throws APIManagementException\n+     * @param md5        MD5 value of the Service\n+     * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, int tenantId)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n-            statement.setString(1, apiId);\n-            statement.setString(2, serviceKey);\n-            statement.execute();\n-            addAPIServiceMapping(apiId, serviceKey, md5, tenantId, connection);\n-        } catch (SQLException e) {\n-            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+            throws SQLException {\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n+            statement.setString(1, serviceKey);\n+            statement.setString(2, md5);\n+            statement.setString(3, apiId);\n+            statement.executeUpdate();\n         }\n     }\n }\n", "next_change": {"commit": "95b99b161914f48446e97478d50c030387f805f1", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 71a9b110d38..c9f67ab52c1 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17062,131 +17079,4 @@ public class ApiMgtDAO {\n     }\n \n \n-    public ServiceEntry retrieveServiceById(String serviceId, int tenantId) throws APIManagementException {\n-    /**\n-     * Retrieve Service Information from Service Catalog\n-     * @param servicKey Unique Key of the Service\n-     * @param tenantId Logged in user tenant domain\n-     * @return\n-     * @throws APIManagementException\n-     */\n-    public ServiceEntry retrieveServiceByKey(String servicKey, int tenantId) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(SQLConstants.GET_SERVICE_INFO_BY_SERVICE_KEY)) {\n-            statement.setString(1, servicKey);\n-            statement.setInt(2, tenantId);\n-            try(ResultSet resultSet = statement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    ServiceEntry serviceEntry = new ServiceEntry();\n-                    serviceEntry.setUuid(resultSet.getString(\"UUID\"));\n-                    serviceEntry.setKey(resultSet.getString(\"SERVICE_KEY\"));\n-                    serviceEntry.setMd5(resultSet.getString(\"MD5\"));\n-                    serviceEntry.setDisplayName(resultSet.getString(\"DISPLAY_NAME\"));\n-                    serviceEntry.setVersion(resultSet.getString(\"ENTRY_VERSION\"));\n-                    serviceEntry.setServiceUrl(resultSet.getString(\"SERVICE_URL\"));\n-                    serviceEntry.setDefType(resultSet.getString(\"DEFINITION_TYPE\"));\n-                    serviceEntry.setDefUrl(resultSet.getString(\"DEFINITION_URL\"));\n-                    serviceEntry.setSecurityType(resultSet.getString(\"SECURITY_TYPE\"));\n-                    serviceEntry.setMutualSSLEnabled(Boolean.parseBoolean(resultSet.getString(\"MUTUAL_SSL_ENABLED\")));\n-                    serviceEntry.setCreatedTime(resultSet.getTimestamp(\"CREATED_TIME\"));\n-                    serviceEntry.setLastUpdatedTime(resultSet.getTimestamp(\"LAST_UPDATED_TIME\"));\n-                    serviceEntry.setCreatedBy(\"CREATED_BY\");\n-                    serviceEntry.setUpdatedBy(\"UPDATED_BY\");\n-                    serviceEntry.setEndpointDef(resultSet.getBinaryStream(\"ENDPOINT_DEFINITION\"));\n-                    serviceEntry.setMetadata(resultSet.getBinaryStream(\"METADATA\"));\n-                    return serviceEntry;\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the Service Entry with ID \" + servicKey + \" - \" + tenantId,\n-                    e);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Retrieve Service Info and Set it to API\n-     *\n-     * @param api API object\n-     * @throws APIManagementException\n-     */\n-    public void setServiceStatusInfoToAPI(API api) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n-                     .GET_MD5_VALUE_OF_SERVICE_BY_API_UUID_SQL)) {\n-            preparedStatement.setString(1, api.getUuid());\n-            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    JSONObject serviceInfo = new JSONObject();\n-                    serviceInfo.put(\"key\", resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY));\n-                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n-                            .getString(\"API_SERVICE_MD5\"))) {\n-                        serviceInfo.put(\"outdated\", false);\n-                    } else {\n-                        serviceInfo.put(\"outdated\", true);\n-                    }\n-                    api.setServiceInfo(serviceInfo);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the service status associated with the API with id \"\n-                    + api.getUuid(), e);\n-        }\n-    }\n-\n-    private void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, int tenantId,\n-                                      Connection connection) throws SQLException {\n-        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n-        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n-            preparedStatement.setString(1, apiId);\n-            preparedStatement.setString(2, serviceKey);\n-            preparedStatement.setString(3, md5sum);\n-            preparedStatement.setInt(4, tenantId);\n-            preparedStatement.executeUpdate();\n-        }\n-    }\n-\n-    /**\n-     * Retrieve the Unique Identifier of the Service used in API\n-     *\n-     * @param apiId Unique Identifier of API\n-     * @param tenantId Tenant ID\n-     * @return Service Key\n-     * @throws APIManagementException\n-     */\n-    public String retrieveServiceKeyByApiId(String apiId, int tenantId) throws APIManagementException {\n-        String retrieveServiceKeySQL = SQLConstants.GET_SERVICE_KEY_BY_API_ID_SQL;\n-        String serviceKey = StringUtils.EMPTY;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement preparedStatement = connection.prepareStatement(retrieveServiceKeySQL)) {\n-            preparedStatement.setString(1, apiId);\n-            preparedStatement.setInt(2, tenantId);\n-            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    serviceKey = resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the Service Key associated with API \" + apiId, e);\n-        }\n-        return serviceKey;\n-    }\n-\n-    /**\n-     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-     *\n-     * @param apiId      Unique Identifier of API\n-     * @param serviceKey Unique key of the Service\n-     * @param md5        MD5 value of the Service\n-     * @throws SQLException\n-     */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n-            throws SQLException {\n-        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n-            statement.setString(1, serviceKey);\n-            statement.setString(2, md5);\n-            statement.setString(3, apiId);\n-            statement.executeUpdate();\n-        }\n-    }\n }\n", "next_change": {"commit": "7724e600765912f417f577ff00cb2839487f8c30", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex c9f67ab52c1..5a1f73906bd 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17078,5 +17061,90 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Retrieve Service Info and Set it to API\n+     *\n+     * @param api API Object\n+     * @param apiId Internal Unique API Id\n+     * @throws APIManagementException\n+     */\n+    public void setServiceStatusInfoToAPI(API api, int apiId) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n+                     .GET_MD5_VALUE_OF_SERVICE_BY_API_ID_SQL)) {\n+            preparedStatement.setInt(1, apiId);\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    JSONObject serviceInfo = new JSONObject();\n+                    serviceInfo.put(\"key\", resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY));\n+                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n+                            .getString(\"API_SERVICE_MD5\"))) {\n+                        serviceInfo.put(\"outdated\", false);\n+                    } else {\n+                        serviceInfo.put(\"outdated\", true);\n+                    }\n+                    api.setServiceInfo(serviceInfo);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the service status associated with the API - \"\n+                    + api.getId().getApiName() + \"-\" + api.getId().getVersion(), e);\n+        }\n+    }\n+\n+    private void addAPIServiceMapping(int apiId, String serviceKey, String md5sum, int tenantId,\n+                                      Connection connection) throws SQLException {\n+        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n+        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n+            preparedStatement.setInt(1, apiId);\n+            preparedStatement.setString(2, serviceKey);\n+            preparedStatement.setString(3, md5sum);\n+            preparedStatement.setInt(4, tenantId);\n+            preparedStatement.executeUpdate();\n+        }\n+    }\n \n+    /**\n+     * Retrieve the Unique Identifier of the Service used in API\n+     *\n+     * @param apiId Unique Identifier of API\n+     * @param tenantId Tenant ID\n+     * @return Service Key\n+     * @throws APIManagementException\n+     */\n+    public String retrieveServiceKeyByApiId(int apiId, int tenantId) throws APIManagementException {\n+        String retrieveServiceKeySQL = SQLConstants.GET_SERVICE_KEY_BY_API_ID_SQL;\n+        String serviceKey = StringUtils.EMPTY;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement preparedStatement = connection.prepareStatement(retrieveServiceKeySQL)) {\n+            preparedStatement.setInt(1, apiId);\n+            preparedStatement.setInt(2, tenantId);\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    serviceKey = resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the Service Key associated with API \" + apiId, e);\n+        }\n+        return serviceKey;\n+    }\n+\n+    /**\n+     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+     *\n+     * @param apiId      Unique Identifier of API\n+     * @param serviceKey Unique key of the Service\n+     * @param md5        MD5 value of the Service\n+     * @throws SQLException\n+     */\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+            throws SQLException {\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n+            statement.setString(1, serviceKey);\n+            statement.setString(2, md5);\n+            statement.setString(3, apiId);\n+            statement.executeUpdate();\n+        }\n+    }\n }\n", "next_change": {"commit": "1e3f42fad8f32bde433320025e9128d41260f349", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 5a1f73906bd..5bee2c26895 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17061,90 +17331,5 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Retrieve Service Info and Set it to API\n-     *\n-     * @param api API Object\n-     * @param apiId Internal Unique API Id\n-     * @throws APIManagementException\n-     */\n-    public void setServiceStatusInfoToAPI(API api, int apiId) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n-                     .GET_MD5_VALUE_OF_SERVICE_BY_API_ID_SQL)) {\n-            preparedStatement.setInt(1, apiId);\n-            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    JSONObject serviceInfo = new JSONObject();\n-                    serviceInfo.put(\"key\", resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY));\n-                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n-                            .getString(\"API_SERVICE_MD5\"))) {\n-                        serviceInfo.put(\"outdated\", false);\n-                    } else {\n-                        serviceInfo.put(\"outdated\", true);\n-                    }\n-                    api.setServiceInfo(serviceInfo);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the service status associated with the API - \"\n-                    + api.getId().getApiName() + \"-\" + api.getId().getVersion(), e);\n-        }\n-    }\n-\n-    private void addAPIServiceMapping(int apiId, String serviceKey, String md5sum, int tenantId,\n-                                      Connection connection) throws SQLException {\n-        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n-        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n-            preparedStatement.setInt(1, apiId);\n-            preparedStatement.setString(2, serviceKey);\n-            preparedStatement.setString(3, md5sum);\n-            preparedStatement.setInt(4, tenantId);\n-            preparedStatement.executeUpdate();\n-        }\n-    }\n \n-    /**\n-     * Retrieve the Unique Identifier of the Service used in API\n-     *\n-     * @param apiId Unique Identifier of API\n-     * @param tenantId Tenant ID\n-     * @return Service Key\n-     * @throws APIManagementException\n-     */\n-    public String retrieveServiceKeyByApiId(int apiId, int tenantId) throws APIManagementException {\n-        String retrieveServiceKeySQL = SQLConstants.GET_SERVICE_KEY_BY_API_ID_SQL;\n-        String serviceKey = StringUtils.EMPTY;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement preparedStatement = connection.prepareStatement(retrieveServiceKeySQL)) {\n-            preparedStatement.setInt(1, apiId);\n-            preparedStatement.setInt(2, tenantId);\n-            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    serviceKey = resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the Service Key associated with API \" + apiId, e);\n-        }\n-        return serviceKey;\n-    }\n-\n-    /**\n-     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-     *\n-     * @param apiId      Unique Identifier of API\n-     * @param serviceKey Unique key of the Service\n-     * @param md5        MD5 value of the Service\n-     * @throws SQLException\n-     */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n-            throws SQLException {\n-        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n-            statement.setString(1, serviceKey);\n-            statement.setString(2, md5);\n-            statement.setString(3, apiId);\n-            statement.executeUpdate();\n-        }\n-    }\n }\n", "next_change": {"commit": "db38bf7d10336202a189db4950cfad710e50c6f9", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 5bee2c26895..2cd3cde26cd 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17332,4 +17080,90 @@ public class ApiMgtDAO {\n     }\n \n \n+    public void setServiceStatusInfoToAPI(API api) throws APIManagementException {\n+        try(Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n+                    .GET_MD5_VALUE_OF_SERVICE_SQL)) {\n+            preparedStatement.setString(1, api.getUuid());\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    api.setServiceInfo(\"id\", resultSet.getString(\"SERVICE_KEY\"));\n+                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n+                            .getString(\"API_SERVICE_MD5\"))) {\n+                        api.setServiceInfo(\"outdated\", \"false\");\n+                    } else {\n+                        api.setServiceInfo(\"outdated\", \"true\");\n+                    }\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the service status associated the API with id \" + api.getUuid(), e);\n+        }\n+    }\n+\n+    /**\n+     * Add API Service Mapping in AM_API_SERVICE_MAPPING\n+     * @param apiId Unique Identifier of the API\n+     * @param serviceKey Unique Key of the service\n+     * @param md5sum MD5 SUM of the Service\n+     *\n+     * @throws APIManagementException\n+     */\n+    public void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, int tenantId) throws\n+            APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            addAPIServiceMapping(apiId, serviceKey, md5sum, tenantId, connection);\n+        } catch (SQLException e) {\n+            handleException(\"Error while adding API Service Mapping\" , e);\n+        }\n+    }\n+\n+    private void addAPIServiceMapping(String apiId, String serviceKey, String md5sum, int tenantId,\n+                                      Connection connection) throws SQLException {\n+        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n+        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n+          preparedStatement.setString(1, apiId);\n+          preparedStatement.setString(2, serviceKey);\n+          preparedStatement.setString(3, md5sum);\n+          preparedStatement.setInt(4, tenantId);\n+          preparedStatement.executeUpdate();\n+        }\n+    }\n+\n+    public String retrieveServiceKeyByApiId(String apiId, int tenantId) throws APIManagementException {\n+        String retrieveServiceKeySQL = SQLConstants.GET_SERVICE_KEY_BY_API_ID_SQL;\n+        String serviceKey = StringUtils.EMPTY;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+            PreparedStatement preparedStatement = connection.prepareStatement(retrieveServiceKeySQL)) {\n+            preparedStatement.setString(1, apiId);\n+            preparedStatement.setInt(2, tenantId);\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    serviceKey = resultSet.getString(\"SERVICE_KEY\");\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the Service Key associated with API \" + apiId, e);\n+        }\n+        return serviceKey;\n+    }\n+\n+//    /**\n+//     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+//     * @param apiId\n+//     * @param serviceId\n+//     * @param md5\n+//     * @throws APIManagementException\n+//     */\n+//    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n+//        try (Connection connection = APIMgtDBUtil.getConnection();\n+//             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n+//            statement.setString(1, apiId);\n+//            statement.setString(2, serviceId);\n+//            statement.execute();\n+//            addAPIServiceMapping(apiId, serviceId, md5, connection);\n+//        } catch (SQLException e) {\n+//            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n+//        }\n+//    }\n }\n", "next_change": {"commit": "32dab0145d1eab627ea5362ff9c5e35672d82b3f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 2cd3cde26cd..42ae0bc740e 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17148,22 +17155,21 @@ public class ApiMgtDAO {\n         return serviceKey;\n     }\n \n-//    /**\n-//     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-//     * @param apiId\n-//     * @param serviceId\n-//     * @param md5\n-//     * @throws APIManagementException\n-//     */\n-//    public void updateAPIServiceMapping(String apiId, String serviceId, String md5) throws APIManagementException {\n-//        try (Connection connection = APIMgtDBUtil.getConnection();\n-//             PreparedStatement statement = connection.prepareStatement(SQLConstants.DELETE_API_SERVICE_MAPPING_SQL)) {\n-//            statement.setString(1, apiId);\n-//            statement.setString(2, serviceId);\n-//            statement.execute();\n-//            addAPIServiceMapping(apiId, serviceId, md5, connection);\n-//        } catch (SQLException e) {\n-//            handleException(\"Error while updating API Service Mapping for API with ID \" + apiId, e);\n-//        }\n-//    }\n+    /**\n+     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+     *\n+     * @param apiId      Unique Identifier of API\n+     * @param serviceKey Unique key of the Service\n+     * @param md5        MD5 value of the Service\n+     * @throws SQLException\n+     */\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+            throws SQLException {\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n+            statement.setString(1, serviceKey);\n+            statement.setString(2, md5);\n+            statement.setString(3, apiId);\n+            statement.executeUpdate();\n+        }\n+    }\n }\n", "next_change": {"commit": "795ed05735cb911d50127c3aa5426862c80c538e", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 42ae0bc740e..98a44f0c74c 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17086,90 +17350,5 @@ public class ApiMgtDAO {\n         }\n     }\n \n-    /**\n-     * Retrieve Service Info and Set it to API\n-     *\n-     * @param api API Object\n-     * @param apiId Internal Unique API Id\n-     * @throws APIManagementException\n-     */\n-    public void setServiceStatusInfoToAPI(API api, int apiId) throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n-                     .GET_MD5_VALUE_OF_SERVICE_BY_API_ID_SQL)) {\n-            preparedStatement.setInt(1, apiId);\n-            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    JSONObject serviceInfo = new JSONObject();\n-                    serviceInfo.put(\"key\", resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY));\n-                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n-                            .getString(\"API_SERVICE_MD5\"))) {\n-                        serviceInfo.put(\"outdated\", false);\n-                    } else {\n-                        serviceInfo.put(\"outdated\", true);\n-                    }\n-                    api.setServiceInfo(serviceInfo);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the service status associated with the API - \"\n-                    + api.getId().getApiName() + \"-\" + api.getId().getVersion(), e);\n-        }\n-    }\n-\n-    private void addAPIServiceMapping(int apiId, String serviceKey, String md5sum, int tenantId,\n-                                      Connection connection) throws SQLException {\n-        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n-        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n-            preparedStatement.setInt(1, apiId);\n-            preparedStatement.setString(2, serviceKey);\n-            preparedStatement.setString(3, md5sum);\n-            preparedStatement.setInt(4, tenantId);\n-            preparedStatement.executeUpdate();\n-        }\n-    }\n \n-    /**\n-     * Retrieve the Unique Identifier of the Service used in API\n-     *\n-     * @param apiId Unique Identifier of API\n-     * @param tenantId Tenant ID\n-     * @return Service Key\n-     * @throws APIManagementException\n-     */\n-    public String retrieveServiceKeyByApiId(int apiId, int tenantId) throws APIManagementException {\n-        String retrieveServiceKeySQL = SQLConstants.GET_SERVICE_KEY_BY_API_ID_SQL;\n-        String serviceKey = StringUtils.EMPTY;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement preparedStatement = connection.prepareStatement(retrieveServiceKeySQL)) {\n-            preparedStatement.setInt(1, apiId);\n-            preparedStatement.setInt(2, tenantId);\n-            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n-                if (resultSet.next()) {\n-                    serviceKey = resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY);\n-                }\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Error while retrieving the Service Key associated with API \" + apiId, e);\n-        }\n-        return serviceKey;\n-    }\n-\n-    /**\n-     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n-     *\n-     * @param apiId      Unique Identifier of API\n-     * @param serviceKey Unique key of the Service\n-     * @param md5        MD5 value of the Service\n-     * @throws SQLException\n-     */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n-            throws SQLException {\n-        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n-            statement.setString(1, serviceKey);\n-            statement.setString(2, md5);\n-            statement.setString(3, apiId);\n-            statement.executeUpdate();\n-        }\n-    }\n }\n", "next_change": {"commit": "9739e5ccaeba556ab0a3a4dd7bffc74169655b2d", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 98a44f0c74c..a552f6dd198 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17350,5 +17518,90 @@ public class ApiMgtDAO {\n         }\n     }\n \n+    /**\n+     * Retrieve Service Info and Set it to API\n+     *\n+     * @param api API Object\n+     * @param apiId Internal Unique API Id\n+     * @throws APIManagementException\n+     */\n+    public void setServiceStatusInfoToAPI(API api, int apiId) throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement preparedStatement = connection.prepareStatement(SQLConstants\n+                     .GET_MD5_VALUE_OF_SERVICE_BY_API_ID_SQL)) {\n+            preparedStatement.setInt(1, apiId);\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    JSONObject serviceInfo = new JSONObject();\n+                    serviceInfo.put(\"key\", resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY));\n+                    if (resultSet.getString(\"SERVICE_MD5\").equals(resultSet\n+                            .getString(\"API_SERVICE_MD5\"))) {\n+                        serviceInfo.put(\"outdated\", false);\n+                    } else {\n+                        serviceInfo.put(\"outdated\", true);\n+                    }\n+                    api.setServiceInfo(serviceInfo);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the service status associated with the API - \"\n+                    + api.getId().getApiName() + \"-\" + api.getId().getVersion(), e);\n+        }\n+    }\n+\n+    private void addAPIServiceMapping(int apiId, String serviceKey, String md5sum, int tenantId,\n+                                      Connection connection) throws SQLException {\n+        String addAPIServiceMappingSQL = SQLConstants.ADD_API_SERVICE_MAPPING_SQL;\n+        try (PreparedStatement preparedStatement = connection.prepareStatement(addAPIServiceMappingSQL)) {\n+            preparedStatement.setInt(1, apiId);\n+            preparedStatement.setString(2, serviceKey);\n+            preparedStatement.setString(3, md5sum);\n+            preparedStatement.setInt(4, tenantId);\n+            preparedStatement.executeUpdate();\n+        }\n+    }\n \n+    /**\n+     * Retrieve the Unique Identifier of the Service used in API\n+     *\n+     * @param apiId Unique Identifier of API\n+     * @param tenantId Tenant ID\n+     * @return Service Key\n+     * @throws APIManagementException\n+     */\n+    public String retrieveServiceKeyByApiId(int apiId, int tenantId) throws APIManagementException {\n+        String retrieveServiceKeySQL = SQLConstants.GET_SERVICE_KEY_BY_API_ID_SQL;\n+        String serviceKey = StringUtils.EMPTY;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement preparedStatement = connection.prepareStatement(retrieveServiceKeySQL)) {\n+            preparedStatement.setInt(1, apiId);\n+            preparedStatement.setInt(2, tenantId);\n+            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    serviceKey = resultSet.getString(APIConstants.ServiceCatalogConstants.SERVICE_KEY);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error while retrieving the Service Key associated with API \" + apiId, e);\n+        }\n+        return serviceKey;\n+    }\n+\n+    /**\n+     * Update API Service Mapping entry in AM_API_SERVICE_MAPPING\n+     *\n+     * @param apiId      Unique Identifier of API\n+     * @param serviceKey Unique key of the Service\n+     * @param md5        MD5 value of the Service\n+     * @throws SQLException\n+     */\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+            throws SQLException {\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n+            statement.setString(1, serviceKey);\n+            statement.setString(2, md5);\n+            statement.setString(3, apiId);\n+            statement.executeUpdate();\n+        }\n+    }\n }\n", "next_change": {"commit": "1d0b8906df0b92b4a2cf958bf817be908f4b5494", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex a552f6dd198..a24cd09b5d5 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17595,12 +17323,12 @@ public class ApiMgtDAO {\n      * @param md5        MD5 value of the Service\n      * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+    public void updateAPIServiceMapping(int apiId, String serviceKey, String md5, Connection connection)\n             throws SQLException {\n         try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n             statement.setString(1, serviceKey);\n             statement.setString(2, md5);\n-            statement.setString(3, apiId);\n+            statement.setInt(3, apiId);\n             statement.executeUpdate();\n         }\n     }\n", "next_change": {"commit": "b78dd1722a67a856c25a913abe2b983fe8057fbd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex a24cd09b5d5..0a3f4a95c9d 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17323,12 +17603,12 @@ public class ApiMgtDAO {\n      * @param md5        MD5 value of the Service\n      * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(int apiId, String serviceKey, String md5, Connection connection)\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n             throws SQLException {\n         try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n             statement.setString(1, serviceKey);\n             statement.setString(2, md5);\n-            statement.setInt(3, apiId);\n+            statement.setString(3, apiId);\n             statement.executeUpdate();\n         }\n     }\n", "next_change": {"commit": "66731b1213c00c7423e4aca7a278d8e875bc4166", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 0a3f4a95c9d..1731ffc3fee 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17603,12 +17335,12 @@ public class ApiMgtDAO {\n      * @param md5        MD5 value of the Service\n      * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+    public void updateAPIServiceMapping(int apiId, String serviceKey, String md5, Connection connection)\n             throws SQLException {\n         try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n             statement.setString(1, serviceKey);\n             statement.setString(2, md5);\n-            statement.setString(3, apiId);\n+            statement.setInt(3, apiId);\n             statement.executeUpdate();\n         }\n     }\n", "next_change": {"commit": "617962f8007329c5347ab29c27f26c83f8a3f6b9", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 1731ffc3fee..b293ca832f7 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17335,12 +17634,12 @@ public class ApiMgtDAO {\n      * @param md5        MD5 value of the Service\n      * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(int apiId, String serviceKey, String md5, Connection connection)\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n             throws SQLException {\n         try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n             statement.setString(1, serviceKey);\n             statement.setString(2, md5);\n-            statement.setInt(3, apiId);\n+            statement.setString(3, apiId);\n             statement.executeUpdate();\n         }\n     }\n", "next_change": {"commit": "a58b248c6681dc3b4ff814137b346a0134b0656a", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b293ca832f7..f2b624e388c 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17634,12 +17365,12 @@ public class ApiMgtDAO {\n      * @param md5        MD5 value of the Service\n      * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+    public void updateAPIServiceMapping(int apiId, String serviceKey, String md5, Connection connection)\n             throws SQLException {\n         try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n             statement.setString(1, serviceKey);\n             statement.setString(2, md5);\n-            statement.setString(3, apiId);\n+            statement.setInt(3, apiId);\n             statement.executeUpdate();\n         }\n     }\n", "next_change": {"commit": "8b56851663554865bad62d7ac549af4a1f58f55b", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex f2b624e388c..50cd7b3fb5c 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17365,12 +17607,12 @@ public class ApiMgtDAO {\n      * @param md5        MD5 value of the Service\n      * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(int apiId, String serviceKey, String md5, Connection connection)\n+    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n             throws SQLException {\n         try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n             statement.setString(1, serviceKey);\n             statement.setString(2, md5);\n-            statement.setInt(3, apiId);\n+            statement.setString(3, apiId);\n             statement.executeUpdate();\n         }\n     }\n", "next_change": {"commit": "bb657c5d0777d0f0d70f0af26403569fdef202a6", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 50cd7b3fb5c..faee107377d 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17607,12 +17708,12 @@ public class ApiMgtDAO {\n      * @param md5        MD5 value of the Service\n      * @throws SQLException\n      */\n-    public void updateAPIServiceMapping(String apiId, String serviceKey, String md5, Connection connection)\n+    public void updateAPIServiceMapping(int apiId, String serviceKey, String md5, Connection connection)\n             throws SQLException {\n         try (PreparedStatement statement = connection.prepareStatement(SQLConstants.UPDATE_API_SERVICE_MAPPING_SQL)) {\n             statement.setString(1, serviceKey);\n             statement.setString(2, md5);\n-            statement.setString(3, apiId);\n+            statement.setInt(3, apiId);\n             statement.executeUpdate();\n         }\n     }\n", "next_change": {"commit": "e7fbe280d33ec6835825f2ae8d5e60c93198035f", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex faee107377d..babbeea8e67 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17717,4 +17827,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "e0b18e115a7c98c54c4e9ac9be6b5eeb55d9fe44", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex babbeea8e67..5187e8205e8 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17827,18 +17928,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "9a605e77eb8e50201f58509860957566ce6fe470", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 5187e8205e8..7b3dba044db 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17928,4 +17980,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "ccfb13901639a4811c6291d14b04eaff1d1d351c", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 7b3dba044db..91c49588186 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17980,18 +17961,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "323d25e7587d04be4a757b3cb97af8a4e1e36a36", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 91c49588186..c3f2898c9ff 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17961,4 +18041,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "2041cbda12d76db1989681abd4326778aa798f79", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex c3f2898c9ff..eb0519b7493 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18041,18 +17007,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "b5bb4e7b4fe98a15592f7f5478c2fb2f854dd62d", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex eb0519b7493..e39cf80ca16 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17007,4 +16803,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "ea286363e63719c04f376fc0ae0b3bf7ef3f91df", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex e39cf80ca16..b4a16030367 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16803,18 +16798,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "e00128f0d50cc0246c56093f2ca3d82137b9b456", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b4a16030367..685571193da 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16798,4 +16806,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "4d150c0d70f1242fc1f86a555d42da472303a8dd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 685571193da..4bcd71ab059 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16806,18 +16801,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "4a28d613ce22c151aac15dde93f4de62e53dc465", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 4bcd71ab059..8790b702334 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16801,4 +16842,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "7e800609a3c59211562d3adec4cbd14a15751bc3", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 8790b702334..a402ba36eb2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16842,18 +16925,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "7bba3023100b62b409d03d252d0f28594ca6a137", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex a402ba36eb2..9028dae0393 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16925,4 +16805,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "d83ad3cf6780e6d63060dc80f5eded8bc4eda23a", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 9028dae0393..85a5aa5f4c8 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16805,18 +16919,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "a4660d9abbc4743739e224605d1cdda47a5ca50b", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 85a5aa5f4c8..b6495f5b662 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16919,4 +16935,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "71fe02147b55256a3434adbcfe56f0132225e4c2", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b6495f5b662..e6ef760d9cd 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16935,18 +16929,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "88b36c4e06902bf090d6e14fcffcbbbdee836f55", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex e6ef760d9cd..670269e9322 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16929,4 +16940,18 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    /**\n+     *\n+     * @param environmentName Environment name\n+     * @param vhost Host of the vhost\n+     * @return Resolved vhost\n+     * @throws APIManagementException if failed to find the read only environment\n+     */\n+    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n+        if (StringUtils.isEmpty(vhost)) {\n+            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n+        }\n+        return vhost;\n+    }\n }\n", "next_change": {"commit": "5e062b024d7031f9325b4629760bfada9dcd51f6", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 670269e9322..8eabb348efa 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16940,18 +16930,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    /**\n-     *\n-     * @param environmentName Environment name\n-     * @param vhost Host of the vhost\n-     * @return Resolved vhost\n-     * @throws APIManagementException if failed to find the read only environment\n-     */\n-    private String getResolvedVhost(String environmentName, String vhost) throws APIManagementException {\n-        if (StringUtils.isEmpty(vhost)) {\n-            return APIUtil.getDefaultVhostOfReadOnlyEnvironment(environmentName).getHost();\n-        }\n-        return vhost;\n-    }\n }\n", "next_change": {"commit": "30e6a9a5ebe290d5e9c8f18718177cea31eae722", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 8eabb348efa..6a53dd3f421 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16930,4 +16936,14 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    private void updateLatestRevisionNumber(Connection connection, String apiUUID, int revisionId) throws SQLException {\n+\n+        try (PreparedStatement preparedStatement =\n+                     connection.prepareStatement(SQLConstants.UPDATE_REVISION_CREATED_BY_API_SQL)) {\n+            preparedStatement.setInt(1, revisionId);\n+            preparedStatement.setString(2, apiUUID);\n+            preparedStatement.executeUpdate();\n+        }\n+    }\n }\n", "next_change": {"commit": "31ccb93c1561952dd93043f8a80484b2bd9121c2", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 6a53dd3f421..92e5c2e2957 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16936,14 +16941,4 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n-\n-    private void updateLatestRevisionNumber(Connection connection, String apiUUID, int revisionId) throws SQLException {\n-\n-        try (PreparedStatement preparedStatement =\n-                     connection.prepareStatement(SQLConstants.UPDATE_REVISION_CREATED_BY_API_SQL)) {\n-            preparedStatement.setInt(1, revisionId);\n-            preparedStatement.setString(2, apiUUID);\n-            preparedStatement.executeUpdate();\n-        }\n-    }\n }\n", "next_change": {"commit": "6f52960b3480ca09e048bc2d4fdf6387984a9712", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 92e5c2e2957..52b35dc4602 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16941,4 +16940,14 @@ public class ApiMgtDAO {\n             statement.executeUpdate();\n         }\n     }\n+\n+    private void updateLatestRevisionNumber(Connection connection, String apiUUID, int revisionId) throws SQLException {\n+\n+        try (PreparedStatement preparedStatement =\n+                     connection.prepareStatement(SQLConstants.UPDATE_REVISION_CREATED_BY_API_SQL)) {\n+            preparedStatement.setInt(1, revisionId);\n+            preparedStatement.setString(2, apiUUID);\n+            preparedStatement.executeUpdate();\n+        }\n+    }\n }\n", "next_change": {"commit": "eb5480f6810f52bf2116ed476c6bdfd0159db7bf", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 52b35dc4602..374718e8b23 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16950,4 +16970,25 @@ public class ApiMgtDAO {\n             preparedStatement.executeUpdate();\n         }\n     }\n+\n+    private void addAPIRevisionMetaData(Connection connection, String apiUUID, String revisionUUID) throws SQLException {\n+\n+        try (PreparedStatement preparedStatement =\n+                     connection.prepareStatement(SQLConstants.ADD_API_REVISION_METADATA)) {\n+            preparedStatement.setString(1, apiUUID);\n+            preparedStatement.setString(2, revisionUUID);\n+            preparedStatement.setString(3, apiUUID);\n+            preparedStatement.executeUpdate();\n+        }\n+    }\n+\n+    private void deleteAPIRevisionMetaData(Connection connection, String apiUUID, String revisionUUID) throws SQLException {\n+\n+        try (PreparedStatement preparedStatement =\n+                     connection.prepareStatement(SQLConstants.DELETE_API_REVISION_METADATA)) {\n+            preparedStatement.setString(1, apiUUID);\n+            preparedStatement.setString(2, revisionUUID);\n+            preparedStatement.executeUpdate();\n+        }\n+    }\n }\n", "next_change": {"commit": "4d92bd9631d93d6f2f17615725ee998485c42f6d", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 374718e8b23..8445699a327 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16991,4 +16992,14 @@ public class ApiMgtDAO {\n             preparedStatement.executeUpdate();\n         }\n     }\n+    private void restoreAPIRevisionMetaDataToWorkingCopy(Connection connection, String apiUUID, String revisionUUID) throws SQLException {\n+\n+        try (PreparedStatement preparedStatement =\n+                     connection.prepareStatement(SQLConstants.RESTORE_API_REVISION_METADATA)) {\n+            preparedStatement.setString(1, apiUUID);\n+            preparedStatement.setString(2, revisionUUID);\n+            preparedStatement.setString(3, apiUUID);\n+            preparedStatement.executeUpdate();\n+        }\n+    }\n }\n", "next_change": {"commit": "fd41a9f1a1c9856f1ef17550be29960c616d2da5", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 8445699a327..dadc567ee62 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17002,4 +17185,12 @@ public class ApiMgtDAO {\n             preparedStatement.executeUpdate();\n         }\n     }\n+\n+    private class SubscriptionInfo {\n+\n+        private int subscriptionId;\n+        private String tierId;\n+        private int applicationId;\n+        private String subscriptionStatus;\n+    }\n }\n", "next_change": {"commit": "7c0c85a8f81e73bae807395d605a56dc6ba5f416", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex dadc567ee62..e7c80233eff 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17192,5 +17195,53 @@ public class ApiMgtDAO {\n         private String tierId;\n         private int applicationId;\n         private String subscriptionStatus;\n+\n+        public SubscriptionInfo(int subscriptionId, String tierId, int applicationId, String subscriptionStatus) {\n+\n+            this.subscriptionId = subscriptionId;\n+            this.tierId = tierId;\n+            this.applicationId = applicationId;\n+            this.subscriptionStatus = subscriptionStatus;\n+        }\n+\n+        public int getSubscriptionId() {\n+\n+            return subscriptionId;\n+        }\n+\n+        public void setSubscriptionId(int subscriptionId) {\n+\n+            this.subscriptionId = subscriptionId;\n+        }\n+\n+        public String getTierId() {\n+\n+            return tierId;\n+        }\n+\n+        public void setTierId(String tierId) {\n+\n+            this.tierId = tierId;\n+        }\n+\n+        public int getApplicationId() {\n+\n+            return applicationId;\n+        }\n+\n+        public void setApplicationId(int applicationId) {\n+\n+            this.applicationId = applicationId;\n+        }\n+\n+        public String getSubscriptionStatus() {\n+\n+            return subscriptionStatus;\n+        }\n+\n+        public void setSubscriptionStatus(String subscriptionStatus) {\n+\n+            this.subscriptionStatus = subscriptionStatus;\n+        }\n     }\n }\n", "next_change": {"commit": "4d77b759feac5c08b9df38ac7973d376f1872964", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex e7c80233eff..1250b19ec67 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17188,60 +16985,4 @@ public class ApiMgtDAO {\n             preparedStatement.executeUpdate();\n         }\n     }\n-\n-    private class SubscriptionInfo {\n-\n-        private int subscriptionId;\n-        private String tierId;\n-        private int applicationId;\n-        private String subscriptionStatus;\n-\n-        public SubscriptionInfo(int subscriptionId, String tierId, int applicationId, String subscriptionStatus) {\n-\n-            this.subscriptionId = subscriptionId;\n-            this.tierId = tierId;\n-            this.applicationId = applicationId;\n-            this.subscriptionStatus = subscriptionStatus;\n-        }\n-\n-        public int getSubscriptionId() {\n-\n-            return subscriptionId;\n-        }\n-\n-        public void setSubscriptionId(int subscriptionId) {\n-\n-            this.subscriptionId = subscriptionId;\n-        }\n-\n-        public String getTierId() {\n-\n-            return tierId;\n-        }\n-\n-        public void setTierId(String tierId) {\n-\n-            this.tierId = tierId;\n-        }\n-\n-        public int getApplicationId() {\n-\n-            return applicationId;\n-        }\n-\n-        public void setApplicationId(int applicationId) {\n-\n-            this.applicationId = applicationId;\n-        }\n-\n-        public String getSubscriptionStatus() {\n-\n-            return subscriptionStatus;\n-        }\n-\n-        public void setSubscriptionStatus(String subscriptionStatus) {\n-\n-            this.subscriptionStatus = subscriptionStatus;\n-        }\n-    }\n }\n", "next_change": {"commit": "7c469008d4b3d4f84db689ccd263bbc7e6e23e89", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 1250b19ec67..1b8dec89f14 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -16985,4 +17206,60 @@ public class ApiMgtDAO {\n             preparedStatement.executeUpdate();\n         }\n     }\n+\n+    private class SubscriptionInfo {\n+\n+        private int subscriptionId;\n+        private String tierId;\n+        private int applicationId;\n+        private String subscriptionStatus;\n+\n+        public SubscriptionInfo(int subscriptionId, String tierId, int applicationId, String subscriptionStatus) {\n+\n+            this.subscriptionId = subscriptionId;\n+            this.tierId = tierId;\n+            this.applicationId = applicationId;\n+            this.subscriptionStatus = subscriptionStatus;\n+        }\n+\n+        public int getSubscriptionId() {\n+\n+            return subscriptionId;\n+        }\n+\n+        public void setSubscriptionId(int subscriptionId) {\n+\n+            this.subscriptionId = subscriptionId;\n+        }\n+\n+        public String getTierId() {\n+\n+            return tierId;\n+        }\n+\n+        public void setTierId(String tierId) {\n+\n+            this.tierId = tierId;\n+        }\n+\n+        public int getApplicationId() {\n+\n+            return applicationId;\n+        }\n+\n+        public void setApplicationId(int applicationId) {\n+\n+            this.applicationId = applicationId;\n+        }\n+\n+        public String getSubscriptionStatus() {\n+\n+            return subscriptionStatus;\n+        }\n+\n+        public void setSubscriptionStatus(String subscriptionStatus) {\n+\n+            this.subscriptionStatus = subscriptionStatus;\n+        }\n+    }\n }\n", "next_change": {"commit": "98e65bd39db61f4a56d5aab83c2ccc4f25b4fa6c", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 1b8dec89f14..3b1032b4b25 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17206,60 +17040,4 @@ public class ApiMgtDAO {\n             preparedStatement.executeUpdate();\n         }\n     }\n-\n-    private class SubscriptionInfo {\n-\n-        private int subscriptionId;\n-        private String tierId;\n-        private int applicationId;\n-        private String subscriptionStatus;\n-\n-        public SubscriptionInfo(int subscriptionId, String tierId, int applicationId, String subscriptionStatus) {\n-\n-            this.subscriptionId = subscriptionId;\n-            this.tierId = tierId;\n-            this.applicationId = applicationId;\n-            this.subscriptionStatus = subscriptionStatus;\n-        }\n-\n-        public int getSubscriptionId() {\n-\n-            return subscriptionId;\n-        }\n-\n-        public void setSubscriptionId(int subscriptionId) {\n-\n-            this.subscriptionId = subscriptionId;\n-        }\n-\n-        public String getTierId() {\n-\n-            return tierId;\n-        }\n-\n-        public void setTierId(String tierId) {\n-\n-            this.tierId = tierId;\n-        }\n-\n-        public int getApplicationId() {\n-\n-            return applicationId;\n-        }\n-\n-        public void setApplicationId(int applicationId) {\n-\n-            this.applicationId = applicationId;\n-        }\n-\n-        public String getSubscriptionStatus() {\n-\n-            return subscriptionStatus;\n-        }\n-\n-        public void setSubscriptionStatus(String subscriptionStatus) {\n-\n-            this.subscriptionStatus = subscriptionStatus;\n-        }\n-    }\n }\n", "next_change": {"commit": "275116d7eb6f6c5fd7ea1ade1cbb4355eea952b4", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 3b1032b4b25..bec8afbdcd4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17040,4 +17230,60 @@ public class ApiMgtDAO {\n             preparedStatement.executeUpdate();\n         }\n     }\n+\n+    private class SubscriptionInfo {\n+\n+        private int subscriptionId;\n+        private String tierId;\n+        private int applicationId;\n+        private String subscriptionStatus;\n+\n+        public SubscriptionInfo(int subscriptionId, String tierId, int applicationId, String subscriptionStatus) {\n+\n+            this.subscriptionId = subscriptionId;\n+            this.tierId = tierId;\n+            this.applicationId = applicationId;\n+            this.subscriptionStatus = subscriptionStatus;\n+        }\n+\n+        public int getSubscriptionId() {\n+\n+            return subscriptionId;\n+        }\n+\n+        public void setSubscriptionId(int subscriptionId) {\n+\n+            this.subscriptionId = subscriptionId;\n+        }\n+\n+        public String getTierId() {\n+\n+            return tierId;\n+        }\n+\n+        public void setTierId(String tierId) {\n+\n+            this.tierId = tierId;\n+        }\n+\n+        public int getApplicationId() {\n+\n+            return applicationId;\n+        }\n+\n+        public void setApplicationId(int applicationId) {\n+\n+            this.applicationId = applicationId;\n+        }\n+\n+        public String getSubscriptionStatus() {\n+\n+            return subscriptionStatus;\n+        }\n+\n+        public void setSubscriptionStatus(String subscriptionStatus) {\n+\n+            this.subscriptionStatus = subscriptionStatus;\n+        }\n+    }\n }\n", "next_change": {"commit": "85de0adab40a447958263043b936d60118f81ef8", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex bec8afbdcd4..c2fc5fce23a 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17286,4 +18068,236 @@ public class ApiMgtDAO {\n             this.subscriptionStatus = subscriptionStatus;\n         }\n     }\n+\n+    public boolean isAPISpecificOperationPolicyDefinitionExists(Connection connection, String apiUUID, String policyName)\n+            throws APIManagementException {\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.OperationPolicyConstants.GET_POLICY_ID_FROM_API_SPECIFIC_POLICY_DEFINITION)) {\n+            statement.setString(1, apiUUID);\n+            statement.setString(2, policyName);\n+            try (ResultSet resultSet = statement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get operation policy status of API \" + apiUUID + \" for policy \" + policyName, e);\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateAPISpecificOperationPolicyDefinition(Connection connection, String apiUUID,\n+                                                              OperationPolicyDefinition policyDefinition)\n+            throws APIManagementException {\n+        boolean result = false;\n+\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.OperationPolicyConstants.UPDATE_API_SPECIFIC_POLICY_DEFINITION)) {\n+            statement.setString(1, policyDefinition.getSpecification().getDisplayName());\n+            statement.setString(2, policyDefinition.getSpecification().getPolicyDescription());\n+            statement.setString(3, policyDefinition.getSpecification().getFlow().toString());\n+            statement.setString(4, policyDefinition.getSpecification().getSupportedGatewayTypes().toString());\n+            statement.setString(5, policyDefinition.getSpecification().getApiTypes().toString());\n+            statement.setBinaryStream(6, new ByteArrayInputStream(APIUtil.getPolicySpecString(policyDefinition).getBytes()));\n+            statement.setBinaryStream(7, new ByteArrayInputStream(policyDefinition.getDefinition().getBytes()));\n+            statement.setString(8, apiUUID);\n+            statement.setString(9, policyDefinition.getName());\n+            result = statement.executeUpdate() == 1;\n+        } catch (SQLException e) {\n+            handleException(\"Failed to update operation policy of API \" + apiUUID + \" for policy \" + policyDefinition.getName(), e);\n+        }\n+        return result;\n+    }\n+\n+    public boolean addAPISpecificOperationPolicyDefinition(String apiUUID, OperationPolicyDefinition policyDefinition)\n+            throws APIManagementException {\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_POLICY_DEFINITION;\n+        try (Connection connection = APIMgtDBUtil.getConnection()){\n+\n+            connection.setAutoCommit(false);\n+            boolean result = false;\n+            if (isAPISpecificOperationPolicyDefinitionExists(connection, apiUUID, policyDefinition.getName())) {\n+                updateAPISpecificOperationPolicyDefinition(connection, apiUUID, policyDefinition);\n+            } else {\n+                try (PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+                    statement.setString(1, apiUUID);\n+                    statement.setString(2, policyDefinition.getName());\n+                    statement.setString(3, policyDefinition.getSpecification().getDisplayName());\n+                    statement.setString(4, policyDefinition.getSpecification().getPolicyDescription());\n+                    statement.setString(5, policyDefinition.getSpecification().getFlow().toString());\n+                    statement.setString(6, policyDefinition.getSpecification().getSupportedGatewayTypes().toString());\n+                    statement.setString(7, policyDefinition.getSpecification().getApiTypes().toString());\n+                    statement.setInt(8, policyDefinition.getTemplateId());\n+                    statement.setBinaryStream(9, new ByteArrayInputStream(APIUtil.getPolicySpecString(policyDefinition).getBytes()));\n+                    statement.setBinaryStream(10, new ByteArrayInputStream(policyDefinition.getDefinition().getBytes()));\n+                    result = statement.executeUpdate() == 1;\n+                    connection.commit();\n+                }\n+            }\n+            return result;\n+        } catch (SQLException | APIManagementException e) {\n+            handleException(\"Failed to add operation policy of API \" + apiUUID + \" for policy \" + policyDefinition.getName(), e);\n+        }\n+        return true;\n+    }\n+\n+    public OperationPolicyDefinition getAPISpecificOperationPolicyDefinition(String apiUUID, String policyName)\n+            throws APIManagementException {\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_POLICY_DEFINITION;\n+        OperationPolicyDefinition policyDefinition;\n+        ResultSet rs = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, apiUUID);\n+            statement.setString(2, policyName);\n+            rs = statement.executeQuery();\n+            if (rs.next()) {\n+                policyDefinition = new OperationPolicyDefinition();\n+                policyDefinition.setName(policyName);\n+                policyDefinition.setApiId(apiUUID);\n+                policyDefinition.setPolicyId(rs.getInt(\"POLICY_ID\"));\n+                policyDefinition.setTemplateId(rs.getInt(\"TEMPLATE_ID\"));\n+\n+                OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+                policySpecification.setPolicyName(policyName);\n+                policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+                policySpecification.setPolicyDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+                policySpecification.setFlow(getListFromString(rs.getString(\"FLOW\")));\n+                policySpecification.setApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+                policySpecification.setSupportedGatewayTypes(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+                List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+                try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+                    String policyParametersString = IOUtils.toString(policyParametersStream);\n+                    policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                            new TypeToken<List<OperationPolicySpecAttribute>>(){}.getType());\n+\n+                } catch (IOException e) {\n+                    log.error(\"Error while converting policy Attributes in API \" + apiUUID + \" and policy \" + policyName, e);\n+                }\n+                policySpecification.setPolicyAttributes(policySpecAttributes);\n+                policyDefinition.setSpecification(policySpecification);\n+                return policyDefinition;\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get operation policy definition for API \" + apiUUID + \" for policy \" + policyName, e);\n+        }\n+        return null;\n+    }\n+\n+    public List<String> getListFromString(String stringElement) {\n+        List<String> list = null;\n+        if (!stringElement.isEmpty()){\n+            list = Arrays.asList(stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n+        }\n+        return list;\n+    }\n+\n+    public boolean addOperationPolicyTemplate(OperationPolicyDefinition policyDefinition)\n+            throws APIManagementException {\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY_TEMPLATE;\n+        try (Connection connection = APIMgtDBUtil.getConnection()){\n+\n+            connection.setAutoCommit(false);\n+            boolean result = false;\n+            if (isOperationPolicyTemplateExists(connection,policyDefinition.getName())) {\n+                updateOperationPolicyTemplate(connection, policyDefinition);\n+            } else {\n+                try (PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+                    statement.setString(1, policyDefinition.getName());\n+                    statement.setString(2, policyDefinition.getSpecification().getDisplayName());\n+                    statement.setString(3, policyDefinition.getSpecification().getPolicyDescription());\n+                    statement.setString(4, policyDefinition.getSpecification().getFlow().toString());\n+                    statement.setString(5, policyDefinition.getSpecification().getSupportedGatewayTypes().toString());\n+                    statement.setString(6, policyDefinition.getSpecification().getApiTypes().toString());\n+                    statement.setBinaryStream(7, new ByteArrayInputStream(APIUtil.getPolicySpecString(policyDefinition).getBytes()));\n+                    statement.setBinaryStream(8, new ByteArrayInputStream(policyDefinition.getDefinition().getBytes()));\n+                    result = statement.executeUpdate() == 1;\n+                    connection.commit();\n+                }\n+            }\n+            return result;\n+        } catch (SQLException | APIManagementException e) {\n+            handleException(\"Failed to add operation policy template \" + policyDefinition.getName(), e);\n+        }\n+        return true;\n+    }\n+\n+    public boolean isOperationPolicyTemplateExists(Connection connection, String policyName)\n+            throws APIManagementException {\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.OperationPolicyConstants.GET_TEMPLATE_ID_FROM_OPERATION_POLICY_TEMPLATE)) {\n+            statement.setString(1, policyName);\n+            try (ResultSet resultSet = statement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get operation policy template status of \" + policyName, e);\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateOperationPolicyTemplate(Connection connection, OperationPolicyDefinition policyDefinition)\n+            throws APIManagementException {\n+        boolean result = false;\n+        try (PreparedStatement statement = connection.prepareStatement(SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_TEMPLATE)) {\n+            statement.setString(1, policyDefinition.getSpecification().getDisplayName());\n+            statement.setString(2, policyDefinition.getSpecification().getPolicyDescription());\n+            statement.setString(3, policyDefinition.getSpecification().getFlow().toString());\n+            statement.setString(4, policyDefinition.getSpecification().getSupportedGatewayTypes().toString());\n+            statement.setString(5, policyDefinition.getSpecification().getApiTypes().toString());\n+            statement.setBinaryStream(6, new ByteArrayInputStream(APIUtil.getPolicySpecString(policyDefinition).getBytes()));\n+            statement.setBinaryStream(7, new ByteArrayInputStream(policyDefinition.getDefinition().getBytes()));\n+            statement.setString(8, policyDefinition.getName());\n+            result = statement.executeUpdate() == 1;\n+        } catch (SQLException e) {\n+            handleException(\"Failed to update operation policy template of \" + policyDefinition.getName(), e);\n+        }\n+        return result;\n+    }\n+\n+    public OperationPolicyDefinition getOperationPolicyTemplate(String policyName)\n+            throws APIManagementException {\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_TEMPLATE_FROM_POLICY_NAME;\n+        OperationPolicyDefinition policyDefinition;\n+        ResultSet rs = null;\n+        String policyDefinitionString = \"\";\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, policyName);\n+            rs = statement.executeQuery();\n+            if (rs.next()) {\n+                policyDefinition = new OperationPolicyDefinition();\n+                policyDefinition.setName(policyName);\n+                policyDefinition.setTemplateId(rs.getInt(\"TEMPLATE_ID\"));\n+\n+                OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+                policySpecification.setPolicyName(policyName);\n+                policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+                policySpecification.setPolicyDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+                policySpecification.setFlow(getListFromString(rs.getString(\"FLOW\")));\n+                policySpecification.setApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+                policySpecification.setSupportedGatewayTypes(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+                List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+                try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+                    String policyParametersString = IOUtils.toString(policyParametersStream);\n+                    policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                            new TypeToken<List<OperationPolicySpecAttribute>>(){}.getType());\n+                } catch (IOException e) {\n+                    log.error(\"Error while converting policy Attributes in policy \" + policyName, e);\n+                }\n+\n+                try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n+                    policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n+                } catch (IOException e) {\n+                    log.error(\"Error while converting policy Attributes in policy \" + policyName, e);\n+                }\n+                policySpecification.setPolicyAttributes(policySpecAttributes);\n+                policyDefinition.setSpecification(policySpecification);\n+                policyDefinition.setDefinition(policyDefinitionString);\n+                return policyDefinition;\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get operation policy template for policy \" + policyName, e);\n+        }\n+        return null;\n+    }\n }\n", "next_change": {"commit": "b59d4107fe54172b6cebbc9242f71f08592a781b", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex c2fc5fce23a..b451ec86260 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18296,7 +18583,7 @@ public class ApiMgtDAO {\n                 return policyDefinition;\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get operation policy template for policy \" + policyName, e);\n+            handleException(\"Failed to get operation policy template for the name \" + templateName, e);\n         }\n         return null;\n     }\n", "next_change": {"commit": "0e5f9e0c2357dc69058a7cda6f6bdf3fa2782763", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b451ec86260..bde92464f72 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18578,13 +18575,30 @@ public class ApiMgtDAO {\n                     log.error(\"Error while converting policy definition of template \" + templateName, e);\n                 }\n                 policySpecification.setPolicyAttributes(policySpecAttributes);\n-                policyDefinition.setSpecification(policySpecification);\n-                policyDefinition.setDefinition(policyDefinitionString);\n-                return policyDefinition;\n+                policyData.setSpecification(policySpecification);\n+                policyData.setDefinition(policyDefinitionString);\n+                return policyData;\n             }\n         } catch (SQLException e) {\n             handleException(\"Failed to get operation policy template for the name \" + templateName, e);\n         }\n         return null;\n     }\n+\n+    public String getTemplateId(Connection connection, String templateName) throws APIManagementException {\n+\n+        String policyId = null;\n+        String query = SQLConstants.OperationPolicyConstants.GET_TEMPLATE_ID_FROM_POLICY_TEMPLATE;\n+        try (PreparedStatement statement = connection.prepareStatement(query)) {\n+            statement.setString(1, templateName);\n+            try (ResultSet resultSet = statement.executeQuery()) {\n+                if (resultSet.next()) {\n+                    policyId = resultSet.getString(\"TEMPLATE_NAME\");\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get operation policy template ID for template \" + templateName, e);\n+        }\n+        return policyId;\n+    }\n }\n", "next_change": {"commit": "7fa78c52f305863f1daec32055e9a57ca9f30675", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex bde92464f72..281cd626701 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18580,24 +18580,24 @@ public class ApiMgtDAO {\n                 return policyData;\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get operation policy template for the name \" + templateName, e);\n+            handleException(\"Failed to get shared operation policy for the name \" + sharedPolicyName, e);\n         }\n         return null;\n     }\n \n-    public String getTemplateId(Connection connection, String templateName) throws APIManagementException {\n+    public String getSharedPolicyId(Connection connection, String sharedPolicyName) throws APIManagementException {\n \n         String policyId = null;\n-        String query = SQLConstants.OperationPolicyConstants.GET_TEMPLATE_ID_FROM_POLICY_TEMPLATE;\n+        String query = SQLConstants.OperationPolicyConstants.GET_SHARED_POLICY_ID_FROM_SHARED_POLICY_NAME;\n         try (PreparedStatement statement = connection.prepareStatement(query)) {\n-            statement.setString(1, templateName);\n+            statement.setString(1, sharedPolicyName);\n             try (ResultSet resultSet = statement.executeQuery()) {\n                 if (resultSet.next()) {\n-                    policyId = resultSet.getString(\"TEMPLATE_NAME\");\n+                    policyId = resultSet.getString(\"SHARED_POLICY_NAME\");\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get operation policy template ID for template \" + templateName, e);\n+            handleException(\"Failed to get policy ID for shared policy \" + sharedPolicyName, e);\n         }\n         return policyId;\n     }\n", "next_change": {"commit": "bd1e04308a090935b42f300d3b0f9b37be2c0754", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 281cd626701..e5b56ad4de2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18569,36 +18701,187 @@ public class ApiMgtDAO {\n                     log.error(\"Error while converting policy specification attributes for the shared policy \" + sharedPolicyName, e);\n                 }\n \n-                try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n-                    policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n+                policySpecification.setPolicyAttributes(policySpecAttributes);\n+                policyData.setSpecification(policySpecification);\n+                return policyData;\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get shared operation policy for the name \" + sharedPolicyName, e);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve the shared operation policy by providing the shared policy uuid\n+     *\n+     * @param sharedPolicyId            Shared policy UUID\n+     * @param tenantDomain              Tenant domain\n+     * @param isWithPolicyDefinition    Include the policy definition to the output or not\n+     * @return Shared operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyDataHolder getSharedOperationPolicyByPolicyID(String sharedPolicyId, String tenantDomain,\n+                                                                        boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        String dbQuery;\n+        if (isWithPolicyDefinition) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_SHARED_OPERATION_POLICY_WITH_DEFINITION_FROM_SHARED_POLICY_ID;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_SHARED_OPERATION_POLICY_FROM_SHARED_POLICY_ID;\n+        }\n+        OperationPolicyDataHolder policyData;\n+        ResultSet rs = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, sharedPolicyId);\n+            statement.setString(2, tenantDomain);\n+            rs = statement.executeQuery();\n+            if (rs.next()) {\n+                policyData = new OperationPolicyDataHolder();\n+                policyData.setPolicyId(sharedPolicyId);\n+                policyData.setSharedPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n+                policyData.setTenantDomain(tenantDomain);\n+\n+                OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+                policySpecification.setPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n+                policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+                policySpecification.setPolicyDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+                policySpecification.setFlow(getListFromString(rs.getString(\"FLOW\")));\n+                policySpecification.setApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+                policySpecification.setSupportedGatewayTypes(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+                List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+                try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+                    String policyParametersString = IOUtils.toString(policyParametersStream);\n+                    policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                            new TypeToken<List<OperationPolicySpecAttribute>>() {\n+                            }.getType());\n                 } catch (IOException e) {\n-                    log.error(\"Error while converting policy definition of shared policy \" + sharedPolicyName, e);\n+                    log.error(\"Error while converting policy specification attributes for the shared policy \"\n+                            + sharedPolicyId, e);\n                 }\n                 policySpecification.setPolicyAttributes(policySpecAttributes);\n                 policyData.setSpecification(policySpecification);\n-                policyData.setDefinition(policyDefinitionString);\n+\n+                if (isWithPolicyDefinition) {\n+                    try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n+                        String policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n+                        policyData.setDefinition(policyDefinitionString);\n+                    } catch (IOException e) {\n+                        log.error(\"Error while converting policy definition of shared policy \" + sharedPolicyId, e);\n+                    }\n+                }\n                 return policyData;\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get shared operation policy for the name \" + sharedPolicyName, e);\n+            handleException(\"Failed to get shared operation policy for id \" + sharedPolicyId, e);\n         }\n         return null;\n     }\n \n-    public String getSharedPolicyId(Connection connection, String sharedPolicyName) throws APIManagementException {\n+    /**\n+     * Get the UUID of a shared policy by using the policy name\n+     *\n+     * @param connection        DB connection\n+     * @param sharedPolicyName  Policy name\n+     * @param tenantDomain      Tenant domain\n+     * @return UUID of the shared operation policy\n+     * @throws APIManagementException\n+     */\n+    public String getSharedPolicyId(Connection connection, String sharedPolicyName, String tenantDomain)\n+            throws APIManagementException {\n \n         String policyId = null;\n         String query = SQLConstants.OperationPolicyConstants.GET_SHARED_POLICY_ID_FROM_SHARED_POLICY_NAME;\n         try (PreparedStatement statement = connection.prepareStatement(query)) {\n             statement.setString(1, sharedPolicyName);\n+            statement.setString(2, tenantDomain);\n             try (ResultSet resultSet = statement.executeQuery()) {\n                 if (resultSet.next()) {\n-                    policyId = resultSet.getString(\"SHARED_POLICY_NAME\");\n+                    policyId = resultSet.getString(\"SHARED_POLICY_ID\");\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get policy ID for shared policy \" + sharedPolicyName, e);\n+            handleException(\"Failed to get policy ID for the shared policy \" + sharedPolicyName, e);\n         }\n         return policyId;\n     }\n+\n+    /**\n+     * Get all the shared operation policies for a given tenant domain. This will contain the policiy specification of\n+     * all the shared policies and policy IDs. This will not include the policy definition as they are bit bulky and\n+     * is not useful for this operation.\n+     *\n+     * @param tenantDomain       Unique Identifier of API\n+     * @return List of OperationPolicies\n+     * @throws APIManagementException\n+     */\n+    public List<OperationPolicyDataHolder> getLightWeightSharedOperationPolicies(String tenantDomain)\n+            throws APIManagementException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_SHARED_OPERATION_POLICIES;\n+        List<OperationPolicyDataHolder> policyDataList = new ArrayList<>();\n+        ResultSet rs = null;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, tenantDomain);\n+            rs = statement.executeQuery();\n+            while (rs.next()) {\n+                OperationPolicyDataHolder policyData = new OperationPolicyDataHolder();\n+                policyData.setPolicyId(rs.getString(\"SHARED_POLICY_ID\"));\n+                policyData.setSharedPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n+                policyData.setTenantDomain(tenantDomain);\n+\n+                OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+                policySpecification.setPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n+                policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+                policySpecification.setPolicyDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+                policySpecification.setFlow(getListFromString(rs.getString(\"FLOW\")));\n+                policySpecification.setApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+                policySpecification.setSupportedGatewayTypes(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+                List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+                try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+                    String policyParametersString = IOUtils.toString(policyParametersStream);\n+                    policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                            new TypeToken<List<OperationPolicySpecAttribute>>() {\n+                            }.getType());\n+\n+                } catch (IOException e) {\n+                    log.error(\"Error while converting policy Attributes int policy \"\n+                            + policySpecification.getPolicyName(), e);\n+                }\n+                policySpecification.setPolicyAttributes(policySpecAttributes);\n+                policyData.setSpecification(policySpecification);\n+\n+                policyDataList.add(policyData);\n+\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the shared operation policy list for tenant \" + tenantDomain , e);\n+        }\n+        return policyDataList;\n+    }\n+\n+    /**\n+     * Delete a shared operation policy by providing the policy UUID and tenant domain\n+     *\n+     * @param policyId          UUID of the policy to be deleted\n+     * @param tenantDomain      Tenant domain name\n+     * @return True if deleted successfully\n+     * @throws APIManagementException\n+     */\n+    public boolean deleteSharedOperationPolicy(String policyId, String tenantDomain) throws APIManagementException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_SHARED_OPERATION_POLICY;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, policyId);\n+            statement.setString(2, tenantDomain);\n+            statement.execute();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete shared operation policy \" + policyId + \" for tenant \" + tenantDomain , e);\n+        }\n+        return true;\n+    }\n+\n }\n", "next_change": {"commit": "e1692244927a73d213df06b6d4e709b418f3db12", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex e5b56ad4de2..6a09f395d81 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18581,307 +18481,363 @@ public class ApiMgtDAO {\n     // Shared operation policy related operations\n \n     /**\n-     * Add a new shared operation policy to the database\n+     * Add a new common operation policy to the database\n      *\n      * @param policyData      Unique Identifier of API\n      * @param tenantDomain    Tenant domain\n      * @return UUID of the newly created shared policy\n      * @throws APIManagementException\n      */\n-    public String addSharedOperationPolicy(OperationPolicyDataHolder policyData, String tenantDomain)\n+    public String addOperationPolicy(OperationPolicyDataHolder policyData, String tenantDomain)\n             throws APIManagementException {\n \n         OperationPolicySpecification policySpecification = policyData.getSpecification();\n         String sharedPolicyUUID = null;\n         try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            connection.setAutoCommit(false);\n-            sharedPolicyUUID = getSharedPolicyId(connection, policySpecification.getPolicyName(), tenantDomain);\n-            if (sharedPolicyUUID != null) {\n-                updateSharedOperationPolicy(connection, policySpecification.getPolicyName(), policyData, tenantDomain);\n+            String dbQuery;\n+            if (policyData.isApiSpecificPolicy()) {\n+                dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY;\n             } else {\n-                String dbQuery = SQLConstants.OperationPolicyConstants.ADD_SHARED_OPERATION_POLICY;\n-                sharedPolicyUUID = UUID.randomUUID().toString();\n-                try (PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-                    statement.setString(1, sharedPolicyUUID);\n-                    statement.setString(2, policySpecification.getPolicyName());\n-                    statement.setString(3, policySpecification.getDisplayName());\n-                    statement.setString(4, policySpecification.getPolicyDescription());\n-                    statement.setString(5, policySpecification.getFlow().toString());\n-                    statement.setString(6, policySpecification.getSupportedGatewayTypes().toString());\n-                    statement.setString(7, policySpecification.getApiTypes().toString());\n-                    statement.setBinaryStream(8,\n-                            new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n-                    statement.setBinaryStream(9, new ByteArrayInputStream(policyData.getDefinition().getBytes()));\n-                    statement.setString(10, tenantDomain);\n-                    statement.executeUpdate();\n-\n+                dbQuery = SQLConstants.OperationPolicyConstants.ADD_COMMON_OPERATION_POLICY;\n+            }\n+            sharedPolicyUUID = UUID.randomUUID().toString();\n+            try (PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+                statement.setString(1, sharedPolicyUUID);\n+                statement.setString(2, policySpecification.getName());\n+                statement.setString(3, policySpecification.getDisplayName());\n+                statement.setString(4, policySpecification.getDescription());\n+                statement.setString(5, policySpecification.getApplicableFlows().toString());\n+                statement.setString(6, policySpecification.getSupportedGateways().toString());\n+                statement.setString(7, policySpecification.getSupportedApiTypes().toString());\n+                statement.setBinaryStream(8,\n+                        new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n+                statement.setBinaryStream(9, new ByteArrayInputStream(policyData.getDefinition().getBytes()));\n+                statement.setString(10, tenantDomain);\n+                statement.setString(11, policySpecification.getCategory().toString());\n+                statement.setBoolean(12, policySpecification.isMultipleAllowed());\n+                statement.setBoolean(13, policyData.isApiSpecificPolicy());\n+                statement.setString(14, policyData.getMd5Hash());\n+                if (policyData.isApiSpecificPolicy()) {\n+                    statement.setString(15, policyData.getApiUUID());\n                 }\n+                statement.executeUpdate();\n             }\n-            connection.commit();\n-        } catch (SQLException | APIManagementException e) {\n-            handleException(\"Failed to add shared operation policy \" + policySpecification.getPolicyName(), e);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add operation policy \" + policySpecification.getName(), e);\n         }\n         return sharedPolicyUUID;\n     }\n \n     /**\n-     * Update an existing shared operation policy\n+     * Update an existing operation policy\n      *\n-     * @param sharedPolicyName      Shared policy name\n+     * @param policyId              Shared policy UUID\n      * @param policyData            Updated policy definition\n      * @param tenantDomain          Tenant domain\n      * @return  True if the update was successful\n      * @throws APIManagementException\n      */\n-    public boolean updateSharedOperationPolicy(Connection connection, String sharedPolicyName,\n-                                               OperationPolicyDataHolder policyData, String tenantDomain)\n+    public boolean updateOperationPolicy(String policyId, OperationPolicyDataHolder policyData, String tenantDomain)\n             throws APIManagementException {\n \n         boolean result = false;\n         OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        try (PreparedStatement statement = connection.prepareStatement(\n-                SQLConstants.OperationPolicyConstants.UPDATE_SHARED_OPERATION_POLICY)) {\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(\n+                SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY)) {\n             statement.setString(1, policySpecification.getDisplayName());\n-            statement.setString(2, policySpecification.getPolicyDescription());\n-            statement.setString(3, policySpecification.getFlow().toString());\n-            statement.setString(4, policySpecification.getSupportedGatewayTypes().toString());\n-            statement.setString(5, policySpecification.getApiTypes().toString());\n+            statement.setString(2, policySpecification.getDescription());\n+            statement.setString(3, policySpecification.getApplicableFlows().toString());\n+            statement.setString(4, policySpecification.getSupportedGateways().toString());\n+            statement.setString(5, policySpecification.getSupportedApiTypes().toString());\n             statement.setBinaryStream(6,\n                     new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n             statement.setBinaryStream(7, new ByteArrayInputStream(policyData.getDefinition().getBytes()));\n-            statement.setString(8, sharedPolicyName);\n-            statement.setString(9, tenantDomain);\n+            statement.setString(8, policySpecification.getCategory().toString());\n+            statement.setBoolean(9, policySpecification.isMultipleAllowed());\n+            statement.setBoolean(10, policyData.isApiSpecificPolicy());\n+            statement.setString(11, policyData.getMd5Hash());\n+            statement.setString(12, policyId);\n             result = statement.executeUpdate() == 1;\n         } catch (SQLException e) {\n-            handleException(\"Failed to update shared operation policy of \" + sharedPolicyName, e);\n+            handleException(\"Failed to update the common operation policy of \" + policySpecification.getName(), e);\n         }\n         return result;\n     }\n \n+\n     /**\n-     * Retrieve the shared operation policy by providing the shared policy name. This output will not include the\n-     * policy definition as it is bulky and does not need for the operation.\n+     * Retrieve an operation policy by providing the policy uuid\n      *\n-     * @param sharedPolicyName      Shared policy name\n-     * @param tenantDomain          Tenant domain\n-     * @return Shared operation policy\n+     * @param policyId                  Policy UUID\n+     * @param isWithPolicyDefinition    Include the policy definition to the output or not\n+     * @return operation policy\n      * @throws APIManagementException\n      */\n-    public OperationPolicyDataHolder getSharedOperationPolicyByPolicyName(String sharedPolicyName, String tenantDomain)\n+    public OperationPolicyDataHolder getOperationPolicyByPolicyID(String policyId, boolean isWithPolicyDefinition)\n             throws APIManagementException {\n \n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_SHARED_OPERATION_POLICY_FROM_SHARED_POLICY_NAME;\n+        String dbQuery;\n+        if (isWithPolicyDefinition) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_ID;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_ID;\n+        }\n         OperationPolicyDataHolder policyData;\n         ResultSet rs = null;\n         try (Connection connection = APIMgtDBUtil.getConnection();\n              PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-            statement.setString(1, sharedPolicyName);\n+            statement.setString(1, policyId);\n+            rs = statement.executeQuery();\n+            if (rs.next()) {\n+                policyData = new OperationPolicyDataHolder();\n+                policyData.setPolicyId(policyId);\n+                policyData.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                policyData.setApiUUID(rs.getString(\"API_UUID\"));\n+                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+                if (isWithPolicyDefinition) {\n+                    policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n+                }\n+                return policyData;\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the operation policy for id \" + policyId, e);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve an operation policy by providing the policy name and tenant domain\n+     *\n+     * @param policyName    Policy name\n+     * @param tenantDomain  Tenant Domain\n+     * @param connection    DB connection\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyDataHolder getOperationPolicyByPolicyName(String policyName, String tenantDomain,\n+                                                                    Connection connection)\n+            throws APIManagementException {\n+\n+        OperationPolicyDataHolder policyData;\n+        ResultSet rs = null;\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_NAME;\n+        try (PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, policyName);\n             statement.setString(2, tenantDomain);\n             rs = statement.executeQuery();\n             if (rs.next()) {\n                 policyData = new OperationPolicyDataHolder();\n-                policyData.setSharedPolicyName(sharedPolicyName);\n-                policyData.setPolicyId(rs.getString(\"SHARED_POLICY_ID\"));\n                 policyData.setTenantDomain(tenantDomain);\n-\n-                OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n-                policySpecification.setPolicyName(sharedPolicyName);\n-                policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n-                policySpecification.setPolicyDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n-                policySpecification.setFlow(getListFromString(rs.getString(\"FLOW\")));\n-                policySpecification.setApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n-                policySpecification.setSupportedGatewayTypes(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n-                List<OperationPolicySpecAttribute> policySpecAttributes = null;\n-                try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n-                    String policyParametersString = IOUtils.toString(policyParametersStream);\n-                    policySpecAttributes = new Gson().fromJson(policyParametersString,\n-                            new TypeToken<List<OperationPolicySpecAttribute>>() {\n-                            }.getType());\n-                } catch (IOException e) {\n-                    log.error(\"Error while converting policy specification attributes for the shared policy \" + sharedPolicyName, e);\n-                }\n-\n-                policySpecification.setPolicyAttributes(policySpecAttributes);\n-                policyData.setSpecification(policySpecification);\n+                policyData.setPolicyId(rs.getString(\"POLICY_ID\"));\n+                policyData.setApiUUID(rs.getString(\"API_UUID\"));\n+                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+                policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n                 return policyData;\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get shared operation policy for the name \" + sharedPolicyName, e);\n+            handleException(\"Failed to get the operation policy of \" + policyName, e);\n         }\n         return null;\n     }\n \n+\n+\n     /**\n-     * Retrieve the shared operation policy by providing the shared policy uuid\n+     * Retrieve an operation policy by providing the policy name and tenant domain\n      *\n-     * @param sharedPolicyId            Shared policy UUID\n-     * @param tenantDomain              Tenant domain\n+     * @param policyName                Policy name\n+     * @param tenantDomain              Tenant Domain\n      * @param isWithPolicyDefinition    Include the policy definition to the output or not\n-     * @return Shared operation policy\n+     * @return operation policy\n      * @throws APIManagementException\n      */\n-    public OperationPolicyDataHolder getSharedOperationPolicyByPolicyID(String sharedPolicyId, String tenantDomain,\n-                                                                        boolean isWithPolicyDefinition)\n+    public OperationPolicyDataHolder getOperationPolicyByPolicyName(String policyName, String apiUUID, String tenantDomain,\n+                                                                    boolean isWithPolicyDefinition)\n             throws APIManagementException {\n \n         String dbQuery;\n         if (isWithPolicyDefinition) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_SHARED_OPERATION_POLICY_WITH_DEFINITION_FROM_SHARED_POLICY_ID;\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_NAME;\n         } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_SHARED_OPERATION_POLICY_FROM_SHARED_POLICY_ID;\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_NAME;\n+        }\n+\n+        if (apiUUID != null) {\n+            dbQuery += \" AND API_UUID = ?\";\n         }\n         OperationPolicyDataHolder policyData;\n         ResultSet rs = null;\n         try (Connection connection = APIMgtDBUtil.getConnection();\n              PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-            statement.setString(1, sharedPolicyId);\n+            statement.setString(1, policyName);\n             statement.setString(2, tenantDomain);\n+            if (apiUUID != null) {\n+                statement.setString(3, apiUUID);\n+            }\n             rs = statement.executeQuery();\n             if (rs.next()) {\n                 policyData = new OperationPolicyDataHolder();\n-                policyData.setPolicyId(sharedPolicyId);\n-                policyData.setSharedPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n                 policyData.setTenantDomain(tenantDomain);\n-\n-                OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n-                policySpecification.setPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n-                policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n-                policySpecification.setPolicyDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n-                policySpecification.setFlow(getListFromString(rs.getString(\"FLOW\")));\n-                policySpecification.setApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n-                policySpecification.setSupportedGatewayTypes(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n-                List<OperationPolicySpecAttribute> policySpecAttributes = null;\n-                try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n-                    String policyParametersString = IOUtils.toString(policyParametersStream);\n-                    policySpecAttributes = new Gson().fromJson(policyParametersString,\n-                            new TypeToken<List<OperationPolicySpecAttribute>>() {\n-                            }.getType());\n-                } catch (IOException e) {\n-                    log.error(\"Error while converting policy specification attributes for the shared policy \"\n-                            + sharedPolicyId, e);\n-                }\n-                policySpecification.setPolicyAttributes(policySpecAttributes);\n-                policyData.setSpecification(policySpecification);\n-\n+                policyData.setPolicyId(rs.getString(\"POLICY_ID\"));\n+                policyData.setApiUUID(rs.getString(\"API_UUID\"));\n+                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n                 if (isWithPolicyDefinition) {\n-                    try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n-                        String policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n-                        policyData.setDefinition(policyDefinitionString);\n-                    } catch (IOException e) {\n-                        log.error(\"Error while converting policy definition of shared policy \" + sharedPolicyId, e);\n-                    }\n+                    policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n                 }\n                 return policyData;\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get shared operation policy for id \" + sharedPolicyId, e);\n+            handleException(\"Failed to get the operation policy of \" + policyName, e);\n         }\n         return null;\n     }\n \n     /**\n-     * Get the UUID of a shared policy by using the policy name\n+     * Get the UUID of a policy by using the policy name\n      *\n-     * @param connection        DB connection\n-     * @param sharedPolicyName  Policy name\n+     * @param policyName        Policy name\n      * @param tenantDomain      Tenant domain\n      * @return UUID of the shared operation policy\n      * @throws APIManagementException\n      */\n-    public String getSharedPolicyId(Connection connection, String sharedPolicyName, String tenantDomain)\n+    public String getOperationPolicyId(String policyName, String apiUUID, String tenantDomain)\n             throws APIManagementException {\n \n         String policyId = null;\n-        String query = SQLConstants.OperationPolicyConstants.GET_SHARED_POLICY_ID_FROM_SHARED_POLICY_NAME;\n-        try (PreparedStatement statement = connection.prepareStatement(query)) {\n-            statement.setString(1, sharedPolicyName);\n+        String query;\n+        if (apiUUID != null) {\n+            query = SQLConstants.OperationPolicyConstants.GET_POLICY_ID_FOR_API_SPECIFIC_POLICY_NAME;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_POLICY_ID_FOR_COMMON_POLICY_NAME;\n+        }\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+                PreparedStatement statement = connection.prepareStatement(query)) {\n+            statement.setString(1, policyName);\n             statement.setString(2, tenantDomain);\n+            if (apiUUID != null) {\n+                statement.setString(3, apiUUID);\n+            }\n             try (ResultSet resultSet = statement.executeQuery()) {\n                 if (resultSet.next()) {\n-                    policyId = resultSet.getString(\"SHARED_POLICY_ID\");\n+                    policyId = resultSet.getString(\"POLICY_ID\");\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get policy ID for the shared policy \" + sharedPolicyName, e);\n+            handleException(\"Failed to get policy ID for the policy \" + policyName, e);\n         }\n         return policyId;\n     }\n \n     /**\n-     * Get all the shared operation policies for a given tenant domain. This will contain the policiy specification of\n-     * all the shared policies and policy IDs. This will not include the policy definition as they are bit bulky and\n-     * is not useful for this operation.\n+     * Get the list of all operation policies. If the API UUID is provided, this will return all the operation policies\n+     * for that API. If not, it will return the common operation policies which are not bound to any API.\n+     * This list will include policy specification of each policy and policy ID. It will not contain the\n+     * policy definition as it is not useful for the operation.\n      *\n-     * @param tenantDomain       Unique Identifier of API\n-     * @return List of OperationPolicies\n+     * @param apiUUID           UUID of the API if exists. Null for common operation policies\n+     * @param tenantDomain      Tenant domain\n+     * @return List of Operation Policies\n      * @throws APIManagementException\n      */\n-    public List<OperationPolicyDataHolder> getLightWeightSharedOperationPolicies(String tenantDomain)\n+    public List<OperationPolicyDataHolder> getLightWeightVersionOfAllOperationPolicies(String apiUUID,\n+                                                                                       String tenantDomain)\n             throws APIManagementException {\n \n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_SHARED_OPERATION_POLICIES;\n+        String dbQuery;\n+        if (apiUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_OPERATION_POLICIES;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_COMMON_OPERATION_POLICIES;\n+        }\n         List<OperationPolicyDataHolder> policyDataList = new ArrayList<>();\n         ResultSet rs = null;\n         try (Connection connection = APIMgtDBUtil.getConnection();\n              PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n             statement.setString(1, tenantDomain);\n+            if (apiUUID != null){\n+                statement.setString(2, apiUUID);\n+            }\n             rs = statement.executeQuery();\n             while (rs.next()) {\n                 OperationPolicyDataHolder policyData = new OperationPolicyDataHolder();\n-                policyData.setPolicyId(rs.getString(\"SHARED_POLICY_ID\"));\n-                policyData.setSharedPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n                 policyData.setTenantDomain(tenantDomain);\n-\n-                OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n-                policySpecification.setPolicyName(rs.getString(\"SHARED_POLICY_NAME\"));\n-                policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n-                policySpecification.setPolicyDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n-                policySpecification.setFlow(getListFromString(rs.getString(\"FLOW\")));\n-                policySpecification.setApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n-                policySpecification.setSupportedGatewayTypes(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n-                List<OperationPolicySpecAttribute> policySpecAttributes = null;\n-                try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n-                    String policyParametersString = IOUtils.toString(policyParametersStream);\n-                    policySpecAttributes = new Gson().fromJson(policyParametersString,\n-                            new TypeToken<List<OperationPolicySpecAttribute>>() {\n-                            }.getType());\n-\n-                } catch (IOException e) {\n-                    log.error(\"Error while converting policy Attributes int policy \"\n-                            + policySpecification.getPolicyName(), e);\n-                }\n-                policySpecification.setPolicyAttributes(policySpecAttributes);\n-                policyData.setSpecification(policySpecification);\n-\n+                policyData.setPolicyId(rs.getString(\"POLICY_ID\"));\n+                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n                 policyDataList.add(policyData);\n-\n             }\n         } catch (SQLException e) {\n-            handleException(\"Failed to get the shared operation policy list for tenant \" + tenantDomain , e);\n+            handleException(\"Failed to get all the common operation policy list for tenant \" + tenantDomain , e);\n         }\n         return policyDataList;\n     }\n \n     /**\n-     * Delete a shared operation policy by providing the policy UUID and tenant domain\n+     * Delete an operation policy by providing the policy UUID and tenant domain\n      *\n      * @param policyId          UUID of the policy to be deleted\n      * @param tenantDomain      Tenant domain name\n      * @return True if deleted successfully\n      * @throws APIManagementException\n      */\n-    public boolean deleteSharedOperationPolicy(String policyId, String tenantDomain) throws APIManagementException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_SHARED_OPERATION_POLICY;\n+    public boolean deleteOperationPolicyByPolicyId(String policyId, String apiUUID, String tenantDomain) throws APIManagementException {\n+        String dbQuery;\n+        if (apiUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.DELETE_API_SPECIFIC_OPERATION_POLICY;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.DELETE_COMMON_OPERATION_POLICY;\n+        }\n         try (Connection connection = APIMgtDBUtil.getConnection();\n              PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n             statement.setString(1, policyId);\n             statement.setString(2, tenantDomain);\n+            if (apiUUID != null) {\n+                statement.setString(3, apiUUID);\n+            }\n             statement.execute();\n         } catch (SQLException e) {\n-            handleException(\"Failed to delete shared operation policy \" + policyId + \" for tenant \" + tenantDomain , e);\n+            handleException(\"Failed to delete operation policy \" + policyId + \" for tenant \" + tenantDomain , e);\n         }\n         return true;\n     }\n \n+    public OperationPolicySpecification populatePolicySpecificationFromRS(ResultSet rs) throws SQLException {\n+        OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+        policySpecification.setName(rs.getString(\"POLICY_NAME\"));\n+        policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+        policySpecification.setDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+        policySpecification.setApplicableFlows(getListFromString(rs.getString(\"APPLICABLE_FLOWS\")));\n+        policySpecification.setSupportedApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+        policySpecification.setSupportedGateways(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+        policySpecification.setCategory(OperationPolicySpecification.PolicyCategory\n+                .valueOf(rs.getString(\"POLICY_CATEGORY\")));\n+        policySpecification.setMultipleAllowed(rs.getBoolean(\"MULTIPLE_ALLOWED\"));\n+        List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+\n+        try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+            String policyParametersString = IOUtils.toString(policyParametersStream);\n+            policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                    new TypeToken<List<OperationPolicySpecAttribute>>() {\n+                    }.getType());\n+        } catch (IOException e) {\n+            log.error(\"Error while converting policy specification attributes for the policy \"\n+                    + policySpecification.getName(), e);\n+        }\n+        policySpecification.setPolicyAttributes(policySpecAttributes);\n+        return policySpecification;\n+    }\n+\n+    public String getPolicyDefinitionFromRs(ResultSet rs) throws SQLException {\n+        try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n+            String policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n+            return policyDefinitionString;\n+        } catch (IOException e) {\n+            log.error(\"Error while converting policy definition for the policy\", e);\n+        }\n+        return null;\n+    }\n }\n", "next_change": {"commit": "4178afd1404fd9ffbfe4d843b7a02c7bdf66adc3", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 6a09f395d81..fd48b23cbeb 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18840,4 +19053,20 @@ public class ApiMgtDAO {\n         }\n         return null;\n     }\n+\n+    /**\n+     * Create a string list from a single string element by splitting from the comma\n+     *\n+     * @param stringElement String element\n+     * @return list of strings\n+     */\n+    private List<String> getListFromString(String stringElement) {\n+\n+        List<String> list = null;\n+        if (!stringElement.isEmpty()) {\n+            list = Arrays.asList(\n+                    stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n+        }\n+        return list;\n+    }\n }\n", "next_change": {"commit": "2a15054184792e6af30c7be4f940029bdce72e2c", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex fd48b23cbeb..86ec021fb73 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17957,1116 +17682,4 @@ public class ApiMgtDAO {\n             this.subscriptionStatus = subscriptionStatus;\n         }\n     }\n-\n-    /**\n-     * Operation policy implementation\n-     *\n-     */\n-\n-    /**\n-     * Add a new common operation policy to the database. This will first add the operation policy content to the\n-     * AM_OPERATION_POLICY table and another entry to AM_COMMON_OPERATION_POLICY table.\n-     *\n-     * @param policyData Operation policy data.\n-     * @return UUID of the newly created shared policy\n-     * @throws APIManagementException\n-     */\n-    public String addCommonOperationPolicy(OperationPolicyDataHolder policyData) throws APIManagementException {\n-\n-        String policyUUID = null;\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                policyUUID = addOperationPolicyContent(connection, policyData);\n-\n-                String dbQuery = SQLConstants.OperationPolicyConstants.ADD_COMMON_OPERATION_POLICY;\n-                PreparedStatement statement = connection.prepareStatement(dbQuery);\n-                statement.setString(1, policyUUID);\n-                statement.executeUpdate();\n-                statement.close();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n-        }\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * Add a new API specific operation policy to the database\n-     *\n-     * @param apiUUID      Unique Identifier of API\n-     * @param revisionUUID Unique Identifier of API revision\n-     * @param policyData   Unique Identifier of API\n-     * @return UUID of the newly created shared policy\n-     * @throws APIManagementException\n-     */\n-    public String addAPISpecificOperationPolicy(String apiUUID, String revisionUUID,\n-                                                OperationPolicyDataHolder policyData)\n-            throws APIManagementException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                String policyID = addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, null);\n-                connection.commit();\n-                return policyID;\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n-                        + \" for API \" + apiUUID, e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n-                    + \" for API \" + apiUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private String addAPISpecificOperationPolicy(Connection connection, String apiUUID, String revisionUUID,\n-                                                OperationPolicyDataHolder policyData, String clonedPolicyId)\n-            throws SQLException {\n-\n-        String policyUUID = addOperationPolicyContent(connection, policyData);\n-\n-        String dbQuery;\n-        if (revisionUUID != null) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY_WITH_REVISION;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY;\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyUUID);\n-        statement.setString(2, apiUUID);\n-        statement.setString(3, clonedPolicyId);\n-        if (revisionUUID != null) {\n-            statement.setString(4, revisionUUID);\n-        }\n-        statement.executeUpdate();\n-        statement.close();\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * This method is used to populate AM_OPERATION_POLICY table. This will return the policy ID.\n-     *\n-     * @param connection DB connection\n-     * @param policyData Unique Identifier of API\n-     * @return UUID of the newly created policy\n-     * @throws SQLException\n-     */\n-    private String addOperationPolicyContent(Connection connection, OperationPolicyDataHolder policyData)\n-            throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY;\n-        String policyUUID = UUID.randomUUID().toString();\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyUUID);\n-        statement.setString(2, policySpecification.getName());\n-        statement.setString(3, policySpecification.getDisplayName());\n-        statement.setString(4, policySpecification.getDescription());\n-        statement.setString(5, policySpecification.getApplicableFlows().toString());\n-        statement.setString(6, policySpecification.getSupportedGateways().toString());\n-        statement.setString(7, policySpecification.getSupportedApiTypes().toString());\n-        statement.setBinaryStream(8,\n-                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n-        statement.setBinaryStream(9, new ByteArrayInputStream(policyData.getDefinition().getBytes()));\n-        statement.setString(10, policyData.getOrganization());\n-        statement.setString(11, policySpecification.getCategory().toString());\n-        statement.setBoolean(12, policySpecification.isMultipleAllowed());\n-        statement.setString(13, policyData.getMd5Hash());\n-        statement.executeUpdate();\n-        statement.close();\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * Update an existing operation policy\n-     *\n-     * @param policyId   Shared policy UUID\n-     * @param policyData Updated policy definition\n-     * @throws APIManagementException\n-     */\n-    public void updateOperationPolicy(String policyId, OperationPolicyDataHolder policyData)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            updateOperationPolicy(connection, policyId, policyData);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to update the operation policy with ID \" + policyId, e);\n-        }\n-    }\n-\n-    /**\n-     * Update an existing operation policy\n-     *\n-     * @param connection DB connection\n-     * @param policyId   Shared policy UUID\n-     * @param policyData Updated policy definition\n-     * @throws SQLException\n-     */\n-    private void updateOperationPolicy(Connection connection, String policyId, OperationPolicyDataHolder policyData)\n-            throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        PreparedStatement statement = connection.prepareStatement(\n-                SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_CONTENT);\n-\n-        statement.setString(1, policySpecification.getName());\n-        statement.setString(2, policySpecification.getDisplayName());\n-        statement.setString(3, policySpecification.getDescription());\n-        statement.setString(4, policySpecification.getApplicableFlows().toString());\n-        statement.setString(5, policySpecification.getSupportedGateways().toString());\n-        statement.setString(6, policySpecification.getSupportedApiTypes().toString());\n-        statement.setBinaryStream(7,\n-                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n-        statement.setBinaryStream(8, new ByteArrayInputStream(policyData.getDefinition().getBytes()));\n-        statement.setString(9, policyData.getOrganization());\n-        statement.setString(10, policySpecification.getCategory().toString());\n-        statement.setBoolean(11, policySpecification.isMultipleAllowed());\n-        statement.setString(12, policyData.getMd5Hash());\n-        statement.setString(13, policyId);\n-        statement.executeUpdate();\n-        statement.close();\n-    }\n-\n-    /**\n-     * Delete an operation policy by providing the policy UUID\n-     *\n-     * @param policyId UUID of the policy to be deleted\n-     * @return True if deleted successfully\n-     * @throws APIManagementException\n-     */\n-    public void deleteOperationPolicyByPolicyId(String policyId) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            deleteOperationPolicyByPolicyId(connection, policyId);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete operation policy \" + policyId, e);\n-        }\n-    }\n-\n-    private void deleteOperationPolicyByPolicyId(Connection connection, String policyId) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.execute();\n-        statement.close();\n-    }\n-\n-    /**\n-     * Get the set of URI templates that have Operation policies\n-     *\n-     * @param apiUUID Unique Identifier of API\n-     * @return URITemplate set\n-     * @throws APIManagementException\n-     */\n-    public Set<URITemplate> getURITemplatesWithOperationPolicies(String apiUUID) throws APIManagementException {\n-\n-        String query;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(apiUUID);\n-\n-        if (apiRevision == null) {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-        }\n-\n-        Map<String, URITemplate> uriTemplates = new HashMap<>();\n-        Set<URITemplate> uriTemplateList = new HashSet<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement prepStmt = connection.prepareStatement(query)) {\n-            if (apiRevision == null) {\n-                int apiId = getAPIID(apiUUID, connection);\n-                prepStmt.setInt(1, apiId);\n-            } else {\n-                int apiId = getAPIID(apiRevision.getApiUUID(), connection);\n-                prepStmt.setInt(1, apiId);\n-                prepStmt.setString(2, apiRevision.getRevisionUUID());\n-            }\n-            try (ResultSet rs = prepStmt.executeQuery()) {\n-                URITemplate uriTemplate;\n-                while (rs.next()) {\n-                    String httpMethod = rs.getString(\"HTTP_METHOD\");\n-                    String urlPattern = rs.getString(\"URL_PATTERN\");\n-                    String urlTemplateKey = httpMethod + \":\" + urlPattern;\n-                    if (!uriTemplates.containsKey(urlTemplateKey)) {\n-                        uriTemplate = new URITemplate();\n-                    } else {\n-                        uriTemplate = uriTemplates.get(urlTemplateKey);\n-                    }\n-                    OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                    uriTemplate.addOperationPolicy(operationPolicy);\n-                    uriTemplate.setHTTPVerb(httpMethod);\n-                    uriTemplate.setUriTemplate(urlPattern);\n-                    uriTemplate.setId(rs.getInt(\"URL_MAPPING_ID\"));\n-                    uriTemplates.put(urlTemplateKey, uriTemplate);\n-                }\n-            }\n-            uriTemplateList.addAll(uriTemplates.values());\n-        } catch (SQLException e) {\n-            handleException(\"Error while fetching URI templates with operation policies for \" + apiUUID, e);\n-        }\n-        return uriTemplateList;\n-    }\n-\n-    /**\n-     * Get operation polycies attached to the resource identified by the url mapping ID\n-     *\n-     * @param urlMappingId URL Mapping ID of the resource\n-     * @return\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private List<OperationPolicy> getOperationPoliciesOfURITemplate(int urlMappingId)\n-            throws SQLException, APIManagementException {\n-\n-        List<OperationPolicy> operationPolicies = new ArrayList<>();\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(\n-                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_BY_URI_TEMPLATE_ID)) {\n-            ps.setInt(1, urlMappingId);\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    OperationPolicy policy = populateOperationPolicyWithRS(rs);\n-                    operationPolicies.add(policy);\n-                }\n-            }\n-        }\n-        return operationPolicies;\n-    }\n-\n-    /**\n-     * Sets operation policies to uriTemplates map\n-     *\n-     * @param uuid         UUID of API or API Revision\n-     * @param uriTemplates URI Templates map with 'URL_PATTERN + HTTP_METHOD' as the map key\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setOperationPoliciesToURITemplatesMap(String uuid, Map<String, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        String currentApiUuid;\n-        String query;\n-        boolean isRevision = false;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n-        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n-            currentApiUuid = apiRevision.getApiUUID();\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-            isRevision = true;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-            currentApiUuid = uuid;\n-        }\n-\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(query)) {\n-            int apiId = getAPIID(currentApiUuid);\n-            ps.setInt(1, apiId);\n-            if (isRevision) {\n-                ps.setString(2, uuid);\n-            }\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(key);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets operation policies to uriTemplates map\n-     *\n-     * @param uuid         UUID of API or API Revision\n-     * @param uriTemplates URI Templates map with URL_MAPPING_ID as the map key\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setOperationPolicies(String uuid, Map<Integer, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        String currentApiUuid;\n-        String query;\n-        boolean isRevision = false;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n-        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n-            currentApiUuid = apiRevision.getApiUUID();\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-            isRevision = true;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-            currentApiUuid = uuid;\n-        }\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(query)) {\n-            int apiId = getAPIID(currentApiUuid);\n-            ps.setInt(1, apiId);\n-            if (isRevision) {\n-                ps.setString(2, uuid);\n-            }\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    int uriTemplateId = rs.getInt(\"URL_MAPPING_ID\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(uriTemplateId);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Populates operation policy mappings in the API Product URITemplate map\n-     *\n-     * @param productRevisionId Product Revision ID\n-     * @param uriTemplates      Map of URI Templates\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setAPIProductOperationPoliciesToURITemplatesMap(String productRevisionId,\n-                                                                 Map<String, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(\n-                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_PER_API_PRODUCT_SQL)) {\n-            ps.setString(1, productRevisionId);\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(key);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Clone an operation policy to the API. This method is used in two flows.\n-     * Cloning a common policy to API.\n-     * Cloning a dependent policy of a product\n-     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n-     *\n-     * @param connection   DB connection\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param apiUUID      UUID of the API\n-     * @param revisionUUID UUID of the revision\n-     * @return cloned policyID\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private String cloneOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID)\n-            throws APIManagementException, SQLException {\n-\n-        OperationPolicyDataHolder policyData = getOperationPolicyByPolicyID(connection, policyId, true);\n-        if (policyData != null) {\n-            // If we are taking a clone from common policy, common policy's Id is used as the CLONED_COMMON_POLICY_ID.\n-            // If we are cloning for an API Product, dependent APIs' id is used.\n-            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, policyId);\n-        } else {\n-            throw new APIManagementException(\"Cannot clone policy with ID \" + policyId + \" as it does not exists.\");\n-        }\n-    }\n-\n-    /**\n-     * This method is used in the creating a revision for API and API product. This will create a new API specific policy\n-     * with API UUID and revision UUID.\n-     *\n-     * @param connection   DB connection\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param apiUUID      UUID of the API\n-     * @param revisionUUID UUID of the revision\n-     * @return cloned policyID\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private String revisionOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID,\n-                                          String organization)\n-            throws APIManagementException, SQLException {\n-\n-        OperationPolicyDataHolder policyData = getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID,\n-                organization, true);\n-        // Since we import all the policies to API at API update, getting the policy from API specific policy list is enough\n-        if (policyData != null) {\n-            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData,\n-                    policyData.getClonedCommonPolicyId());\n-        } else {\n-            throw new APIManagementException(\"Cannot create a revision of policy with ID \" + policyId\n-                    + \" as it does not exists.\");\n-        }\n-    }\n-\n-    /**\n-     * This method is used the restore flow. At the restore, apart from the policy details, CLONED_COMMON_POLICY_ID column\n-     * too can change and that needs to be updated.\n-     *\n-     * @param connection DB connection\n-     * @param policyId   Original policy's ID that needs to be cloned\n-     * @param policyData Updated policy data\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private void updateAPISpecificOperationPolicyWithClonedPolicyId(Connection connection, String policyId,\n-                                                                   OperationPolicyDataHolder policyData)\n-            throws SQLException {\n-\n-        if (policyData.getClonedCommonPolicyId() != null) {\n-            PreparedStatement statement = connection.prepareStatement(\n-                    SQLConstants.OperationPolicyConstants.UPDATE_API_OPERATION_POLICY_BY_POLICY_ID);\n-            statement.setString(1, policyData.getClonedCommonPolicyId());\n-            statement.executeUpdate();\n-            statement.close();\n-        }\n-        updateOperationPolicy(connection, policyId, policyData);\n-    }\n-\n-    /**\n-     * This method is used to restore an API specific operation policy revision.\n-     *\n-     * @param connection   DB connection\n-     * @param apiUUID      UUID of the API\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param revisionId   The revision number\n-     * @param organization Organization name\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     **/\n-    private String restoreOperationPolicyRevision(Connection connection, String apiUUID, String policyId, int revisionId,\n-                                                 String organization) throws SQLException, APIManagementException {\n-\n-        OperationPolicyDataHolder revisionedPolicy = getAPISpecificOperationPolicyByPolicyID(connection, policyId,\n-                apiUUID, organization, true);\n-        String restoredPolicyId = null;\n-        if (revisionedPolicy != null) {\n-            // First check whether there exists a API specific policy for same policy name with revision uuid null\n-            // This is the state where we record the policies applied in the working copy.\n-            OperationPolicyDataHolder apiSpecificPolicy = getAPISpecificOperationPolicyByPolicyName(connection,\n-                    revisionedPolicy.getSpecification().getName(), revisionedPolicy.getApiUUID(), null,\n-                    organization, false);\n-            if (apiSpecificPolicy != null) {\n-                if (apiSpecificPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Matching API specific operation policy found for the revisioned policy and \" +\n-                                \"MD5 hashes match\");\n-                    }\n-\n-                } else {\n-                    updateAPISpecificOperationPolicyWithClonedPolicyId(connection, apiSpecificPolicy.getPolicyId(),\n-                            revisionedPolicy);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Even though a matching API specific operation policy found for name,\"\n-                                + \" MD5 hashes does not match. Policy \" + apiSpecificPolicy.getPolicyId()\n-                                + \" has been updated from the revision.\");\n-                    }\n-                }\n-                restoredPolicyId = apiSpecificPolicy.getPolicyId();\n-            } else {\n-                if (revisionedPolicy.isClonedPolicy()) {\n-                    // Check for a common operation policy only if it is a cloned policy.\n-                    OperationPolicyDataHolder commonPolicy = getCommonOperationPolicyByPolicyID(connection,\n-                            revisionedPolicy.getClonedCommonPolicyId(), organization, false);\n-                    if (commonPolicy != null) {\n-                        if (commonPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\"Matching common operation policy found. MD5 hash match\");\n-                            }\n-                            //This means the common policy is same with our revision. A clone is created and original\n-                            // common policy ID is referenced as the ClonedCommonPolicyId\n-                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n-                                    revisionedPolicy, revisionedPolicy.getClonedCommonPolicyId());\n-                        } else {\n-                            // This means the common policy is updated since we created the revision.\n-                            // we have to create a clone and since policy is different, we can't refer the original common\n-                            // policy as ClonedCommonPolicyId. This should be a new API specific policy\n-                            revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n-                                    + \"_restored-\" + revisionId);\n-                            revisionedPolicy.getSpecification()\n-                                    .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n-                                            + \" Restored from revision \" + revisionId);\n-                            revisionedPolicy\n-                                    .setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy.getSpecification(),\n-                                            revisionedPolicy.getDefinition()));\n-                            revisionedPolicy.setRevisionUUID(null);\n-                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n-                                    revisionedPolicy, null);\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\n-                                        \"An updated matching common operation policy found. A new API specific operation \" +\n-                                                \"policy created by the display name \" +\n-                                                revisionedPolicy.getSpecification().getName());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    // This means this is a completely new policy and we don't have any reference of a previous state in\n-                    // working copy. A new API specific policy will be created.\n-                    revisionedPolicy.setRevisionUUID(null);\n-                    restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"No matching operation policy found. A new API specific operation \" +\n-                                \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n-                    }\n-                }\n-            }\n-        } else {\n-            throw new APIManagementException(\"A revisioned operation policy not found for \" + policyId);\n-        }\n-        return restoredPolicyId;\n-    }\n-\n-    /**\n-     * Retrieve an operation policy by providing the policy uuid\n-     *\n-     * @param connection             DB connection\n-     * @param policyId               Policy UUID\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws SQLException\n-     */\n-    private OperationPolicyDataHolder getOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                           boolean isWithPolicyDefinition) throws SQLException {\n-\n-        String dbQuery;\n-        if (isWithPolicyDefinition) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_ID;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_ID;\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        ResultSet rs = statement.executeQuery();\n-        if (rs.next()) {\n-            OperationPolicyDataHolder policyData = new OperationPolicyDataHolder();\n-            policyData.setPolicyId(policyId);\n-            policyData.setOrganization(rs.getString(\"ORGANIZATION\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-            if (isWithPolicyDefinition) {\n-                policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n-            }\n-            return policyData;\n-        }\n-        rs.close();\n-        statement.close();\n-        return null;\n-    }\n-\n-    /**\n-     * Get the API specific operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n-     * table and AM_API_OPERATION_POLICY table from API UUID. Policy id might be available, but if it is not referenced in the\n-     * APIS table, this will return null.\n-     * The returned policy data can be either an API only policy, cloned common policy to API or a revisioned API specific policy\n-     *\n-     * @param policyId               Policy UUID\n-     * @param apiUUID                UUID of the API\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyDataHolder getAPISpecificOperationPolicyByPolicyID(String policyId, String apiUUID,\n-                                                                             String organization,\n-                                                                             boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID, organization,\n-                    isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the API specific operation policy for id \" + policyId + \" from API \"\n-                    + apiUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyDataHolder getAPISpecificOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                                              String apiUUID,\n-                                                                              String organization,\n-                                                                              boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery;\n-        if (isWithPolicyDefinition) {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_ID;\n-        } else {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_ID;\n-        }\n-        OperationPolicyDataHolder policyData = null;\n-        ResultSet rs = null;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, organization);\n-        statement.setString(3, apiUUID);\n-        rs = statement.executeQuery();\n-        if (rs.next()) {\n-            policyData = new OperationPolicyDataHolder();\n-            policyData.setPolicyId(policyId);\n-            policyData.setApiUUID(apiUUID);\n-            policyData.setOrganization(organization);\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n-            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_COMMON_POLICY_UUID\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-            if (isWithPolicyDefinition) {\n-                policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n-            }\n-        }\n-        rs.close();\n-        statement.close();\n-        return policyData;\n-    }\n-\n-    /**\n-     * Get the common operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n-     * table and AM_COMMON_OPERATION_POLICY table. Policy id might be available, but if it is not referenced in the\n-     * common policies table, this will return null.\n-     *\n-     * @param policyId               Policy UUID\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyDataHolder getCommonOperationPolicyByPolicyID(String policyId, String organization,\n-                                                                        boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getCommonOperationPolicyByPolicyID(connection, policyId, organization, isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the operation policy for id \" + policyId, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyDataHolder getCommonOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                                         String organization,\n-                                                                         boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery;\n-        if (isWithPolicyDefinition) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_ID;\n-        } else {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_ID;\n-        }\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, organization);\n-        ResultSet rs = statement.executeQuery();\n-        if (rs.next()) {\n-            OperationPolicyDataHolder policyData = new OperationPolicyDataHolder();\n-            policyData.setPolicyId(policyId);\n-            policyData.setOrganization(organization);\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-            if (isWithPolicyDefinition) {\n-                policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n-            }\n-        }\n-        rs.close();\n-        statement.close();\n-        return null;\n-    }\n-\n-    /**\n-     * Retrieve a common operation policy by providing the policy name and organization\n-     *\n-     * @param policyName             Policy name\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyDataHolder getCommonOperationPolicyByPolicyName(String policyName, String organization,\n-                                                                          boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getCommonOperationPolicyByPolicyName(connection, policyName, organization, isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get common operation policy for name \" + policyName + \"for organization \"\n-                    + organization, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyDataHolder getCommonOperationPolicyByPolicyName(Connection connection, String policyName,\n-                                                                           String tenantDomain,\n-                                                                           boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery;\n-        if (isWithPolicyDefinition) {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_NAME;\n-        } else {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_NAME;\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyName);\n-        statement.setString(2, tenantDomain);\n-        ResultSet rs = statement.executeQuery();\n-        if (rs.next()) {\n-            OperationPolicyDataHolder policyData = new OperationPolicyDataHolder();\n-            policyData.setOrganization(tenantDomain);\n-            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-            if (isWithPolicyDefinition) {\n-                policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n-            }\n-            return policyData;\n-        }\n-        rs.close();\n-        statement.close();\n-        return null;\n-    }\n-\n-    /**\n-     * Retrieve an API Specific operation policy by providing the policy name. In order to narrow down the specific policy\n-     * this needs policy name, apiUUID, api revision UUID (if exists) and organization. If revision UUID is not provided,\n-     * that means the policy is not a revisioned policy.\n-     *\n-     * @param policyName             Policy name\n-     * @param apiUUID                UUID of API\n-     * @param revisionUUID           UUID of API revision\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyDataHolder getAPISpecificOperationPolicyByPolicyName(String policyName, String apiUUID,\n-                                                                               String revisionUUID, String organization,\n-                                                                               boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getAPISpecificOperationPolicyByPolicyName(connection, policyName, apiUUID, revisionUUID,\n-                    organization,\n-                    isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API specific operation policy for name \" + policyName + \" with API UUID \"\n-                    + apiUUID + \" revision UUID \" + revisionUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyDataHolder getAPISpecificOperationPolicyByPolicyName(Connection connection,\n-                                                                                String policyName, String apiUUID,\n-                                                                                String revisionUUID,\n-                                                                                String tenantDomain,\n-                                                                                boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery;\n-        if (isWithPolicyDefinition) {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_WITH_DEFINITION_FROM_POLICY_NAME;\n-        } else {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_NAME;\n-        }\n-\n-        if (revisionUUID != null) {\n-            dbQuery += \" AND AOP.REVISION_UUID = ?\";\n-        } else {\n-            dbQuery += \" AND AOP.REVISION_UUID IS NULL\";\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyName);\n-        statement.setString(2, tenantDomain);\n-        statement.setString(3, apiUUID);\n-        if (revisionUUID != null) {\n-            statement.setString(4, revisionUUID);\n-        }\n-        ResultSet rs = statement.executeQuery();\n-        if (rs.next()) {\n-            OperationPolicyDataHolder policyData = new OperationPolicyDataHolder();\n-            policyData.setOrganization(tenantDomain);\n-            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-            policyData.setApiUUID(rs.getString(\"API_UUID\"));\n-            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-            if (isWithPolicyDefinition) {\n-                policyData.setDefinition(getPolicyDefinitionFromRs(rs));\n-            }\n-            return policyData;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get the list of all operation policies. If the API UUID is provided, this will return all the operation policies\n-     * for that API. If not, it will return the common operation policies which are not bound to any API.\n-     * This list will include policy specification of each policy and policy ID. It will not contain the\n-     * policy definition as it is not useful for the operation.\n-     *\n-     * @param apiUUID      UUID of the API if exists. Null for common operation policies\n-     * @param organization Organization name\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    public List<OperationPolicyDataHolder> getLightWeightVersionOfAllOperationPolicies(String apiUUID,\n-                                                                                       String organization)\n-            throws APIManagementException {\n-\n-        String dbQuery;\n-        if (apiUUID != null) {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_OPERATION_POLICIES_WITHOUT_CLONED_POLICIES;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_COMMON_OPERATION_POLICIES;\n-        }\n-        List<OperationPolicyDataHolder> policyDataList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-            statement.setString(1, organization);\n-            if (apiUUID != null) {\n-                statement.setString(2, apiUUID);\n-            }\n-            ResultSet rs = statement.executeQuery();\n-            while (rs.next()) {\n-                OperationPolicyDataHolder policyData = new OperationPolicyDataHolder();\n-                policyData.setOrganization(organization);\n-                policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-                policyDataList.add(policyData);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get all the operation policy for tenant \" + organization, e);\n-        }\n-        return policyDataList;\n-    }\n-\n-    /**\n-     * This method will return a list of all cloned policies for an API.\n-     *\n-     * @param connection DB connection\n-     * @param apiUUID    UUID of the API if exists. Null for common operation policies\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private Set<String> getAllClonedPolicyIdsForAPI(Connection connection, String apiUUID)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_CLONED_POLICIES_FOR_API;\n-        Set<String> policyIds = new HashSet<>();\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            policyIds.add(rs.getString(\"POLICY_UUID\"));\n-        }\n-        rs.close();\n-        statement.close();\n-        return policyIds;\n-    }\n-\n-    /**\n-     * This method will query AM_API_OPERATION_POLICY table from CLONED_COMMON_POLICY_ID row for a matching policy ID\n-     * for the required API. This is useful to find the cloned API specific policy ID from a common policy.\n-     *\n-     * @param connection     DB connection\n-     * @param commonPolicyId Common policy ID\n-     * @param apiUUID        UUID of API\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private String getClonedPolicyIdForCommonPolicyId(Connection connection, String commonPolicyId, String apiUUID)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_CLONED_POLICY_ID_FOR_COMMON_POLICY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, commonPolicyId);\n-        statement.setString(2, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        if (rs.next()) {\n-            return rs.getString(\"POLICY_UUID\");\n-        }\n-        rs.close();\n-        statement.close();\n-        return null;\n-    }\n-\n-    /**\n-     * Delete all the API specific policies for a given API UUID. If revision UUID is provided, only the policies that\n-     * are revisioned will be deleted. This is used when we delete an API revision.\n-     * If revision id is null, all the API specific policies will be deleted. This is used in API deleting flow.\n-     *\n-     * @param connection   DB connection\n-     * @param apiUUID      UUID of API\n-     * @param revisionUUID Revision UUID\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private void deleteAllAPISpecificOperationPoliciesByAPIUUID(Connection connection, String apiUUID,\n-                                                               String revisionUUID)\n-            throws SQLException {\n-\n-        String dbQuery;\n-        if (revisionUUID != null) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_REVISION_UUID;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_API_ID;\n-        }\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, apiUUID);\n-        if (revisionUUID != null) {\n-            statement.setString(2, revisionUUID);\n-        }\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            String deleteQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n-            PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);\n-            deleteStatement.setString(1, rs.getString(\"POLICY_UUID\"));\n-            deleteStatement.execute();\n-            deleteStatement.close();\n-        }\n-        rs.close();\n-        statement.close();\n-    }\n-\n-    /**\n-     * When we apply a common policy to an operation, this policy will be cloned to the API at the backend. However, if\n-     * that policy is removed from the UI, this method is used to clean such unused policies that are imported,\n-     * but not used\n-     *\n-     * @param connection                DB connection\n-     * @param usedClonedPoliciesSet     Currently used imported API specific policies set\n-     * @param apiUUID                   UUID of the API\n-     * @throws SQLException\n-     */\n-    private void cleanUnusedClonedOperationPolicies(Connection connection, Set<String> usedClonedPoliciesSet, String apiUUID)\n-            throws SQLException {\n-        Set<String> allClonedPoliciesForAPI = getAllClonedPolicyIdsForAPI(connection, apiUUID);\n-        Set<String> policiesToDelete = allClonedPoliciesForAPI;\n-        policiesToDelete.removeAll(usedClonedPoliciesSet);\n-        for (String policyId : allClonedPoliciesForAPI) {\n-            deleteOperationPolicyByPolicyId(connection, policyId);\n-        }\n-    }\n-\n-    /**\n-     * This method will read the result set and populate OperationPolicy object, which later will be set to the URI template.\n-     * This object has the information regarding the policy allocation\n-     *\n-     * @param rs Result set\n-     * @return OperationPolicy object\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     */\n-    private OperationPolicy populateOperationPolicyWithRS(ResultSet rs) throws SQLException, APIManagementException {\n-\n-        OperationPolicy operationPolicy = new OperationPolicy();\n-        operationPolicy.setPolicyName(rs.getString(\"POLICY_NAME\"));\n-        operationPolicy.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-        operationPolicy.setOrder(rs.getInt(\"POLICY_ORDER\"));\n-        operationPolicy.setDirection(rs.getString(\"DIRECTION\"));\n-        operationPolicy.setParameters(APIMgtDBUtil.convertJSONStringToMap(rs.getString(\"PARAMETERS\")));\n-        return operationPolicy;\n-    }\n-\n-    /**\n-     * This method will read the result set and populate OperationPolicySpecification object.\n-     *\n-     * @param rs Result set\n-     * @return OperationPolicySpecification object\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     */\n-    private OperationPolicySpecification populatePolicySpecificationFromRS(ResultSet rs) throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n-        policySpecification.setName(rs.getString(\"POLICY_NAME\"));\n-        policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n-        policySpecification.setDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n-        policySpecification.setApplicableFlows(getListFromString(rs.getString(\"APPLICABLE_FLOWS\")));\n-        policySpecification.setSupportedApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n-        policySpecification.setSupportedGateways(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n-        policySpecification.setCategory(OperationPolicySpecification.PolicyCategory\n-                .valueOf(rs.getString(\"POLICY_CATEGORY\")));\n-        policySpecification.setMultipleAllowed(rs.getBoolean(\"MULTIPLE_ALLOWED\"));\n-        List<OperationPolicySpecAttribute> policySpecAttributes = null;\n-\n-        try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n-            String policyParametersString = IOUtils.toString(policyParametersStream);\n-            policySpecAttributes = new Gson().fromJson(policyParametersString,\n-                    new TypeToken<List<OperationPolicySpecAttribute>>() {\n-                    }.getType());\n-        } catch (IOException e) {\n-            log.error(\"Error while converting policy specification attributes for the policy \"\n-                    + policySpecification.getName(), e);\n-        }\n-        policySpecification.setPolicyAttributes(policySpecAttributes);\n-        return policySpecification;\n-    }\n-\n-    /**\n-     * This method will read the result set and return policy definition.\n-     *\n-     * @param rs Result set\n-     * @return OperationPolicySpecification object\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     */\n-    private String getPolicyDefinitionFromRs(ResultSet rs) throws SQLException {\n-\n-        try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n-            String policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n-            return policyDefinitionString;\n-        } catch (IOException e) {\n-            log.error(\"Error while converting policy definition for the policy\", e);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Create a string list from a single string element by splitting from the comma\n-     *\n-     * @param stringElement String element\n-     * @return list of strings\n-     */\n-    private List<String> getListFromString(String stringElement) {\n-\n-        List<String> list = null;\n-        if (!stringElement.isEmpty()) {\n-            list = Arrays.asList(\n-                    stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n-        }\n-        return list;\n-    }\n }\n", "next_change": {"commit": "a54c0b446696b5e5058ad383d29d8a4b54a5a5de", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 86ec021fb73..394581b089f 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17682,4 +17983,1197 @@ public class ApiMgtDAO {\n             this.subscriptionStatus = subscriptionStatus;\n         }\n     }\n+\n+    /**\n+     * Operation policy implementation\n+     *\n+     */\n+\n+    /**\n+     * Add a new common operation policy to the database. This will first add the operation policy content to the\n+     * AM_OPERATION_POLICY table and another entry to AM_COMMON_OPERATION_POLICY table.\n+     *\n+     * @param policyData Operation policy data.\n+     * @return UUID of the newly created shared policy\n+     * @throws APIManagementException\n+     */\n+    public String addCommonOperationPolicy(OperationPolicyData policyData) throws APIManagementException {\n+\n+        String policyUUID = null;\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                policyUUID = addOperationPolicyContent(connection, policyData);\n+\n+                String dbQuery = SQLConstants.OperationPolicyConstants.ADD_COMMON_OPERATION_POLICY;\n+                PreparedStatement statement = connection.prepareStatement(dbQuery);\n+                statement.setString(1, policyUUID);\n+                statement.executeUpdate();\n+                statement.close();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n+        }\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * Add a new API specific operation policy to the database\n+     *\n+     * @param apiUUID      Unique Identifier of API\n+     * @param revisionUUID Unique Identifier of API revision\n+     * @param policyData   Unique Identifier of API\n+     * @return UUID of the newly created shared policy\n+     * @throws APIManagementException\n+     */\n+    public String addAPISpecificOperationPolicy(String apiUUID, String revisionUUID,\n+                                                OperationPolicyData policyData)\n+            throws APIManagementException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                String policyID = addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, null);\n+                connection.commit();\n+                return policyID;\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n+                        + \" for API \" + apiUUID, e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n+                    + \" for API \" + apiUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private String addAPISpecificOperationPolicy(Connection connection, String apiUUID, String revisionUUID,\n+                                                 OperationPolicyData policyData, String clonedPolicyId)\n+            throws SQLException {\n+\n+        String policyUUID = addOperationPolicyContent(connection, policyData);\n+\n+        String dbQuery;\n+        if (revisionUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY_WITH_REVISION;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY;\n+        }\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyUUID);\n+        statement.setString(2, apiUUID);\n+        statement.setString(3, clonedPolicyId);\n+        if (revisionUUID != null) {\n+            statement.setString(4, revisionUUID);\n+        }\n+        statement.executeUpdate();\n+        statement.close();\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * This method is used to populate AM_OPERATION_POLICY table. This will return the policy ID.\n+     *\n+     * @param connection DB connection\n+     * @param policyData Unique Identifier of API\n+     * @return UUID of the newly created policy\n+     * @throws SQLException\n+     */\n+    private String addOperationPolicyContent(Connection connection, OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY;\n+        String policyUUID = UUID.randomUUID().toString();\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyUUID);\n+        statement.setString(2, policySpecification.getName());\n+        statement.setString(3, policySpecification.getDisplayName());\n+        statement.setString(4, policySpecification.getDescription());\n+        statement.setString(5, policySpecification.getApplicableFlows().toString());\n+        statement.setString(6, policySpecification.getSupportedGateways().toString());\n+        statement.setString(7, policySpecification.getSupportedApiTypes().toString());\n+        statement.setBinaryStream(8,\n+                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n+        statement.setString(9, policyData.getOrganization());\n+        statement.setString(10, policySpecification.getCategory().toString());\n+        statement.setBoolean(11, policySpecification.isMultipleAllowed());\n+        statement.setString(12, policyData.getMd5Hash());\n+        statement.executeUpdate();\n+        statement.close();\n+\n+        if (policyData.getSynapsePolicyDefinition() != null) {\n+            addOperationPolicyDefinition(connection, policyUUID, policyData.getSynapsePolicyDefinition());\n+        }\n+        if (policyData.getCcPolicyDefinition() != null) {\n+            addOperationPolicyDefinition(connection, policyUUID, policyData.getCcPolicyDefinition());\n+        }\n+\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * Update an existing operation policy\n+     *\n+     * @param policyId   Shared policy UUID\n+     * @param policyData Updated policy definition\n+     * @throws APIManagementException\n+     */\n+    public void updateOperationPolicy(String policyId, OperationPolicyData policyData)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            connection.setAutoCommit(false);\n+            updateOperationPolicy(connection, policyId, policyData);\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to update the operation policy with ID \" + policyId, e);\n+        }\n+    }\n+\n+    /**\n+     * Update an existing operation policy\n+     *\n+     * @param connection DB connection\n+     * @param policyId   Shared policy UUID\n+     * @param policyData Updated policy definition\n+     * @throws SQLException\n+     */\n+    private void updateOperationPolicy(Connection connection, String policyId, OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        PreparedStatement statement = connection.prepareStatement(\n+                SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_CONTENT);\n+\n+        statement.setString(1, policySpecification.getName());\n+        statement.setString(2, policySpecification.getDisplayName());\n+        statement.setString(3, policySpecification.getDescription());\n+        statement.setString(4, policySpecification.getApplicableFlows().toString());\n+        statement.setString(5, policySpecification.getSupportedGateways().toString());\n+        statement.setString(6, policySpecification.getSupportedApiTypes().toString());\n+        statement.setBinaryStream(7,\n+                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n+        statement.setString(8, policyData.getOrganization());\n+        statement.setString(9, policySpecification.getCategory().toString());\n+        statement.setBoolean(10, policySpecification.isMultipleAllowed());\n+        statement.setString(11, policyData.getMd5Hash());\n+        statement.setString(12, policyId);\n+        statement.executeUpdate();\n+        statement.close();\n+\n+        if (policyData.getSynapsePolicyDefinition() != null) {\n+            updateOperationPolicyDefinition(connection, policyId, policyData.getSynapsePolicyDefinition());\n+        }\n+        if (policyData.getCcPolicyDefinition() != null) {\n+            updateOperationPolicyDefinition(connection, policyId, policyData.getCcPolicyDefinition());\n+        }\n+\n+    }\n+\n+    /**\n+     * Delete an operation policy by providing the policy UUID\n+     *\n+     * @param policyId UUID of the policy to be deleted\n+     * @return True if deleted successfully\n+     * @throws APIManagementException\n+     */\n+    public void deleteOperationPolicyByPolicyId(String policyId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            deleteOperationPolicyByPolicyId(connection, policyId);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete operation policy \" + policyId, e);\n+        }\n+    }\n+\n+    private void deleteOperationPolicyByPolicyId(Connection connection, String policyId) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.execute();\n+        statement.close();\n+    }\n+\n+    /**\n+     * Get the set of URI templates that have Operation policies\n+     *\n+     * @param apiUUID Unique Identifier of API\n+     * @return URITemplate set\n+     * @throws APIManagementException\n+     */\n+    public Set<URITemplate> getURITemplatesWithOperationPolicies(String apiUUID) throws APIManagementException {\n+\n+        String query;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(apiUUID);\n+\n+        if (apiRevision == null) {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+        }\n+\n+        Map<String, URITemplate> uriTemplates = new HashMap<>();\n+        Set<URITemplate> uriTemplateList = new HashSet<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement prepStmt = connection.prepareStatement(query)) {\n+            if (apiRevision == null) {\n+                int apiId = getAPIID(apiUUID, connection);\n+                prepStmt.setInt(1, apiId);\n+            } else {\n+                int apiId = getAPIID(apiRevision.getApiUUID(), connection);\n+                prepStmt.setInt(1, apiId);\n+                prepStmt.setString(2, apiRevision.getRevisionUUID());\n+            }\n+            try (ResultSet rs = prepStmt.executeQuery()) {\n+                URITemplate uriTemplate;\n+                while (rs.next()) {\n+                    String httpMethod = rs.getString(\"HTTP_METHOD\");\n+                    String urlPattern = rs.getString(\"URL_PATTERN\");\n+                    String urlTemplateKey = httpMethod + \":\" + urlPattern;\n+                    if (!uriTemplates.containsKey(urlTemplateKey)) {\n+                        uriTemplate = new URITemplate();\n+                    } else {\n+                        uriTemplate = uriTemplates.get(urlTemplateKey);\n+                    }\n+                    OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                    uriTemplate.addOperationPolicy(operationPolicy);\n+                    uriTemplate.setHTTPVerb(httpMethod);\n+                    uriTemplate.setUriTemplate(urlPattern);\n+                    uriTemplate.setId(rs.getInt(\"URL_MAPPING_ID\"));\n+                    uriTemplates.put(urlTemplateKey, uriTemplate);\n+                }\n+            }\n+            uriTemplateList.addAll(uriTemplates.values());\n+        } catch (SQLException e) {\n+            handleException(\"Error while fetching URI templates with operation policies for \" + apiUUID, e);\n+        }\n+        return uriTemplateList;\n+    }\n+\n+    /**\n+     * Get operation polycies attached to the resource identified by the url mapping ID\n+     *\n+     * @param urlMappingId URL Mapping ID of the resource\n+     * @return\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private List<OperationPolicy> getOperationPoliciesOfURITemplate(int urlMappingId)\n+            throws SQLException, APIManagementException {\n+\n+        List<OperationPolicy> operationPolicies = new ArrayList<>();\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(\n+                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_BY_URI_TEMPLATE_ID)) {\n+            ps.setInt(1, urlMappingId);\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    OperationPolicy policy = populateOperationPolicyWithRS(rs);\n+                    operationPolicies.add(policy);\n+                }\n+            }\n+        }\n+        return operationPolicies;\n+    }\n+\n+    /**\n+     * Sets operation policies to uriTemplates map\n+     *\n+     * @param uuid         UUID of API or API Revision\n+     * @param uriTemplates URI Templates map with 'URL_PATTERN + HTTP_METHOD' as the map key\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setOperationPoliciesToURITemplatesMap(String uuid, Map<String, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        String currentApiUuid;\n+        String query;\n+        boolean isRevision = false;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n+        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n+            currentApiUuid = apiRevision.getApiUUID();\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+            isRevision = true;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+            currentApiUuid = uuid;\n+        }\n+\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(query)) {\n+            int apiId = getAPIID(currentApiUuid);\n+            ps.setInt(1, apiId);\n+            if (isRevision) {\n+                ps.setString(2, uuid);\n+            }\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(key);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets operation policies to uriTemplates map\n+     *\n+     * @param uuid         UUID of API or API Revision\n+     * @param uriTemplates URI Templates map with URL_MAPPING_ID as the map key\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setOperationPolicies(String uuid, Map<Integer, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        String currentApiUuid;\n+        String query;\n+        boolean isRevision = false;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n+        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n+            currentApiUuid = apiRevision.getApiUUID();\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+            isRevision = true;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+            currentApiUuid = uuid;\n+        }\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(query)) {\n+            int apiId = getAPIID(currentApiUuid);\n+            ps.setInt(1, apiId);\n+            if (isRevision) {\n+                ps.setString(2, uuid);\n+            }\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    int uriTemplateId = rs.getInt(\"URL_MAPPING_ID\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(uriTemplateId);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Populates operation policy mappings in the API Product URITemplate map\n+     *\n+     * @param productRevisionId Product Revision ID\n+     * @param uriTemplates      Map of URI Templates\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setAPIProductOperationPoliciesToURITemplatesMap(String productRevisionId,\n+                                                                 Map<String, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(\n+                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_PER_API_PRODUCT_SQL)) {\n+            ps.setString(1, productRevisionId);\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(key);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clone an operation policy to the API. This method is used in two flows.\n+     * Cloning a common policy to API.\n+     * Cloning a dependent policy of a product\n+     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n+     *\n+     * @param connection   DB connection\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param apiUUID      UUID of the API\n+     * @param revisionUUID UUID of the revision\n+     * @return cloned policyID\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private String cloneOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID)\n+            throws APIManagementException, SQLException {\n+\n+        OperationPolicyData policyData = getOperationPolicyByPolicyID(connection, policyId, true);\n+        if (policyData != null) {\n+            // If we are taking a clone from common policy, common policy's Id is used as the CLONED_POLICY_ID.\n+            // If we are cloning for an API Product, dependent APIs' id is used.\n+            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, policyId);\n+        } else {\n+            throw new APIManagementException(\"Cannot clone policy with ID \" + policyId + \" as it does not exists.\");\n+        }\n+    }\n+\n+    /**\n+     * This method is used in the creating a revision for API and API product. This will create a new API specific policy\n+     * with API UUID and revision UUID.\n+     *\n+     * @param connection   DB connection\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param apiUUID      UUID of the API\n+     * @param revisionUUID UUID of the revision\n+     * @return cloned policyID\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private String revisionOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID,\n+                                           String organization)\n+            throws APIManagementException, SQLException {\n+\n+        OperationPolicyData policyData = getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID,\n+                organization, true);\n+        // Since we import all the policies to API at API update, getting the policy from API specific policy list is enough\n+        if (policyData != null) {\n+            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData,\n+                    policyData.getClonedCommonPolicyId());\n+        } else {\n+            throw new APIManagementException(\"Cannot create a revision of policy with ID \" + policyId\n+                    + \" as it does not exists.\");\n+        }\n+    }\n+\n+    /**\n+     * This method is used the restore flow. At the restore, apart from the policy details, CLONED_POLICY_ID column\n+     * too can change and that needs to be updated.\n+     *\n+     * @param connection DB connection\n+     * @param policyId   Original policy's ID that needs to be cloned\n+     * @param policyData Updated policy data\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private void updateAPISpecificOperationPolicyWithClonedPolicyId(Connection connection, String policyId,\n+                                                                    OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        if (policyData.getClonedCommonPolicyId() != null) {\n+            PreparedStatement statement = connection.prepareStatement(\n+                    SQLConstants.OperationPolicyConstants.UPDATE_API_OPERATION_POLICY_BY_POLICY_ID);\n+            statement.setString(1, policyData.getClonedCommonPolicyId());\n+            statement.executeUpdate();\n+            statement.close();\n+        }\n+        updateOperationPolicy(connection, policyId, policyData);\n+    }\n+\n+    /**\n+     * This method is used to restore an API specific operation policy revision.\n+     *\n+     * @param connection   DB connection\n+     * @param apiUUID      UUID of the API\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param revisionId   The revision number\n+     * @param organization Organization name\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     **/\n+    private String restoreOperationPolicyRevision(Connection connection, String apiUUID, String policyId,\n+                                                  int revisionId,\n+                                                  String organization) throws SQLException, APIManagementException {\n+\n+        OperationPolicyData revisionedPolicy = getAPISpecificOperationPolicyByPolicyID(connection, policyId,\n+                apiUUID, organization, true);\n+        String restoredPolicyId = null;\n+        if (revisionedPolicy != null) {\n+            // First check whether there exists a API specific policy for same policy name with revision uuid null\n+            // This is the state where we record the policies applied in the working copy.\n+            OperationPolicyData apiSpecificPolicy = getAPISpecificOperationPolicyByPolicyName(connection,\n+                    revisionedPolicy.getSpecification().getName(), revisionedPolicy.getApiUUID(), null,\n+                    organization, false);\n+            if (apiSpecificPolicy != null) {\n+                if (apiSpecificPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Matching API specific operation policy found for the revisioned policy and \" +\n+                                \"MD5 hashes match\");\n+                    }\n+\n+                } else {\n+                    updateAPISpecificOperationPolicyWithClonedPolicyId(connection, apiSpecificPolicy.getPolicyId(),\n+                            revisionedPolicy);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Even though a matching API specific operation policy found for name,\"\n+                                + \" MD5 hashes does not match. Policy \" + apiSpecificPolicy.getPolicyId()\n+                                + \" has been updated from the revision.\");\n+                    }\n+                }\n+                restoredPolicyId = apiSpecificPolicy.getPolicyId();\n+            } else {\n+                if (revisionedPolicy.isClonedPolicy()) {\n+                    // Check for a common operation policy only if it is a cloned policy.\n+                    OperationPolicyData commonPolicy = getCommonOperationPolicyByPolicyID(connection,\n+                            revisionedPolicy.getClonedCommonPolicyId(), organization, false);\n+                    if (commonPolicy != null) {\n+                        if (commonPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\"Matching common operation policy found. MD5 hash match\");\n+                            }\n+                            //This means the common policy is same with our revision. A clone is created and original\n+                            // common policy ID is referenced as the ClonedCommonPolicyId\n+                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n+                                    revisionedPolicy, revisionedPolicy.getClonedCommonPolicyId());\n+                        } else {\n+                            // This means the common policy is updated since we created the revision.\n+                            // we have to create a clone and since policy is different, we can't refer the original common\n+                            // policy as ClonedCommonPolicyId. This should be a new API specific policy\n+                            revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n+                                    + \"_restored-\" + revisionId);\n+                            revisionedPolicy.getSpecification()\n+                                    .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n+                                            + \" Restored from revision \" + revisionId);\n+                            revisionedPolicy.setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy));\n+                            revisionedPolicy.setRevisionUUID(null);\n+                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n+                                    revisionedPolicy, null);\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\n+                                        \"An updated matching common operation policy found. A new API specific operation \" +\n+                                                \"policy created by the display name \" +\n+                                                revisionedPolicy.getSpecification().getName());\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // This means this is a completely new policy and we don't have any reference of a previous state in\n+                    // working copy. A new API specific policy will be created.\n+                    revisionedPolicy.setRevisionUUID(null);\n+                    restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No matching operation policy found. A new API specific operation \" +\n+                                \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n+                    }\n+                }\n+            }\n+        } else {\n+            throw new APIManagementException(\"A revisioned operation policy not found for \" + policyId);\n+        }\n+        return restoredPolicyId;\n+    }\n+\n+    /**\n+     * Retrieve an operation policy by providing the policy uuid\n+     *\n+     * @param connection             DB connection\n+     * @param policyId               Policy UUID\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws SQLException\n+     */\n+    private OperationPolicyData getOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                             boolean isWithPolicyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_ID;\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setOrganization(rs.getString(\"ORGANIZATION\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyId, policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Get the API specific operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n+     * table and AM_API_OPERATION_POLICY table from API UUID. Policy id might be available, but if it is not referenced in the\n+     * APIS table, this will return null.\n+     * The returned policy data can be either an API only policy, cloned common policy to API or a revisioned API specific policy\n+     *\n+     * @param policyId               Policy UUID\n+     * @param apiUUID                UUID of the API\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getAPISpecificOperationPolicyByPolicyID(String policyId, String apiUUID,\n+                                                                       String organization,\n+                                                                       boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID, organization,\n+                    isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the API specific operation policy for id \" + policyId + \" from API \"\n+                    + apiUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getAPISpecificOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                                        String apiUUID,\n+                                                                        String organization,\n+                                                                        boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_ID;\n+        OperationPolicyData policyData = null;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, organization);\n+        statement.setString(3, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setApiUUID(apiUUID);\n+            policyData.setOrganization(organization);\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n+            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyId, policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    private List<OperationPolicyDefinition> getPolicyDefinitionForPolicyId(Connection connection, String policyId)\n+            throws SQLException {\n+\n+        List<OperationPolicyDefinition> operationPolicyDefinitions = new ArrayList<>();\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_DEFINITION_FROM_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            String policyDefinitionString;\n+            OperationPolicyDefinition policyDefinition = new OperationPolicyDefinition();\n+\n+            try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n+                policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n+                policyDefinition.setContent(policyDefinitionString);\n+                policyDefinition.setGatewayType(\n+                        OperationPolicyDefinition.GatewayType.valueOf(rs.getString(\"GATEWAY_TYPE\")));\n+                policyDefinition.setMd5Hash(rs.getString(\"DEFINITION_MD5\"));\n+\n+                operationPolicyDefinitions.add(policyDefinition);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting policy definition for the policy\", e);\n+            }\n+\n+        }\n+        rs.close();\n+        statement.close();\n+        return operationPolicyDefinitions;\n+    }\n+\n+\n+    public void populatePolicyDefinitions(Connection connection, String policyId, OperationPolicyData policyData)\n+            throws SQLException {\n+        if (policyId != null && !policyId.isEmpty()) {\n+            List<OperationPolicyDefinition> policyDefinitions = getPolicyDefinitionForPolicyId(connection, policyId);\n+            for (OperationPolicyDefinition policyDefinition : policyDefinitions) {\n+                if (OperationPolicyDefinition.GatewayType.Synapse.equals(policyDefinition.getGatewayType())) {\n+                    policyData.setSynapsePolicyDefinition(policyDefinition);\n+                } else if (OperationPolicyDefinition.GatewayType.ChoreoConnect.equals(policyDefinition.getGatewayType())) {\n+                    policyData.setCcPolicyDefinition(policyDefinition);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private void addOperationPolicyDefinition (Connection connection, String policyId,\n+                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY_DEFINITION;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, policyDefinition.getGatewayType().toString());\n+        statement.setString(3, policyDefinition.getMd5Hash());\n+        statement.setBinaryStream(4, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n+        statement.executeUpdate();\n+        statement.close();\n+    }\n+\n+\n+    private void updateOperationPolicyDefinition(Connection connection, String policyId,\n+                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_DEFINITION;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyDefinition.getMd5Hash());\n+        statement.setBinaryStream(2, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n+        statement.setString(3, policyId);\n+        statement.setString(4, policyDefinition.getGatewayType().toString());\n+        statement.executeUpdate();\n+        statement.close();\n+    }\n+\n+    /**\n+     * Get the common operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n+     * table and AM_COMMON_OPERATION_POLICY table. Policy id might be available, but if it is not referenced in the\n+     * common policies table, this will return null.\n+     *\n+     * @param policyId               Policy UUID\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getCommonOperationPolicyByPolicyID(String policyId, String organization,\n+                                                                  boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getCommonOperationPolicyByPolicyID(connection, policyId, organization, isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the operation policy for id \" + policyId, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getCommonOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                                   String organization,\n+                                                                   boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, organization);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setOrganization(organization);\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            populatePolicyDefinitions(connection, policyId, policyData);\n+        }\n+\n+        return policyData;\n+    }\n+\n+    /**\n+     * Retrieve a common operation policy by providing the policy name and organization\n+     *\n+     * @param policyName             Policy name\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getCommonOperationPolicyByPolicyName(String policyName, String organization,\n+                                                                    boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getCommonOperationPolicyByPolicyName(connection, policyName, organization, isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get common operation policy for name \" + policyName + \"for organization \"\n+                    + organization, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getCommonOperationPolicyByPolicyName(Connection connection, String policyName,\n+                                                                     String tenantDomain,\n+                                                                     boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_FROM_POLICY_NAME;\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyName);\n+        statement.setString(2, tenantDomain);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setOrganization(tenantDomain);\n+            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Retrieve an API Specific operation policy by providing the policy name. In order to narrow down the specific policy\n+     * this needs policy name, apiUUID, api revision UUID (if exists) and organization. If revision UUID is not provided,\n+     * that means the policy is not a revisioned policy.\n+     *\n+     * @param policyName             Policy name\n+     * @param apiUUID                UUID of API\n+     * @param revisionUUID           UUID of API revision\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getAPISpecificOperationPolicyByPolicyName(String policyName, String apiUUID,\n+                                                                         String revisionUUID, String organization,\n+                                                                         boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getAPISpecificOperationPolicyByPolicyName(connection, policyName, apiUUID, revisionUUID,\n+                    organization,\n+                    isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API specific operation policy for name \" + policyName + \" with API UUID \"\n+                    + apiUUID + \" revision UUID \" + revisionUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getAPISpecificOperationPolicyByPolicyName(Connection connection,\n+                                                                          String policyName, String apiUUID,\n+                                                                          String revisionUUID,\n+                                                                          String tenantDomain,\n+                                                                          boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_NAME;\n+        if (revisionUUID != null) {\n+            dbQuery += \" AND AOP.REVISION_UUID = ?\";\n+        } else {\n+            dbQuery += \" AND AOP.REVISION_UUID IS NULL\";\n+        }\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyName);\n+        statement.setString(2, tenantDomain);\n+        statement.setString(3, apiUUID);\n+        if (revisionUUID != null) {\n+            statement.setString(4, revisionUUID);\n+        }\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setOrganization(tenantDomain);\n+            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+            policyData.setApiUUID(rs.getString(\"API_UUID\"));\n+            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Get the list of all operation policies. If the API UUID is provided, this will return all the operation policies\n+     * for that API. If not, it will return the common operation policies which are not bound to any API.\n+     * This list will include policy specification of each policy and policy ID. It will not contain the\n+     * policy definition as it is not useful for the operation.\n+     *\n+     * @param apiUUID      UUID of the API if exists. Null for common operation policies\n+     * @param organization Organization name\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    public List<OperationPolicyData> getLightWeightVersionOfAllOperationPolicies(String apiUUID,\n+                                                                                 String organization)\n+            throws APIManagementException {\n+\n+        String dbQuery;\n+        if (apiUUID != null) {\n+            dbQuery =\n+                    SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_OPERATION_POLICIES_WITHOUT_CLONED_POLICIES;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_COMMON_OPERATION_POLICIES;\n+        }\n+        List<OperationPolicyData> policyDataList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, organization);\n+            if (apiUUID != null) {\n+                statement.setString(2, apiUUID);\n+            }\n+            ResultSet rs = statement.executeQuery();\n+            while (rs.next()) {\n+                OperationPolicyData policyData = new OperationPolicyData();\n+                policyData.setOrganization(organization);\n+                policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+                if (apiUUID != null) {\n+                    policyData.setApiUUID(apiUUID);\n+                }\n+                policyDataList.add(policyData);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get all the operation policy for tenant \" + organization, e);\n+        }\n+        return policyDataList;\n+    }\n+\n+    public int getOperationPolicyCount(String organization) throws APIManagementException {\n+\n+        int count = -1;\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_THE_COUNT_OF_OPERATION_POLICIES_FOR_ORGANIZATION;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, organization);\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                count = rs.getInt(\"POLICY_COUNT\");\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the count of operation policies for organization \" + organization, e);\n+        }\n+        return count;\n+    }\n+\n+\n+\n+    /**\n+     * This method will return a list of all cloned policies for an API.\n+     *\n+     * @param connection DB connection\n+     * @param apiUUID    UUID of the API if exists. Null for common operation policies\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private Set<String> getAllClonedPolicyIdsForAPI(Connection connection, String apiUUID)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_CLONED_POLICIES_FOR_API;\n+        Set<String> policyIds = new HashSet<>();\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            policyIds.add(rs.getString(\"POLICY_UUID\"));\n+        }\n+        rs.close();\n+        statement.close();\n+        return policyIds;\n+    }\n+\n+    /**\n+     * This method will query AM_API_OPERATION_POLICY table from CLONED_POLICY_ID row for a matching policy ID\n+     * for the required API. This is useful to find the cloned API specific policy ID from a common policy.\n+     *\n+     * @param connection     DB connection\n+     * @param commonPolicyId Common policy ID\n+     * @param apiUUID        UUID of API\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private String getClonedPolicyIdForCommonPolicyId(Connection connection, String commonPolicyId, String apiUUID)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_CLONED_POLICY_ID_FOR_COMMON_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, commonPolicyId);\n+        statement.setString(2, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        String policyId = null;\n+        if (rs.next()) {\n+            policyId = rs.getString(\"POLICY_UUID\");\n+        }\n+        rs.close();\n+        statement.close();\n+        return policyId;\n+    }\n+\n+    /**\n+     * Delete all the API specific policies for a given API UUID. If revision UUID is provided, only the policies that\n+     * are revisioned will be deleted. This is used when we delete an API revision.\n+     * If revision id is null, all the API specific policies will be deleted. This is used in API deleting flow.\n+     *\n+     * @param connection   DB connection\n+     * @param apiUUID      UUID of API\n+     * @param revisionUUID Revision UUID\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private void deleteAllAPISpecificOperationPoliciesByAPIUUID(Connection connection, String apiUUID,\n+                                                                String revisionUUID)\n+            throws SQLException {\n+\n+        String dbQuery;\n+        if (revisionUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_REVISION_UUID;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_API_ID;\n+        }\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, apiUUID);\n+        if (revisionUUID != null) {\n+            statement.setString(2, revisionUUID);\n+        }\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            String deleteQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n+            PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);\n+            deleteStatement.setString(1, rs.getString(\"POLICY_UUID\"));\n+            deleteStatement.execute();\n+            deleteStatement.close();\n+        }\n+        rs.close();\n+        statement.close();\n+    }\n+\n+    /**\n+     * When we apply a common policy to an operation, this policy will be cloned to the API at the backend. However, if\n+     * that policy is removed from the UI, this method is used to clean such unused policies that are imported,\n+     * but not used\n+     *\n+     * @param connection            DB connection\n+     * @param usedClonedPoliciesSet Currently used imported API specific policies set\n+     * @param apiUUID               UUID of the API\n+     * @throws SQLException\n+     */\n+    private void cleanUnusedClonedOperationPolicies(Connection connection, Set<String> usedClonedPoliciesSet,\n+                                                    String apiUUID)\n+            throws SQLException {\n+\n+        Set<String> allClonedPoliciesForAPI = getAllClonedPolicyIdsForAPI(connection, apiUUID);\n+        Set<String> policiesToDelete = allClonedPoliciesForAPI;\n+        policiesToDelete.removeAll(usedClonedPoliciesSet);\n+        for (String policyId : allClonedPoliciesForAPI) {\n+            deleteOperationPolicyByPolicyId(connection, policyId);\n+        }\n+    }\n+\n+    /**\n+     * This method will read the result set and populate OperationPolicy object, which later will be set to the URI template.\n+     * This object has the information regarding the policy allocation\n+     *\n+     * @param rs Result set\n+     * @return OperationPolicy object\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     */\n+    private OperationPolicy populateOperationPolicyWithRS(ResultSet rs) throws SQLException, APIManagementException {\n+\n+        OperationPolicy operationPolicy = new OperationPolicy();\n+        operationPolicy.setPolicyName(rs.getString(\"POLICY_NAME\"));\n+        operationPolicy.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+        operationPolicy.setOrder(rs.getInt(\"POLICY_ORDER\"));\n+        operationPolicy.setDirection(rs.getString(\"DIRECTION\"));\n+        operationPolicy.setParameters(APIMgtDBUtil.convertJSONStringToMap(rs.getString(\"PARAMETERS\")));\n+        return operationPolicy;\n+    }\n+\n+    /**\n+     * This method will read the result set and populate OperationPolicySpecification object.\n+     *\n+     * @param rs Result set\n+     * @return OperationPolicySpecification object\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     */\n+    private OperationPolicySpecification populatePolicySpecificationFromRS(ResultSet rs) throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+        policySpecification.setName(rs.getString(\"POLICY_NAME\"));\n+        policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+        policySpecification.setDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+        policySpecification.setApplicableFlows(getListFromString(rs.getString(\"APPLICABLE_FLOWS\")));\n+        policySpecification.setSupportedApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+        policySpecification.setSupportedGateways(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+        policySpecification.setCategory(OperationPolicySpecification.PolicyCategory\n+                .valueOf(rs.getString(\"POLICY_CATEGORY\")));\n+        policySpecification.setMultipleAllowed(rs.getBoolean(\"MULTIPLE_ALLOWED\"));\n+        List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+\n+        try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+            String policyParametersString = IOUtils.toString(policyParametersStream);\n+            policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                    new TypeToken<List<OperationPolicySpecAttribute>>() {\n+                    }.getType());\n+        } catch (IOException e) {\n+            log.error(\"Error while converting policy specification attributes for the policy \"\n+                    + policySpecification.getName(), e);\n+        }\n+        policySpecification.setPolicyAttributes(policySpecAttributes);\n+        return policySpecification;\n+    }\n+\n+\n+    /**\n+     * Create a string list from a single string element by splitting from the comma\n+     *\n+     * @param stringElement String element\n+     * @return list of strings\n+     */\n+    private List<String> getListFromString(String stringElement) {\n+\n+        List<String> list = null;\n+        if (!stringElement.isEmpty()) {\n+            list = Arrays.asList(\n+                    stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n+        }\n+        return list;\n+    }\n }\n", "next_change": {"commit": "da33a8924e3ac2b08450db69b5134ec6b0958f8d", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 394581b089f..2a0da146a65 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17983,1197 +17681,4 @@ public class ApiMgtDAO {\n             this.subscriptionStatus = subscriptionStatus;\n         }\n     }\n-\n-    /**\n-     * Operation policy implementation\n-     *\n-     */\n-\n-    /**\n-     * Add a new common operation policy to the database. This will first add the operation policy content to the\n-     * AM_OPERATION_POLICY table and another entry to AM_COMMON_OPERATION_POLICY table.\n-     *\n-     * @param policyData Operation policy data.\n-     * @return UUID of the newly created shared policy\n-     * @throws APIManagementException\n-     */\n-    public String addCommonOperationPolicy(OperationPolicyData policyData) throws APIManagementException {\n-\n-        String policyUUID = null;\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                policyUUID = addOperationPolicyContent(connection, policyData);\n-\n-                String dbQuery = SQLConstants.OperationPolicyConstants.ADD_COMMON_OPERATION_POLICY;\n-                PreparedStatement statement = connection.prepareStatement(dbQuery);\n-                statement.setString(1, policyUUID);\n-                statement.executeUpdate();\n-                statement.close();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n-        }\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * Add a new API specific operation policy to the database\n-     *\n-     * @param apiUUID      Unique Identifier of API\n-     * @param revisionUUID Unique Identifier of API revision\n-     * @param policyData   Unique Identifier of API\n-     * @return UUID of the newly created shared policy\n-     * @throws APIManagementException\n-     */\n-    public String addAPISpecificOperationPolicy(String apiUUID, String revisionUUID,\n-                                                OperationPolicyData policyData)\n-            throws APIManagementException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                String policyID = addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, null);\n-                connection.commit();\n-                return policyID;\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n-                        + \" for API \" + apiUUID, e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n-                    + \" for API \" + apiUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private String addAPISpecificOperationPolicy(Connection connection, String apiUUID, String revisionUUID,\n-                                                 OperationPolicyData policyData, String clonedPolicyId)\n-            throws SQLException {\n-\n-        String policyUUID = addOperationPolicyContent(connection, policyData);\n-\n-        String dbQuery;\n-        if (revisionUUID != null) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY_WITH_REVISION;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY;\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyUUID);\n-        statement.setString(2, apiUUID);\n-        statement.setString(3, clonedPolicyId);\n-        if (revisionUUID != null) {\n-            statement.setString(4, revisionUUID);\n-        }\n-        statement.executeUpdate();\n-        statement.close();\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * This method is used to populate AM_OPERATION_POLICY table. This will return the policy ID.\n-     *\n-     * @param connection DB connection\n-     * @param policyData Unique Identifier of API\n-     * @return UUID of the newly created policy\n-     * @throws SQLException\n-     */\n-    private String addOperationPolicyContent(Connection connection, OperationPolicyData policyData)\n-            throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY;\n-        String policyUUID = UUID.randomUUID().toString();\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyUUID);\n-        statement.setString(2, policySpecification.getName());\n-        statement.setString(3, policySpecification.getDisplayName());\n-        statement.setString(4, policySpecification.getDescription());\n-        statement.setString(5, policySpecification.getApplicableFlows().toString());\n-        statement.setString(6, policySpecification.getSupportedGateways().toString());\n-        statement.setString(7, policySpecification.getSupportedApiTypes().toString());\n-        statement.setBinaryStream(8,\n-                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n-        statement.setString(9, policyData.getOrganization());\n-        statement.setString(10, policySpecification.getCategory().toString());\n-        statement.setBoolean(11, policySpecification.isMultipleAllowed());\n-        statement.setString(12, policyData.getMd5Hash());\n-        statement.executeUpdate();\n-        statement.close();\n-\n-        if (policyData.getSynapsePolicyDefinition() != null) {\n-            addOperationPolicyDefinition(connection, policyUUID, policyData.getSynapsePolicyDefinition());\n-        }\n-        if (policyData.getCcPolicyDefinition() != null) {\n-            addOperationPolicyDefinition(connection, policyUUID, policyData.getCcPolicyDefinition());\n-        }\n-\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * Update an existing operation policy\n-     *\n-     * @param policyId   Shared policy UUID\n-     * @param policyData Updated policy definition\n-     * @throws APIManagementException\n-     */\n-    public void updateOperationPolicy(String policyId, OperationPolicyData policyData)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            connection.setAutoCommit(false);\n-            updateOperationPolicy(connection, policyId, policyData);\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to update the operation policy with ID \" + policyId, e);\n-        }\n-    }\n-\n-    /**\n-     * Update an existing operation policy\n-     *\n-     * @param connection DB connection\n-     * @param policyId   Shared policy UUID\n-     * @param policyData Updated policy definition\n-     * @throws SQLException\n-     */\n-    private void updateOperationPolicy(Connection connection, String policyId, OperationPolicyData policyData)\n-            throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        PreparedStatement statement = connection.prepareStatement(\n-                SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_CONTENT);\n-\n-        statement.setString(1, policySpecification.getName());\n-        statement.setString(2, policySpecification.getDisplayName());\n-        statement.setString(3, policySpecification.getDescription());\n-        statement.setString(4, policySpecification.getApplicableFlows().toString());\n-        statement.setString(5, policySpecification.getSupportedGateways().toString());\n-        statement.setString(6, policySpecification.getSupportedApiTypes().toString());\n-        statement.setBinaryStream(7,\n-                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n-        statement.setString(8, policyData.getOrganization());\n-        statement.setString(9, policySpecification.getCategory().toString());\n-        statement.setBoolean(10, policySpecification.isMultipleAllowed());\n-        statement.setString(11, policyData.getMd5Hash());\n-        statement.setString(12, policyId);\n-        statement.executeUpdate();\n-        statement.close();\n-\n-        if (policyData.getSynapsePolicyDefinition() != null) {\n-            updateOperationPolicyDefinition(connection, policyId, policyData.getSynapsePolicyDefinition());\n-        }\n-        if (policyData.getCcPolicyDefinition() != null) {\n-            updateOperationPolicyDefinition(connection, policyId, policyData.getCcPolicyDefinition());\n-        }\n-\n-    }\n-\n-    /**\n-     * Delete an operation policy by providing the policy UUID\n-     *\n-     * @param policyId UUID of the policy to be deleted\n-     * @return True if deleted successfully\n-     * @throws APIManagementException\n-     */\n-    public void deleteOperationPolicyByPolicyId(String policyId) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            deleteOperationPolicyByPolicyId(connection, policyId);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete operation policy \" + policyId, e);\n-        }\n-    }\n-\n-    private void deleteOperationPolicyByPolicyId(Connection connection, String policyId) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.execute();\n-        statement.close();\n-    }\n-\n-    /**\n-     * Get the set of URI templates that have Operation policies\n-     *\n-     * @param apiUUID Unique Identifier of API\n-     * @return URITemplate set\n-     * @throws APIManagementException\n-     */\n-    public Set<URITemplate> getURITemplatesWithOperationPolicies(String apiUUID) throws APIManagementException {\n-\n-        String query;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(apiUUID);\n-\n-        if (apiRevision == null) {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-        }\n-\n-        Map<String, URITemplate> uriTemplates = new HashMap<>();\n-        Set<URITemplate> uriTemplateList = new HashSet<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement prepStmt = connection.prepareStatement(query)) {\n-            if (apiRevision == null) {\n-                int apiId = getAPIID(apiUUID, connection);\n-                prepStmt.setInt(1, apiId);\n-            } else {\n-                int apiId = getAPIID(apiRevision.getApiUUID(), connection);\n-                prepStmt.setInt(1, apiId);\n-                prepStmt.setString(2, apiRevision.getRevisionUUID());\n-            }\n-            try (ResultSet rs = prepStmt.executeQuery()) {\n-                URITemplate uriTemplate;\n-                while (rs.next()) {\n-                    String httpMethod = rs.getString(\"HTTP_METHOD\");\n-                    String urlPattern = rs.getString(\"URL_PATTERN\");\n-                    String urlTemplateKey = httpMethod + \":\" + urlPattern;\n-                    if (!uriTemplates.containsKey(urlTemplateKey)) {\n-                        uriTemplate = new URITemplate();\n-                    } else {\n-                        uriTemplate = uriTemplates.get(urlTemplateKey);\n-                    }\n-                    OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                    uriTemplate.addOperationPolicy(operationPolicy);\n-                    uriTemplate.setHTTPVerb(httpMethod);\n-                    uriTemplate.setUriTemplate(urlPattern);\n-                    uriTemplate.setId(rs.getInt(\"URL_MAPPING_ID\"));\n-                    uriTemplates.put(urlTemplateKey, uriTemplate);\n-                }\n-            }\n-            uriTemplateList.addAll(uriTemplates.values());\n-        } catch (SQLException e) {\n-            handleException(\"Error while fetching URI templates with operation policies for \" + apiUUID, e);\n-        }\n-        return uriTemplateList;\n-    }\n-\n-    /**\n-     * Get operation polycies attached to the resource identified by the url mapping ID\n-     *\n-     * @param urlMappingId URL Mapping ID of the resource\n-     * @return\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private List<OperationPolicy> getOperationPoliciesOfURITemplate(int urlMappingId)\n-            throws SQLException, APIManagementException {\n-\n-        List<OperationPolicy> operationPolicies = new ArrayList<>();\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(\n-                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_BY_URI_TEMPLATE_ID)) {\n-            ps.setInt(1, urlMappingId);\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    OperationPolicy policy = populateOperationPolicyWithRS(rs);\n-                    operationPolicies.add(policy);\n-                }\n-            }\n-        }\n-        return operationPolicies;\n-    }\n-\n-    /**\n-     * Sets operation policies to uriTemplates map\n-     *\n-     * @param uuid         UUID of API or API Revision\n-     * @param uriTemplates URI Templates map with 'URL_PATTERN + HTTP_METHOD' as the map key\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setOperationPoliciesToURITemplatesMap(String uuid, Map<String, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        String currentApiUuid;\n-        String query;\n-        boolean isRevision = false;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n-        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n-            currentApiUuid = apiRevision.getApiUUID();\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-            isRevision = true;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-            currentApiUuid = uuid;\n-        }\n-\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(query)) {\n-            int apiId = getAPIID(currentApiUuid);\n-            ps.setInt(1, apiId);\n-            if (isRevision) {\n-                ps.setString(2, uuid);\n-            }\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(key);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets operation policies to uriTemplates map\n-     *\n-     * @param uuid         UUID of API or API Revision\n-     * @param uriTemplates URI Templates map with URL_MAPPING_ID as the map key\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setOperationPolicies(String uuid, Map<Integer, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        String currentApiUuid;\n-        String query;\n-        boolean isRevision = false;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n-        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n-            currentApiUuid = apiRevision.getApiUUID();\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-            isRevision = true;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-            currentApiUuid = uuid;\n-        }\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(query)) {\n-            int apiId = getAPIID(currentApiUuid);\n-            ps.setInt(1, apiId);\n-            if (isRevision) {\n-                ps.setString(2, uuid);\n-            }\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    int uriTemplateId = rs.getInt(\"URL_MAPPING_ID\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(uriTemplateId);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Populates operation policy mappings in the API Product URITemplate map\n-     *\n-     * @param productRevisionId Product Revision ID\n-     * @param uriTemplates      Map of URI Templates\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setAPIProductOperationPoliciesToURITemplatesMap(String productRevisionId,\n-                                                                 Map<String, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(\n-                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_PER_API_PRODUCT_SQL)) {\n-            ps.setString(1, productRevisionId);\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(key);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Clone an operation policy to the API. This method is used in two flows.\n-     * Cloning a common policy to API.\n-     * Cloning a dependent policy of a product\n-     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n-     *\n-     * @param connection   DB connection\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param apiUUID      UUID of the API\n-     * @param revisionUUID UUID of the revision\n-     * @return cloned policyID\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private String cloneOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID)\n-            throws APIManagementException, SQLException {\n-\n-        OperationPolicyData policyData = getOperationPolicyByPolicyID(connection, policyId, true);\n-        if (policyData != null) {\n-            // If we are taking a clone from common policy, common policy's Id is used as the CLONED_POLICY_ID.\n-            // If we are cloning for an API Product, dependent APIs' id is used.\n-            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, policyId);\n-        } else {\n-            throw new APIManagementException(\"Cannot clone policy with ID \" + policyId + \" as it does not exists.\");\n-        }\n-    }\n-\n-    /**\n-     * This method is used in the creating a revision for API and API product. This will create a new API specific policy\n-     * with API UUID and revision UUID.\n-     *\n-     * @param connection   DB connection\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param apiUUID      UUID of the API\n-     * @param revisionUUID UUID of the revision\n-     * @return cloned policyID\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private String revisionOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID,\n-                                           String organization)\n-            throws APIManagementException, SQLException {\n-\n-        OperationPolicyData policyData = getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID,\n-                organization, true);\n-        // Since we import all the policies to API at API update, getting the policy from API specific policy list is enough\n-        if (policyData != null) {\n-            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData,\n-                    policyData.getClonedCommonPolicyId());\n-        } else {\n-            throw new APIManagementException(\"Cannot create a revision of policy with ID \" + policyId\n-                    + \" as it does not exists.\");\n-        }\n-    }\n-\n-    /**\n-     * This method is used the restore flow. At the restore, apart from the policy details, CLONED_POLICY_ID column\n-     * too can change and that needs to be updated.\n-     *\n-     * @param connection DB connection\n-     * @param policyId   Original policy's ID that needs to be cloned\n-     * @param policyData Updated policy data\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private void updateAPISpecificOperationPolicyWithClonedPolicyId(Connection connection, String policyId,\n-                                                                    OperationPolicyData policyData)\n-            throws SQLException {\n-\n-        if (policyData.getClonedCommonPolicyId() != null) {\n-            PreparedStatement statement = connection.prepareStatement(\n-                    SQLConstants.OperationPolicyConstants.UPDATE_API_OPERATION_POLICY_BY_POLICY_ID);\n-            statement.setString(1, policyData.getClonedCommonPolicyId());\n-            statement.executeUpdate();\n-            statement.close();\n-        }\n-        updateOperationPolicy(connection, policyId, policyData);\n-    }\n-\n-    /**\n-     * This method is used to restore an API specific operation policy revision.\n-     *\n-     * @param connection   DB connection\n-     * @param apiUUID      UUID of the API\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param revisionId   The revision number\n-     * @param organization Organization name\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     **/\n-    private String restoreOperationPolicyRevision(Connection connection, String apiUUID, String policyId,\n-                                                  int revisionId,\n-                                                  String organization) throws SQLException, APIManagementException {\n-\n-        OperationPolicyData revisionedPolicy = getAPISpecificOperationPolicyByPolicyID(connection, policyId,\n-                apiUUID, organization, true);\n-        String restoredPolicyId = null;\n-        if (revisionedPolicy != null) {\n-            // First check whether there exists a API specific policy for same policy name with revision uuid null\n-            // This is the state where we record the policies applied in the working copy.\n-            OperationPolicyData apiSpecificPolicy = getAPISpecificOperationPolicyByPolicyName(connection,\n-                    revisionedPolicy.getSpecification().getName(), revisionedPolicy.getApiUUID(), null,\n-                    organization, false);\n-            if (apiSpecificPolicy != null) {\n-                if (apiSpecificPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Matching API specific operation policy found for the revisioned policy and \" +\n-                                \"MD5 hashes match\");\n-                    }\n-\n-                } else {\n-                    updateAPISpecificOperationPolicyWithClonedPolicyId(connection, apiSpecificPolicy.getPolicyId(),\n-                            revisionedPolicy);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Even though a matching API specific operation policy found for name,\"\n-                                + \" MD5 hashes does not match. Policy \" + apiSpecificPolicy.getPolicyId()\n-                                + \" has been updated from the revision.\");\n-                    }\n-                }\n-                restoredPolicyId = apiSpecificPolicy.getPolicyId();\n-            } else {\n-                if (revisionedPolicy.isClonedPolicy()) {\n-                    // Check for a common operation policy only if it is a cloned policy.\n-                    OperationPolicyData commonPolicy = getCommonOperationPolicyByPolicyID(connection,\n-                            revisionedPolicy.getClonedCommonPolicyId(), organization, false);\n-                    if (commonPolicy != null) {\n-                        if (commonPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\"Matching common operation policy found. MD5 hash match\");\n-                            }\n-                            //This means the common policy is same with our revision. A clone is created and original\n-                            // common policy ID is referenced as the ClonedCommonPolicyId\n-                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n-                                    revisionedPolicy, revisionedPolicy.getClonedCommonPolicyId());\n-                        } else {\n-                            // This means the common policy is updated since we created the revision.\n-                            // we have to create a clone and since policy is different, we can't refer the original common\n-                            // policy as ClonedCommonPolicyId. This should be a new API specific policy\n-                            revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n-                                    + \"_restored-\" + revisionId);\n-                            revisionedPolicy.getSpecification()\n-                                    .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n-                                            + \" Restored from revision \" + revisionId);\n-                            revisionedPolicy.setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy));\n-                            revisionedPolicy.setRevisionUUID(null);\n-                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n-                                    revisionedPolicy, null);\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\n-                                        \"An updated matching common operation policy found. A new API specific operation \" +\n-                                                \"policy created by the display name \" +\n-                                                revisionedPolicy.getSpecification().getName());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    // This means this is a completely new policy and we don't have any reference of a previous state in\n-                    // working copy. A new API specific policy will be created.\n-                    revisionedPolicy.setRevisionUUID(null);\n-                    restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"No matching operation policy found. A new API specific operation \" +\n-                                \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n-                    }\n-                }\n-            }\n-        } else {\n-            throw new APIManagementException(\"A revisioned operation policy not found for \" + policyId);\n-        }\n-        return restoredPolicyId;\n-    }\n-\n-    /**\n-     * Retrieve an operation policy by providing the policy uuid\n-     *\n-     * @param connection             DB connection\n-     * @param policyId               Policy UUID\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws SQLException\n-     */\n-    private OperationPolicyData getOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                             boolean isWithPolicyDefinition) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_ID;\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setPolicyId(policyId);\n-            policyData.setOrganization(rs.getString(\"ORGANIZATION\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyId, policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    /**\n-     * Get the API specific operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n-     * table and AM_API_OPERATION_POLICY table from API UUID. Policy id might be available, but if it is not referenced in the\n-     * APIS table, this will return null.\n-     * The returned policy data can be either an API only policy, cloned common policy to API or a revisioned API specific policy\n-     *\n-     * @param policyId               Policy UUID\n-     * @param apiUUID                UUID of the API\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getAPISpecificOperationPolicyByPolicyID(String policyId, String apiUUID,\n-                                                                       String organization,\n-                                                                       boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID, organization,\n-                    isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the API specific operation policy for id \" + policyId + \" from API \"\n-                    + apiUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getAPISpecificOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                                        String apiUUID,\n-                                                                        String organization,\n-                                                                        boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery =\n-                SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_ID;\n-        OperationPolicyData policyData = null;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, organization);\n-        statement.setString(3, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setPolicyId(policyId);\n-            policyData.setApiUUID(apiUUID);\n-            policyData.setOrganization(organization);\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n-            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyId, policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    private List<OperationPolicyDefinition> getPolicyDefinitionForPolicyId(Connection connection, String policyId)\n-            throws SQLException {\n-\n-        List<OperationPolicyDefinition> operationPolicyDefinitions = new ArrayList<>();\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_DEFINITION_FROM_POLICY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            String policyDefinitionString;\n-            OperationPolicyDefinition policyDefinition = new OperationPolicyDefinition();\n-\n-            try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n-                policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n-                policyDefinition.setContent(policyDefinitionString);\n-                policyDefinition.setGatewayType(\n-                        OperationPolicyDefinition.GatewayType.valueOf(rs.getString(\"GATEWAY_TYPE\")));\n-                policyDefinition.setMd5Hash(rs.getString(\"DEFINITION_MD5\"));\n-\n-                operationPolicyDefinitions.add(policyDefinition);\n-            } catch (IOException e) {\n-                log.error(\"Error while converting policy definition for the policy\", e);\n-            }\n-\n-        }\n-        rs.close();\n-        statement.close();\n-        return operationPolicyDefinitions;\n-    }\n-\n-\n-    public void populatePolicyDefinitions(Connection connection, String policyId, OperationPolicyData policyData)\n-            throws SQLException {\n-        if (policyId != null && !policyId.isEmpty()) {\n-            List<OperationPolicyDefinition> policyDefinitions = getPolicyDefinitionForPolicyId(connection, policyId);\n-            for (OperationPolicyDefinition policyDefinition : policyDefinitions) {\n-                if (OperationPolicyDefinition.GatewayType.Synapse.equals(policyDefinition.getGatewayType())) {\n-                    policyData.setSynapsePolicyDefinition(policyDefinition);\n-                } else if (OperationPolicyDefinition.GatewayType.ChoreoConnect.equals(policyDefinition.getGatewayType())) {\n-                    policyData.setCcPolicyDefinition(policyDefinition);\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    private void addOperationPolicyDefinition (Connection connection, String policyId,\n-                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY_DEFINITION;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, policyDefinition.getGatewayType().toString());\n-        statement.setString(3, policyDefinition.getMd5Hash());\n-        statement.setBinaryStream(4, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n-        statement.executeUpdate();\n-        statement.close();\n-    }\n-\n-\n-    private void updateOperationPolicyDefinition(Connection connection, String policyId,\n-                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_DEFINITION;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyDefinition.getMd5Hash());\n-        statement.setBinaryStream(2, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n-        statement.setString(3, policyId);\n-        statement.setString(4, policyDefinition.getGatewayType().toString());\n-        statement.executeUpdate();\n-        statement.close();\n-    }\n-\n-    /**\n-     * Get the common operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n-     * table and AM_COMMON_OPERATION_POLICY table. Policy id might be available, but if it is not referenced in the\n-     * common policies table, this will return null.\n-     *\n-     * @param policyId               Policy UUID\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getCommonOperationPolicyByPolicyID(String policyId, String organization,\n-                                                                  boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getCommonOperationPolicyByPolicyID(connection, policyId, organization, isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the operation policy for id \" + policyId, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getCommonOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                                   String organization,\n-                                                                   boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery =\n-                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, organization);\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setPolicyId(policyId);\n-            policyData.setOrganization(organization);\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            populatePolicyDefinitions(connection, policyId, policyData);\n-        }\n-\n-        return policyData;\n-    }\n-\n-    /**\n-     * Retrieve a common operation policy by providing the policy name and organization\n-     *\n-     * @param policyName             Policy name\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getCommonOperationPolicyByPolicyName(String policyName, String organization,\n-                                                                    boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getCommonOperationPolicyByPolicyName(connection, policyName, organization, isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get common operation policy for name \" + policyName + \"for organization \"\n-                    + organization, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getCommonOperationPolicyByPolicyName(Connection connection, String policyName,\n-                                                                     String tenantDomain,\n-                                                                     boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery =\n-                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_FROM_POLICY_NAME;\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyName);\n-        statement.setString(2, tenantDomain);\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setOrganization(tenantDomain);\n-            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    /**\n-     * Retrieve an API Specific operation policy by providing the policy name. In order to narrow down the specific policy\n-     * this needs policy name, apiUUID, api revision UUID (if exists) and organization. If revision UUID is not provided,\n-     * that means the policy is not a revisioned policy.\n-     *\n-     * @param policyName             Policy name\n-     * @param apiUUID                UUID of API\n-     * @param revisionUUID           UUID of API revision\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getAPISpecificOperationPolicyByPolicyName(String policyName, String apiUUID,\n-                                                                         String revisionUUID, String organization,\n-                                                                         boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getAPISpecificOperationPolicyByPolicyName(connection, policyName, apiUUID, revisionUUID,\n-                    organization,\n-                    isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API specific operation policy for name \" + policyName + \" with API UUID \"\n-                    + apiUUID + \" revision UUID \" + revisionUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getAPISpecificOperationPolicyByPolicyName(Connection connection,\n-                                                                          String policyName, String apiUUID,\n-                                                                          String revisionUUID,\n-                                                                          String tenantDomain,\n-                                                                          boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_NAME;\n-        if (revisionUUID != null) {\n-            dbQuery += \" AND AOP.REVISION_UUID = ?\";\n-        } else {\n-            dbQuery += \" AND AOP.REVISION_UUID IS NULL\";\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyName);\n-        statement.setString(2, tenantDomain);\n-        statement.setString(3, apiUUID);\n-        if (revisionUUID != null) {\n-            statement.setString(4, revisionUUID);\n-        }\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setOrganization(tenantDomain);\n-            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-            policyData.setApiUUID(rs.getString(\"API_UUID\"));\n-            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    /**\n-     * Get the list of all operation policies. If the API UUID is provided, this will return all the operation policies\n-     * for that API. If not, it will return the common operation policies which are not bound to any API.\n-     * This list will include policy specification of each policy and policy ID. It will not contain the\n-     * policy definition as it is not useful for the operation.\n-     *\n-     * @param apiUUID      UUID of the API if exists. Null for common operation policies\n-     * @param organization Organization name\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    public List<OperationPolicyData> getLightWeightVersionOfAllOperationPolicies(String apiUUID,\n-                                                                                 String organization)\n-            throws APIManagementException {\n-\n-        String dbQuery;\n-        if (apiUUID != null) {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_OPERATION_POLICIES_WITHOUT_CLONED_POLICIES;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_COMMON_OPERATION_POLICIES;\n-        }\n-        List<OperationPolicyData> policyDataList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-            statement.setString(1, organization);\n-            if (apiUUID != null) {\n-                statement.setString(2, apiUUID);\n-            }\n-            ResultSet rs = statement.executeQuery();\n-            while (rs.next()) {\n-                OperationPolicyData policyData = new OperationPolicyData();\n-                policyData.setOrganization(organization);\n-                policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-                if (apiUUID != null) {\n-                    policyData.setApiUUID(apiUUID);\n-                }\n-                policyDataList.add(policyData);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get all the operation policy for tenant \" + organization, e);\n-        }\n-        return policyDataList;\n-    }\n-\n-    public int getOperationPolicyCount(String organization) throws APIManagementException {\n-\n-        int count = -1;\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_THE_COUNT_OF_OPERATION_POLICIES_FOR_ORGANIZATION;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-            statement.setString(1, organization);\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                count = rs.getInt(\"POLICY_COUNT\");\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the count of operation policies for organization \" + organization, e);\n-        }\n-        return count;\n-    }\n-\n-\n-\n-    /**\n-     * This method will return a list of all cloned policies for an API.\n-     *\n-     * @param connection DB connection\n-     * @param apiUUID    UUID of the API if exists. Null for common operation policies\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private Set<String> getAllClonedPolicyIdsForAPI(Connection connection, String apiUUID)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_CLONED_POLICIES_FOR_API;\n-        Set<String> policyIds = new HashSet<>();\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            policyIds.add(rs.getString(\"POLICY_UUID\"));\n-        }\n-        rs.close();\n-        statement.close();\n-        return policyIds;\n-    }\n-\n-    /**\n-     * This method will query AM_API_OPERATION_POLICY table from CLONED_POLICY_ID row for a matching policy ID\n-     * for the required API. This is useful to find the cloned API specific policy ID from a common policy.\n-     *\n-     * @param connection     DB connection\n-     * @param commonPolicyId Common policy ID\n-     * @param apiUUID        UUID of API\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private String getClonedPolicyIdForCommonPolicyId(Connection connection, String commonPolicyId, String apiUUID)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_CLONED_POLICY_ID_FOR_COMMON_POLICY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, commonPolicyId);\n-        statement.setString(2, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        String policyId = null;\n-        if (rs.next()) {\n-            policyId = rs.getString(\"POLICY_UUID\");\n-        }\n-        rs.close();\n-        statement.close();\n-        return policyId;\n-    }\n-\n-    /**\n-     * Delete all the API specific policies for a given API UUID. If revision UUID is provided, only the policies that\n-     * are revisioned will be deleted. This is used when we delete an API revision.\n-     * If revision id is null, all the API specific policies will be deleted. This is used in API deleting flow.\n-     *\n-     * @param connection   DB connection\n-     * @param apiUUID      UUID of API\n-     * @param revisionUUID Revision UUID\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private void deleteAllAPISpecificOperationPoliciesByAPIUUID(Connection connection, String apiUUID,\n-                                                                String revisionUUID)\n-            throws SQLException {\n-\n-        String dbQuery;\n-        if (revisionUUID != null) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_REVISION_UUID;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_API_ID;\n-        }\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, apiUUID);\n-        if (revisionUUID != null) {\n-            statement.setString(2, revisionUUID);\n-        }\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            String deleteQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n-            PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);\n-            deleteStatement.setString(1, rs.getString(\"POLICY_UUID\"));\n-            deleteStatement.execute();\n-            deleteStatement.close();\n-        }\n-        rs.close();\n-        statement.close();\n-    }\n-\n-    /**\n-     * When we apply a common policy to an operation, this policy will be cloned to the API at the backend. However, if\n-     * that policy is removed from the UI, this method is used to clean such unused policies that are imported,\n-     * but not used\n-     *\n-     * @param connection            DB connection\n-     * @param usedClonedPoliciesSet Currently used imported API specific policies set\n-     * @param apiUUID               UUID of the API\n-     * @throws SQLException\n-     */\n-    private void cleanUnusedClonedOperationPolicies(Connection connection, Set<String> usedClonedPoliciesSet,\n-                                                    String apiUUID)\n-            throws SQLException {\n-\n-        Set<String> allClonedPoliciesForAPI = getAllClonedPolicyIdsForAPI(connection, apiUUID);\n-        Set<String> policiesToDelete = allClonedPoliciesForAPI;\n-        policiesToDelete.removeAll(usedClonedPoliciesSet);\n-        for (String policyId : allClonedPoliciesForAPI) {\n-            deleteOperationPolicyByPolicyId(connection, policyId);\n-        }\n-    }\n-\n-    /**\n-     * This method will read the result set and populate OperationPolicy object, which later will be set to the URI template.\n-     * This object has the information regarding the policy allocation\n-     *\n-     * @param rs Result set\n-     * @return OperationPolicy object\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     */\n-    private OperationPolicy populateOperationPolicyWithRS(ResultSet rs) throws SQLException, APIManagementException {\n-\n-        OperationPolicy operationPolicy = new OperationPolicy();\n-        operationPolicy.setPolicyName(rs.getString(\"POLICY_NAME\"));\n-        operationPolicy.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-        operationPolicy.setOrder(rs.getInt(\"POLICY_ORDER\"));\n-        operationPolicy.setDirection(rs.getString(\"DIRECTION\"));\n-        operationPolicy.setParameters(APIMgtDBUtil.convertJSONStringToMap(rs.getString(\"PARAMETERS\")));\n-        return operationPolicy;\n-    }\n-\n-    /**\n-     * This method will read the result set and populate OperationPolicySpecification object.\n-     *\n-     * @param rs Result set\n-     * @return OperationPolicySpecification object\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     */\n-    private OperationPolicySpecification populatePolicySpecificationFromRS(ResultSet rs) throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n-        policySpecification.setName(rs.getString(\"POLICY_NAME\"));\n-        policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n-        policySpecification.setDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n-        policySpecification.setApplicableFlows(getListFromString(rs.getString(\"APPLICABLE_FLOWS\")));\n-        policySpecification.setSupportedApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n-        policySpecification.setSupportedGateways(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n-        policySpecification.setCategory(OperationPolicySpecification.PolicyCategory\n-                .valueOf(rs.getString(\"POLICY_CATEGORY\")));\n-        policySpecification.setMultipleAllowed(rs.getBoolean(\"MULTIPLE_ALLOWED\"));\n-        List<OperationPolicySpecAttribute> policySpecAttributes = null;\n-\n-        try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n-            String policyParametersString = IOUtils.toString(policyParametersStream);\n-            policySpecAttributes = new Gson().fromJson(policyParametersString,\n-                    new TypeToken<List<OperationPolicySpecAttribute>>() {\n-                    }.getType());\n-        } catch (IOException e) {\n-            log.error(\"Error while converting policy specification attributes for the policy \"\n-                    + policySpecification.getName(), e);\n-        }\n-        policySpecification.setPolicyAttributes(policySpecAttributes);\n-        return policySpecification;\n-    }\n-\n-\n-    /**\n-     * Create a string list from a single string element by splitting from the comma\n-     *\n-     * @param stringElement String element\n-     * @return list of strings\n-     */\n-    private List<String> getListFromString(String stringElement) {\n-\n-        List<String> list = null;\n-        if (!stringElement.isEmpty()) {\n-            list = Arrays.asList(\n-                    stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n-        }\n-        return list;\n-    }\n }\n", "next_change": {"commit": "8683de3dde50b90f9cd609f3242a7aa63ea2d009", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 2a0da146a65..bb912116576 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17681,4 +17983,1211 @@ public class ApiMgtDAO {\n             this.subscriptionStatus = subscriptionStatus;\n         }\n     }\n+\n+    /**\n+     * Operation policy implementation\n+     *\n+     */\n+\n+    /**\n+     * Add a new common operation policy to the database. This will first add the operation policy content to the\n+     * AM_OPERATION_POLICY table and another entry to AM_COMMON_OPERATION_POLICY table.\n+     *\n+     * @param policyData Operation policy data.\n+     * @return UUID of the newly created shared policy\n+     * @throws APIManagementException\n+     */\n+    public String addCommonOperationPolicy(OperationPolicyData policyData) throws APIManagementException {\n+\n+        String policyUUID = null;\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                policyUUID = addOperationPolicyContent(connection, policyData);\n+\n+                String dbQuery = SQLConstants.OperationPolicyConstants.ADD_COMMON_OPERATION_POLICY;\n+                PreparedStatement statement = connection.prepareStatement(dbQuery);\n+                statement.setString(1, policyUUID);\n+                statement.executeUpdate();\n+                statement.close();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n+        }\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * Add a new API specific operation policy to the database\n+     *\n+     * @param apiUUID      Unique Identifier of API\n+     * @param revisionUUID Unique Identifier of API revision\n+     * @param policyData   Unique Identifier of API\n+     * @return UUID of the newly created shared policy\n+     * @throws APIManagementException\n+     */\n+    public String addAPISpecificOperationPolicy(String apiUUID, String revisionUUID,\n+                                                OperationPolicyData policyData)\n+            throws APIManagementException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                String policyID = addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, null);\n+                connection.commit();\n+                return policyID;\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n+                        + \" for API \" + apiUUID, e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n+                    + \" for API \" + apiUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private String addAPISpecificOperationPolicy(Connection connection, String apiUUID, String revisionUUID,\n+                                                 OperationPolicyData policyData, String clonedPolicyId)\n+            throws SQLException {\n+\n+        String policyUUID = addOperationPolicyContent(connection, policyData);\n+\n+        String dbQuery;\n+        if (revisionUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY_WITH_REVISION;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY;\n+        }\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyUUID);\n+        statement.setString(2, apiUUID);\n+        statement.setString(3, clonedPolicyId);\n+        if (revisionUUID != null) {\n+            statement.setString(4, revisionUUID);\n+        }\n+        statement.executeUpdate();\n+        statement.close();\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * This method is used to populate AM_OPERATION_POLICY table. This will return the policy ID.\n+     *\n+     * @param connection DB connection\n+     * @param policyData Unique Identifier of API\n+     * @return UUID of the newly created policy\n+     * @throws SQLException\n+     */\n+    private String addOperationPolicyContent(Connection connection, OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY;\n+        String policyUUID = UUID.randomUUID().toString();\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyUUID);\n+        statement.setString(2, policySpecification.getName());\n+        statement.setString(3, policySpecification.getDisplayName());\n+        statement.setString(4, policySpecification.getDescription());\n+        statement.setString(5, policySpecification.getApplicableFlows().toString());\n+        statement.setString(6, policySpecification.getSupportedGateways().toString());\n+        statement.setString(7, policySpecification.getSupportedApiTypes().toString());\n+        statement.setBinaryStream(8,\n+                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n+        statement.setString(9, policyData.getOrganization());\n+        statement.setString(10, policySpecification.getCategory().toString());\n+        statement.setBoolean(11, policySpecification.isMultipleAllowed());\n+        statement.setString(12, policyData.getMd5Hash());\n+        statement.executeUpdate();\n+        statement.close();\n+\n+        if (policyData.getSynapsePolicyDefinition() != null) {\n+            addOperationPolicyDefinition(connection, policyUUID, policyData.getSynapsePolicyDefinition());\n+        }\n+        if (policyData.getCcPolicyDefinition() != null) {\n+            addOperationPolicyDefinition(connection, policyUUID, policyData.getCcPolicyDefinition());\n+        }\n+\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * Update an existing operation policy\n+     *\n+     * @param policyId   Shared policy UUID\n+     * @param policyData Updated policy definition\n+     * @throws APIManagementException\n+     */\n+    public void updateOperationPolicy(String policyId, OperationPolicyData policyData)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            connection.setAutoCommit(false);\n+            updateOperationPolicy(connection, policyId, policyData);\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to update the operation policy with ID \" + policyId, e);\n+        }\n+    }\n+\n+    /**\n+     * Update an existing operation policy\n+     *\n+     * @param connection DB connection\n+     * @param policyId   Shared policy UUID\n+     * @param policyData Updated policy definition\n+     * @throws SQLException\n+     */\n+    private void updateOperationPolicy(Connection connection, String policyId, OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        PreparedStatement statement = connection.prepareStatement(\n+                SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_CONTENT);\n+\n+        statement.setString(1, policySpecification.getName());\n+        statement.setString(2, policySpecification.getDisplayName());\n+        statement.setString(3, policySpecification.getDescription());\n+        statement.setString(4, policySpecification.getApplicableFlows().toString());\n+        statement.setString(5, policySpecification.getSupportedGateways().toString());\n+        statement.setString(6, policySpecification.getSupportedApiTypes().toString());\n+        statement.setBinaryStream(7,\n+                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n+        statement.setString(8, policyData.getOrganization());\n+        statement.setString(9, policySpecification.getCategory().toString());\n+        statement.setBoolean(10, policySpecification.isMultipleAllowed());\n+        statement.setString(11, policyData.getMd5Hash());\n+        statement.setString(12, policyId);\n+        statement.executeUpdate();\n+        statement.close();\n+\n+        if (policyData.getSynapsePolicyDefinition() != null) {\n+            updateOperationPolicyDefinition(connection, policyId, policyData.getSynapsePolicyDefinition());\n+        }\n+        if (policyData.getCcPolicyDefinition() != null) {\n+            updateOperationPolicyDefinition(connection, policyId, policyData.getCcPolicyDefinition());\n+        }\n+\n+    }\n+\n+    /**\n+     * Delete an operation policy by providing the policy UUID\n+     *\n+     * @param policyId UUID of the policy to be deleted\n+     * @return True if deleted successfully\n+     * @throws APIManagementException\n+     */\n+    public void deleteOperationPolicyByPolicyId(String policyId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            deleteOperationPolicyByPolicyId(connection, policyId);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete operation policy \" + policyId, e);\n+        }\n+    }\n+\n+    private void deleteOperationPolicyByPolicyId(Connection connection, String policyId) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.execute();\n+        statement.close();\n+    }\n+\n+    /**\n+     * Get the set of URI templates that have Operation policies\n+     *\n+     * @param apiUUID Unique Identifier of API\n+     * @return URITemplate set\n+     * @throws APIManagementException\n+     */\n+    public Set<URITemplate> getURITemplatesWithOperationPolicies(String apiUUID) throws APIManagementException {\n+\n+        String query;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(apiUUID);\n+\n+        if (apiRevision == null) {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+        }\n+\n+        Map<String, URITemplate> uriTemplates = new HashMap<>();\n+        Set<URITemplate> uriTemplateList = new HashSet<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement prepStmt = connection.prepareStatement(query)) {\n+            if (apiRevision == null) {\n+                int apiId = getAPIID(apiUUID, connection);\n+                prepStmt.setInt(1, apiId);\n+            } else {\n+                int apiId = getAPIID(apiRevision.getApiUUID(), connection);\n+                prepStmt.setInt(1, apiId);\n+                prepStmt.setString(2, apiRevision.getRevisionUUID());\n+            }\n+            try (ResultSet rs = prepStmt.executeQuery()) {\n+                URITemplate uriTemplate;\n+                while (rs.next()) {\n+                    String httpMethod = rs.getString(\"HTTP_METHOD\");\n+                    String urlPattern = rs.getString(\"URL_PATTERN\");\n+                    String urlTemplateKey = httpMethod + \":\" + urlPattern;\n+                    if (!uriTemplates.containsKey(urlTemplateKey)) {\n+                        uriTemplate = new URITemplate();\n+                    } else {\n+                        uriTemplate = uriTemplates.get(urlTemplateKey);\n+                    }\n+                    OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                    uriTemplate.addOperationPolicy(operationPolicy);\n+                    uriTemplate.setHTTPVerb(httpMethod);\n+                    uriTemplate.setUriTemplate(urlPattern);\n+                    uriTemplate.setId(rs.getInt(\"URL_MAPPING_ID\"));\n+                    uriTemplates.put(urlTemplateKey, uriTemplate);\n+                }\n+            }\n+            uriTemplateList.addAll(uriTemplates.values());\n+        } catch (SQLException e) {\n+            handleException(\"Error while fetching URI templates with operation policies for \" + apiUUID, e);\n+        }\n+        return uriTemplateList;\n+    }\n+\n+    /**\n+     * Get operation polycies attached to the resource identified by the url mapping ID\n+     *\n+     * @param urlMappingId URL Mapping ID of the resource\n+     * @return\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private List<OperationPolicy> getOperationPoliciesOfURITemplate(int urlMappingId)\n+            throws SQLException, APIManagementException {\n+\n+        List<OperationPolicy> operationPolicies = new ArrayList<>();\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(\n+                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_BY_URI_TEMPLATE_ID)) {\n+            ps.setInt(1, urlMappingId);\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    OperationPolicy policy = populateOperationPolicyWithRS(rs);\n+                    operationPolicies.add(policy);\n+                }\n+            }\n+        }\n+        return operationPolicies;\n+    }\n+\n+    /**\n+     * Sets operation policies to uriTemplates map\n+     *\n+     * @param uuid         UUID of API or API Revision\n+     * @param uriTemplates URI Templates map with 'URL_PATTERN + HTTP_METHOD' as the map key\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setOperationPoliciesToURITemplatesMap(String uuid, Map<String, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        String currentApiUuid;\n+        String query;\n+        boolean isRevision = false;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n+        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n+            currentApiUuid = apiRevision.getApiUUID();\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+            isRevision = true;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+            currentApiUuid = uuid;\n+        }\n+\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(query)) {\n+            int apiId = getAPIID(currentApiUuid);\n+            ps.setInt(1, apiId);\n+            if (isRevision) {\n+                ps.setString(2, uuid);\n+            }\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(key);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets operation policies to uriTemplates map\n+     *\n+     * @param uuid         UUID of API or API Revision\n+     * @param uriTemplates URI Templates map with URL_MAPPING_ID as the map key\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setOperationPolicies(String uuid, Map<Integer, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        String currentApiUuid;\n+        String query;\n+        boolean isRevision = false;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n+        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n+            currentApiUuid = apiRevision.getApiUUID();\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+            isRevision = true;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+            currentApiUuid = uuid;\n+        }\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(query)) {\n+            int apiId = getAPIID(currentApiUuid);\n+            ps.setInt(1, apiId);\n+            if (isRevision) {\n+                ps.setString(2, uuid);\n+            }\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    int uriTemplateId = rs.getInt(\"URL_MAPPING_ID\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(uriTemplateId);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Populates operation policy mappings in the API Product URITemplate map\n+     *\n+     * @param productRevisionId Product Revision ID\n+     * @param uriTemplates      Map of URI Templates\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setAPIProductOperationPoliciesToURITemplatesMap(String productRevisionId,\n+                                                                 Map<String, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(\n+                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_PER_API_PRODUCT_SQL)) {\n+            ps.setString(1, productRevisionId);\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(key);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clone an operation policy to the API. This method is used in two flows.\n+     * Cloning a common policy to API.\n+     * Cloning a dependent policy of a product\n+     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n+     *\n+     * @param connection   DB connection\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param apiUUID      UUID of the API\n+     * @param revisionUUID UUID of the revision\n+     * @return cloned policyID\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private String cloneOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID)\n+            throws APIManagementException, SQLException {\n+\n+        OperationPolicyData policyData = getOperationPolicyByPolicyID(connection, policyId, true);\n+        if (policyData != null) {\n+            // If we are taking a clone from common policy, common policy's Id is used as the CLONED_POLICY_ID.\n+            // If we are cloning for an API Product, dependent APIs' id is used.\n+            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, policyId);\n+        } else {\n+            throw new APIManagementException(\"Cannot clone policy with ID \" + policyId + \" as it does not exists.\");\n+        }\n+    }\n+\n+    /**\n+     * This method is used in the creating a revision for API and API product. This will create a new API specific policy\n+     * with API UUID and revision UUID.\n+     *\n+     * @param connection   DB connection\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param apiUUID      UUID of the API\n+     * @param revisionUUID UUID of the revision\n+     * @return cloned policyID\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private String revisionOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID,\n+                                           String organization)\n+            throws APIManagementException, SQLException {\n+\n+        OperationPolicyData policyData = getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID,\n+                organization, true);\n+        // Since we import all the policies to API at API update, getting the policy from API specific policy list is enough\n+        if (policyData != null) {\n+            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData,\n+                    policyData.getClonedCommonPolicyId());\n+        } else {\n+            throw new APIManagementException(\"Cannot create a revision of policy with ID \" + policyId\n+                    + \" as it does not exists.\");\n+        }\n+    }\n+\n+    /**\n+     * This method is used the restore flow. At the restore, apart from the policy details, CLONED_POLICY_ID column\n+     * too can change and that needs to be updated.\n+     *\n+     * @param connection DB connection\n+     * @param policyId   Original policy's ID that needs to be cloned\n+     * @param policyData Updated policy data\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private void updateAPISpecificOperationPolicyWithClonedPolicyId(Connection connection, String policyId,\n+                                                                    OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        if (policyData.getClonedCommonPolicyId() != null) {\n+            PreparedStatement statement = connection.prepareStatement(\n+                    SQLConstants.OperationPolicyConstants.UPDATE_API_OPERATION_POLICY_BY_POLICY_ID);\n+            statement.setString(1, policyData.getClonedCommonPolicyId());\n+            statement.executeUpdate();\n+            statement.close();\n+        }\n+        updateOperationPolicy(connection, policyId, policyData);\n+    }\n+\n+    /**\n+     * This method is used to restore an API specific operation policy revision.\n+     *\n+     * @param connection   DB connection\n+     * @param apiUUID      UUID of the API\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param revisionId   The revision number\n+     * @param organization Organization name\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     **/\n+    private String restoreOperationPolicyRevision(Connection connection, String apiUUID, String policyId,\n+                                                  int revisionId,\n+                                                  String organization) throws SQLException, APIManagementException {\n+\n+        OperationPolicyData revisionedPolicy = getAPISpecificOperationPolicyByPolicyID(connection, policyId,\n+                apiUUID, organization, true);\n+        String restoredPolicyId = null;\n+        if (revisionedPolicy != null) {\n+            // First check whether there exists a API specific policy for same policy name with revision uuid null\n+            // This is the state where we record the policies applied in the working copy.\n+            OperationPolicyData apiSpecificPolicy = getAPISpecificOperationPolicyByPolicyName(connection,\n+                    revisionedPolicy.getSpecification().getName(), revisionedPolicy.getApiUUID(), null,\n+                    organization, false);\n+            if (apiSpecificPolicy != null) {\n+                if (apiSpecificPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Matching API specific operation policy found for the revisioned policy and \" +\n+                                \"MD5 hashes match\");\n+                    }\n+\n+                } else {\n+                    updateAPISpecificOperationPolicyWithClonedPolicyId(connection, apiSpecificPolicy.getPolicyId(),\n+                            revisionedPolicy);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Even though a matching API specific operation policy found for name,\"\n+                                + \" MD5 hashes does not match. Policy \" + apiSpecificPolicy.getPolicyId()\n+                                + \" has been updated from the revision.\");\n+                    }\n+                }\n+                restoredPolicyId = apiSpecificPolicy.getPolicyId();\n+            } else {\n+                if (revisionedPolicy.isClonedPolicy()) {\n+                    // Check for a common operation policy only if it is a cloned policy.\n+                    OperationPolicyData commonPolicy = getCommonOperationPolicyByPolicyID(connection,\n+                            revisionedPolicy.getClonedCommonPolicyId(), organization, false);\n+                    if (commonPolicy != null) {\n+                        if (commonPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\"Matching common operation policy found. MD5 hash match\");\n+                            }\n+                            //This means the common policy is same with our revision. A clone is created and original\n+                            // common policy ID is referenced as the ClonedCommonPolicyId\n+                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n+                                    revisionedPolicy, revisionedPolicy.getClonedCommonPolicyId());\n+                        } else {\n+                            // This means the common policy is updated since we created the revision.\n+                            // we have to create a clone and since policy is different, we can't refer the original common\n+                            // policy as ClonedCommonPolicyId. This should be a new API specific policy\n+                            revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n+                                    + \"_restored-\" + revisionId);\n+                            revisionedPolicy.getSpecification()\n+                                    .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n+                                            + \" Restored from revision \" + revisionId);\n+                            revisionedPolicy.setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy));\n+                            revisionedPolicy.setRevisionUUID(null);\n+                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n+                                    revisionedPolicy, null);\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\n+                                        \"An updated matching common operation policy found. A new API specific operation \" +\n+                                                \"policy created by the display name \" +\n+                                                revisionedPolicy.getSpecification().getName());\n+                            }\n+                        }\n+                    } else {\n+                        // This means this is a clone of a deleted common policy. A new API specific policy will be created.\n+                        revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n+                                + \"_restored-\" + revisionId);\n+                        revisionedPolicy.getSpecification()\n+                                .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n+                                        + \" Restored from revision \" + revisionId);\n+                        revisionedPolicy.setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy));\n+                        revisionedPolicy.setRevisionUUID(null);\n+                        restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"No matching operation policy found. A new API specific operation \" +\n+                                    \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n+                        }\n+                    }\n+                } else {\n+                    // This means this is a completely new policy and we don't have any reference of a previous state in\n+                    // working copy. A new API specific policy will be created.\n+                    revisionedPolicy.setRevisionUUID(null);\n+                    restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No matching operation policy found. A new API specific operation \" +\n+                                \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n+                    }\n+                }\n+            }\n+        } else {\n+            throw new APIManagementException(\"A revisioned operation policy not found for \" + policyId);\n+        }\n+        return restoredPolicyId;\n+    }\n+\n+    /**\n+     * Retrieve an operation policy by providing the policy uuid\n+     *\n+     * @param connection             DB connection\n+     * @param policyId               Policy UUID\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws SQLException\n+     */\n+    private OperationPolicyData getOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                             boolean isWithPolicyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_ID;\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setOrganization(rs.getString(\"ORGANIZATION\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyId, policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Get the API specific operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n+     * table and AM_API_OPERATION_POLICY table from API UUID. Policy id might be available, but if it is not referenced in the\n+     * APIS table, this will return null.\n+     * The returned policy data can be either an API only policy, cloned common policy to API or a revisioned API specific policy\n+     *\n+     * @param policyId               Policy UUID\n+     * @param apiUUID                UUID of the API\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getAPISpecificOperationPolicyByPolicyID(String policyId, String apiUUID,\n+                                                                       String organization,\n+                                                                       boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID, organization,\n+                    isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the API specific operation policy for id \" + policyId + \" from API \"\n+                    + apiUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getAPISpecificOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                                        String apiUUID,\n+                                                                        String organization,\n+                                                                        boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_ID;\n+        OperationPolicyData policyData = null;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, organization);\n+        statement.setString(3, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setApiUUID(apiUUID);\n+            policyData.setOrganization(organization);\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n+            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyId, policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    private List<OperationPolicyDefinition> getPolicyDefinitionForPolicyId(Connection connection, String policyId)\n+            throws SQLException {\n+\n+        List<OperationPolicyDefinition> operationPolicyDefinitions = new ArrayList<>();\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_DEFINITION_FROM_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            String policyDefinitionString;\n+            OperationPolicyDefinition policyDefinition = new OperationPolicyDefinition();\n+\n+            try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n+                policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n+                policyDefinition.setContent(policyDefinitionString);\n+                policyDefinition.setGatewayType(\n+                        OperationPolicyDefinition.GatewayType.valueOf(rs.getString(\"GATEWAY_TYPE\")));\n+                policyDefinition.setMd5Hash(rs.getString(\"DEFINITION_MD5\"));\n+\n+                operationPolicyDefinitions.add(policyDefinition);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting policy definition for the policy\", e);\n+            }\n+\n+        }\n+        rs.close();\n+        statement.close();\n+        return operationPolicyDefinitions;\n+    }\n+\n+\n+    public void populatePolicyDefinitions(Connection connection, String policyId, OperationPolicyData policyData)\n+            throws SQLException {\n+        if (policyId != null && !policyId.isEmpty()) {\n+            List<OperationPolicyDefinition> policyDefinitions = getPolicyDefinitionForPolicyId(connection, policyId);\n+            for (OperationPolicyDefinition policyDefinition : policyDefinitions) {\n+                if (OperationPolicyDefinition.GatewayType.Synapse.equals(policyDefinition.getGatewayType())) {\n+                    policyData.setSynapsePolicyDefinition(policyDefinition);\n+                } else if (OperationPolicyDefinition.GatewayType.ChoreoConnect.equals(policyDefinition.getGatewayType())) {\n+                    policyData.setCcPolicyDefinition(policyDefinition);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private void addOperationPolicyDefinition (Connection connection, String policyId,\n+                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY_DEFINITION;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, policyDefinition.getGatewayType().toString());\n+        statement.setString(3, policyDefinition.getMd5Hash());\n+        statement.setBinaryStream(4, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n+        statement.executeUpdate();\n+        statement.close();\n+    }\n+\n+\n+    private void updateOperationPolicyDefinition(Connection connection, String policyId,\n+                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_DEFINITION;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyDefinition.getMd5Hash());\n+        statement.setBinaryStream(2, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n+        statement.setString(3, policyId);\n+        statement.setString(4, policyDefinition.getGatewayType().toString());\n+        statement.executeUpdate();\n+        statement.close();\n+    }\n+\n+    /**\n+     * Get the common operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n+     * table and AM_COMMON_OPERATION_POLICY table. Policy id might be available, but if it is not referenced in the\n+     * common policies table, this will return null.\n+     *\n+     * @param policyId               Policy UUID\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getCommonOperationPolicyByPolicyID(String policyId, String organization,\n+                                                                  boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getCommonOperationPolicyByPolicyID(connection, policyId, organization, isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the operation policy for id \" + policyId, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getCommonOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                                   String organization,\n+                                                                   boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, organization);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setOrganization(organization);\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            populatePolicyDefinitions(connection, policyId, policyData);\n+        }\n+\n+        return policyData;\n+    }\n+\n+    /**\n+     * Retrieve a common operation policy by providing the policy name and organization\n+     *\n+     * @param policyName             Policy name\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getCommonOperationPolicyByPolicyName(String policyName, String organization,\n+                                                                    boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getCommonOperationPolicyByPolicyName(connection, policyName, organization, isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get common operation policy for name \" + policyName + \"for organization \"\n+                    + organization, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getCommonOperationPolicyByPolicyName(Connection connection, String policyName,\n+                                                                     String tenantDomain,\n+                                                                     boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_FROM_POLICY_NAME;\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyName);\n+        statement.setString(2, tenantDomain);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setOrganization(tenantDomain);\n+            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Retrieve an API Specific operation policy by providing the policy name. In order to narrow down the specific policy\n+     * this needs policy name, apiUUID, api revision UUID (if exists) and organization. If revision UUID is not provided,\n+     * that means the policy is not a revisioned policy.\n+     *\n+     * @param policyName             Policy name\n+     * @param apiUUID                UUID of API\n+     * @param revisionUUID           UUID of API revision\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getAPISpecificOperationPolicyByPolicyName(String policyName, String apiUUID,\n+                                                                         String revisionUUID, String organization,\n+                                                                         boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getAPISpecificOperationPolicyByPolicyName(connection, policyName, apiUUID, revisionUUID,\n+                    organization,\n+                    isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API specific operation policy for name \" + policyName + \" with API UUID \"\n+                    + apiUUID + \" revision UUID \" + revisionUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getAPISpecificOperationPolicyByPolicyName(Connection connection,\n+                                                                          String policyName, String apiUUID,\n+                                                                          String revisionUUID,\n+                                                                          String tenantDomain,\n+                                                                          boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_NAME;\n+        if (revisionUUID != null) {\n+            dbQuery += \" AND AOP.REVISION_UUID = ?\";\n+        } else {\n+            dbQuery += \" AND AOP.REVISION_UUID IS NULL\";\n+        }\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyName);\n+        statement.setString(2, tenantDomain);\n+        statement.setString(3, apiUUID);\n+        if (revisionUUID != null) {\n+            statement.setString(4, revisionUUID);\n+        }\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setOrganization(tenantDomain);\n+            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+            policyData.setApiUUID(rs.getString(\"API_UUID\"));\n+            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Get the list of all operation policies. If the API UUID is provided, this will return all the operation policies\n+     * for that API. If not, it will return the common operation policies which are not bound to any API.\n+     * This list will include policy specification of each policy and policy ID. It will not contain the\n+     * policy definition as it is not useful for the operation.\n+     *\n+     * @param apiUUID      UUID of the API if exists. Null for common operation policies\n+     * @param organization Organization name\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    public List<OperationPolicyData> getLightWeightVersionOfAllOperationPolicies(String apiUUID,\n+                                                                                 String organization)\n+            throws APIManagementException {\n+\n+        String dbQuery;\n+        if (apiUUID != null) {\n+            dbQuery =\n+                    SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_OPERATION_POLICIES_WITHOUT_CLONED_POLICIES;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_COMMON_OPERATION_POLICIES;\n+        }\n+        List<OperationPolicyData> policyDataList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, organization);\n+            if (apiUUID != null) {\n+                statement.setString(2, apiUUID);\n+            }\n+            ResultSet rs = statement.executeQuery();\n+            while (rs.next()) {\n+                OperationPolicyData policyData = new OperationPolicyData();\n+                policyData.setOrganization(organization);\n+                policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+                if (apiUUID != null) {\n+                    policyData.setApiUUID(apiUUID);\n+                }\n+                policyDataList.add(policyData);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get all the operation policy for tenant \" + organization, e);\n+        }\n+        return policyDataList;\n+    }\n+\n+    public int getOperationPolicyCount(String organization) throws APIManagementException {\n+\n+        int count = -1;\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_THE_COUNT_OF_OPERATION_POLICIES_FOR_ORGANIZATION;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, organization);\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                count = rs.getInt(\"POLICY_COUNT\");\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the count of operation policies for organization \" + organization, e);\n+        }\n+        return count;\n+    }\n+\n+\n+\n+    /**\n+     * This method will return a list of all cloned policies for an API.\n+     *\n+     * @param connection DB connection\n+     * @param apiUUID    UUID of the API if exists. Null for common operation policies\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private Set<String> getAllClonedPolicyIdsForAPI(Connection connection, String apiUUID)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_CLONED_POLICIES_FOR_API;\n+        Set<String> policyIds = new HashSet<>();\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            policyIds.add(rs.getString(\"POLICY_UUID\"));\n+        }\n+        rs.close();\n+        statement.close();\n+        return policyIds;\n+    }\n+\n+    /**\n+     * This method will query AM_API_OPERATION_POLICY table from CLONED_POLICY_ID row for a matching policy ID\n+     * for the required API. This is useful to find the cloned API specific policy ID from a common policy.\n+     *\n+     * @param connection     DB connection\n+     * @param commonPolicyId Common policy ID\n+     * @param apiUUID        UUID of API\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private String getClonedPolicyIdForCommonPolicyId(Connection connection, String commonPolicyId, String apiUUID)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_CLONED_POLICY_ID_FOR_COMMON_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, commonPolicyId);\n+        statement.setString(2, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        String policyId = null;\n+        if (rs.next()) {\n+            policyId = rs.getString(\"POLICY_UUID\");\n+        }\n+        rs.close();\n+        statement.close();\n+        return policyId;\n+    }\n+\n+    /**\n+     * Delete all the API specific policies for a given API UUID. If revision UUID is provided, only the policies that\n+     * are revisioned will be deleted. This is used when we delete an API revision.\n+     * If revision id is null, all the API specific policies will be deleted. This is used in API deleting flow.\n+     *\n+     * @param connection   DB connection\n+     * @param apiUUID      UUID of API\n+     * @param revisionUUID Revision UUID\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private void deleteAllAPISpecificOperationPoliciesByAPIUUID(Connection connection, String apiUUID,\n+                                                                String revisionUUID)\n+            throws SQLException {\n+\n+        String dbQuery;\n+        if (revisionUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_REVISION_UUID;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_API_ID;\n+        }\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, apiUUID);\n+        if (revisionUUID != null) {\n+            statement.setString(2, revisionUUID);\n+        }\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            String deleteQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n+            PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);\n+            deleteStatement.setString(1, rs.getString(\"POLICY_UUID\"));\n+            deleteStatement.execute();\n+            deleteStatement.close();\n+        }\n+        rs.close();\n+        statement.close();\n+    }\n+\n+    /**\n+     * When we apply a common policy to an operation, this policy will be cloned to the API at the backend. However, if\n+     * that policy is removed from the UI, this method is used to clean such unused policies that are imported,\n+     * but not used\n+     *\n+     * @param connection            DB connection\n+     * @param usedClonedPoliciesSet Currently used imported API specific policies set\n+     * @param apiUUID               UUID of the API\n+     * @throws SQLException\n+     */\n+    private void cleanUnusedClonedOperationPolicies(Connection connection, Set<String> usedClonedPoliciesSet,\n+                                                    String apiUUID)\n+            throws SQLException {\n+\n+        Set<String> allClonedPoliciesForAPI = getAllClonedPolicyIdsForAPI(connection, apiUUID);\n+        Set<String> policiesToDelete = allClonedPoliciesForAPI;\n+        policiesToDelete.removeAll(usedClonedPoliciesSet);\n+        for (String policyId : allClonedPoliciesForAPI) {\n+            deleteOperationPolicyByPolicyId(connection, policyId);\n+        }\n+    }\n+\n+    /**\n+     * This method will read the result set and populate OperationPolicy object, which later will be set to the URI template.\n+     * This object has the information regarding the policy allocation\n+     *\n+     * @param rs Result set\n+     * @return OperationPolicy object\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     */\n+    private OperationPolicy populateOperationPolicyWithRS(ResultSet rs) throws SQLException, APIManagementException {\n+\n+        OperationPolicy operationPolicy = new OperationPolicy();\n+        operationPolicy.setPolicyName(rs.getString(\"POLICY_NAME\"));\n+        operationPolicy.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+        operationPolicy.setOrder(rs.getInt(\"POLICY_ORDER\"));\n+        operationPolicy.setDirection(rs.getString(\"DIRECTION\"));\n+        operationPolicy.setParameters(APIMgtDBUtil.convertJSONStringToMap(rs.getString(\"PARAMETERS\")));\n+        return operationPolicy;\n+    }\n+\n+    /**\n+     * This method will read the result set and populate OperationPolicySpecification object.\n+     *\n+     * @param rs Result set\n+     * @return OperationPolicySpecification object\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     */\n+    private OperationPolicySpecification populatePolicySpecificationFromRS(ResultSet rs) throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+        policySpecification.setName(rs.getString(\"POLICY_NAME\"));\n+        policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+        policySpecification.setDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+        policySpecification.setApplicableFlows(getListFromString(rs.getString(\"APPLICABLE_FLOWS\")));\n+        policySpecification.setSupportedApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+        policySpecification.setSupportedGateways(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+        policySpecification.setCategory(OperationPolicySpecification.PolicyCategory\n+                .valueOf(rs.getString(\"POLICY_CATEGORY\")));\n+        policySpecification.setMultipleAllowed(rs.getBoolean(\"MULTIPLE_ALLOWED\"));\n+        List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+\n+        try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+            String policyParametersString = IOUtils.toString(policyParametersStream);\n+            policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                    new TypeToken<List<OperationPolicySpecAttribute>>() {\n+                    }.getType());\n+        } catch (IOException e) {\n+            log.error(\"Error while converting policy specification attributes for the policy \"\n+                    + policySpecification.getName(), e);\n+        }\n+        policySpecification.setPolicyAttributes(policySpecAttributes);\n+        return policySpecification;\n+    }\n+\n+\n+    /**\n+     * Create a string list from a single string element by splitting from the comma\n+     *\n+     * @param stringElement String element\n+     * @return list of strings\n+     */\n+    private List<String> getListFromString(String stringElement) {\n+\n+        List<String> list = null;\n+        if (!stringElement.isEmpty()) {\n+            list = Arrays.asList(\n+                    stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n+        }\n+        return list;\n+    }\n }\n", "next_change": {"commit": "b0865e91c3716e810d1b508907d908dfd1f321bb", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex bb912116576..749be8d4e2d 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -19190,4 +19238,5 @@ public class ApiMgtDAO {\n         }\n         return list;\n     }\n+\n }\n", "next_change": {"commit": "f571b104d294fa213a06440c0af90c5c6fa3ce38", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex 749be8d4e2d..a6106fbf8c4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -18017,1226 +17683,4 @@ public class ApiMgtDAO {\n             this.subscriptionStatus = subscriptionStatus;\n         }\n     }\n-\n-    /**\n-     * Operation policy implementation\n-     *\n-     */\n-\n-    /**\n-     * Add a new common operation policy to the database. This will first add the operation policy content to the\n-     * AM_OPERATION_POLICY table and another entry to AM_COMMON_OPERATION_POLICY table.\n-     *\n-     * @param policyData Operation policy data.\n-     * @return UUID of the newly created shared policy\n-     * @throws APIManagementException\n-     */\n-    public String addCommonOperationPolicy(OperationPolicyData policyData) throws APIManagementException {\n-\n-        String policyUUID = null;\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                policyUUID = addOperationPolicyContent(connection, policyData);\n-\n-                String dbQuery = SQLConstants.OperationPolicyConstants.ADD_COMMON_OPERATION_POLICY;\n-                PreparedStatement statement = connection.prepareStatement(dbQuery);\n-                statement.setString(1, policyUUID);\n-                statement.executeUpdate();\n-                statement.close();\n-\n-                connection.commit();\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n-        }\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * Add a new API specific operation policy to the database\n-     *\n-     * @param apiUUID      Unique Identifier of API\n-     * @param revisionUUID Unique Identifier of API revision\n-     * @param policyData   Unique Identifier of API\n-     * @return UUID of the newly created shared policy\n-     * @throws APIManagementException\n-     */\n-    public String addAPISpecificOperationPolicy(String apiUUID, String revisionUUID,\n-                                                OperationPolicyData policyData)\n-            throws APIManagementException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                String policyID = addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, null);\n-                connection.commit();\n-                return policyID;\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n-                        + \" for API \" + apiUUID, e);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n-                    + \" for API \" + apiUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private String addAPISpecificOperationPolicy(Connection connection, String apiUUID, String revisionUUID,\n-                                                 OperationPolicyData policyData, String clonedPolicyId)\n-            throws SQLException {\n-\n-        String policyUUID = addOperationPolicyContent(connection, policyData);\n-\n-        String dbQuery;\n-        if (revisionUUID != null) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY_WITH_REVISION;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY;\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyUUID);\n-        statement.setString(2, apiUUID);\n-        statement.setString(3, clonedPolicyId);\n-        if (revisionUUID != null) {\n-            statement.setString(4, revisionUUID);\n-        }\n-        statement.executeUpdate();\n-        statement.close();\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * This method is used to populate AM_OPERATION_POLICY table. This will return the policy ID.\n-     *\n-     * @param connection DB connection\n-     * @param policyData Unique Identifier of API\n-     * @return UUID of the newly created policy\n-     * @throws SQLException\n-     */\n-    private String addOperationPolicyContent(Connection connection, OperationPolicyData policyData)\n-            throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY;\n-        String policyUUID = UUID.randomUUID().toString();\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyUUID);\n-        statement.setString(2, policySpecification.getName());\n-        statement.setString(3, policySpecification.getDisplayName());\n-        statement.setString(4, policySpecification.getDescription());\n-        statement.setString(5, policySpecification.getApplicableFlows().toString());\n-        statement.setString(6, policySpecification.getSupportedGateways().toString());\n-        statement.setString(7, policySpecification.getSupportedApiTypes().toString());\n-        statement.setBinaryStream(8,\n-                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n-        statement.setString(9, policyData.getOrganization());\n-        statement.setString(10, policySpecification.getCategory().toString());\n-        statement.setBoolean(11, policySpecification.isMultipleAllowed());\n-        statement.setString(12, policyData.getMd5Hash());\n-        statement.executeUpdate();\n-        statement.close();\n-\n-        if (policyData.getSynapsePolicyDefinition() != null) {\n-            addOperationPolicyDefinition(connection, policyUUID, policyData.getSynapsePolicyDefinition());\n-        }\n-        if (policyData.getCcPolicyDefinition() != null) {\n-            addOperationPolicyDefinition(connection, policyUUID, policyData.getCcPolicyDefinition());\n-        }\n-\n-        return policyUUID;\n-    }\n-\n-    /**\n-     * Update an existing operation policy\n-     *\n-     * @param policyId   Shared policy UUID\n-     * @param policyData Updated policy definition\n-     * @throws APIManagementException\n-     */\n-    public void updateOperationPolicy(String policyId, OperationPolicyData policyData)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            connection.setAutoCommit(false);\n-            updateOperationPolicy(connection, policyId, policyData);\n-            connection.commit();\n-        } catch (SQLException e) {\n-            handleException(\"Failed to update the operation policy with ID \" + policyId, e);\n-        }\n-    }\n-\n-    /**\n-     * Update an existing operation policy\n-     *\n-     * @param connection DB connection\n-     * @param policyId   Shared policy UUID\n-     * @param policyData Updated policy definition\n-     * @throws SQLException\n-     */\n-    private void updateOperationPolicy(Connection connection, String policyId, OperationPolicyData policyData)\n-            throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = policyData.getSpecification();\n-        PreparedStatement statement = connection.prepareStatement(\n-                SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_CONTENT);\n-\n-        statement.setString(1, policySpecification.getName());\n-        statement.setString(2, policySpecification.getDisplayName());\n-        statement.setString(3, policySpecification.getDescription());\n-        statement.setString(4, policySpecification.getApplicableFlows().toString());\n-        statement.setString(5, policySpecification.getSupportedGateways().toString());\n-        statement.setString(6, policySpecification.getSupportedApiTypes().toString());\n-        statement.setBinaryStream(7,\n-                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n-        statement.setString(8, policyData.getOrganization());\n-        statement.setString(9, policySpecification.getCategory().toString());\n-        statement.setBoolean(10, policySpecification.isMultipleAllowed());\n-        statement.setString(11, policyData.getMd5Hash());\n-        statement.setString(12, policyId);\n-        statement.executeUpdate();\n-        statement.close();\n-\n-        if (policyData.getSynapsePolicyDefinition() != null) {\n-            updateOperationPolicyDefinition(connection, policyId, policyData.getSynapsePolicyDefinition());\n-        }\n-        if (policyData.getCcPolicyDefinition() != null) {\n-            updateOperationPolicyDefinition(connection, policyId, policyData.getCcPolicyDefinition());\n-        }\n-\n-    }\n-\n-    /**\n-     * Delete an operation policy by providing the policy UUID\n-     *\n-     * @param policyId UUID of the policy to be deleted\n-     * @return True if deleted successfully\n-     * @throws APIManagementException\n-     */\n-    public void deleteOperationPolicyByPolicyId(String policyId) throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            deleteOperationPolicyByPolicyId(connection, policyId);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to delete operation policy \" + policyId, e);\n-        }\n-    }\n-\n-    private void deleteOperationPolicyByPolicyId(Connection connection, String policyId) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.execute();\n-        statement.close();\n-    }\n-\n-    /**\n-     * Get the set of URI templates that have Operation policies\n-     *\n-     * @param apiUUID Unique Identifier of API\n-     * @return URITemplate set\n-     * @throws APIManagementException\n-     */\n-    public Set<URITemplate> getURITemplatesWithOperationPolicies(String apiUUID) throws APIManagementException {\n-\n-        String query;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(apiUUID);\n-\n-        if (apiRevision == null) {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-        }\n-\n-        Map<String, URITemplate> uriTemplates = new HashMap<>();\n-        Set<URITemplate> uriTemplateList = new HashSet<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement prepStmt = connection.prepareStatement(query)) {\n-            if (apiRevision == null) {\n-                int apiId = getAPIID(apiUUID, connection);\n-                prepStmt.setInt(1, apiId);\n-            } else {\n-                int apiId = getAPIID(apiRevision.getApiUUID(), connection);\n-                prepStmt.setInt(1, apiId);\n-                prepStmt.setString(2, apiRevision.getRevisionUUID());\n-            }\n-            try (ResultSet rs = prepStmt.executeQuery()) {\n-                URITemplate uriTemplate;\n-                while (rs.next()) {\n-                    String httpMethod = rs.getString(\"HTTP_METHOD\");\n-                    String urlPattern = rs.getString(\"URL_PATTERN\");\n-                    String urlTemplateKey = httpMethod + \":\" + urlPattern;\n-                    if (!uriTemplates.containsKey(urlTemplateKey)) {\n-                        uriTemplate = new URITemplate();\n-                    } else {\n-                        uriTemplate = uriTemplates.get(urlTemplateKey);\n-                    }\n-                    OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                    uriTemplate.addOperationPolicy(operationPolicy);\n-                    uriTemplate.setHTTPVerb(httpMethod);\n-                    uriTemplate.setUriTemplate(urlPattern);\n-                    uriTemplate.setId(rs.getInt(\"URL_MAPPING_ID\"));\n-                    uriTemplates.put(urlTemplateKey, uriTemplate);\n-                }\n-            }\n-            uriTemplateList.addAll(uriTemplates.values());\n-        } catch (SQLException e) {\n-            handleException(\"Error while fetching URI templates with operation policies for \" + apiUUID, e);\n-        }\n-        return uriTemplateList;\n-    }\n-\n-    /**\n-     * Get operation polycies attached to the resource identified by the url mapping ID\n-     *\n-     * @param urlMappingId URL Mapping ID of the resource\n-     * @return\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private List<OperationPolicy> getOperationPoliciesOfURITemplate(int urlMappingId)\n-            throws SQLException, APIManagementException {\n-\n-        List<OperationPolicy> operationPolicies = new ArrayList<>();\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(\n-                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_BY_URI_TEMPLATE_ID)) {\n-            ps.setInt(1, urlMappingId);\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    OperationPolicy policy = populateOperationPolicyWithRS(rs);\n-                    operationPolicies.add(policy);\n-                }\n-            }\n-        }\n-        return operationPolicies;\n-    }\n-\n-    /**\n-     * Sets operation policies to uriTemplates map\n-     *\n-     * @param uuid         UUID of API or API Revision\n-     * @param uriTemplates URI Templates map with 'URL_PATTERN + HTTP_METHOD' as the map key\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setOperationPoliciesToURITemplatesMap(String uuid, Map<String, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        String currentApiUuid;\n-        String query;\n-        boolean isRevision = false;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n-        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n-            currentApiUuid = apiRevision.getApiUUID();\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-            isRevision = true;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-            currentApiUuid = uuid;\n-        }\n-\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(query)) {\n-            int apiId = getAPIID(currentApiUuid);\n-            ps.setInt(1, apiId);\n-            if (isRevision) {\n-                ps.setString(2, uuid);\n-            }\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(key);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets operation policies to uriTemplates map\n-     *\n-     * @param uuid         UUID of API or API Revision\n-     * @param uriTemplates URI Templates map with URL_MAPPING_ID as the map key\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setOperationPolicies(String uuid, Map<Integer, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        String currentApiUuid;\n-        String query;\n-        boolean isRevision = false;\n-        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n-        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n-            currentApiUuid = apiRevision.getApiUUID();\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n-            isRevision = true;\n-        } else {\n-            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n-            currentApiUuid = uuid;\n-        }\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(query)) {\n-            int apiId = getAPIID(currentApiUuid);\n-            ps.setInt(1, apiId);\n-            if (isRevision) {\n-                ps.setString(2, uuid);\n-            }\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    int uriTemplateId = rs.getInt(\"URL_MAPPING_ID\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(uriTemplateId);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Populates operation policy mappings in the API Product URITemplate map\n-     *\n-     * @param productRevisionId Product Revision ID\n-     * @param uriTemplates      Map of URI Templates\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     */\n-    private void setAPIProductOperationPoliciesToURITemplatesMap(String productRevisionId,\n-                                                                 Map<String, URITemplate> uriTemplates)\n-            throws SQLException, APIManagementException {\n-\n-        try (Connection conn = APIMgtDBUtil.getConnection();\n-             PreparedStatement ps = conn.prepareStatement(\n-                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_PER_API_PRODUCT_SQL)) {\n-            ps.setString(1, productRevisionId);\n-            try (ResultSet rs = ps.executeQuery()) {\n-                while (rs.next()) {\n-                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n-\n-                    URITemplate uriTemplate = uriTemplates.get(key);\n-                    if (uriTemplate != null) {\n-                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n-                        uriTemplate.addOperationPolicy(operationPolicy);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Clone an operation policy to the API. This method is used to clone policy to a newly created api version.\n-     * Cloning a common policy to API.\n-     * Cloning a dependent policy of a product\n-     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n-     *\n-     * @param apiUUID      UUID of the API\n-     * @param operationPolicyData\n-     * @return cloned policyID\n-     * @throws APIManagementException\n-     **/\n-    public String cloneOperationPolicy(String apiUUID, OperationPolicyData operationPolicyData)\n-            throws APIManagementException {\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            try {\n-                connection.setAutoCommit(false);\n-                String policyId = addAPISpecificOperationPolicy(connection, apiUUID, null, operationPolicyData, operationPolicyData.getClonedCommonPolicyId());\n-                connection.commit();\n-                return policyId;\n-            } catch (SQLException e) {\n-                connection.rollback();\n-                throw e;\n-            }\n-        } catch (SQLException e) {\n-            throw new APIManagementException(\"Error while cloning Operation policies\", e);\n-        }\n-    }\n-\n-    /**\n-     * Clone an operation policy to the API. This method is used in two flows.\n-     * Cloning a common policy to API.\n-     * Cloning a dependent policy of a product\n-     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n-     *\n-     * @param connection   DB connection\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param apiUUID      UUID of the API\n-     * @param revisionUUID UUID of the revision\n-     * @return cloned policyID\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private String cloneOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID)\n-            throws APIManagementException, SQLException {\n-\n-        OperationPolicyData policyData = getOperationPolicyByPolicyID(connection, policyId, true);\n-        if (policyData != null) {\n-            // If we are taking a clone from common policy, common policy's Id is used as the CLONED_POLICY_ID.\n-            // If we are cloning for an API Product, dependent APIs' id is used.\n-            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, policyId);\n-        } else {\n-            throw new APIManagementException(\"Cannot clone policy with ID \" + policyId + \" as it does not exists.\");\n-        }\n-    }\n-\n-    /**\n-     * This method is used in the creating a revision for API and API product. This will create a new API specific policy\n-     * with API UUID and revision UUID.\n-     *\n-     * @param connection   DB connection\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param apiUUID      UUID of the API\n-     * @param revisionUUID UUID of the revision\n-     * @return cloned policyID\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private String revisionOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID,\n-                                           String organization)\n-            throws APIManagementException, SQLException {\n-\n-        OperationPolicyData policyData = getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID,\n-                organization, true);\n-        // Since we import all the policies to API at API update, getting the policy from API specific policy list is enough\n-        if (policyData != null) {\n-            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData,\n-                    policyData.getClonedCommonPolicyId());\n-        } else {\n-            throw new APIManagementException(\"Cannot create a revision of policy with ID \" + policyId\n-                    + \" as it does not exists.\");\n-        }\n-    }\n-\n-    /**\n-     * This method is used the restore flow. At the restore, apart from the policy details, CLONED_POLICY_ID column\n-     * too can change and that needs to be updated.\n-     *\n-     * @param connection DB connection\n-     * @param policyId   Original policy's ID that needs to be cloned\n-     * @param policyData Updated policy data\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     **/\n-    private void updateAPISpecificOperationPolicyWithClonedPolicyId(Connection connection, String policyId,\n-                                                                    OperationPolicyData policyData)\n-            throws SQLException {\n-\n-        if (policyData.getClonedCommonPolicyId() != null) {\n-            PreparedStatement statement = connection.prepareStatement(\n-                    SQLConstants.OperationPolicyConstants.UPDATE_API_OPERATION_POLICY_BY_POLICY_ID);\n-            statement.setString(1, policyData.getClonedCommonPolicyId());\n-            statement.executeUpdate();\n-            statement.close();\n-        }\n-        updateOperationPolicy(connection, policyId, policyData);\n-    }\n-\n-    /**\n-     * This method is used to restore an API specific operation policy revision.\n-     *\n-     * @param connection   DB connection\n-     * @param apiUUID      UUID of the API\n-     * @param policyId     Original policy's ID that needs to be cloned\n-     * @param revisionId   The revision number\n-     * @param organization Organization name\n-     * @throws SQLException\n-     * @throws APIManagementException\n-     **/\n-    private String restoreOperationPolicyRevision(Connection connection, String apiUUID, String policyId,\n-                                                  int revisionId,\n-                                                  String organization) throws SQLException, APIManagementException {\n-\n-        OperationPolicyData revisionedPolicy = getAPISpecificOperationPolicyByPolicyID(connection, policyId,\n-                apiUUID, organization, true);\n-        String restoredPolicyId = null;\n-        if (revisionedPolicy != null) {\n-            // First check whether there exists a API specific policy for same policy name with revision uuid null\n-            // This is the state where we record the policies applied in the working copy.\n-            OperationPolicyData apiSpecificPolicy = getAPISpecificOperationPolicyByPolicyName(connection,\n-                    revisionedPolicy.getSpecification().getName(), revisionedPolicy.getApiUUID(), null,\n-                    organization, false);\n-            if (apiSpecificPolicy != null) {\n-                if (apiSpecificPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Matching API specific operation policy found for the revisioned policy and \" +\n-                                \"MD5 hashes match\");\n-                    }\n-\n-                } else {\n-                    updateAPISpecificOperationPolicyWithClonedPolicyId(connection, apiSpecificPolicy.getPolicyId(),\n-                            revisionedPolicy);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Even though a matching API specific operation policy found for name,\"\n-                                + \" MD5 hashes does not match. Policy \" + apiSpecificPolicy.getPolicyId()\n-                                + \" has been updated from the revision.\");\n-                    }\n-                }\n-                restoredPolicyId = apiSpecificPolicy.getPolicyId();\n-            } else {\n-                if (revisionedPolicy.isClonedPolicy()) {\n-                    // Check for a common operation policy only if it is a cloned policy.\n-                    OperationPolicyData commonPolicy = getCommonOperationPolicyByPolicyID(connection,\n-                            revisionedPolicy.getClonedCommonPolicyId(), organization, false);\n-                    if (commonPolicy != null) {\n-                        if (commonPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\"Matching common operation policy found. MD5 hash match\");\n-                            }\n-                            //This means the common policy is same with our revision. A clone is created and original\n-                            // common policy ID is referenced as the ClonedCommonPolicyId\n-                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n-                                    revisionedPolicy, revisionedPolicy.getClonedCommonPolicyId());\n-                        } else {\n-                            // This means the common policy is updated since we created the revision.\n-                            // we have to create a clone and since policy is different, we can't refer the original common\n-                            // policy as ClonedCommonPolicyId. This should be a new API specific policy\n-                            revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n-                                    + \"_restored-\" + revisionId);\n-                            revisionedPolicy.getSpecification()\n-                                    .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n-                                            + \" Restored from revision \" + revisionId);\n-                            revisionedPolicy.setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy));\n-                            revisionedPolicy.setRevisionUUID(null);\n-                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n-                                    revisionedPolicy, null);\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\n-                                        \"An updated matching common operation policy found. A new API specific operation \" +\n-                                                \"policy created by the display name \" +\n-                                                revisionedPolicy.getSpecification().getName());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    // This means this is a completely new policy and we don't have any reference of a previous state in\n-                    // working copy. A new API specific policy will be created.\n-                    revisionedPolicy.setRevisionUUID(null);\n-                    restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"No matching operation policy found. A new API specific operation \" +\n-                                \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n-                    }\n-                }\n-            }\n-        } else {\n-            throw new APIManagementException(\"A revisioned operation policy not found for \" + policyId);\n-        }\n-        return restoredPolicyId;\n-    }\n-\n-    /**\n-     * Retrieve an operation policy by providing the policy uuid\n-     *\n-     * @param connection             DB connection\n-     * @param policyId               Policy UUID\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws SQLException\n-     */\n-    private OperationPolicyData getOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                             boolean isWithPolicyDefinition) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_ID;\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setPolicyId(policyId);\n-            policyData.setOrganization(rs.getString(\"ORGANIZATION\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyId, policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    /**\n-     * Get the API specific operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n-     * table and AM_API_OPERATION_POLICY table from API UUID. Policy id might be available, but if it is not referenced in the\n-     * APIS table, this will return null.\n-     * The returned policy data can be either an API only policy, cloned common policy to API or a revisioned API specific policy\n-     *\n-     * @param policyId               Policy UUID\n-     * @param apiUUID                UUID of the API\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getAPISpecificOperationPolicyByPolicyID(String policyId, String apiUUID,\n-                                                                       String organization,\n-                                                                       boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID, organization,\n-                    isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the API specific operation policy for id \" + policyId + \" from API \"\n-                    + apiUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getAPISpecificOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                                        String apiUUID,\n-                                                                        String organization,\n-                                                                        boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery =\n-                SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_ID;\n-        OperationPolicyData policyData = null;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, organization);\n-        statement.setString(3, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setPolicyId(policyId);\n-            policyData.setApiUUID(apiUUID);\n-            policyData.setOrganization(organization);\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n-            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyId, policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    private List<OperationPolicyDefinition> getPolicyDefinitionForPolicyId(Connection connection, String policyId)\n-            throws SQLException {\n-\n-        List<OperationPolicyDefinition> operationPolicyDefinitions = new ArrayList<>();\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_DEFINITION_FROM_POLICY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            String policyDefinitionString;\n-            OperationPolicyDefinition policyDefinition = new OperationPolicyDefinition();\n-\n-            try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n-                policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n-                policyDefinition.setContent(policyDefinitionString);\n-                policyDefinition.setGatewayType(\n-                        OperationPolicyDefinition.GatewayType.valueOf(rs.getString(\"GATEWAY_TYPE\")));\n-                policyDefinition.setMd5Hash(rs.getString(\"DEFINITION_MD5\"));\n-\n-                operationPolicyDefinitions.add(policyDefinition);\n-            } catch (IOException e) {\n-                log.error(\"Error while converting policy definition for the policy\", e);\n-            }\n-\n-        }\n-        rs.close();\n-        statement.close();\n-        return operationPolicyDefinitions;\n-    }\n-\n-\n-    public void populatePolicyDefinitions(Connection connection, String policyId, OperationPolicyData policyData)\n-            throws SQLException {\n-        if (policyId != null && !policyId.isEmpty()) {\n-            List<OperationPolicyDefinition> policyDefinitions = getPolicyDefinitionForPolicyId(connection, policyId);\n-            for (OperationPolicyDefinition policyDefinition : policyDefinitions) {\n-                if (OperationPolicyDefinition.GatewayType.Synapse.equals(policyDefinition.getGatewayType())) {\n-                    policyData.setSynapsePolicyDefinition(policyDefinition);\n-                } else if (OperationPolicyDefinition.GatewayType.ChoreoConnect.equals(policyDefinition.getGatewayType())) {\n-                    policyData.setCcPolicyDefinition(policyDefinition);\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    private void addOperationPolicyDefinition (Connection connection, String policyId,\n-                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY_DEFINITION;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, policyDefinition.getGatewayType().toString());\n-        statement.setString(3, policyDefinition.getMd5Hash());\n-        statement.setBinaryStream(4, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n-        statement.executeUpdate();\n-        statement.close();\n-    }\n-\n-\n-    private void updateOperationPolicyDefinition(Connection connection, String policyId,\n-                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_DEFINITION;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyDefinition.getMd5Hash());\n-        statement.setBinaryStream(2, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n-        statement.setString(3, policyId);\n-        statement.setString(4, policyDefinition.getGatewayType().toString());\n-        statement.executeUpdate();\n-        statement.close();\n-    }\n-\n-    /**\n-     * Get the common operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n-     * table and AM_COMMON_OPERATION_POLICY table. Policy id might be available, but if it is not referenced in the\n-     * common policies table, this will return null.\n-     *\n-     * @param policyId               Policy UUID\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getCommonOperationPolicyByPolicyID(String policyId, String organization,\n-                                                                  boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getCommonOperationPolicyByPolicyID(connection, policyId, organization, isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the operation policy for id \" + policyId, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getCommonOperationPolicyByPolicyID(Connection connection, String policyId,\n-                                                                   String organization,\n-                                                                   boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery =\n-                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyId);\n-        statement.setString(2, organization);\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setPolicyId(policyId);\n-            policyData.setOrganization(organization);\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            populatePolicyDefinitions(connection, policyId, policyData);\n-        }\n-\n-        return policyData;\n-    }\n-\n-    /**\n-     * Retrieve a common operation policy by providing the policy name and organization\n-     *\n-     * @param policyName             Policy name\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getCommonOperationPolicyByPolicyName(String policyName, String organization,\n-                                                                    boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getCommonOperationPolicyByPolicyName(connection, policyName, organization, isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get common operation policy for name \" + policyName + \"for organization \"\n-                    + organization, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getCommonOperationPolicyByPolicyName(Connection connection, String policyName,\n-                                                                     String tenantDomain,\n-                                                                     boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery =\n-                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_FROM_POLICY_NAME;\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyName);\n-        statement.setString(2, tenantDomain);\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setOrganization(tenantDomain);\n-            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-        rs.close();\n-        statement.close();\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    /**\n-     * Retrieve an API Specific operation policy by providing the policy name. In order to narrow down the specific policy\n-     * this needs policy name, apiUUID, api revision UUID (if exists) and organization. If revision UUID is not provided,\n-     * that means the policy is not a revisioned policy.\n-     *\n-     * @param policyName             Policy name\n-     * @param apiUUID                UUID of API\n-     * @param revisionUUID           UUID of API revision\n-     * @param organization           Organization name\n-     * @param isWithPolicyDefinition Include the policy definition to the output or not\n-     * @return operation policy\n-     * @throws APIManagementException\n-     */\n-    public OperationPolicyData getAPISpecificOperationPolicyByPolicyName(String policyName, String apiUUID,\n-                                                                         String revisionUUID, String organization,\n-                                                                         boolean isWithPolicyDefinition)\n-            throws APIManagementException {\n-\n-        try (Connection connection = APIMgtDBUtil.getConnection()) {\n-            return getAPISpecificOperationPolicyByPolicyName(connection, policyName, apiUUID, revisionUUID,\n-                    organization,\n-                    isWithPolicyDefinition);\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get API specific operation policy for name \" + policyName + \" with API UUID \"\n-                    + apiUUID + \" revision UUID \" + revisionUUID, e);\n-        }\n-        return null;\n-    }\n-\n-    private OperationPolicyData getAPISpecificOperationPolicyByPolicyName(Connection connection,\n-                                                                          String policyName, String apiUUID,\n-                                                                          String revisionUUID,\n-                                                                          String tenantDomain,\n-                                                                          boolean isWithPolicyDefinition)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_NAME;\n-        if (revisionUUID != null) {\n-            dbQuery += \" AND AOP.REVISION_UUID = ?\";\n-        } else {\n-            dbQuery += \" AND AOP.REVISION_UUID IS NULL\";\n-        }\n-\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, policyName);\n-        statement.setString(2, tenantDomain);\n-        statement.setString(3, apiUUID);\n-        if (revisionUUID != null) {\n-            statement.setString(4, revisionUUID);\n-        }\n-        ResultSet rs = statement.executeQuery();\n-        OperationPolicyData policyData = null;\n-        if (rs.next()) {\n-            policyData = new OperationPolicyData();\n-            policyData.setOrganization(tenantDomain);\n-            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-            policyData.setApiUUID(rs.getString(\"API_UUID\"));\n-            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n-            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n-            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-        }\n-\n-        if (isWithPolicyDefinition && policyData != null) {\n-            if (isWithPolicyDefinition && policyData != null) {\n-                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n-            }\n-        }\n-        return policyData;\n-    }\n-\n-    /**\n-     * Get the list of all operation policies. If the API UUID is provided, this will return all the operation policies\n-     * for that API. If not, it will return the common operation policies which are not bound to any API.\n-     * This list will include policy specification of each policy and policy ID. It will not contain the\n-     * policy definition as it is not useful for the operation.\n-     *\n-     * @param apiUUID      UUID of the API if exists. Null for common operation policies\n-     * @param organization Organization name\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    public List<OperationPolicyData> getLightWeightVersionOfAllOperationPolicies(String apiUUID,\n-                                                                                 String organization)\n-            throws APIManagementException {\n-\n-        String dbQuery;\n-        if (apiUUID != null) {\n-            dbQuery =\n-                    SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_OPERATION_POLICIES_WITHOUT_CLONED_POLICIES;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_COMMON_OPERATION_POLICIES;\n-        }\n-        List<OperationPolicyData> policyDataList = new ArrayList<>();\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-            statement.setString(1, organization);\n-            if (apiUUID != null) {\n-                statement.setString(2, apiUUID);\n-            }\n-            ResultSet rs = statement.executeQuery();\n-            while (rs.next()) {\n-                OperationPolicyData policyData = new OperationPolicyData();\n-                policyData.setOrganization(organization);\n-                policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n-                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n-                if (apiUUID != null) {\n-                    policyData.setApiUUID(apiUUID);\n-                }\n-                policyDataList.add(policyData);\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get all the operation policy for tenant \" + organization, e);\n-        }\n-        return policyDataList;\n-    }\n-\n-    public int getOperationPolicyCount(String organization) throws APIManagementException {\n-\n-        int count = -1;\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_THE_COUNT_OF_OPERATION_POLICIES_FOR_ORGANIZATION;\n-        try (Connection connection = APIMgtDBUtil.getConnection();\n-             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n-            statement.setString(1, organization);\n-            ResultSet rs = statement.executeQuery();\n-            if (rs.next()) {\n-                count = rs.getInt(\"POLICY_COUNT\");\n-            }\n-        } catch (SQLException e) {\n-            handleException(\"Failed to get the count of operation policies for organization \" + organization, e);\n-        }\n-        return count;\n-    }\n-\n-\n-\n-    /**\n-     * This method will return a list of all cloned policies for an API.\n-     *\n-     * @param connection DB connection\n-     * @param apiUUID    UUID of the API if exists. Null for common operation policies\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private Set<String> getAllClonedPolicyIdsForAPI(Connection connection, String apiUUID)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_CLONED_POLICIES_FOR_API;\n-        Set<String> policyIds = new HashSet<>();\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            policyIds.add(rs.getString(\"POLICY_UUID\"));\n-        }\n-        rs.close();\n-        statement.close();\n-        return policyIds;\n-    }\n-\n-    /**\n-     * This method will query AM_API_OPERATION_POLICY table from CLONED_POLICY_ID row for a matching policy ID\n-     * for the required API. This is useful to find the cloned API specific policy ID from a common policy.\n-     *\n-     * @param connection     DB connection\n-     * @param commonPolicyId Common policy ID\n-     * @param apiUUID        UUID of API\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private String getClonedPolicyIdForCommonPolicyId(Connection connection, String commonPolicyId, String apiUUID)\n-            throws SQLException {\n-\n-        String dbQuery = SQLConstants.OperationPolicyConstants.GET_CLONED_POLICY_ID_FOR_COMMON_POLICY_ID;\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, commonPolicyId);\n-        statement.setString(2, apiUUID);\n-        ResultSet rs = statement.executeQuery();\n-        String policyId = null;\n-        if (rs.next()) {\n-            policyId = rs.getString(\"POLICY_UUID\");\n-        }\n-        rs.close();\n-        statement.close();\n-        return policyId;\n-    }\n-\n-    /**\n-     * Delete all the API specific policies for a given API UUID. If revision UUID is provided, only the policies that\n-     * are revisioned will be deleted. This is used when we delete an API revision.\n-     * If revision id is null, all the API specific policies will be deleted. This is used in API deleting flow.\n-     *\n-     * @param connection   DB connection\n-     * @param apiUUID      UUID of API\n-     * @param revisionUUID Revision UUID\n-     * @return List of Operation Policies\n-     * @throws APIManagementException\n-     */\n-    private void deleteAllAPISpecificOperationPoliciesByAPIUUID(Connection connection, String apiUUID,\n-                                                                String revisionUUID)\n-            throws SQLException {\n-\n-        String dbQuery;\n-        if (revisionUUID != null) {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_REVISION_UUID;\n-        } else {\n-            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_API_ID;\n-        }\n-        PreparedStatement statement = connection.prepareStatement(dbQuery);\n-        statement.setString(1, apiUUID);\n-        if (revisionUUID != null) {\n-            statement.setString(2, revisionUUID);\n-        }\n-        ResultSet rs = statement.executeQuery();\n-        while (rs.next()) {\n-            String deleteQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n-            PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);\n-            deleteStatement.setString(1, rs.getString(\"POLICY_UUID\"));\n-            deleteStatement.execute();\n-            deleteStatement.close();\n-        }\n-        rs.close();\n-        statement.close();\n-    }\n-\n-    /**\n-     * When we apply a common policy to an operation, this policy will be cloned to the API at the backend. However, if\n-     * that policy is removed from the UI, this method is used to clean such unused policies that are imported,\n-     * but not used\n-     *\n-     * @param connection            DB connection\n-     * @param usedClonedPoliciesSet Currently used imported API specific policies set\n-     * @param apiUUID               UUID of the API\n-     * @throws SQLException\n-     */\n-    private void cleanUnusedClonedOperationPolicies(Connection connection, Set<String> usedClonedPoliciesSet,\n-                                                    String apiUUID)\n-            throws SQLException {\n-\n-        Set<String> allClonedPoliciesForAPI = getAllClonedPolicyIdsForAPI(connection, apiUUID);\n-        Set<String> policiesToDelete = allClonedPoliciesForAPI;\n-        policiesToDelete.removeAll(usedClonedPoliciesSet);\n-        for (String policyId : allClonedPoliciesForAPI) {\n-            deleteOperationPolicyByPolicyId(connection, policyId);\n-        }\n-    }\n-\n-    /**\n-     * This method will read the result set and populate OperationPolicy object, which later will be set to the URI template.\n-     * This object has the information regarding the policy allocation\n-     *\n-     * @param rs Result set\n-     * @return OperationPolicy object\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     */\n-    private OperationPolicy populateOperationPolicyWithRS(ResultSet rs) throws SQLException, APIManagementException {\n-\n-        OperationPolicy operationPolicy = new OperationPolicy();\n-        operationPolicy.setPolicyName(rs.getString(\"POLICY_NAME\"));\n-        operationPolicy.setPolicyId(rs.getString(\"POLICY_UUID\"));\n-        operationPolicy.setOrder(rs.getInt(\"POLICY_ORDER\"));\n-        operationPolicy.setDirection(rs.getString(\"DIRECTION\"));\n-        operationPolicy.setParameters(APIMgtDBUtil.convertJSONStringToMap(rs.getString(\"PARAMETERS\")));\n-        return operationPolicy;\n-    }\n-\n-    /**\n-     * This method will read the result set and populate OperationPolicySpecification object.\n-     *\n-     * @param rs Result set\n-     * @return OperationPolicySpecification object\n-     * @throws APIManagementException\n-     * @throws SQLException\n-     */\n-    private OperationPolicySpecification populatePolicySpecificationFromRS(ResultSet rs) throws SQLException {\n-\n-        OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n-        policySpecification.setName(rs.getString(\"POLICY_NAME\"));\n-        policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n-        policySpecification.setDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n-        policySpecification.setApplicableFlows(getListFromString(rs.getString(\"APPLICABLE_FLOWS\")));\n-        policySpecification.setSupportedApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n-        policySpecification.setSupportedGateways(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n-        policySpecification.setCategory(OperationPolicySpecification.PolicyCategory\n-                .valueOf(rs.getString(\"POLICY_CATEGORY\")));\n-        policySpecification.setMultipleAllowed(rs.getBoolean(\"MULTIPLE_ALLOWED\"));\n-        List<OperationPolicySpecAttribute> policySpecAttributes = null;\n-\n-        try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n-            String policyParametersString = IOUtils.toString(policyParametersStream);\n-            policySpecAttributes = new Gson().fromJson(policyParametersString,\n-                    new TypeToken<List<OperationPolicySpecAttribute>>() {\n-                    }.getType());\n-        } catch (IOException e) {\n-            log.error(\"Error while converting policy specification attributes for the policy \"\n-                    + policySpecification.getName(), e);\n-        }\n-        policySpecification.setPolicyAttributes(policySpecAttributes);\n-        return policySpecification;\n-    }\n-\n-\n-    /**\n-     * Create a string list from a single string element by splitting from the comma\n-     *\n-     * @param stringElement String element\n-     * @return list of strings\n-     */\n-    private List<String> getListFromString(String stringElement) {\n-\n-        List<String> list = null;\n-        if (!stringElement.isEmpty()) {\n-            list = Arrays.asList(\n-                    stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n-        }\n-        return list;\n-    }\n-\n }\n", "next_change": {"commit": "7716e365de7b207dda7c209a9d97aba8dd863328", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex a6106fbf8c4..7c294a971ce 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -17683,4 +18016,1240 @@ public class ApiMgtDAO {\n             this.subscriptionStatus = subscriptionStatus;\n         }\n     }\n+\n+    /**\n+     * Operation policy implementation\n+     *\n+     */\n+\n+    /**\n+     * Add a new common operation policy to the database. This will first add the operation policy content to the\n+     * AM_OPERATION_POLICY table and another entry to AM_COMMON_OPERATION_POLICY table.\n+     *\n+     * @param policyData Operation policy data.\n+     * @return UUID of the newly created shared policy\n+     * @throws APIManagementException\n+     */\n+    public String addCommonOperationPolicy(OperationPolicyData policyData) throws APIManagementException {\n+\n+        String policyUUID = null;\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                policyUUID = addOperationPolicyContent(connection, policyData);\n+\n+                String dbQuery = SQLConstants.OperationPolicyConstants.ADD_COMMON_OPERATION_POLICY;\n+                PreparedStatement statement = connection.prepareStatement(dbQuery);\n+                statement.setString(1, policyUUID);\n+                statement.executeUpdate();\n+                statement.close();\n+\n+                connection.commit();\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add common operation policy \" + policySpecification.getName(), e);\n+        }\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * Add a new API specific operation policy to the database\n+     *\n+     * @param apiUUID      Unique Identifier of API\n+     * @param revisionUUID Unique Identifier of API revision\n+     * @param policyData   Unique Identifier of API\n+     * @return UUID of the newly created shared policy\n+     * @throws APIManagementException\n+     */\n+    public String addAPISpecificOperationPolicy(String apiUUID, String revisionUUID,\n+                                                OperationPolicyData policyData)\n+            throws APIManagementException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                String policyID = addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, null);\n+                connection.commit();\n+                return policyID;\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n+                        + \" for API \" + apiUUID, e);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to add API specific operation policy \" + policySpecification.getName()\n+                    + \" for API \" + apiUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private String addAPISpecificOperationPolicy(Connection connection, String apiUUID, String revisionUUID,\n+                                                 OperationPolicyData policyData, String clonedPolicyId)\n+            throws SQLException {\n+\n+        String policyUUID = addOperationPolicyContent(connection, policyData);\n+\n+        String dbQuery;\n+        if (revisionUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY_WITH_REVISION;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.ADD_API_SPECIFIC_OPERATION_POLICY;\n+        }\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyUUID);\n+        statement.setString(2, apiUUID);\n+        statement.setString(3, clonedPolicyId);\n+        if (revisionUUID != null) {\n+            statement.setString(4, revisionUUID);\n+        }\n+        statement.executeUpdate();\n+        statement.close();\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * This method is used to populate AM_OPERATION_POLICY table. This will return the policy ID.\n+     *\n+     * @param connection DB connection\n+     * @param policyData Unique Identifier of API\n+     * @return UUID of the newly created policy\n+     * @throws SQLException\n+     */\n+    private String addOperationPolicyContent(Connection connection, OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY;\n+        String policyUUID = UUID.randomUUID().toString();\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyUUID);\n+        statement.setString(2, policySpecification.getName());\n+        statement.setString(3, policySpecification.getDisplayName());\n+        statement.setString(4, policySpecification.getDescription());\n+        statement.setString(5, policySpecification.getApplicableFlows().toString());\n+        statement.setString(6, policySpecification.getSupportedGateways().toString());\n+        statement.setString(7, policySpecification.getSupportedApiTypes().toString());\n+        statement.setBinaryStream(8,\n+                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n+        statement.setString(9, policyData.getOrganization());\n+        statement.setString(10, policySpecification.getCategory().toString());\n+        statement.setBoolean(11, policySpecification.isMultipleAllowed());\n+        statement.setString(12, policyData.getMd5Hash());\n+        statement.executeUpdate();\n+        statement.close();\n+\n+        if (policyData.getSynapsePolicyDefinition() != null) {\n+            addOperationPolicyDefinition(connection, policyUUID, policyData.getSynapsePolicyDefinition());\n+        }\n+        if (policyData.getCcPolicyDefinition() != null) {\n+            addOperationPolicyDefinition(connection, policyUUID, policyData.getCcPolicyDefinition());\n+        }\n+\n+        return policyUUID;\n+    }\n+\n+    /**\n+     * Update an existing operation policy\n+     *\n+     * @param policyId   Shared policy UUID\n+     * @param policyData Updated policy definition\n+     * @throws APIManagementException\n+     */\n+    public void updateOperationPolicy(String policyId, OperationPolicyData policyData)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            connection.setAutoCommit(false);\n+            updateOperationPolicy(connection, policyId, policyData);\n+            connection.commit();\n+        } catch (SQLException e) {\n+            handleException(\"Failed to update the operation policy with ID \" + policyId, e);\n+        }\n+    }\n+\n+    /**\n+     * Update an existing operation policy\n+     *\n+     * @param connection DB connection\n+     * @param policyId   Shared policy UUID\n+     * @param policyData Updated policy definition\n+     * @throws SQLException\n+     */\n+    private void updateOperationPolicy(Connection connection, String policyId, OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = policyData.getSpecification();\n+        PreparedStatement statement = connection.prepareStatement(\n+                SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_CONTENT);\n+\n+        statement.setString(1, policySpecification.getName());\n+        statement.setString(2, policySpecification.getDisplayName());\n+        statement.setString(3, policySpecification.getDescription());\n+        statement.setString(4, policySpecification.getApplicableFlows().toString());\n+        statement.setString(5, policySpecification.getSupportedGateways().toString());\n+        statement.setString(6, policySpecification.getSupportedApiTypes().toString());\n+        statement.setBinaryStream(7,\n+                new ByteArrayInputStream(APIUtil.getPolicyAttributesAsString(policySpecification).getBytes()));\n+        statement.setString(8, policyData.getOrganization());\n+        statement.setString(9, policySpecification.getCategory().toString());\n+        statement.setBoolean(10, policySpecification.isMultipleAllowed());\n+        statement.setString(11, policyData.getMd5Hash());\n+        statement.setString(12, policyId);\n+        statement.executeUpdate();\n+        statement.close();\n+\n+        if (policyData.getSynapsePolicyDefinition() != null) {\n+            updateOperationPolicyDefinition(connection, policyId, policyData.getSynapsePolicyDefinition());\n+        }\n+        if (policyData.getCcPolicyDefinition() != null) {\n+            updateOperationPolicyDefinition(connection, policyId, policyData.getCcPolicyDefinition());\n+        }\n+\n+    }\n+\n+    /**\n+     * Delete an operation policy by providing the policy UUID\n+     *\n+     * @param policyId UUID of the policy to be deleted\n+     * @return True if deleted successfully\n+     * @throws APIManagementException\n+     */\n+    public void deleteOperationPolicyByPolicyId(String policyId) throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            deleteOperationPolicyByPolicyId(connection, policyId);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to delete operation policy \" + policyId, e);\n+        }\n+    }\n+\n+    private void deleteOperationPolicyByPolicyId(Connection connection, String policyId) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.execute();\n+        statement.close();\n+    }\n+\n+    /**\n+     * Get the set of URI templates that have Operation policies\n+     *\n+     * @param apiUUID Unique Identifier of API\n+     * @return URITemplate set\n+     * @throws APIManagementException\n+     */\n+    public Set<URITemplate> getURITemplatesWithOperationPolicies(String apiUUID) throws APIManagementException {\n+\n+        String query;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(apiUUID);\n+\n+        if (apiRevision == null) {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+        }\n+\n+        Map<String, URITemplate> uriTemplates = new HashMap<>();\n+        Set<URITemplate> uriTemplateList = new HashSet<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement prepStmt = connection.prepareStatement(query)) {\n+            if (apiRevision == null) {\n+                int apiId = getAPIID(apiUUID, connection);\n+                prepStmt.setInt(1, apiId);\n+            } else {\n+                int apiId = getAPIID(apiRevision.getApiUUID(), connection);\n+                prepStmt.setInt(1, apiId);\n+                prepStmt.setString(2, apiRevision.getRevisionUUID());\n+            }\n+            try (ResultSet rs = prepStmt.executeQuery()) {\n+                URITemplate uriTemplate;\n+                while (rs.next()) {\n+                    String httpMethod = rs.getString(\"HTTP_METHOD\");\n+                    String urlPattern = rs.getString(\"URL_PATTERN\");\n+                    String urlTemplateKey = httpMethod + \":\" + urlPattern;\n+                    if (!uriTemplates.containsKey(urlTemplateKey)) {\n+                        uriTemplate = new URITemplate();\n+                    } else {\n+                        uriTemplate = uriTemplates.get(urlTemplateKey);\n+                    }\n+                    OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                    uriTemplate.addOperationPolicy(operationPolicy);\n+                    uriTemplate.setHTTPVerb(httpMethod);\n+                    uriTemplate.setUriTemplate(urlPattern);\n+                    uriTemplate.setId(rs.getInt(\"URL_MAPPING_ID\"));\n+                    uriTemplates.put(urlTemplateKey, uriTemplate);\n+                }\n+            }\n+            uriTemplateList.addAll(uriTemplates.values());\n+        } catch (SQLException e) {\n+            handleException(\"Error while fetching URI templates with operation policies for \" + apiUUID, e);\n+        }\n+        return uriTemplateList;\n+    }\n+\n+    /**\n+     * Get operation polycies attached to the resource identified by the url mapping ID\n+     *\n+     * @param urlMappingId URL Mapping ID of the resource\n+     * @return\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private List<OperationPolicy> getOperationPoliciesOfURITemplate(int urlMappingId)\n+            throws SQLException, APIManagementException {\n+\n+        List<OperationPolicy> operationPolicies = new ArrayList<>();\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(\n+                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_BY_URI_TEMPLATE_ID)) {\n+            ps.setInt(1, urlMappingId);\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    OperationPolicy policy = populateOperationPolicyWithRS(rs);\n+                    operationPolicies.add(policy);\n+                }\n+            }\n+        }\n+        return operationPolicies;\n+    }\n+\n+    /**\n+     * Sets operation policies to uriTemplates map\n+     *\n+     * @param uuid         UUID of API or API Revision\n+     * @param uriTemplates URI Templates map with 'URL_PATTERN + HTTP_METHOD' as the map key\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setOperationPoliciesToURITemplatesMap(String uuid, Map<String, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        String currentApiUuid;\n+        String query;\n+        boolean isRevision = false;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n+        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n+            currentApiUuid = apiRevision.getApiUUID();\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+            isRevision = true;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+            currentApiUuid = uuid;\n+        }\n+\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(query)) {\n+            int apiId = getAPIID(currentApiUuid);\n+            ps.setInt(1, apiId);\n+            if (isRevision) {\n+                ps.setString(2, uuid);\n+            }\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(key);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets operation policies to uriTemplates map\n+     *\n+     * @param uuid         UUID of API or API Revision\n+     * @param uriTemplates URI Templates map with URL_MAPPING_ID as the map key\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setOperationPolicies(String uuid, Map<Integer, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        String currentApiUuid;\n+        String query;\n+        boolean isRevision = false;\n+        APIRevision apiRevision = checkAPIUUIDIsARevisionUUID(uuid);\n+        if (apiRevision != null && apiRevision.getApiUUID() != null) {\n+            currentApiUuid = apiRevision.getApiUUID();\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_FOR_API_REVISION_SQL;\n+            isRevision = true;\n+        } else {\n+            query = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_OF_API_SQL;\n+            currentApiUuid = uuid;\n+        }\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(query)) {\n+            int apiId = getAPIID(currentApiUuid);\n+            ps.setInt(1, apiId);\n+            if (isRevision) {\n+                ps.setString(2, uuid);\n+            }\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    int uriTemplateId = rs.getInt(\"URL_MAPPING_ID\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(uriTemplateId);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Populates operation policy mappings in the API Product URITemplate map\n+     *\n+     * @param productRevisionId Product Revision ID\n+     * @param uriTemplates      Map of URI Templates\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     */\n+    private void setAPIProductOperationPoliciesToURITemplatesMap(String productRevisionId,\n+                                                                 Map<String, URITemplate> uriTemplates)\n+            throws SQLException, APIManagementException {\n+\n+        try (Connection conn = APIMgtDBUtil.getConnection();\n+             PreparedStatement ps = conn.prepareStatement(\n+                     SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICIES_PER_API_PRODUCT_SQL)) {\n+            ps.setString(1, productRevisionId);\n+            try (ResultSet rs = ps.executeQuery()) {\n+                while (rs.next()) {\n+                    String key = rs.getString(\"URL_PATTERN\") + rs.getString(\"HTTP_METHOD\");\n+\n+                    URITemplate uriTemplate = uriTemplates.get(key);\n+                    if (uriTemplate != null) {\n+                        OperationPolicy operationPolicy = populateOperationPolicyWithRS(rs);\n+                        uriTemplate.addOperationPolicy(operationPolicy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clone an operation policy to the API. This method is used to clone policy to a newly created api version.\n+     * Cloning a common policy to API.\n+     * Cloning a dependent policy of a product\n+     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n+     *\n+     * @param apiUUID      UUID of the API\n+     * @param operationPolicyData\n+     * @return cloned policyID\n+     * @throws APIManagementException\n+     **/\n+    public String cloneOperationPolicy(String apiUUID, OperationPolicyData operationPolicyData)\n+            throws APIManagementException {\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            try {\n+                connection.setAutoCommit(false);\n+                String policyId = addAPISpecificOperationPolicy(connection, apiUUID, null, operationPolicyData, operationPolicyData.getClonedCommonPolicyId());\n+                connection.commit();\n+                return policyId;\n+            } catch (SQLException e) {\n+                connection.rollback();\n+                throw e;\n+            }\n+        } catch (SQLException e) {\n+            throw new APIManagementException(\"Error while cloning Operation policies\", e);\n+        }\n+    }\n+\n+    /**\n+     * Clone an operation policy to the API. This method is used in two flows.\n+     * Cloning a common policy to API.\n+     * Cloning a dependent policy of a product\n+     * Each of these scenarios, original APIs' policy ID will be recorded as the cloned policy ID.\n+     *\n+     * @param connection   DB connection\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param apiUUID      UUID of the API\n+     * @param revisionUUID UUID of the revision\n+     * @return cloned policyID\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private String cloneOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID)\n+            throws APIManagementException, SQLException {\n+\n+        OperationPolicyData policyData = getOperationPolicyByPolicyID(connection, policyId, true);\n+        if (policyData != null) {\n+            // If we are taking a clone from common policy, common policy's Id is used as the CLONED_POLICY_ID.\n+            // If we are cloning for an API Product, dependent APIs' id is used.\n+            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData, policyId);\n+        } else {\n+            throw new APIManagementException(\"Cannot clone policy with ID \" + policyId + \" as it does not exists.\");\n+        }\n+    }\n+\n+    /**\n+     * This method is used in the creating a revision for API and API product. This will create a new API specific policy\n+     * with API UUID and revision UUID.\n+     *\n+     * @param connection   DB connection\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param apiUUID      UUID of the API\n+     * @param revisionUUID UUID of the revision\n+     * @return cloned policyID\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private String revisionOperationPolicy(Connection connection, String policyId, String apiUUID, String revisionUUID,\n+                                           String organization)\n+            throws APIManagementException, SQLException {\n+\n+        OperationPolicyData policyData = getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID,\n+                organization, true);\n+        // Since we import all the policies to API at API update, getting the policy from API specific policy list is enough\n+        if (policyData != null) {\n+            return addAPISpecificOperationPolicy(connection, apiUUID, revisionUUID, policyData,\n+                    policyData.getClonedCommonPolicyId());\n+        } else {\n+            throw new APIManagementException(\"Cannot create a revision of policy with ID \" + policyId\n+                    + \" as it does not exists.\");\n+        }\n+    }\n+\n+    /**\n+     * This method is used the restore flow. At the restore, apart from the policy details, CLONED_POLICY_ID column\n+     * too can change and that needs to be updated.\n+     *\n+     * @param connection DB connection\n+     * @param policyId   Original policy's ID that needs to be cloned\n+     * @param policyData Updated policy data\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     **/\n+    private void updateAPISpecificOperationPolicyWithClonedPolicyId(Connection connection, String policyId,\n+                                                                    OperationPolicyData policyData)\n+            throws SQLException {\n+\n+        if (policyData.getClonedCommonPolicyId() != null) {\n+            PreparedStatement statement = connection.prepareStatement(\n+                    SQLConstants.OperationPolicyConstants.UPDATE_API_OPERATION_POLICY_BY_POLICY_ID);\n+            statement.setString(1, policyData.getClonedCommonPolicyId());\n+            statement.executeUpdate();\n+            statement.close();\n+        }\n+        updateOperationPolicy(connection, policyId, policyData);\n+    }\n+\n+    /**\n+     * This method is used to restore an API specific operation policy revision.\n+     *\n+     * @param connection   DB connection\n+     * @param apiUUID      UUID of the API\n+     * @param policyId     Original policy's ID that needs to be cloned\n+     * @param revisionId   The revision number\n+     * @param organization Organization name\n+     * @throws SQLException\n+     * @throws APIManagementException\n+     **/\n+    private String restoreOperationPolicyRevision(Connection connection, String apiUUID, String policyId,\n+                                                  int revisionId,\n+                                                  String organization) throws SQLException, APIManagementException {\n+\n+        OperationPolicyData revisionedPolicy = getAPISpecificOperationPolicyByPolicyID(connection, policyId,\n+                apiUUID, organization, true);\n+        String restoredPolicyId = null;\n+        if (revisionedPolicy != null) {\n+            // First check whether there exists a API specific policy for same policy name with revision uuid null\n+            // This is the state where we record the policies applied in the working copy.\n+            OperationPolicyData apiSpecificPolicy = getAPISpecificOperationPolicyByPolicyName(connection,\n+                    revisionedPolicy.getSpecification().getName(), revisionedPolicy.getApiUUID(), null,\n+                    organization, false);\n+            if (apiSpecificPolicy != null) {\n+                if (apiSpecificPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Matching API specific operation policy found for the revisioned policy and \" +\n+                                \"MD5 hashes match\");\n+                    }\n+\n+                } else {\n+                    updateAPISpecificOperationPolicyWithClonedPolicyId(connection, apiSpecificPolicy.getPolicyId(),\n+                            revisionedPolicy);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Even though a matching API specific operation policy found for name,\"\n+                                + \" MD5 hashes does not match. Policy \" + apiSpecificPolicy.getPolicyId()\n+                                + \" has been updated from the revision.\");\n+                    }\n+                }\n+                restoredPolicyId = apiSpecificPolicy.getPolicyId();\n+            } else {\n+                if (revisionedPolicy.isClonedPolicy()) {\n+                    // Check for a common operation policy only if it is a cloned policy.\n+                    OperationPolicyData commonPolicy = getCommonOperationPolicyByPolicyID(connection,\n+                            revisionedPolicy.getClonedCommonPolicyId(), organization, false);\n+                    if (commonPolicy != null) {\n+                        if (commonPolicy.getMd5Hash().equals(revisionedPolicy.getMd5Hash())) {\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\"Matching common operation policy found. MD5 hash match\");\n+                            }\n+                            //This means the common policy is same with our revision. A clone is created and original\n+                            // common policy ID is referenced as the ClonedCommonPolicyId\n+                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n+                                    revisionedPolicy, revisionedPolicy.getClonedCommonPolicyId());\n+                        } else {\n+                            // This means the common policy is updated since we created the revision.\n+                            // we have to create a clone and since policy is different, we can't refer the original common\n+                            // policy as ClonedCommonPolicyId. This should be a new API specific policy\n+                            revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n+                                    + \"_restored-\" + revisionId);\n+                            revisionedPolicy.getSpecification()\n+                                    .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n+                                            + \" Restored from revision \" + revisionId);\n+                            revisionedPolicy.setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy));\n+                            revisionedPolicy.setRevisionUUID(null);\n+                            restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null,\n+                                    revisionedPolicy, null);\n+                            if (log.isDebugEnabled()) {\n+                                log.debug(\n+                                        \"An updated matching common operation policy found. A new API specific operation \" +\n+                                                \"policy created by the display name \" +\n+                                                revisionedPolicy.getSpecification().getName());\n+                            }\n+                        }\n+                    } else {\n+                        // This means this is a clone of a deleted common policy. A new API specific policy will be created.\n+                        revisionedPolicy.getSpecification().setName(revisionedPolicy.getSpecification().getName()\n+                                + \"_restored-\" + revisionId);\n+                        revisionedPolicy.getSpecification()\n+                                .setDisplayName(revisionedPolicy.getSpecification().getDisplayName()\n+                                        + \" Restored from revision \" + revisionId);\n+                        revisionedPolicy.setMd5Hash(APIUtil.getMd5OfOperationPolicy(revisionedPolicy));\n+                        revisionedPolicy.setRevisionUUID(null);\n+                        restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"No matching operation policy found. A new API specific operation \" +\n+                                    \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n+                        }\n+                    }\n+                } else {\n+                    // This means this is a completely new policy and we don't have any reference of a previous state in\n+                    // working copy. A new API specific policy will be created.\n+                    revisionedPolicy.setRevisionUUID(null);\n+                    restoredPolicyId = addAPISpecificOperationPolicy(connection, apiUUID, null, revisionedPolicy, null);\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No matching operation policy found. A new API specific operation \" +\n+                                \"policy created by the name \" + revisionedPolicy.getSpecification().getName());\n+                    }\n+                }\n+            }\n+        } else {\n+            throw new APIManagementException(\"A revisioned operation policy not found for \" + policyId);\n+        }\n+        return restoredPolicyId;\n+    }\n+\n+    /**\n+     * Retrieve an operation policy by providing the policy uuid\n+     *\n+     * @param connection             DB connection\n+     * @param policyId               Policy UUID\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws SQLException\n+     */\n+    private OperationPolicyData getOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                             boolean isWithPolicyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_FROM_POLICY_ID;\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setOrganization(rs.getString(\"ORGANIZATION\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyId, policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Get the API specific operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n+     * table and AM_API_OPERATION_POLICY table from API UUID. Policy id might be available, but if it is not referenced in the\n+     * APIS table, this will return null.\n+     * The returned policy data can be either an API only policy, cloned common policy to API or a revisioned API specific policy\n+     *\n+     * @param policyId               Policy UUID\n+     * @param apiUUID                UUID of the API\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getAPISpecificOperationPolicyByPolicyID(String policyId, String apiUUID,\n+                                                                       String organization,\n+                                                                       boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getAPISpecificOperationPolicyByPolicyID(connection, policyId, apiUUID, organization,\n+                    isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the API specific operation policy for id \" + policyId + \" from API \"\n+                    + apiUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getAPISpecificOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                                        String apiUUID,\n+                                                                        String organization,\n+                                                                        boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_ID;\n+        OperationPolicyData policyData = null;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, organization);\n+        statement.setString(3, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setApiUUID(apiUUID);\n+            policyData.setOrganization(organization);\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n+            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyId, policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    private List<OperationPolicyDefinition> getPolicyDefinitionForPolicyId(Connection connection, String policyId)\n+            throws SQLException {\n+\n+        List<OperationPolicyDefinition> operationPolicyDefinitions = new ArrayList<>();\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_OPERATION_POLICY_DEFINITION_FROM_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            String policyDefinitionString;\n+            OperationPolicyDefinition policyDefinition = new OperationPolicyDefinition();\n+\n+            try (InputStream policyDefinitionStream = rs.getBinaryStream(\"POLICY_DEFINITION\")) {\n+                policyDefinitionString = IOUtils.toString(policyDefinitionStream);\n+                policyDefinition.setContent(policyDefinitionString);\n+                policyDefinition.setGatewayType(\n+                        OperationPolicyDefinition.GatewayType.valueOf(rs.getString(\"GATEWAY_TYPE\")));\n+                policyDefinition.setMd5Hash(rs.getString(\"DEFINITION_MD5\"));\n+\n+                operationPolicyDefinitions.add(policyDefinition);\n+            } catch (IOException e) {\n+                log.error(\"Error while converting policy definition for the policy\", e);\n+            }\n+\n+        }\n+        rs.close();\n+        statement.close();\n+        return operationPolicyDefinitions;\n+    }\n+\n+\n+    public void populatePolicyDefinitions(Connection connection, String policyId, OperationPolicyData policyData)\n+            throws SQLException {\n+        if (policyId != null && !policyId.isEmpty()) {\n+            List<OperationPolicyDefinition> policyDefinitions = getPolicyDefinitionForPolicyId(connection, policyId);\n+            for (OperationPolicyDefinition policyDefinition : policyDefinitions) {\n+                if (OperationPolicyDefinition.GatewayType.Synapse.equals(policyDefinition.getGatewayType())) {\n+                    policyData.setSynapsePolicyDefinition(policyDefinition);\n+                } else if (OperationPolicyDefinition.GatewayType.ChoreoConnect.equals(policyDefinition.getGatewayType())) {\n+                    policyData.setCcPolicyDefinition(policyDefinition);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private void addOperationPolicyDefinition (Connection connection, String policyId,\n+                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.ADD_OPERATION_POLICY_DEFINITION;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, policyDefinition.getGatewayType().toString());\n+        statement.setString(3, policyDefinition.getMd5Hash());\n+        statement.setBinaryStream(4, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n+        statement.executeUpdate();\n+        statement.close();\n+    }\n+\n+\n+    private void updateOperationPolicyDefinition(Connection connection, String policyId,\n+                                               OperationPolicyDefinition policyDefinition) throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.UPDATE_OPERATION_POLICY_DEFINITION;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyDefinition.getMd5Hash());\n+        statement.setBinaryStream(2, new ByteArrayInputStream(policyDefinition.getContent().getBytes()));\n+        statement.setString(3, policyId);\n+        statement.setString(4, policyDefinition.getGatewayType().toString());\n+        statement.executeUpdate();\n+        statement.close();\n+    }\n+\n+    /**\n+     * Get the common operation policy from the policy ID if exists. This method will take the intersection of AM_OPERATION_POLICY\n+     * table and AM_COMMON_OPERATION_POLICY table. Policy id might be available, but if it is not referenced in the\n+     * common policies table, this will return null.\n+     *\n+     * @param policyId               Policy UUID\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getCommonOperationPolicyByPolicyID(String policyId, String organization,\n+                                                                  boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getCommonOperationPolicyByPolicyID(connection, policyId, organization, isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the operation policy for id \" + policyId, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getCommonOperationPolicyByPolicyID(Connection connection, String policyId,\n+                                                                   String organization,\n+                                                                   boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_WITH_OUT_DEFINITION_FROM_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyId);\n+        statement.setString(2, organization);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setPolicyId(policyId);\n+            policyData.setOrganization(organization);\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            populatePolicyDefinitions(connection, policyId, policyData);\n+        }\n+\n+        return policyData;\n+    }\n+\n+    /**\n+     * Retrieve a common operation policy by providing the policy name and organization\n+     *\n+     * @param policyName             Policy name\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getCommonOperationPolicyByPolicyName(String policyName, String organization,\n+                                                                    boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getCommonOperationPolicyByPolicyName(connection, policyName, organization, isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get common operation policy for name \" + policyName + \"for organization \"\n+                    + organization, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getCommonOperationPolicyByPolicyName(Connection connection, String policyName,\n+                                                                     String tenantDomain,\n+                                                                     boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery =\n+                SQLConstants.OperationPolicyConstants.GET_COMMON_OPERATION_POLICY_FROM_POLICY_NAME;\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyName);\n+        statement.setString(2, tenantDomain);\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setOrganization(tenantDomain);\n+            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+        rs.close();\n+        statement.close();\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Retrieve an API Specific operation policy by providing the policy name. In order to narrow down the specific policy\n+     * this needs policy name, apiUUID, api revision UUID (if exists) and organization. If revision UUID is not provided,\n+     * that means the policy is not a revisioned policy.\n+     *\n+     * @param policyName             Policy name\n+     * @param apiUUID                UUID of API\n+     * @param revisionUUID           UUID of API revision\n+     * @param organization           Organization name\n+     * @param isWithPolicyDefinition Include the policy definition to the output or not\n+     * @return operation policy\n+     * @throws APIManagementException\n+     */\n+    public OperationPolicyData getAPISpecificOperationPolicyByPolicyName(String policyName, String apiUUID,\n+                                                                         String revisionUUID, String organization,\n+                                                                         boolean isWithPolicyDefinition)\n+            throws APIManagementException {\n+\n+        try (Connection connection = APIMgtDBUtil.getConnection()) {\n+            return getAPISpecificOperationPolicyByPolicyName(connection, policyName, apiUUID, revisionUUID,\n+                    organization,\n+                    isWithPolicyDefinition);\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get API specific operation policy for name \" + policyName + \" with API UUID \"\n+                    + apiUUID + \" revision UUID \" + revisionUUID, e);\n+        }\n+        return null;\n+    }\n+\n+    private OperationPolicyData getAPISpecificOperationPolicyByPolicyName(Connection connection,\n+                                                                          String policyName, String apiUUID,\n+                                                                          String revisionUUID,\n+                                                                          String tenantDomain,\n+                                                                          boolean isWithPolicyDefinition)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_API_SPECIFIC_OPERATION_POLICY_FROM_POLICY_NAME;\n+        if (revisionUUID != null) {\n+            dbQuery += \" AND AOP.REVISION_UUID = ?\";\n+        } else {\n+            dbQuery += \" AND AOP.REVISION_UUID IS NULL\";\n+        }\n+\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, policyName);\n+        statement.setString(2, tenantDomain);\n+        statement.setString(3, apiUUID);\n+        if (revisionUUID != null) {\n+            statement.setString(4, revisionUUID);\n+        }\n+        ResultSet rs = statement.executeQuery();\n+        OperationPolicyData policyData = null;\n+        if (rs.next()) {\n+            policyData = new OperationPolicyData();\n+            policyData.setOrganization(tenantDomain);\n+            policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+            policyData.setApiUUID(rs.getString(\"API_UUID\"));\n+            policyData.setRevisionUUID(rs.getString(\"REVISION_UUID\"));\n+            policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+            policyData.setClonedCommonPolicyId(rs.getString(\"CLONED_POLICY_UUID\"));\n+            policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+        }\n+\n+        if (isWithPolicyDefinition && policyData != null) {\n+            if (isWithPolicyDefinition && policyData != null) {\n+                populatePolicyDefinitions(connection, policyData.getPolicyId(), policyData);\n+            }\n+        }\n+        return policyData;\n+    }\n+\n+    /**\n+     * Get the list of all operation policies. If the API UUID is provided, this will return all the operation policies\n+     * for that API. If not, it will return the common operation policies which are not bound to any API.\n+     * This list will include policy specification of each policy and policy ID. It will not contain the\n+     * policy definition as it is not useful for the operation.\n+     *\n+     * @param apiUUID      UUID of the API if exists. Null for common operation policies\n+     * @param organization Organization name\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    public List<OperationPolicyData> getLightWeightVersionOfAllOperationPolicies(String apiUUID,\n+                                                                                 String organization)\n+            throws APIManagementException {\n+\n+        String dbQuery;\n+        if (apiUUID != null) {\n+            dbQuery =\n+                    SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_OPERATION_POLICIES_WITHOUT_CLONED_POLICIES;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_COMMON_OPERATION_POLICIES;\n+        }\n+        List<OperationPolicyData> policyDataList = new ArrayList<>();\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, organization);\n+            if (apiUUID != null) {\n+                statement.setString(2, apiUUID);\n+            }\n+            ResultSet rs = statement.executeQuery();\n+            while (rs.next()) {\n+                OperationPolicyData policyData = new OperationPolicyData();\n+                policyData.setOrganization(organization);\n+                policyData.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+                policyData.setMd5Hash(rs.getString(\"POLICY_MD5\"));\n+                policyData.setSpecification(populatePolicySpecificationFromRS(rs));\n+                if (apiUUID != null) {\n+                    policyData.setApiUUID(apiUUID);\n+                }\n+                policyDataList.add(policyData);\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get all the operation policy for tenant \" + organization, e);\n+        }\n+        return policyDataList;\n+    }\n+\n+    public int getOperationPolicyCount(String organization) throws APIManagementException {\n+\n+        int count = -1;\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_THE_COUNT_OF_OPERATION_POLICIES_FOR_ORGANIZATION;\n+        try (Connection connection = APIMgtDBUtil.getConnection();\n+             PreparedStatement statement = connection.prepareStatement(dbQuery)) {\n+            statement.setString(1, organization);\n+            ResultSet rs = statement.executeQuery();\n+            if (rs.next()) {\n+                count = rs.getInt(\"POLICY_COUNT\");\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Failed to get the count of operation policies for organization \" + organization, e);\n+        }\n+        return count;\n+    }\n+\n+\n+\n+    /**\n+     * This method will return a list of all cloned policies for an API.\n+     *\n+     * @param connection DB connection\n+     * @param apiUUID    UUID of the API if exists. Null for common operation policies\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private Set<String> getAllClonedPolicyIdsForAPI(Connection connection, String apiUUID)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_CLONED_POLICIES_FOR_API;\n+        Set<String> policyIds = new HashSet<>();\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            policyIds.add(rs.getString(\"POLICY_UUID\"));\n+        }\n+        rs.close();\n+        statement.close();\n+        return policyIds;\n+    }\n+\n+    /**\n+     * This method will query AM_API_OPERATION_POLICY table from CLONED_POLICY_ID row for a matching policy ID\n+     * for the required API. This is useful to find the cloned API specific policy ID from a common policy.\n+     *\n+     * @param connection     DB connection\n+     * @param commonPolicyId Common policy ID\n+     * @param apiUUID        UUID of API\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private String getClonedPolicyIdForCommonPolicyId(Connection connection, String commonPolicyId, String apiUUID)\n+            throws SQLException {\n+\n+        String dbQuery = SQLConstants.OperationPolicyConstants.GET_CLONED_POLICY_ID_FOR_COMMON_POLICY_ID;\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, commonPolicyId);\n+        statement.setString(2, apiUUID);\n+        ResultSet rs = statement.executeQuery();\n+        String policyId = null;\n+        if (rs.next()) {\n+            policyId = rs.getString(\"POLICY_UUID\");\n+        }\n+        rs.close();\n+        statement.close();\n+        return policyId;\n+    }\n+\n+    /**\n+     * Delete all the API specific policies for a given API UUID. If revision UUID is provided, only the policies that\n+     * are revisioned will be deleted. This is used when we delete an API revision.\n+     * If revision id is null, all the API specific policies will be deleted. This is used in API deleting flow.\n+     *\n+     * @param connection   DB connection\n+     * @param apiUUID      UUID of API\n+     * @param revisionUUID Revision UUID\n+     * @return List of Operation Policies\n+     * @throws APIManagementException\n+     */\n+    private void deleteAllAPISpecificOperationPoliciesByAPIUUID(Connection connection, String apiUUID,\n+                                                                String revisionUUID)\n+            throws SQLException {\n+\n+        String dbQuery;\n+        if (revisionUUID != null) {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_REVISION_UUID;\n+        } else {\n+            dbQuery = SQLConstants.OperationPolicyConstants.GET_ALL_API_SPECIFIC_POLICIES_FOR_API_ID;\n+        }\n+        PreparedStatement statement = connection.prepareStatement(dbQuery);\n+        statement.setString(1, apiUUID);\n+        if (revisionUUID != null) {\n+            statement.setString(2, revisionUUID);\n+        }\n+        ResultSet rs = statement.executeQuery();\n+        while (rs.next()) {\n+            String deleteQuery = SQLConstants.OperationPolicyConstants.DELETE_OPERATION_POLICY_BY_ID;\n+            PreparedStatement deleteStatement = connection.prepareStatement(deleteQuery);\n+            deleteStatement.setString(1, rs.getString(\"POLICY_UUID\"));\n+            deleteStatement.execute();\n+            deleteStatement.close();\n+        }\n+        rs.close();\n+        statement.close();\n+    }\n+\n+    /**\n+     * When we apply a common policy to an operation, this policy will be cloned to the API at the backend. However, if\n+     * that policy is removed from the UI, this method is used to clean such unused policies that are imported,\n+     * but not used\n+     *\n+     * @param connection            DB connection\n+     * @param usedClonedPoliciesSet Currently used imported API specific policies set\n+     * @param apiUUID               UUID of the API\n+     * @throws SQLException\n+     */\n+    private void cleanUnusedClonedOperationPolicies(Connection connection, Set<String> usedClonedPoliciesSet,\n+                                                    String apiUUID)\n+            throws SQLException {\n+\n+        Set<String> allClonedPoliciesForAPI = getAllClonedPolicyIdsForAPI(connection, apiUUID);\n+        Set<String> policiesToDelete = allClonedPoliciesForAPI;\n+        policiesToDelete.removeAll(usedClonedPoliciesSet);\n+        for (String policyId : allClonedPoliciesForAPI) {\n+            deleteOperationPolicyByPolicyId(connection, policyId);\n+        }\n+    }\n+\n+    /**\n+     * This method will read the result set and populate OperationPolicy object, which later will be set to the URI template.\n+     * This object has the information regarding the policy allocation\n+     *\n+     * @param rs Result set\n+     * @return OperationPolicy object\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     */\n+    private OperationPolicy populateOperationPolicyWithRS(ResultSet rs) throws SQLException, APIManagementException {\n+\n+        OperationPolicy operationPolicy = new OperationPolicy();\n+        operationPolicy.setPolicyName(rs.getString(\"POLICY_NAME\"));\n+        operationPolicy.setPolicyId(rs.getString(\"POLICY_UUID\"));\n+        operationPolicy.setOrder(rs.getInt(\"POLICY_ORDER\"));\n+        operationPolicy.setDirection(rs.getString(\"DIRECTION\"));\n+        operationPolicy.setParameters(APIMgtDBUtil.convertJSONStringToMap(rs.getString(\"PARAMETERS\")));\n+        return operationPolicy;\n+    }\n+\n+    /**\n+     * This method will read the result set and populate OperationPolicySpecification object.\n+     *\n+     * @param rs Result set\n+     * @return OperationPolicySpecification object\n+     * @throws APIManagementException\n+     * @throws SQLException\n+     */\n+    private OperationPolicySpecification populatePolicySpecificationFromRS(ResultSet rs) throws SQLException {\n+\n+        OperationPolicySpecification policySpecification = new OperationPolicySpecification();\n+        policySpecification.setName(rs.getString(\"POLICY_NAME\"));\n+        policySpecification.setDisplayName(rs.getString(\"DISPLAY_NAME\"));\n+        policySpecification.setDescription(rs.getString(\"POLICY_DESCRIPTION\"));\n+        policySpecification.setApplicableFlows(getListFromString(rs.getString(\"APPLICABLE_FLOWS\")));\n+        policySpecification.setSupportedApiTypes(getListFromString(rs.getString(\"API_TYPES\")));\n+        policySpecification.setSupportedGateways(getListFromString(rs.getString(\"GATEWAY_TYPES\")));\n+        policySpecification.setCategory(OperationPolicySpecification.PolicyCategory\n+                .valueOf(rs.getString(\"POLICY_CATEGORY\")));\n+        policySpecification.setMultipleAllowed(rs.getBoolean(\"MULTIPLE_ALLOWED\"));\n+        List<OperationPolicySpecAttribute> policySpecAttributes = null;\n+\n+        try (InputStream policyParametersStream = rs.getBinaryStream(\"POLICY_PARAMETERS\")) {\n+            String policyParametersString = IOUtils.toString(policyParametersStream);\n+            policySpecAttributes = new Gson().fromJson(policyParametersString,\n+                    new TypeToken<List<OperationPolicySpecAttribute>>() {\n+                    }.getType());\n+        } catch (IOException e) {\n+            log.error(\"Error while converting policy specification attributes for the policy \"\n+                    + policySpecification.getName(), e);\n+        }\n+        policySpecification.setPolicyAttributes(policySpecAttributes);\n+        return policySpecification;\n+    }\n+\n+\n+    /**\n+     * Create a string list from a single string element by splitting from the comma\n+     *\n+     * @param stringElement String element\n+     * @return list of strings\n+     */\n+    private List<String> getListFromString(String stringElement) {\n+\n+        List<String> list = null;\n+        if (!stringElement.isEmpty()) {\n+            list = Arrays.asList(\n+                    stringElement.substring(1, stringElement.length() - 1).replaceAll(\"\\\\s\", \"\").split(\",\"));\n+        }\n+        return list;\n+    }\n+\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "8f4619855f84b58847bd9b1bae181401f0a81961", "message": "Merge commit", "committedDate": null}, {"oid": "c7d3d00674fe6a5b9062190d1bcdfdfca6fcd723", "committedDate": "2019-11-14 14:14:22 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt"}, {"oid": "c0731f3f7ff434965966418c028344ca19ff28ac", "committedDate": "2019-12-10 12:38:44 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt"}, {"oid": "85b52286473b1a2260b300a05692b4740acf15a5", "committedDate": "2019-12-22 22:17:33 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt"}, {"oid": "922eec3e8b9c38ce1e91b6e6a092bc08115c7875", "committedDate": "2020-01-18 23:59:59 +0530", "message": "Changes in ApiMgtDAO.java"}, {"oid": "126cf4b4440582d26a3db5952822cf783fd82d24", "committedDate": "2020-01-19 16:11:13 +0530", "message": "Changes made to ApiMgtDAO.java and to some related queries under SQLConstants.java"}, {"oid": "34bbfbb563c46c459d3856ae2c5d2907105621f9", "committedDate": "2020-01-21 19:52:26 +0530", "message": "Started working on the depth section"}, {"oid": "a093aeda5b37d647b5e8f32d26c48a8bd277eb3c", "committedDate": "2020-01-22 17:07:59 +0530", "message": "Added basic query analysis details to execute at API creation"}, {"oid": "45e15f6ceeb10c61f5951161f45bee508a8cabbe", "committedDate": "2020-01-23 11:07:13 +0530", "message": "Added functionality to retrieve a GraphqlPolicyDefinition object at the time of local entry creation"}, {"oid": "62787fca5c0ce4332f064bd08eb54c8992ce9bd7", "committedDate": "2020-01-24 10:22:44 +0530", "message": "Interim changes"}, {"oid": "541e929d2bce7e5826a1214570da4aa1ac164e14", "committedDate": "2020-01-26 11:29:41 +0530", "message": "Completed individual role-depth mapping get, update and delete resource APIs"}, {"oid": "caad50e77cc4972cb931f44afbafc5e0e0a9fba3", "committedDate": "2020-01-26 22:20:21 +0530", "message": "Completed depth and complexity enable/disable rest apis along with the implementations"}, {"oid": "00a843e08df7787760c1ad3703611679ac3e8693", "committedDate": "2020-01-27 09:42:29 +0530", "message": "Changes in backend REST APIs"}, {"oid": "e4447a376c42fee44e49de2a244512a8ae9ef6ef", "committedDate": "2020-01-27 11:04:42 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt"}, {"oid": "13f8552d29aadadb04d1334f0c6087e0166600aa", "committedDate": "2020-01-27 23:42:51 +0530", "message": "Changes made to fix test failures"}, {"oid": "6732d0563330f22a2004e0336ef9f902a79f768f", "committedDate": "2020-01-28 17:24:55 +0530", "message": "Issue fixes"}, {"oid": "be63f1579612da56a6384b2d56e76ba43842c2ae", "committedDate": "2020-01-29 04:39:41 +0530", "message": "DAO file changes"}, {"oid": "1203ada7e23a19a5de9376afe9513bcf4faa9bc9", "committedDate": "2020-02-05 13:30:25 +0530", "message": "Fixes"}, {"oid": "a4ca8c27681d9ef559c963f407abb71ebd99f8db", "committedDate": "2020-02-05 14:18:40 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt"}, {"oid": "6350401de242648f2dc44957416f85dd430ed222", "committedDate": "2020-02-06 15:34:04 +0530", "message": "Changes in backend REST API definitions"}, {"oid": "ab0e0792d4705f3b680580f2a282c7c338d1518c", "committedDate": "2020-03-05 14:51:59 +0530", "message": "handle case sensitivity in context"}, {"oid": "c472ea9a5f94f1f5fffd4533274fb9f40b42596c", "committedDate": "2020-03-09 16:34:11 +0530", "message": "Fixes"}, {"oid": "23c93a808b75c28e5bf577b0e0c83803c5db055b", "committedDate": "2020-03-13 10:59:43 +0530", "message": "Merge remote-tracking branch 'other/master' into test1"}, {"oid": "b65ad2efcec6f670ef4ad31a1019f2c8f9a061ce", "committedDate": "2020-04-14 10:15:20 +0530", "message": "Add implementation for retrieving subscriber claims"}, {"oid": "11af67c9b4d1b6b12b00e9c8297b3b49add005f8", "committedDate": "2020-04-14 10:31:44 +0530", "message": "Modified testcases"}, {"oid": "4b0356dbd07b9e8aaa4f283845c343996467b748", "committedDate": "2020-04-21 09:39:37 +0530", "message": "Resolve review comments"}, {"oid": "db1fba2e93691a076652d91d9d3f6274d8932157", "committedDate": "2020-04-21 15:00:25 +0530", "message": "Fix wso2/product-apim#6704"}, {"oid": "e8702e0e454947d190b01fa92d3b06fd14f1ac4b", "committedDate": "2020-04-21 16:42:48 +0530", "message": "Add review changes"}, {"oid": "de00b92445b9dfe25177e3b824ad869e850e69ee", "committedDate": "2020-04-29 13:20:22 +0530", "message": "fixing case sensitivity of username while searching for applications in api store"}, {"oid": "4d5c6ffa35091830ed619f409fd17d41ac68117f", "committedDate": "2020-04-30 16:58:21 +0530", "message": "Merge pull request #8420 from msm1992/master_duplicate_table_entry_fix"}, {"oid": "e05c5d48319fe068a471b7469fb1069531222bd2", "committedDate": "2020-05-05 11:14:48 +0530", "message": "Add implementation to addRegistry resource"}, {"oid": "e0c793516a89b1cdc8923e4d9b887a41ed154e6d", "committedDate": "2020-05-05 13:12:15 +0530", "message": "Resolve review comments"}, {"oid": "e38cceed0e90ed4fdfccd4b3b923ac821c094727", "committedDate": "2020-05-05 14:59:56 +0530", "message": "Add EndpointRegistry interface and impl"}, {"oid": "890a30fb07bd56414d370e6845a218f34c2b6145", "committedDate": "2020-05-05 17:33:47 +0530", "message": "Merge pull request #8317 from Sarangan0219/context"}, {"oid": "db2628efa03380158193c72b58c1b46338b66191", "committedDate": "2020-05-06 10:27:26 +0530", "message": "Add getRegistries resource implementation"}, {"oid": "fdfb313431cfbba58dd8cde0e94c566b69573787", "committedDate": "2020-05-06 10:31:54 +0530", "message": "Merge pull request #8467 from ChamodDamitha/aip-platform"}, {"oid": "20bcc3585d9a367bdb71230f7710420c3e21b222", "committedDate": "2020-05-11 16:58:06 +0530", "message": "Add getAllEntriesInRegistry resource"}, {"oid": "ad92f59f471289422531dc03396415ce5b694b82", "committedDate": "2020-05-11 18:00:08 +0530", "message": "Fetch specific registry entry"}, {"oid": "e1a039ddf7a6b9dc073e4214a59f1b7dadbf6ffd", "committedDate": "2020-05-12 08:16:22 +0530", "message": "Add initial impl of add registry entry"}, {"oid": "aa992591b9f853f141f63c937fd05ade3fa31024", "committedDate": "2020-05-12 08:25:22 +0530", "message": "Fetch GET resources impl"}, {"oid": "4fa06ad511c80776ea0b2ef7fffce3732695acf6", "committedDate": "2020-05-12 12:49:04 +0530", "message": "Add impl for POST RegistryEntry"}, {"oid": "9ec56847f87e56b3bac72faabfa6d265f98959e8", "committedDate": "2020-05-12 16:48:59 +0530", "message": "Add deleteEndpointRegistry resource"}, {"oid": "a6e1f3813d3d253476c07cf3ae7b5e4900f70600", "committedDate": "2020-05-12 18:23:34 +0530", "message": "Add cross-tenant restriction for endpoint registry resources"}, {"oid": "ff8b5f92252c2c3497e900ed0ffdc9071c032be5", "committedDate": "2020-05-12 19:33:29 +0530", "message": "Remove unnecessary endpoint registry entry delete query"}, {"oid": "e1d64fc7bd4323dbcc752da4129e17deb33ea05b", "committedDate": "2020-05-12 21:05:25 +0530", "message": "Update wendpoint registry"}, {"oid": "673eb96a79ebfb16d2e70071939589967e47c699", "committedDate": "2020-05-13 10:43:05 +0530", "message": "Fix signature of update method"}, {"oid": "32b5faf1684c62a4478cbdfeed5ecbbc36ab152d", "committedDate": "2020-05-13 11:14:58 +0530", "message": "reomve unused field"}, {"oid": "cd28620ca836ac26df91a3e62637fa5fe74c6c23", "committedDate": "2020-05-13 14:43:47 +0530", "message": "Add pagination and sortBy functionality to getRegistries resource"}, {"oid": "f123d0ce89ce0057e5b171de6325f633337d1330", "committedDate": "2020-05-13 14:44:00 +0530", "message": "Update endpoint registry queries with constants"}, {"oid": "c9d435ae3d4ee73b67d164574fbad1ba865373a4", "committedDate": "2020-05-13 14:44:00 +0530", "message": "Fix formating issues"}, {"oid": "f3a455666cb21e26c4065d1452e45a02c239ebff", "committedDate": "2020-05-13 18:23:09 +0530", "message": "Add updateRegistryEntry resource"}, {"oid": "e5051f7e1b455e07f7bccfda06af9c3c29a35693", "committedDate": "2020-05-13 20:56:18 +0530", "message": "Add deleteEndpointRegistryEntry resource"}, {"oid": "a3388f2645c590807d500daf19f9a1923ff618a2", "committedDate": "2020-05-14 18:43:08 +0530", "message": "Modified categories API and blocking condition REST API."}, {"oid": "695d9ffcc33a1837feb2d4616ccd7327cbbcd5fc", "committedDate": "2020-05-15 17:49:09 +0530", "message": "Add resource to download endpoint definition"}, {"oid": "4173ecea8742958417c72e175e73d328b48c6a40", "committedDate": "2020-05-18 11:10:14 +0530", "message": "Adding serviceCategory param"}, {"oid": "9be2a7b8567820ed06d464c7f32b6ffd0795f72b", "committedDate": "2020-05-18 11:49:22 +0530", "message": "Add pagination and sorting support for get endpoint registry entries resource"}, {"oid": "ee820810adb5a97bb1b7988a8262c6d95de97ac1", "committedDate": "2020-05-19 12:21:33 +0530", "message": "Adding subscriber name to CREATED_BY column value of AM_SUBSCRIPTION table"}, {"oid": "53bd5bd1cd0eb33eb68183ae123c104e22fc2441", "committedDate": "2020-05-19 12:27:21 +0530", "message": "edit whitespaces"}, {"oid": "32efd32edd3c2ca791281eea000f281341d39bd6", "committedDate": "2020-05-19 13:23:13 +0530", "message": "update subscriber in prepared statement"}, {"oid": "addeadb1826dd47ebcaec6150e62e71089faae77", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Change scope ID to String to support Global Scope UUID."}, {"oid": "d6abe8c445f62e1b305256385ffeadd6b35bc701", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Add global scope db support"}, {"oid": "4de4437685398d0c0f486c278a5099350052767a", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Add scope management dao"}, {"oid": "596459dad9b3f52e22882ec6bd6be0e0f9f16987", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Add DAO Changes related to scope management."}, {"oid": "18f79850176bb87a925e89be917fa861b3fd5c1b", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix formatting and minor issues."}, {"oid": "5334517535852bb0736f795486acc71d417f7ee9", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix minor formatting and add missing java docs."}, {"oid": "bed4378051599bbe0942accca1a2adc757baa857", "committedDate": "2020-05-19 13:50:26 +0530", "message": "update local scope adding logic."}, {"oid": "4e9aba633749033ef068a7cb7b0e90f887130719", "committedDate": "2020-05-19 13:50:26 +0530", "message": "skip throwing error when scope already exists in KM when creating new API versions."}, {"oid": "252011c2f63a44dc64e3b742e1d2c741d2b96f14", "committedDate": "2020-05-19 13:50:26 +0530", "message": "remove initialAutoCommit static variable access."}, {"oid": "85b3db197e8d72bf002fc61cf6ac4ea9ef40848d", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Pass scope name to delete global scope."}, {"oid": "4fc9a7bc822884c10a63fbf1e71eb927fda5799a", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Rename Global Scope -> Shared Scope"}, {"oid": "bf6ae3e7835e74ae41541d188a1b7827b6c4d2a9", "committedDate": "2020-05-19 13:50:26 +0530", "message": "add support for multiple scopes per resource."}, {"oid": "0f7b68a07c6ee45d589cfd594d4bbca9edac2046", "committedDate": "2020-05-19 13:50:26 +0530", "message": "fix issue of not deleting local scopes during API delete if the same scope name is available in a different tenant."}, {"oid": "bdb0f32a08263b6092840d663da1c36b6207217c", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Remove only unversioned scopes during API update. Versioned scopes cannot change during API update."}, {"oid": "c4dc0cb954be0523d1dbf54b2ec95788e035793b", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Handle null in connection rollbacks. Move AddLocalScopes to updateScope transaction. Move getAPIContext to deleteAPI transaction."}, {"oid": "27252f29c71f307f091f9a30615d80c53db44c42", "committedDate": "2020-05-19 13:50:26 +0530", "message": "remove unnecessary null checks for resultset. Add notes to methods for removing in future."}, {"oid": "d7affaa5ab9f0f770bc1554b36fbaf1aa95c15c5", "committedDate": "2020-05-19 13:50:26 +0530", "message": "handle connection rollback for URItemplate removal in update."}, {"oid": "351d0114b70a3a35a8bcdc633e23a8c7ceeba444", "committedDate": "2020-05-19 13:50:26 +0530", "message": "fix api delete issue."}, {"oid": "2631363c78f0e291597b2f59453a11f33eb97989", "committedDate": "2020-05-19 13:50:26 +0530", "message": "seperate local scope existence validation and registration logic."}, {"oid": "eb1a96de2b506ab2dc50fff80c522fa7bb7f1c67", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Seperate KM service calls from ApiMgtDAO layer."}, {"oid": "7ba91458f379603a550f8bc2a8f4537a894bc6d3", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix review comments. 1.During API deletion, separately delete the resource scope mappings from API-M before deleting the URI templates. 2. Use the same DB connection when retrieving the API Id during API update and delete. 3. Provide default implementation for attachResourceScopes, deatachResourceScopes, and updateResourceScopes in KeyManager interface. 4. Let updating the local scopes (during API update) which are shared across versioned APIs. 5. Explicitly handle the resource scope operations from default KM implementation to make sure current usecases work."}, {"oid": "0e5752e166cf62657165fddb16ebe3844d167bea", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Move getAPIScopes to APIUtil so that KM call will not be done from DAO layer."}, {"oid": "259a78d0c7ed09843a919bfa6ef8cd902b774c6e", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Remove getAllSharedScopes DAO."}, {"oid": "16c71f4c94363e7d9370e3be01bdd0fa65f285be", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Add DisplayName to ScopeDTO in publisher REST API. Keep display name in Scope.name and scope key in Scope.key."}, {"oid": "ebe502f9aee0dcc2c2436e002ce0eac16b241930", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix review comments. Add specific field names to SELECT queries."}, {"oid": "a4be51df8803ac4ba9ce003dd4f72d3f6c6d8bc8", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix get scope id using scope name."}, {"oid": "94703b1b72f94af9eeb2a254508fdb2820c94d4e", "committedDate": "2020-05-19 13:50:26 +0530", "message": "remove tenantId parameter for api update."}, {"oid": "d4cb2c80458a6cbd536fc754b09a512c01970008", "committedDate": "2020-05-19 13:50:26 +0530", "message": "fix tests. remove unused methods and sql queries."}, {"oid": "f255ff8f898b5df36c4991d22e1022bbbc47ae57", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix issues when retrieving shared scopes and searching paginated apis."}, {"oid": "b01404669b1e660399548a689ffb98746f6b156d", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Get versioned local scopes and remove them from the old local scope set sending to KM, during API update."}, {"oid": "3c2041719a0d7087da3ae2de65e0bfb43b40e7b7", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Add resource scope to URITemplate.scopes array."}, {"oid": "98b7b82742e84d396d260e72f95cde1d8f6b5c5c", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix issue of returning scopes in uri templates for creation new version flow. Fix graphql oauth token invocation issue."}, {"oid": "1e168dfed4b75089c029cefce27e3f3503166c49", "committedDate": "2020-05-19 13:50:26 +0530", "message": "Fix comments and javadoc comments."}, {"oid": "52f5b01de954626ad32b1bef75df776bb399ac28", "committedDate": "2020-05-19 13:50:26 +0530", "message": "fix bug, remove shared scope by tenantId."}, {"oid": "6f386852ee113804feea14a4f55f0e07f4bb2676", "committedDate": "2020-05-19 14:59:12 +0530", "message": "Merge pull request #8531 from Sarangan0219/subscription"}, {"oid": "e031fd8c2e57c4355c053f32b37d33cb742909bb", "committedDate": "2020-05-19 15:43:19 +0530", "message": "Adding Shared Scope Management UI"}, {"oid": "f1fa6783878e18829e414cdd3c4e95a3d68989b6", "committedDate": "2020-05-19 16:10:23 +0530", "message": "Fix database connection leak when importing APIs"}, {"oid": "6f7db71c79119a38e92ffea77c8d305fae081ae3", "committedDate": "2020-05-19 17:45:14 +0530", "message": "Merge pull request #8508 from Meruja/admin-rest-api"}, {"oid": "2a9f525259f8a57fdf68976d2c2c91563e85406d", "committedDate": "2020-05-19 18:49:20 +0530", "message": "Merge pull request #8537 from 1akshitha/con_leak"}, {"oid": "ab79cd0a66fbe2ad80bc182e4b6760ffdf90712d", "committedDate": "2020-05-20 09:56:22 +0530", "message": "Add filtering and serach for Registry Entries"}, {"oid": "d520200dab33f21ec0019209a417dbd0cb1a8a46", "committedDate": "2020-05-20 16:19:07 +0530", "message": "Merge pull request #8542 from vithu30/enpoint-reg-3"}, {"oid": "81e924875e0203053a6a2e85d58786e6e71eef83", "committedDate": "2020-05-21 18:09:15 +0530", "message": "Add audit columns to endpoint registry DB tables"}, {"oid": "d29130c659d23aef2a47475d566e30fa30bcdc56", "committedDate": "2020-05-22 10:32:58 +0530", "message": "Fix review comments"}, {"oid": "426a9e1d192e8c5a2eda9a4a0e5ac3be9a1c4405", "committedDate": "2020-05-22 14:35:47 +0530", "message": "Adding sandboxServiceUrl to registryEntry"}, {"oid": "41d4c57c9fb8ab7347137fac535121381688f639", "committedDate": "2020-05-23 09:31:42 +0530", "message": "graphql_query_analysis"}, {"oid": "d6a4aaa1d444685b3fd05a17281632441f86f49f", "committedDate": "2020-05-23 10:08:07 +0530", "message": "fixed conflicts"}, {"oid": "1ab142912ad6ea022b77ff87d4d0ff33e56e454f", "committedDate": "2020-05-23 10:37:53 +0530", "message": "Merge pull request #8536 from mushthaq33/master"}, {"oid": "82a2acab22f91b599e63964fe3e19cf1b1a84388", "committedDate": "2020-05-25 09:49:10 +0530", "message": "adding subscription tier update in an existing subscription"}, {"oid": "21ce9862c39260ad9cbbb2db321ccea865c0a971", "committedDate": "2020-05-26 13:24:12 +0530", "message": "Add version support to endpoint registry"}, {"oid": "de354e7b31c9bc4637a80af5e551435f03047469", "committedDate": "2020-05-26 13:24:13 +0530", "message": "Add exact match for version when filtering endpoint registry entries"}, {"oid": "2e4fc3359a12761f8fd1c33a63865ea894d24406", "committedDate": "2020-05-26 21:22:26 +0530", "message": "Move endpoint registry API code to a separate package"}, {"oid": "95ff64947dcd54c260a0867c3c314fae064d6a85", "committedDate": "2020-05-27 16:21:02 +0530", "message": "change subscriptionPolicy method to support graphql queryanalysis"}, {"oid": "b83d05cbc5af0df3b51aba83c26c2b5abce1f1da", "committedDate": "2020-05-27 16:25:05 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into test1"}, {"oid": "f7cdfe2469a6038cc8fec3cdd94289808376c727", "committedDate": "2020-05-28 20:30:42 +0530", "message": "Fix \"Can't view application after deleting the application tier\" issue"}, {"oid": "373f75e9a46644249cc280b0dd99fa904530a99b", "committedDate": "2020-06-02 14:40:20 +0530", "message": "add tenant wise key manager support"}, {"oid": "e82c3793f8cb51d2c0b19127091ec1adc23ff8e1", "committedDate": "2020-06-02 14:40:20 +0530", "message": "add validation on key manager configuration"}, {"oid": "bdbb51f6e410f06f2bed3d890e18e26a07a76557", "committedDate": "2020-06-02 14:40:20 +0530", "message": "add application level support to multiple key managers"}, {"oid": "f640c3ecb9fd1be49ca3655ed9cfea288fc43cd6", "committedDate": "2020-06-02 14:40:20 +0530", "message": "add jwt validator to support with multiple key manager"}, {"oid": "7893b3291dc7c91be33421454491d63897a5cfed", "committedDate": "2020-06-02 14:40:20 +0530", "message": "add changes according to select api level key manager"}, {"oid": "510c5bb4fb8eb9373cc76a4a4553aa15b42f0aee", "committedDate": "2020-06-02 14:40:20 +0530", "message": "bring configuration as osgi service"}, {"oid": "e60c97f4c093fa4a3b52bc14ef536629751e9538", "committedDate": "2020-06-02 14:40:20 +0530", "message": "add code review changes"}, {"oid": "ecfe7debc6c80092e9e02bff7dd29d93c2a40837", "committedDate": "2020-06-03 12:46:25 +0530", "message": "Adding shared scope usage REST API"}, {"oid": "3550c6ac829d5e756dab682eab507f16e5616d0b", "committedDate": "2020-06-04 12:27:12 +0530", "message": "Adding changes"}, {"oid": "a51b668933084320582323b93053d353cd7e18de", "committedDate": "2020-06-04 14:46:45 +0530", "message": "Revert \"Revert \"Added workflow Executors for Approval workflow executor\"\""}, {"oid": "8382b25a402ca4620d6d8b948d77a8cc82f041f4", "committedDate": "2020-06-05 13:22:42 +0530", "message": "Modify GraphQLQueryAnalysisHandler"}, {"oid": "50ab04b0da7001cb31481e0ba12a182c125a12e0", "committedDate": "2020-06-05 13:56:06 +0530", "message": "fixed conflict"}, {"oid": "10381108dc2f2b5477bbad20a64acb40a29de85c", "committedDate": "2020-06-10 03:13:22 +0530", "message": "validate GraphqlQuery using opaque token"}, {"oid": "c9b873014b0abf532f6e63fb3f1de778fe5fe90a", "committedDate": "2020-06-10 17:54:57 +0530", "message": "add REST API support forAPIPolicies"}, {"oid": "14581a1bd3a77bdfb3ccadf5c707835a773543a6", "committedDate": "2020-06-10 23:13:51 +0530", "message": "improve keymanagement to store information related to oauth app info"}, {"oid": "3d36fb9cfd3fae63519ba54c9d7e02ab7e2c5fe8", "committedDate": "2020-06-10 23:13:51 +0530", "message": "add reviewed fixes"}, {"oid": "db05cb582eb8cfb391b5d94d7880912caf7e1702", "committedDate": "2020-06-11 06:06:59 +0530", "message": "Merge pull request #8701 from isharac/ishara-master"}, {"oid": "ff9b8d91164e2ea577ae34360297d5c39e6efe08", "committedDate": "2020-06-11 11:24:07 +0530", "message": "modify dbscripts"}, {"oid": "c72744b88405ebd2fde02b64b15eadaec445eb6f", "committedDate": "2020-06-11 11:25:21 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into test1"}, {"oid": "fbd081f232dc8ae337f60f24abe3832816cf4212", "committedDate": "2020-06-11 16:30:42 +0530", "message": "Implemented the db publisher and retriever for gateway artifact synchronizer"}, {"oid": "153387abded97189ea48e1ebd41731edf450ecca", "committedDate": "2020-06-11 16:30:43 +0530", "message": "Implemented update and delete in publisher extension"}, {"oid": "30a18a39c99a55ef9cf01db195254e894f26a9e9", "committedDate": "2020-06-11 16:30:43 +0530", "message": "Added support to update API and delete API"}, {"oid": "0694cd2ffdd85d5445606583f3f23754a5d37ebb", "committedDate": "2020-06-11 16:30:43 +0530", "message": "Changed DB Schema"}, {"oid": "578850aa17ba64ebac7c4d41de94b0e93080022a", "committedDate": "2020-06-11 16:32:23 +0530", "message": "Restructured DB operations"}, {"oid": "b62f4f934e566477dbca89cd1387b0fbf3b43359", "committedDate": "2020-06-11 16:32:23 +0530", "message": "Added a new method to check whether the api is published in any of the gateways"}, {"oid": "8220100a7947dc2da69e41f4dfc2e265a45a410c", "committedDate": "2020-06-11 16:34:52 +0530", "message": "Improved with comments, meaningful variable names"}, {"oid": "670179614b01867305f09f29cdbdb1452bb47129", "committedDate": "2020-06-11 16:34:52 +0530", "message": "Changed DB column names"}, {"oid": "6383363e86f907118804e12368398b9861529e99", "committedDate": "2020-06-11 16:34:52 +0530", "message": "Changed configurations"}, {"oid": "c9a85d7cac9219e967db29a44a87bf054fba5471", "committedDate": "2020-06-11 16:34:52 +0530", "message": "Fixes for Artifact synchronizer"}, {"oid": "d6c765a9223d6299ba14fed4fbe4681b5c8a0c7e", "committedDate": "2020-06-11 16:34:52 +0530", "message": "Add database entries for retrieving"}, {"oid": "08c1481d3cb79e9e760681de349644360be9f10d", "committedDate": "2020-06-11 16:34:53 +0530", "message": "Add method descriptions"}, {"oid": "864254a4b28348d88853dae918e5d91d14f69baf", "committedDate": "2020-06-11 16:34:53 +0530", "message": "Remove loggings"}, {"oid": "b87691087d7808a2ccc9a624d531b3f0b81bec9f", "committedDate": "2020-06-11 16:34:53 +0530", "message": "Rename method parameter in description"}, {"oid": "6b35ea5d367b80d8aa4b9b3822b79fc783be5b40", "committedDate": "2020-06-12 12:00:43 +0530", "message": "add displayName into key manager"}, {"oid": "32b524cb19a5934d20921b03ca58d3fb3bfb5c86", "committedDate": "2020-06-15 11:43:56 +0530", "message": "modify addSubscriptionPolicy method"}, {"oid": "52cee1f846d8fcd6fa16f1f00e6a6dac16857084", "committedDate": "2020-06-16 12:08:56 +0530", "message": "modify add custom complexity method"}, {"oid": "88933eef3f2e32e6a6268fb4152fb7d23604f4b0", "committedDate": "2020-06-16 12:55:26 +0530", "message": "Implement service calls for KM operations"}, {"oid": "af98df696fced642eda0ae0bcfc045c008cfeebe", "committedDate": "2020-06-17 11:08:31 +0530", "message": "fix missing notification events"}, {"oid": "394d1f883e536c2a20ea790593ffd2dedb00f0f3", "committedDate": "2020-06-17 14:27:43 +0530", "message": "requested changes"}, {"oid": "54b8b0dee65b5f42167cc19a61190b0ccb0779f7", "committedDate": "2020-06-19 13:05:20 +0530", "message": "Fix compilation errors"}, {"oid": "9d7d64d86d263b4351632c794a3946848ee4625c", "committedDate": "2020-06-21 09:27:22 +0530", "message": "Fix subscription related events"}, {"oid": "edbc0d837772f4578e3661a9679c443b27bc8e55", "committedDate": "2020-06-22 21:35:47 +0530", "message": "Change of CRUD functionality of subscription policy"}, {"oid": "efc2b70c504bdd1ea2749f0d218cc869484d97cb", "committedDate": "2020-06-24 13:21:17 +0530", "message": "fix key manager displayName issues"}, {"oid": "e0813dc6c78936ec5c3f1ee2b80a8fc65fe94f4d", "committedDate": "2020-06-24 15:21:34 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into test1"}, {"oid": "d5ee84cfc9f51af5e494932fc5b2fbc5efc00502", "committedDate": "2020-06-24 19:36:20 +0530", "message": "fixed comments"}, {"oid": "fc3ceedb4ca74675e65c0053c558ad5961da9584", "committedDate": "2020-06-24 22:50:36 +0530", "message": "Fixing product-apim/issues/8451"}, {"oid": "24ffeaa0f907b14138410d411b8346e504eb7b72", "committedDate": "2020-06-25 11:53:42 +0530", "message": "fix jwt subscription blocking issue"}, {"oid": "e500e26028ec99a91fbafd429844052ad5d0c35d", "committedDate": "2020-06-26 04:32:36 +0530", "message": "Merge remote-tracking branch 'upstream/master-inmem-validation' into master-merge"}, {"oid": "197c4407952f0b1ef1982ee330551667fb7d7b7c", "committedDate": "2020-06-26 11:15:11 +0530", "message": "resolve H2 DB errors"}, {"oid": "2d799a0c9112170f9428b7ade4525c2b7a162f50", "committedDate": "2020-06-26 12:26:30 +0530", "message": "fix the issue in limit parameter"}, {"oid": "cb8977c0db58e8cb0830438fef2dc55286eb5c7c", "committedDate": "2020-06-28 10:14:51 +0530", "message": "Add Impl and DAO functionality related to the revamp"}, {"oid": "5e4e31cb654ed8cc4b1161906e7031e7a195a13b", "committedDate": "2020-06-28 10:14:51 +0530", "message": "Revamp bot detection alert subscription related ApiMgtDao codes"}, {"oid": "380732ae11e0e1a7965f375dedb2951e8cd9be3f", "committedDate": "2020-06-29 10:44:01 +0530", "message": "Merge upstream"}, {"oid": "4d9b0e514feabb100d718d7547ea0566315f5eb4", "committedDate": "2020-06-29 19:43:53 +0530", "message": "Merge pull request #8854 from ShalkiWenushika/limit-fix"}, {"oid": "8b73aa02e4dd3517bf51c8cddc6d5862cc5c7020", "committedDate": "2020-06-30 12:29:12 +0530", "message": "Merge remote-tracking branch 'upstream/master' into dataservice2"}, {"oid": "49af2f9f2b2d1cd5390ecb3c7b0aa1ba1870ca10", "committedDate": "2020-06-30 14:23:38 +0530", "message": "Merge pull request #8791 from hisanhunais/bot-detection-revamp-v3"}, {"oid": "85481f6982117165f23bb143d9fe0179bcd5284c", "committedDate": "2020-06-30 17:27:26 +0530", "message": "remove HTTP call from artifact saver"}, {"oid": "50e6358767be9177a39b394da24c7dba8ab8b4ae", "committedDate": "2020-06-30 19:16:34 +0530", "message": "Merge remote-tracking branch 'upstream/master' into dataservice2"}, {"oid": "d1b6216beac2821a59488028705d0b1088e31fdb", "committedDate": "2020-07-07 21:49:54 +0530", "message": "Add tenant theme database implementations"}, {"oid": "948fb62038d82906651cc2bbce5b2394c035025f", "committedDate": "2020-07-07 21:49:54 +0530", "message": "Add tenant theme REST API layer implementations"}, {"oid": "8db4b29a63253c5b03d8ff10c75b8c9180695a3f", "committedDate": "2020-07-07 21:49:55 +0530", "message": "Improve tenant theme import export implementations"}, {"oid": "c5b80643a4273c328e312b53f321cd79db495265", "committedDate": "2020-07-07 21:49:55 +0530", "message": "Add functionality to delete tenant theme from database"}, {"oid": "f32af04bfed6d8781ad41fb9030d2438ab3eac2b", "committedDate": "2020-07-07 21:49:55 +0530", "message": "Fix error in method which deletes tenant theme from db"}, {"oid": "a12776b42ad36b8039cf3c139611830f5f2736b4", "committedDate": "2020-07-07 21:49:56 +0530", "message": "Add and improve java doc comments related to tenant themes"}, {"oid": "f15c57e810c12048cd8cd47535f00754062512f2", "committedDate": "2020-07-07 21:49:56 +0530", "message": "Modify tenant theme add and update methods"}, {"oid": "0b0ed544da530b1f2f0140694df94c4639320ae9", "committedDate": "2020-07-08 09:05:28 +0530", "message": "adding admin portal approval workflow flow for subscription tier update feature"}, {"oid": "8fd073bcb7b0954313e01780657e3f4fb8dded85", "committedDate": "2020-07-08 17:59:01 +0530", "message": "Externalize Token Revocation"}, {"oid": "89a921cdfa36bb8c1eb54e8d6e7a29e1dd4805f5", "committedDate": "2020-07-09 10:59:48 +0530", "message": "Merge pull request #8927 from hisanhunais/tenant-theme-changes"}, {"oid": "0f59b7a768cd8046ddaf0bf73b1a9926ae295004", "committedDate": "2020-07-09 13:16:54 +0530", "message": "fix already existing tier update request update issue"}, {"oid": "08613183e69e0c4b7522a2840645d69fef1583d7", "committedDate": "2020-07-13 22:41:51 +0530", "message": "generalize IS connection configs"}, {"oid": "9207e34138475f5ad2422fd6a92ec16e06152117", "committedDate": "2020-07-14 09:31:23 +0530", "message": "Modify Admin v1 GET /applications to search by application name"}, {"oid": "d4b76858b80e10cd349f43277ea6126fe3a12752", "committedDate": "2020-07-14 09:31:23 +0530", "message": "Change comments"}, {"oid": "6b5f63413b8e5f1a2219c08ab46469a4f9e4aa1f", "committedDate": "2020-07-14 16:42:35 +0530", "message": "Merge pull request #8972 from tharindu1st/master-inmem-validation"}, {"oid": "c49717045f7d86dd8ae85ded0638b4e1490640f5", "committedDate": "2020-07-15 19:55:58 +0530", "message": "remove enable advance throttling config and related code refactoring"}, {"oid": "240e74f971867c62d96f233cb59efb26593e99cb", "committedDate": "2020-07-16 15:01:40 +0530", "message": "Set api type"}, {"oid": "8da93bb2636acb81aed514000bb733b97fd969ee", "committedDate": "2020-07-16 21:48:45 +0530", "message": "remove extra line"}, {"oid": "1e0d8b26297492e49aa3d5a28949c82360ef8cb8", "committedDate": "2020-07-21 14:57:20 +0530", "message": "Merge branch 'master' into ishara-master"}, {"oid": "d721966a1118ee1819de92b515b898aa34513453", "committedDate": "2020-07-22 15:06:31 +0530", "message": "Remove unused methods"}, {"oid": "3d9eedf4ed01addad2632492af1ef249c89abb01", "committedDate": "2020-07-22 18:59:03 +0530", "message": "Alter shared scope sql queries"}, {"oid": "5a5c75c761998ef327caf28a1a69394513aeb8f0", "committedDate": "2020-07-24 14:43:37 +0530", "message": "fixing https://github.com/wso2/product-apim/issues/8809"}, {"oid": "ae2cd231e604b260a65cb3517343dd248e6619b5", "committedDate": "2020-07-25 00:47:40 +0530", "message": "remove unused DAO methods and SQL queries. get scope key from scope-resource scope mapping table for api product resources. fix JWT and opaque token scope validation."}, {"oid": "f648e06532f4c2935dabadd02ca9a39addc7e06f", "committedDate": "2020-08-03 12:47:07 +0530", "message": "fix token issuers from config"}, {"oid": "146947ed3683d2430a0ef34b944d1b9fcbc3e344", "committedDate": "2020-08-03 23:28:58 +0530", "message": "able to delete application when km not in use"}, {"oid": "c3cad379a39665d21db7e7603a6be2eb6e3b83f7", "committedDate": "2020-08-07 16:12:57 +0530", "message": "fix Opaque token validation issue on websocket in distributed fix JWT doesn't contains application attributed and application uuid fix APIKey throttling"}, {"oid": "d78fee0a9e473bb6321f9e3446977344855a0874", "committedDate": "2020-08-19 13:31:02 +0530", "message": "Add update methods for api Policy"}, {"oid": "35c9483b3ea4812a849575c348102180aedb74e2", "committedDate": "2020-08-19 23:30:49 +0530", "message": "Refine code"}, {"oid": "e971726f2428e47a6a3bfafa26cfd1895f31cd7f", "committedDate": "2020-08-19 23:32:51 +0530", "message": "Remove unwanted methods"}, {"oid": "1788459dc274d1c9e95773443995d58c5c7ffbc8", "committedDate": "2020-08-20 00:12:55 +0530", "message": "Refine Code"}, {"oid": "24c7808a51f98927d3ae08c0f11edbb943ce4215", "committedDate": "2020-08-20 00:15:43 +0530", "message": "Remove unwanted queries"}, {"oid": "dad95bac1473d4a3456e7fe6c902d794b32a9293", "committedDate": "2020-08-20 00:24:11 +0530", "message": "fix db2 issue"}, {"oid": "527d760a98cb02cd90164e39397df5bd0996a44c", "committedDate": "2020-08-20 00:41:23 +0530", "message": "Update method Description"}, {"oid": "cea946a138945713c9af8c793cc218167525382f", "committedDate": "2020-08-20 10:56:24 +0530", "message": "use try with resources"}, {"oid": "e37cabc6b88b47586e44dd06001f42a8a9fac298", "committedDate": "2020-08-20 10:59:14 +0530", "message": "Refine imports"}, {"oid": "ac69c0fa8a7c202a9d45ac30e24258f8a757a95a", "committedDate": "2020-08-20 12:12:34 +0530", "message": "Address review Comments"}, {"oid": "f84c89555026d4a88bd5a2ea1618ab9771ed4518", "committedDate": "2020-08-20 12:20:35 +0530", "message": "Address review Comments"}, {"oid": "31a317949d5bfe926cc4dcdbc670648ac4656c11", "committedDate": "2020-08-20 12:21:13 +0530", "message": "remove newlines"}, {"oid": "9798d20e92d815ceb26391aff89a027114313fb2", "committedDate": "2020-08-20 13:26:02 +0530", "message": "Add Roll back to transaction"}, {"oid": "f48a836dcbd925885c9f995e38a33f7c5ebe8460", "committedDate": "2020-08-20 14:41:35 +0530", "message": "Merge pull request #9211 from Sarangan0219/api_policy_update"}, {"oid": "c58be459bc0f6087dc82f8a21612b950ab01b222", "committedDate": "2020-08-20 19:46:33 +0530", "message": "Ignoring inserting empty values to avoid error in DB2"}, {"oid": "4d82fb04ef90dab6edd3b28cce6e541a1f026a34", "committedDate": "2020-08-20 19:51:47 +0530", "message": "Merge pull request #9225 from renuka-fernando/db2-empty-custom-attrib-v6.7.192"}, {"oid": "4d95baf02a8331f1d8c75c77aa25e19e077c003b", "committedDate": "2020-09-24 17:53:12 +0530", "message": "fix https://github.com/wso2/product-apim/issues/8644"}, {"oid": "f87d6b2a5f9c30c88951cfacca3f1c8dbbbe25f7", "committedDate": "2020-10-18 14:54:58 +0530", "message": "Fix oracle 11g query issue"}, {"oid": "1d5b384287a379d1f283c68671c4ac430d29ddb4", "committedDate": "2020-11-17 11:37:01 +0530", "message": "Store APIs registry UUID to Database AM_API table"}, {"oid": "aeee44d2bebd5f884533a98eff602a64dcfddbe7", "committedDate": "2020-11-23 11:16:01 +0530", "message": "Fix Publisher V1 Rest Interface issues"}, {"oid": "90c485345e50aef950a396a8645b6b930bc7ee2e", "committedDate": "2020-11-26 19:23:22 +0530", "message": "Fix LC page loading"}, {"oid": "9f0131bd081bd512bb03b78fcb9aa50d04909692", "committedDate": "2020-11-30 18:03:34 +0530", "message": "Merge remote-tracking branch 'upstream/master' into reg-merge"}, {"oid": "a0b1f3bab1310a1d2ce24042819364ca0103929d", "committedDate": "2020-12-02 06:50:47 +0530", "message": "fix for https://github.com/wso2/product-apim/issues/9553"}, {"oid": "5ee1c9db916fbfea6df7dff3b7120adcd91d9b21", "committedDate": "2020-12-04 13:33:36 +0530", "message": "adding initial revision support implementation"}, {"oid": "c5f0dce495bd0bd70b2868910c01b755d2ae428f", "committedDate": "2020-12-14 09:55:11 +0530", "message": "adding changes to API revision retrieval path"}, {"oid": "551e8005cf73bc23547da10360e07c23ca635342", "committedDate": "2020-12-15 15:58:38 +0530", "message": "adding revision-deploy and revision-deployment mapping implementation"}, {"oid": "a9ed9f2065b948c187b1d854505ef37d2d21090b", "committedDate": "2020-12-17 08:21:51 +0530", "message": "adding undeploy-revision and removing deploy from api save/publish path"}, {"oid": "6212e0d1a79974db6cef329b6e32719d2d21b66f", "committedDate": "2021-01-04 17:38:08 +0530", "message": "adding revision restore and delete implementations"}, {"oid": "2809e66ce7558218fa0dd2ac5e74a4e82ff5fb83", "committedDate": "2021-01-05 12:51:49 +0530", "message": "Address Review Comments"}, {"oid": "8b4869163c4f604e352097c355057ed6b5901bc0", "committedDate": "2021-01-05 18:19:26 +0530", "message": "Use UUID to register an oauth App"}, {"oid": "d56d577f622bd982dbd9b5eed0c16e9418bd594e", "committedDate": "2021-01-06 16:10:27 +0530", "message": "adding revision implementation requested changes"}, {"oid": "10c140890f72638b1c497e5c33008a32a97b219a", "committedDate": "2021-01-06 18:05:45 +0530", "message": "Add depricate old version logic"}, {"oid": "fd8d3dc4ada8100a745c41795a894da514315544", "committedDate": "2021-01-07 10:51:08 +0530", "message": "Merge pull request #9455 from isharac/fix9553"}, {"oid": "086073a1a7dccb9ea8875cd81d5e6f351ad750b1", "committedDate": "2021-01-07 21:31:13 +0530", "message": "Add initial impl"}, {"oid": "dd47eef8e08d26d24704b2332f9646609e1e4a47", "committedDate": "2021-01-11 08:07:25 +0530", "message": "Merge remote-tracking branch 'upstream/master' into reg-merge-3"}, {"oid": "47f711d60c3a92f7318346b6260c2396c8c6a6b0", "committedDate": "2021-01-11 15:21:54 +0530", "message": "adding relevant error messages for Revision REST APIs"}, {"oid": "c7998c8b8ace9b82a97793eda9fc4a86f4388532", "committedDate": "2021-01-13 02:34:26 +0530", "message": "Merge pull request #9541 from Sarangan0219/PR_fixes"}, {"oid": "330961ad0ba118c67d745425169fab00775af54f", "committedDate": "2021-01-13 10:44:04 +0530", "message": "Merge remote-tracking branch 'upstream/master' into registry-abstraction-2"}, {"oid": "8cdef9ecd5233ee32b13a1abbe3f7be09f7ea0b3", "committedDate": "2021-01-13 16:34:21 +0530", "message": "Add db-level filtering to get API specific subscriptions"}, {"oid": "ba626a226b085de62a2a542e207759f77042cbf4", "committedDate": "2021-01-18 17:57:51 +0530", "message": "fixing issues related to revision deploy and deletion"}, {"oid": "0ac481c817e84ea23ce8210cd8ad44c93ab2e286", "committedDate": "2021-01-19 11:23:25 +0530", "message": "adding initial revision support implementation"}, {"oid": "f4f39620dffa3c496899beeef1be172fdafc364e", "committedDate": "2021-01-19 11:47:01 +0530", "message": "adding changes to API revision retrieval path"}, {"oid": "543b5603da0e399f3363e8bfea54ca1fec96ed5e", "committedDate": "2021-01-19 11:59:00 +0530", "message": "adding revision-deploy and revision-deployment mapping implementation"}, {"oid": "7b69a1ada06e4d06321188f8378fedb5fdb8f2ce", "committedDate": "2021-01-19 12:10:26 +0530", "message": "adding undeploy-revision and removing deploy from api save/publish path"}, {"oid": "0d912c09c96726bbf0e27ee0e0ed38822624c443", "committedDate": "2021-01-19 18:02:35 +0530", "message": "adding initial revision support implementation"}, {"oid": "92d20512a84cc86f69d46eb5e5eac6416a10f5eb", "committedDate": "2021-01-19 18:46:20 +0530", "message": "adding revision-deploy and revision-deployment mapping implementation"}, {"oid": "abd84c9f05339be8cc5666aba87e6917a4ec64b7", "committedDate": "2021-01-19 19:01:12 +0530", "message": "adding undeploy-revision and removing deploy from api save/publish path"}, {"oid": "95ed74bd63348ffa8f8763b291c37abb6014be01", "committedDate": "2021-01-19 19:06:06 +0530", "message": "adding revision restore and delete implementations"}, {"oid": "706c5446c342f7e820c9daedcccda10e31889ccf", "committedDate": "2021-01-19 19:15:52 +0530", "message": "adding revision implementation requested changes"}, {"oid": "36882218de10458d3a02f7beaeb3bc48d24219bb", "committedDate": "2021-01-19 19:19:26 +0530", "message": "adding relevant error messages for Revision REST APIs"}, {"oid": "11d01ff8c988dbec8c48763611e8f17fe86ffb91", "committedDate": "2021-01-19 19:28:35 +0530", "message": "fixing issues related to revision deploy and deletion"}, {"oid": "5c9c12770da52bdcf2d98f0e379c2316b9b9b2d1", "committedDate": "2021-01-20 15:35:33 +0530", "message": "fixing merge conflicts"}, {"oid": "6da602b252a0d9ac6b36b0b5f0d300d286ce738f", "committedDate": "2021-01-23 12:32:31 +0530", "message": "Fix mssql application pagination issue"}, {"oid": "a6a99e403ac5c2b9088fa80d8a664898d52b2d00", "committedDate": "2021-01-23 13:34:31 +0530", "message": "fixing revision related issues"}, {"oid": "81cd2c2f900fb19cc331a6d9e6fc0a1e77615a9c", "committedDate": "2021-01-28 19:29:19 +0530", "message": "fixing multiple scope attached resources revision issue"}, {"oid": "639fd82263f93ddf9ac5992474e3dd74c1982d34", "committedDate": "2021-01-29 18:36:17 +0530", "message": "add Initial Synapse GW related implementation"}, {"oid": "9e362b962b7368b72b7812b253fba07bf242d0ed", "committedDate": "2021-01-29 18:36:17 +0530", "message": "refactor deployment changes with revision"}, {"oid": "504a4339f8fc905fe8c3020aa17f2959d9c49087", "committedDate": "2021-01-29 18:36:17 +0530", "message": "remove unwanted code"}, {"oid": "fbcb31f8ce0879a7e6e05ac01515e230343550fb", "committedDate": "2021-02-02 10:38:55 +0530", "message": "Merge pull request #9616 from HeshanSudarshana/master-mssql-pagination-issue"}, {"oid": "f39ed1e5333a9182f3bae96a5b30ec0eee6bcbc9", "committedDate": "2021-02-03 18:07:28 +0530", "message": "Improve java docs of methods"}, {"oid": "3e3c7d15f00e8fc372fd48d5808fc68ed5a033a9", "committedDate": "2021-02-03 18:42:03 +0530", "message": "changing revision word working copy to current api"}, {"oid": "674fd53a7ace7bd49d7d71013297f7b959c303ed", "committedDate": "2021-02-03 18:42:03 +0530", "message": "fixing revision restore related issues"}, {"oid": "b59ee231fb1c227802aa699220c95dada756c4e8", "committedDate": "2021-02-07 14:54:59 +0530", "message": "Committed the db accesses"}, {"oid": "c254d66922dd3649955a81bd90eb2a2469b6e75e", "committedDate": "2021-02-08 13:02:54 +0530", "message": "adding initial API Product revision implementation"}, {"oid": "0466513ced0990fd6cf5d4b5cdba6b94e90851f2", "committedDate": "2021-02-08 15:36:44 +0530", "message": "Add web hook listing view for applications."}, {"oid": "8909acf3a816ab4b2855451e741438b2bdcc8125", "committedDate": "2021-02-08 15:38:52 +0530", "message": "Add mechanism to retrieve WH api endpoint URL for topic."}, {"oid": "22186e8526ab4a29aeb7c44c1d133dba67933547", "committedDate": "2021-02-09 12:58:28 +0530", "message": "Added java docs and reformatted the code"}, {"oid": "12603659047eb97a1f97baad3ce0e374cad39e0f", "committedDate": "2021-02-09 14:46:50 +0530", "message": "Merge pull request #9702 from hisanhunais/code-structure-improvement"}, {"oid": "079a0b5b4e2790827ce39fa6cc74d55b001f9763", "committedDate": "2021-02-10 10:47:30 +0530", "message": "Merge remote-tracking branch 'upstream/master' into api-revision-product2"}, {"oid": "901b1aedb5ecb81731476c8d7fe8e39a4919ef33", "committedDate": "2021-02-10 13:45:03 +0530", "message": "Fix issues in dev portal for async API's."}, {"oid": "90ed98d387fadcb0742e1a693873b8c385386f82", "committedDate": "2021-02-10 16:51:23 +0530", "message": "Merge pull request #9744 from 1akshitha/revision-ctl-support"}, {"oid": "b197d6ceb5aba15be2cf582514c43c00f1d86160", "committedDate": "2021-02-10 17:15:55 +0530", "message": "Add  Publisher API changes related to service catalog"}, {"oid": "149bbf10978d34160c3597031d6c45848639a9a7", "committedDate": "2021-02-10 17:15:55 +0530", "message": "Refactored & add serviceInfo to API model"}, {"oid": "6edafdd383561901c24f5f891a8da6ffa52eb297", "committedDate": "2021-02-10 17:15:55 +0530", "message": "Add reimport-service,createNewVersion resource impl"}, {"oid": "2e12fde4b12502f10d3444490375758fd032aff6", "committedDate": "2021-02-10 21:46:38 +0530", "message": "Refactored, add endpointConfig from ServiceInfo"}, {"oid": "8ee9a0184e32feda8dd68235ec68e670e83b572d", "committedDate": "2021-02-11 12:57:33 +0530", "message": "Merge remote-tracking branch 'upstream/master' into api-revision-product2"}, {"oid": "c101d6dc4bc2f190dbfc467dc9e264be7070752e", "committedDate": "2021-02-11 23:01:03 +0530", "message": "fixing revision product related issues"}, {"oid": "e9d78d34cb1ed8ca8ced8f1c4d92676c2c070465", "committedDate": "2021-02-12 01:54:49 +0530", "message": "Added the support to export the latest revision from ctl"}, {"oid": "fec4103c8916c964eb0179328be3880d484461f9", "committedDate": "2021-02-12 11:38:30 +0530", "message": "Refactor async api related backends in dev portal."}, {"oid": "f2a1d5394443e2bd1e5c1831be107182bce9aa58", "committedDate": "2021-02-12 14:17:23 +0530", "message": "Merge pull request #9580 from RakhithaRR/api-sub-db"}, {"oid": "18c3c6d3de9358f6e37a6287fd43d936c26e018f", "committedDate": "2021-02-12 23:12:56 +0530", "message": "fixing product revision issues"}, {"oid": "6cfb094a554904ddb6a2e667ee524c28efb6d886", "committedDate": "2021-02-13 11:12:51 +0530", "message": "Merge pull request #9776 from wso2/revision-product"}, {"oid": "41588e822a0097c6c2568999be24d4f72e589b43", "committedDate": "2021-02-13 16:28:43 +0530", "message": "Implement environment resource of Admin Rest API"}, {"oid": "09f103948a1b70d88e701fdcd30c0c1bb24b831b", "committedDate": "2021-02-13 20:55:44 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into dynamic-gateway-environments"}, {"oid": "3b7c6b3fddabaafdbf79e4a0030f1c3dc000790f", "committedDate": "2021-02-14 17:16:10 +0530", "message": "Refactor Apimgtdao and introduce STATUS column to AM_API table"}, {"oid": "99566c22d8b1e7771c770104997bcb2bbaa3c5a1", "committedDate": "2021-02-15 03:41:42 +0530", "message": "Add cross tenant subscription feature."}, {"oid": "c7c4a6059d318f5fffcf55f3dc9ffda18a661e43", "committedDate": "2021-02-15 05:26:57 +0530", "message": "Merge branch 'master' into asyncapi-feature"}, {"oid": "53847fbbf0177efa97d29ad2318bfa72b6cdc4d2", "committedDate": "2021-02-15 12:10:53 +0530", "message": "Add  Publisher API changes related to service catalog"}, {"oid": "7c620ef359348f3ad2464e92c339d93d304a67c5", "committedDate": "2021-02-15 12:13:14 +0530", "message": "Refactored & add serviceInfo to API model"}, {"oid": "c80d190fec8f6061fc395b51a2ea24d5c0a2d2a7", "committedDate": "2021-02-15 12:13:14 +0530", "message": "Add reimport-service,createNewVersion resource impl"}, {"oid": "670b671b6fac54b597ffb35181c947c60b613116", "committedDate": "2021-02-15 12:13:58 +0530", "message": "Refactored, add endpointConfig from ServiceInfo"}, {"oid": "576f442b48d1be5b7f82b1381f10852fcedf1fd3", "committedDate": "2021-02-15 12:13:58 +0530", "message": "Add reimport-service resource impl"}, {"oid": "095de1a413cf19c73aef4e3c98776f0dbbf284b2", "committedDate": "2021-02-15 12:16:08 +0530", "message": "Refactored and added DB scripts"}, {"oid": "fe9053e0a86eba24eab73ceadc0f1319dd6f7403", "committedDate": "2021-02-15 12:16:08 +0530", "message": "Update the DDL of API-service mapping table"}, {"oid": "95b99b161914f48446e97478d50c030387f805f1", "committedDate": "2021-02-15 13:32:58 +0530", "message": "Merge pull request #9774 from 1akshitha/ctl-revision-deploy"}, {"oid": "7724e600765912f417f577ff00cb2839487f8c30", "committedDate": "2021-02-15 13:48:19 +0530", "message": "Fix issues"}, {"oid": "1e3f42fad8f32bde433320025e9128d41260f349", "committedDate": "2021-02-15 15:24:51 +0530", "message": "Set Gateway Access URL when deploying API revision"}, {"oid": "ff27f283274725a007b04ce371811073f18108be", "committedDate": "2021-02-15 15:40:38 +0530", "message": "Merge remote-tracking branch 'upstream/master' into asyncapi-feature-fix"}, {"oid": "db38bf7d10336202a189db4950cfad710e50c6f9", "committedDate": "2021-02-15 16:13:14 +0530", "message": "Resolved conflicts"}, {"oid": "32dab0145d1eab627ea5362ff9c5e35672d82b3f", "committedDate": "2021-02-15 19:26:00 +0530", "message": "Resolved conflicts"}, {"oid": "b4e2b263566854fde8f73b05e09ecd763ed85d1b", "committedDate": "2021-02-16 19:44:26 +0530", "message": "Merge pull request #9793 from Arshardh/cross-tenant-master"}, {"oid": "0f70c5b0678af393f17d13c604a4fa27480ae5ef", "committedDate": "2021-02-16 21:30:34 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into asyncapi-feature-mergeable-with-master"}, {"oid": "cf2ce62a4d0fd8767e852640dcc0d9f53378b80d", "committedDate": "2021-02-17 16:55:54 +0530", "message": "Add backend implementations for event based throttling."}, {"oid": "795ed05735cb911d50127c3aa5426862c80c538e", "committedDate": "2021-02-17 17:46:25 +0530", "message": "Remove validating vhosts in an environment when PUT /environment environments of VHost can be changed, do no need to be equal with existing vhost values"}, {"oid": "9739e5ccaeba556ab0a3a4dd7bffc74169655b2d", "committedDate": "2021-02-17 20:12:00 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into dynamic-gateway-environments"}, {"oid": "d6eec7f51f2599a1c5ef6a0a7053f283b42c007a", "committedDate": "2021-02-18 13:04:12 +0530", "message": "Preserve serviceInfo when creating new version"}, {"oid": "3f8c6c4ee08310022cce5a8ba4d7582e0f749c09", "committedDate": "2021-02-18 22:42:30 +0530", "message": "fix application registration workflow"}, {"oid": "fce1baa958fe94cd81ba3c0a344ebcbb0b46166e", "committedDate": "2021-02-19 12:54:35 +0530", "message": "Merge remote-tracking branch 'upstream/master' into rebaseMasterThrottling"}, {"oid": "1d0b8906df0b92b4a2cf958bf817be908f4b5494", "committedDate": "2021-02-20 08:32:40 +0530", "message": "Fix issue in reimport-service"}, {"oid": "80f1a070772eb4df672e25a22220da1a853da020", "committedDate": "2021-02-20 08:33:28 +0530", "message": "Merge remote-tracking branch 'remotes/origin/master' into service-catalog-apis"}, {"oid": "b78dd1722a67a856c25a913abe2b983fe8057fbd", "committedDate": "2021-02-21 13:52:08 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into dynamic-gateway-environments"}, {"oid": "66731b1213c00c7423e4aca7a278d8e875bc4166", "committedDate": "2021-02-22 11:54:05 +0530", "message": "Add name and version to serviceInfo model"}, {"oid": "617962f8007329c5347ab29c27f26c83f8a3f6b9", "committedDate": "2021-02-22 15:43:24 +0530", "message": "Update dev portal Rest API"}, {"oid": "30635470a1c94c3fa8ab79a1c95c80555b1c8f4a", "committedDate": "2021-02-23 12:30:45 +0530", "message": "Adding comment function in ApisApiServiceImpl.java completed"}, {"oid": "818f85d3adad9b9e99479ced07c0107393b761e9", "committedDate": "2021-02-23 12:30:45 +0530", "message": "getComment function modified with the sql query"}, {"oid": "77fe77c1976278f5dda2942ae37c41dacf969f8a", "committedDate": "2021-02-23 12:30:45 +0530", "message": "getComments method modified"}, {"oid": "9a64fecec54f5a49119fa80d6d68bee1165bc9b8", "committedDate": "2021-02-23 12:30:45 +0530", "message": "Bug fixes"}, {"oid": "2565bfd1b0fccb468d4a5f16b54f6203a40587ca", "committedDate": "2021-02-23 12:32:12 +0530", "message": "Revert \"Changed PostRequestBodyDTO-->AddCommentDTO and putRequestBodyDTO-->updateCommentDTO\""}, {"oid": "45b267cd4eec77d1a6de13c4df685559c851779a", "committedDate": "2021-02-23 12:32:41 +0530", "message": "Complete Adding new comment"}, {"oid": "aebd631d55ea57f4155583eef6ac5bef9fa0dd6a", "committedDate": "2021-02-23 12:32:42 +0530", "message": "(Partially completed) Adding new comment functionality"}, {"oid": "f1e9a0de90834e0080ed36d656eeef43a371afae", "committedDate": "2021-02-23 12:32:42 +0530", "message": "Updated h2.sql databases,DAO layer and queries"}, {"oid": "28297ad12a62557aa0fc3d77bef0196ca954a75b", "committedDate": "2021-02-23 12:32:42 +0530", "message": "Getting a single comment with replies function completed"}, {"oid": "1c6d728e70a73c5eebabf95d07566dd4ff5b215a", "committedDate": "2021-02-23 12:32:42 +0530", "message": "Get all comments completed(partially)"}, {"oid": "e9c37b79234c40a6d681e768c1b34dfd006a0c17", "committedDate": "2021-02-23 12:41:49 +0530", "message": "Removed unnecessary comments & changed the order of some functions"}, {"oid": "13a3987ba0c39cfb034db8554029f0d791f6fe7b", "committedDate": "2021-02-23 12:41:49 +0530", "message": "Update getting all the comments(any number of nesting levels possible)"}, {"oid": "325cb7070cf05b2954e96446eaca001ad4c78317", "committedDate": "2021-02-23 12:41:49 +0530", "message": "Modified single comment get"}, {"oid": "0fa0d59d00cf87f174d6ce6bb5eeef7aed1f71c7", "committedDate": "2021-02-23 12:41:50 +0530", "message": "Update Delete comment"}, {"oid": "a7929811814af5330ca643361e4a9377ef86705e", "committedDate": "2021-02-23 12:41:50 +0530", "message": "Removed unnecessary comments and code segments"}, {"oid": "8b1202d7feaa0636b360e5230485ff794aff37c0", "committedDate": "2021-02-23 12:41:50 +0530", "message": "Added method overloading to deleteComment function"}, {"oid": "64f4ca62d8c8fb5939b4a99b25dc3c42f792ed0e", "committedDate": "2021-02-23 12:41:50 +0530", "message": "Add comment editing functionality"}, {"oid": "83af86dc817920abcda1986cf3dbf33f428dbf7f", "committedDate": "2021-02-23 12:41:51 +0530", "message": "Modifications(After code review)"}, {"oid": "bc5d6e9c1f19d0d9f8227cde149a95e143ce6a0c", "committedDate": "2021-02-23 12:41:51 +0530", "message": "Fix DB connection reusing issue in getComments()"}, {"oid": "72f92642673ab12ef17a5744e14c07a6672e8e9b", "committedDate": "2021-02-23 12:41:51 +0530", "message": "Modify DB, Add error responses, code reformat"}, {"oid": "eaf1db66613e19249af31531cb9755464ed25630", "committedDate": "2021-02-23 12:41:51 +0530", "message": "Refactor DAO functions"}, {"oid": "a58b248c6681dc3b4ff814137b346a0134b0656a", "committedDate": "2021-02-23 15:08:51 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into asyncapi-feature"}, {"oid": "51dfa562f8fdccc627cebd59dab69c4a1c805036", "committedDate": "2021-02-23 19:35:15 +0530", "message": "Merge pull request #9904 from tmkasun/nested-comment-new-tmkasun-backup"}, {"oid": "8b56851663554865bad62d7ac549af4a1f58f55b", "committedDate": "2021-02-24 13:14:18 +0530", "message": "replace database queries with getting by index to getting by column name"}, {"oid": "bb657c5d0777d0f0d70f0af26403569fdef202a6", "committedDate": "2021-02-24 13:21:11 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into dynamic-gateway-environments"}, {"oid": "78474679f7c590a70a9a2103b0a985fd47a337a7", "committedDate": "2021-02-25 13:35:43 +0530", "message": "Merge pull request #9891 from AnuGayan/asyncapi-feature"}, {"oid": "4ab96864b59989e8a4887f56e64ac6440a790b8f", "committedDate": "2021-02-25 15:16:05 +0530", "message": "fixing oracle db scripts related issues"}, {"oid": "21f4d4c0dd394b956d39936d7b435626d5159b39", "committedDate": "2021-02-25 16:04:15 +0530", "message": "fix status issue"}, {"oid": "c93bf75fce7e6a087ca72cb0914f340182ca8f20", "committedDate": "2021-02-25 16:04:15 +0530", "message": "Add Internal Key Authenticator"}, {"oid": "3297d5b4a42916e3360f5e351d7add9a8cd7e5a0", "committedDate": "2021-02-28 17:44:18 +0530", "message": "add unit test cases"}, {"oid": "ca6f9689270d66ff4f004bdf0c9254bd624d183b", "committedDate": "2021-03-01 13:39:14 +0530", "message": "Merge pull request #9868 from tharindu1st/status-fix-1"}, {"oid": "a0b52671113f3bd195d0dc95b6fb434b2bc782a6", "committedDate": "2021-03-01 17:53:53 +0530", "message": "fix API Status not show correctly in revision view"}, {"oid": "df101175d483dbf124f8d967984e33838e9086d6", "committedDate": "2021-03-02 11:28:22 +0530", "message": "move query to constant"}, {"oid": "8b35877869e8abaf117f3ca08136cdc0104f6299", "committedDate": "2021-03-07 22:03:45 +0530", "message": "Complete Pagination"}, {"oid": "e7fbe280d33ec6835825f2ae8d5e60c93198035f", "committedDate": "2021-03-08 14:58:05 +0530", "message": "Set and resolve default vhost with null DB value"}, {"oid": "e0b18e115a7c98c54c4e9ac9be6b5eeb55d9fe44", "committedDate": "2021-03-08 18:58:30 +0530", "message": "remove unwanted code"}, {"oid": "1d80354768115b9ae80b3f58dc74d7d13043f050", "committedDate": "2021-03-08 18:58:30 +0530", "message": "fix show correct published default version in devportal"}, {"oid": "c2e9bd5f5fb85bc06825be5cf7949ae776d4e26f", "committedDate": "2021-03-10 23:23:34 +0530", "message": "Change deleting comment functionality"}, {"oid": "9a605e77eb8e50201f58509860957566ce6fe470", "committedDate": "2021-03-11 09:34:46 +0530", "message": "Merge pull request #9990 from renuka-fernando/set-null-vhost"}, {"oid": "906c32752979c14a7c75386430463d65fe8eba14", "committedDate": "2021-03-11 15:21:06 +0530", "message": "Merge branch 'master' into nested-comment-new-1"}, {"oid": "17e4589d1824525964fef46e2bbd9c0f404e4001", "committedDate": "2021-03-11 21:23:22 +0530", "message": "Fix mssql errors"}, {"oid": "f44979b06b2969b08c9ff1ddb68e0c79162ae472", "committedDate": "2021-03-12 15:29:39 +0530", "message": "Remove Microgateway labels Rest API"}, {"oid": "2ed02505c772c3f36b739b8e4755acfde462704a", "committedDate": "2021-03-14 20:30:38 +0530", "message": "Enable DB level pagination for H2, MSSQL"}, {"oid": "66a313836f05bb08b14776bf4665b546d3dbd994", "committedDate": "2021-03-14 22:26:08 +0530", "message": "Add sql query strings for DB2,Postgre and Oracle"}, {"oid": "b283978f0713b2d38407e4982b86af8c60746092", "committedDate": "2021-03-15 10:55:44 +0530", "message": "remove unused code"}, {"oid": "ccfb13901639a4811c6291d14b04eaff1d1d351c", "committedDate": "2021-03-15 11:56:54 +0530", "message": "Update split condition to support app names with dashes"}, {"oid": "323d25e7587d04be4a757b3cb97af8a4e1e36a36", "committedDate": "2021-03-15 16:41:05 +0530", "message": "Merge pull request #10014 from RakhithaRR/master-10117-10029"}, {"oid": "3537499f03e8416547eb82c3ed97e88198f57b71", "committedDate": "2021-03-15 20:43:03 +0530", "message": "Changes requested by @malinthaprasan"}, {"oid": "55f61a98c6ec65bbc790ffcfd70de6e7954c4148", "committedDate": "2021-03-15 20:54:44 +0530", "message": "Reformat and rearrange code"}, {"oid": "0d269012d8b89a8d8673811db931d1ff60541e35", "committedDate": "2021-03-15 21:52:24 +0530", "message": "Merge pull request #10008 from tharindu1st/git-10237"}, {"oid": "7bfbaaa0239fb930bffdb436cba03ef48a1aa356", "committedDate": "2021-03-17 11:50:02 +0530", "message": "Merge branch 'master' into nested-comment-new-1"}, {"oid": "8e6b0ec6a9febfaea3659cb8733df664fb3b8db8", "committedDate": "2021-03-17 17:09:39 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into remove-mg-label"}, {"oid": "2041cbda12d76db1989681abd4326778aa798f79", "committedDate": "2021-03-18 06:51:00 +0530", "message": "Populate VHost in the DB table 'AM_GW_API_DEPLOYMENTS' when deploying a revision"}, {"oid": "b5bb4e7b4fe98a15592f7f5478c2fb2f854dd62d", "committedDate": "2021-03-19 13:39:39 +0530", "message": "Merge pull request #10021 from thisaltennakoon/nested-comment-new-1"}, {"oid": "ea286363e63719c04f376fc0ae0b3bf7ef3f91df", "committedDate": "2021-03-21 06:34:13 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into mg-deployment-vhost"}, {"oid": "e00128f0d50cc0246c56093f2ca3d82137b9b456", "committedDate": "2021-03-22 11:09:58 +0530", "message": "fixing non-exiting revision deployment issue"}, {"oid": "45425989de16be06f06b33a343d4de3b13e2c4dd", "committedDate": "2021-03-23 06:52:16 +0530", "message": "Convert auto generated column name for Environments in PostgreSQL fix wso2/product-apim#10402"}, {"oid": "a2553ee71d0c1a13580af056ab67b30a3f7465ae", "committedDate": "2021-03-23 14:04:22 +0530", "message": "add api product usage check when deleting API"}, {"oid": "8536b0cf129b790dff73a7f494c53b10467de378", "committedDate": "2021-03-23 15:37:44 +0530", "message": "adding REST api to support displayOnDevportal change for deployments"}, {"oid": "4d150c0d70f1242fc1f86a555d42da472303a8dd", "committedDate": "2021-03-23 16:39:17 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into mg-deployment-vhost"}, {"oid": "4a28d613ce22c151aac15dde93f4de62e53dc465", "committedDate": "2021-03-24 09:56:39 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into postgress-environments"}, {"oid": "f6741571a8940c10cf607be9039f2a3635ce444f", "committedDate": "2021-03-24 10:06:28 +0530", "message": "Merge pull request #10076 from CrowleyRajapakse/myLatest4"}, {"oid": "a4decff8ec39d1b826c3911bea8db06e57ff8bab", "committedDate": "2021-03-24 15:04:13 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into postgress-environments"}, {"oid": "3aad2cac80970216ddcf63258bc5bc2efdb0e731", "committedDate": "2021-03-25 11:00:25 +0530", "message": "Fix product-apim/issues/10404"}, {"oid": "51f17425c2c765e9ed3efc852783dc72451971ad", "committedDate": "2021-03-25 11:00:25 +0530", "message": "Fix review comments"}, {"oid": "7e800609a3c59211562d3adec4cbd14a15751bc3", "committedDate": "2021-03-25 13:35:19 +0530", "message": "Merge pull request #10047 from renuka-fernando/mg-deployment-vhost"}, {"oid": "cbe0c26ba6d16f407f47ac86daf81fb46960d23e", "committedDate": "2021-03-25 13:46:27 +0530", "message": "fixing index name too long issue"}, {"oid": "7bba3023100b62b409d03d252d0f28594ca6a137", "committedDate": "2021-03-25 14:15:47 +0530", "message": "Fix cross tenant unsubscribe issue.."}, {"oid": "d83ad3cf6780e6d63060dc80f5eded8bc4eda23a", "committedDate": "2021-03-25 15:47:14 +0530", "message": "Merge pull request #10107 from uvindra/master"}, {"oid": "b65276e0d4b36f38a44cd989bd9ba4457b2cf24c", "committedDate": "2021-03-25 15:48:58 +0530", "message": "Merge pull request #10088 from CrowleyRajapakse/myLatest4"}, {"oid": "a4660d9abbc4743739e224605d1cdda47a5ca50b", "committedDate": "2021-03-25 15:57:48 +0530", "message": "fix multiple issues resolves #https://github.com/wso2/product-apim/issues/8804 resolves #https://github.com/wso2/product-apim/issues/10101"}, {"oid": "71fe02147b55256a3434adbcfe56f0132225e4c2", "committedDate": "2021-03-25 16:21:38 +0530", "message": "Merge pull request #10091 from tharindu1st/git-10237"}, {"oid": "88b36c4e06902bf090d6e14fcffcbbbdee836f55", "committedDate": "2021-03-25 16:53:30 +0530", "message": "fix not including create_mode"}, {"oid": "5e062b024d7031f9325b4629760bfada9dcd51f6", "committedDate": "2021-03-25 17:27:06 +0530", "message": "Merge pull request #10070 from renuka-fernando/postgress-environments"}, {"oid": "a3033a0b3dfd86d93229838645c22380929387c1", "committedDate": "2021-03-25 17:28:25 +0530", "message": "Merge pull request #10116 from tharindu1st/git-10237"}, {"oid": "34f834e846eb08faa3f02e3a22bdefa0a4a4b4b2", "committedDate": "2021-03-26 08:47:33 +0530", "message": "Change getNString to getString when fetching STATUS column value"}, {"oid": "aa9d28cd594a2a6d1931f221f12b3163a777f267", "committedDate": "2021-03-29 10:40:39 +0530", "message": "Merge pull request #10090 from chamilaadhi/cross-tenant"}, {"oid": "af575eb519af497779cc50a92d9d28e3023d1cab", "committedDate": "2021-03-31 19:52:34 +0530", "message": "Fix issue in application listing in admin portal"}, {"oid": "34b06ca9f9a7d301ed63a359122430418b56af8b", "committedDate": "2021-04-01 11:59:22 +0530", "message": "Support application search with sortby/sortorder"}, {"oid": "30e6a9a5ebe290d5e9c8f18718177cea31eae722", "committedDate": "2021-04-02 10:11:43 +0530", "message": "fix https://github.com/wso2/product-apim/issues/10713 Revision numbers get altered at server restart"}, {"oid": "31ccb93c1561952dd93043f8a80484b2bd9121c2", "committedDate": "2021-04-02 10:12:05 +0530", "message": "Fix issue in oracle"}, {"oid": "6f52960b3480ca09e048bc2d4fdf6387984a9712", "committedDate": "2021-04-02 15:25:16 +0530", "message": "Merge pull request #10198 from tharindu1st/module-refactor"}, {"oid": "eb5480f6810f52bf2116ed476c6bdfd0159db7bf", "committedDate": "2021-04-04 20:58:46 +0530", "message": "Fix API Tier Change in revision"}, {"oid": "4d92bd9631d93d6f2f17615725ee998485c42f6d", "committedDate": "2021-04-05 02:26:35 +0530", "message": "add restore revision support for api tier"}, {"oid": "e03dfd2b92e99d6c04ebac06a760e8d13579710d", "committedDate": "2021-04-09 16:19:47 +0530", "message": "Fix https://github.com/wso2/product-apim/issues/10805 (#10268)"}, {"oid": "fd41a9f1a1c9856f1ef17550be29960c616d2da5", "committedDate": "2021-04-10 12:22:57 +0530", "message": "add applicationUUID,apiUUID into SubscriptionEvent"}, {"oid": "7c0c85a8f81e73bae807395d605a56dc6ba5f416", "committedDate": "2021-04-10 12:22:57 +0530", "message": "fix unit test cases"}, {"oid": "3dc7a33284ff702c04efa97554be3c74255570be", "committedDate": "2021-04-10 18:47:46 +0530", "message": "add subscriptionUUID"}, {"oid": "4d77b759feac5c08b9df38ac7973d376f1872964", "committedDate": "2021-04-10 22:40:17 +0530", "message": "initial LC based permission validation"}, {"oid": "f423d9624811f2166510b799f7b86efb74bff021", "committedDate": "2021-04-10 22:42:13 +0530", "message": "resolve conflicts"}, {"oid": "55d4ab10001541de3b1f2dea03308a159c07c011", "committedDate": "2021-04-11 01:17:29 +0530", "message": "code style fix"}, {"oid": "f7823e37803fc31d2fbeeeda2dc2fc0d6e218499", "committedDate": "2021-04-11 07:51:29 +0530", "message": "adding missing columns"}, {"oid": "7c469008d4b3d4f84db689ccd263bbc7e6e23e89", "committedDate": "2021-04-12 00:27:20 +0530", "message": "resolve conflicts"}, {"oid": "98e65bd39db61f4a56d5aab83c2ccc4f25b4fa6c", "committedDate": "2021-04-12 17:20:46 +0530", "message": "Fix issue in add/edit subscription policy"}, {"oid": "275116d7eb6f6c5fd7ea1ade1cbb4355eea952b4", "committedDate": "2021-04-12 17:39:53 +0530", "message": "Resolved conflicts"}, {"oid": "e6faf83b634968c0192801abd2474dd5a9402495", "committedDate": "2021-04-15 19:16:49 +0530", "message": "fix for wso2/product-apim/issues/11011 subscription issue"}, {"oid": "ee4e1cdabe8c24f67c56671969f2bc71ff0b86e5", "committedDate": "2021-04-16 20:24:58 +0530", "message": "fix publish issue when no versions"}, {"oid": "292f71d267ad339cf16bd2722dae88ec0ea0c5d8", "committedDate": "2021-04-19 22:12:51 +0530", "message": "Fix Internal key throws analytics errors Fix Cache Mediator not working when JWT enable. Able to generate internal key for revision. API Product Tier not revisioned."}, {"oid": "d05524232d9321ae49f076c8494eff3d2da3b7d3", "committedDate": "2021-04-20 23:12:04 +0530", "message": "fix https://github.com/wso2/product-apim/issues/11085"}, {"oid": "0a50f78a12ba055f18fafe5a41554a1ff383d34d", "committedDate": "2021-04-21 13:42:29 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into 4.0.0-error-code"}, {"oid": "8aa76be3c2dce618267e5bcee909cfdad7317dd2", "committedDate": "2021-04-21 21:12:12 +0530", "message": "fix deleting application issue for cross tenant subscription."}, {"oid": "3565f87f5736194abe681b56886360698bf1f94d", "committedDate": "2021-04-21 21:55:45 +0530", "message": "Update components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java"}, {"oid": "4cd2fceab81827dcf439ca54ea4355b144d6bedf", "committedDate": "2021-04-22 01:30:26 +0530", "message": "fix issue of not removing consumer keys from inmemory map when cross tenant app is deleted"}, {"oid": "7be0bbfaefd6300527684e313b48f4098a2824fe", "committedDate": "2021-05-14 21:31:10 +0530", "message": "Add initial refactoring to accommodate organization in devportal application"}, {"oid": "175b2824d5a1a38787b05c1e35473675992e1331", "committedDate": "2021-05-17 17:26:21 +0530", "message": "Merge branch 'master-org-refactor' into master-org-refactor-initial"}, {"oid": "8889c5298da8cecb683abc7de6e69aa3d20054c2", "committedDate": "2021-05-18 10:59:36 +0530", "message": "deleteAPI flow"}, {"oid": "9f7f2ae100118bc607c6abaf12cc8f9fe95858d4", "committedDate": "2021-05-18 13:53:05 +0530", "message": "Incorporate organization in createAPI"}, {"oid": "60d2f6fff07afc6168b157932b6b259a24934e2a", "committedDate": "2021-05-18 15:53:17 +0530", "message": "Merge other changes"}, {"oid": "260f8518209f88fe62d1bf9af2467ca9fe06db46", "committedDate": "2021-05-18 18:00:16 +0530", "message": "Remove the use of APIIdentifier and replace with UUID 1"}, {"oid": "7fa1ca6c0c8f041bf5c8201ece5f1a263bdfa84f", "committedDate": "2021-05-18 18:00:16 +0530", "message": "Remove the use of APIIdentifier and replace with UUID 2"}, {"oid": "5f06a29e90d39586fb6bd4e059c5390d0fd29bdf", "committedDate": "2021-05-18 18:00:16 +0530", "message": "Add review comments"}, {"oid": "c33454de0bd37735747f1d36fd8dc80bd75acbde", "committedDate": "2021-05-18 18:02:15 +0530", "message": "Fix revision and product issues"}, {"oid": "6239eabdc9312370e9e70516c16d5ac6e30a1701", "committedDate": "2021-05-19 06:09:43 +0530", "message": "Fix comment loading issue for revisions"}, {"oid": "22acd3b89b629728fefbd3474664d99273d2b97d", "committedDate": "2021-05-19 08:31:26 +0530", "message": "Merge pull request #10487 from tharikaGitHub/master-org-refactor"}, {"oid": "ad7a1ff4300e2d63550b03a771689da04829c0ac", "committedDate": "2021-05-19 09:42:32 +0530", "message": "Merge pull request #10498 from senthuran16/master-org-refactor-initial"}, {"oid": "cf8e3447cad724d4312760a603c1e1e20e5c9687", "committedDate": "2021-05-19 14:01:18 +0530", "message": "Persistence layer changes after db changes"}, {"oid": "c53f94a749ea7197b022ee0cdc76f44506b80012", "committedDate": "2021-05-21 09:40:35 +0530", "message": "Add organization when publishing the API"}, {"oid": "7ced8244ce46466731f6a524551c7934223b8bfe", "committedDate": "2021-05-21 10:19:08 +0530", "message": "Merge pull request #10520 from senthuran16/master-org-refactor-subscriptions-new"}, {"oid": "d8f5c7743288fa8fd990698190e4035d00ef160f", "committedDate": "2021-05-21 17:18:14 +0530", "message": "Incorporate organization in updateAPI"}, {"oid": "3989f4605b7908204c677211809e4f28e5e65a23", "committedDate": "2021-05-21 19:32:24 +0530", "message": "Introduce organization in methods related to SubscriptionsApiServiceImpl"}, {"oid": "281a7676b51fd28941fb0471e645aef47cff7629", "committedDate": "2021-05-21 19:51:48 +0530", "message": "Merge branch 'master-org-refactor' of https://github.com/wso2/carbon-apimgt into master-org-refactor-subscriptions-new"}, {"oid": "c0d1633af6020e99576e663cb06a81f329640cc9", "committedDate": "2021-05-24 08:28:57 +0530", "message": "Merge pull request #10529 from Shakila/local-master-org-refactor"}, {"oid": "16c7c48134d09fa2dab6b465747b2c4638924691", "committedDate": "2021-05-27 21:03:31 +0530", "message": "Add organization to API Categories"}, {"oid": "a85682c017e6fb7f72ae168e7f018b40a04bda01", "committedDate": "2021-05-28 10:01:44 +0530", "message": "Remove APIIdentifier from getAPIUsageByAPIId and getAllAPIUsageByProviderAndApiId"}, {"oid": "14bb927bcc7c41a2d8707d01075f5b2fca93d030", "committedDate": "2021-05-28 10:01:44 +0530", "message": "Remove APIIdentifier from addLocalScopes"}, {"oid": "4b195a2531f9ce5a37c582d4eb550ab6ce207e24", "committedDate": "2021-05-28 10:01:44 +0530", "message": "Remove APIIdentifier from getAPIContext"}, {"oid": "ef8cf5cb3701f12b21aa179bff244ef8e4ba080d", "committedDate": "2021-05-28 10:01:44 +0530", "message": "Fix OrgId related changes in update API path"}, {"oid": "edd56eceef061b5f511f89d46c50a33efa114eab", "committedDate": "2021-05-28 10:45:35 +0530", "message": "Merge pull request #10539 from senthuran16/master-org-refactor-subscriptions-new"}, {"oid": "4af1eed5796e14bf3e5d6bbbff606d0822077dc4", "committedDate": "2021-05-28 10:47:17 +0530", "message": "Add APIIdentifier and orgId changes in Publisher"}, {"oid": "5f86604448c5fccf9a323eb88b0e4949c75f800f", "committedDate": "2021-05-28 10:47:17 +0530", "message": "Remove APIIdentifier from deleteAPI path in publisher"}, {"oid": "e939713468ce4f410e84d4810c5d464181181ce0", "committedDate": "2021-05-28 10:48:40 +0530", "message": "Add APIIdentifier changes"}, {"oid": "7b8b863401130c288f4cd9e1ae8cf83a7e9a85d8", "committedDate": "2021-05-28 11:01:11 +0530", "message": "Add APIIdentifier fixes for get UUID by identifier"}, {"oid": "266d825a94b8053852a181f98470622a01644913", "committedDate": "2021-05-28 11:04:53 +0530", "message": "Add APIIdentifier changes"}, {"oid": "086ec0b73dddcfc594da0ac2edcb3bafd3471978", "committedDate": "2021-05-28 11:06:29 +0530", "message": "Fix get lightweight api by identifier"}, {"oid": "2fc80fbd5f01c3f41f9007017d87ca402c7af443", "committedDate": "2021-05-28 11:06:29 +0530", "message": "Change lifecycle status method"}, {"oid": "4d96c0234aff22ade1b47363ca2ce2f5fd032aa6", "committedDate": "2021-05-28 11:07:50 +0530", "message": "Add identifier fixes"}, {"oid": "7cdd19303a7ab3282563eb2e9e0d928e0fe2dbdc", "committedDate": "2021-05-28 12:55:45 +0530", "message": "Merge pull request #10541 from tharikaGitHub/master-branch-with-all-my-fixes"}, {"oid": "dedc559483dad207403a41179bec158f50cdf301", "committedDate": "2021-05-31 20:30:39 +0530", "message": "Add identifier to UUID fixes for consumer impl"}, {"oid": "f0b8a4f6227dbfde536e63e8d2ff077409bdda73", "committedDate": "2021-05-31 20:30:39 +0530", "message": "Fix test failure"}, {"oid": "cae5f36f84914ce7b0c8d660fed4143c2c1327b7", "committedDate": "2021-06-01 10:05:37 +0530", "message": "Modified with Organization"}, {"oid": "aa62cae284a3335e5df993a85c68a59b612855b6", "committedDate": "2021-06-01 11:42:03 +0530", "message": "Merge pull request #10550 from Shakila/local-master-org-refactor"}, {"oid": "c8d6dc6465e8614d344677a21323c8bdbf556760", "committedDate": "2021-06-01 17:49:11 +0530", "message": "Add organization to ApiProjectDto"}, {"oid": "87be64e695b86bd5bcc444b18d570b49df8f78f7", "committedDate": "2021-06-01 20:06:26 +0530", "message": "Fix integration test failures for product"}, {"oid": "caf9874bd2bf1a8b83499a6b0125f9acddb60b9a", "committedDate": "2021-06-02 07:28:58 +0530", "message": "Merge pull request #10558 from tharikaGitHub/master-branch-with-all-my-fixes"}, {"oid": "f12d5e8669a0f9a3409c4ccd25401e41fc6e9c60", "committedDate": "2021-06-02 08:47:39 +0530", "message": "Merge pull request #10556 from GDLMadushanka/ApiProjectDto"}, {"oid": "c1d321ef0d3793b917ac3d547d80ddf7128d3abf", "committedDate": "2021-06-04 11:45:17 +0530", "message": "Adding doc comments"}, {"oid": "37158abec84c566087fdcf7e29c9fd27849a9f6c", "committedDate": "2021-06-04 19:50:49 +0530", "message": "Remove references to tenant ID in API Categories"}, {"oid": "4566972ddcbbc39e0d5261878d826b7a0f9bec15", "committedDate": "2021-06-05 06:27:52 +0530", "message": "Add try with resources"}, {"oid": "ced1206522a10c34f6bada974c1609f88631b831", "committedDate": "2021-06-06 14:46:04 +0530", "message": "Remove unused isDuplicateContextTemplate() method in APIProvider"}, {"oid": "3286147bbd50babd1b8206c6286543a81850ad36", "committedDate": "2021-06-06 15:03:32 +0530", "message": "Fix connection in getUUIDFromIdentifier method for products"}, {"oid": "bf76479fa0d4e67c9c01abe7a77cf792acb8912a", "committedDate": "2021-06-09 15:08:50 +0530", "message": "reduce query counts for benchmark tests"}, {"oid": "e6213773cfdf66f3d777f2a130629120e339fbab", "committedDate": "2021-06-09 20:51:54 +0530", "message": "Fix api category issue"}, {"oid": "a782efc9690c087ea20a65238a391c5eb3992e26", "committedDate": "2021-06-09 23:53:05 +0530", "message": "Add functionality to skip key manager connector configs if EXCHANGED token type"}, {"oid": "cea188f5e316cd03b8166257d76f2d5793df7d24", "committedDate": "2021-06-09 23:53:05 +0530", "message": "Correct assigning the TOKEN_TYPE from results set when retrieving"}, {"oid": "00564d688d9e18d58f2cca21583981c678901c08", "committedDate": "2021-06-09 23:53:05 +0530", "message": "Update IDP tables when adding IdP with EXCHANGED tokenType"}, {"oid": "d2aa9f09f34f122575072d83a28dfdfa96afb5b2", "committedDate": "2021-06-11 12:31:54 +0530", "message": "Merge pull request #10593 from wasuradananjith/external-idp-master"}, {"oid": "47a5d8ec00f3361d11dcb504ee35e0c03a93eafe", "committedDate": "2021-06-15 08:45:10 +0530", "message": "Update db scripts and function names with orgs  related to key managers"}, {"oid": "562d0b88a4b31e53577543274080fb82473520bf", "committedDate": "2021-06-15 08:45:10 +0530", "message": "Refactor tenantDomain to organization in KeyManagerConfigurationDTO"}, {"oid": "c9946e15e7881a39020c6497b1891507377a6632", "committedDate": "2021-06-18 15:14:37 +0530", "message": "Fix cleanUp integration test failure"}, {"oid": "9865dd06b8f0cbc4cd4a2e06fd45b232518ab06b", "committedDate": "2021-06-28 11:26:29 +0530", "message": "Allow changing API Name in Choreo during API update"}, {"oid": "9f250644675dcd0f135094ec2111cfbd0d54d87c", "committedDate": "2021-06-28 11:26:29 +0530", "message": "Removed wildcard import"}, {"oid": "d055cfd99c07e595582649d597fbeb191f73beba", "committedDate": "2021-06-28 11:26:29 +0530", "message": "Fix issue with choreo change API Name"}, {"oid": "38b856283e50484e7a0502836addb574d435226b", "committedDate": "2021-06-28 11:26:29 +0530", "message": "Add review comments"}, {"oid": "6b507efb6aa225ecb1186968b15eebfec5d72529", "committedDate": "2021-06-30 11:44:35 +0530", "message": "Fix review comments"}, {"oid": "e2bc587420ddb2859ae2d1afe0c94d747468529d", "committedDate": "2021-06-30 12:55:57 +0530", "message": "Remove unwanted line"}, {"oid": "9612445076e8c142975fd084a7c5d0053c0c1202", "committedDate": "2021-07-15 02:30:41 +0530", "message": "Fixing wso2/product-apim#11417"}, {"oid": "fbd5378f40fd4444d655dccb2f3d4cdcce24152f", "committedDate": "2021-07-15 02:33:36 +0530", "message": "Fixing wso2/product-apim#11246"}, {"oid": "307192fc9036b537b359ceb2b1a361e34e1231ce", "committedDate": "2021-07-19 09:22:14 +0530", "message": "support successful deployment info"}, {"oid": "8fd493c1e010dcc806caeb0b23758aac783dccaa", "committedDate": "2021-07-20 10:11:59 +0530", "message": "Fix review comments"}, {"oid": "8953e1f6445f0a81bf2036d4983b5c7d040e45b7", "committedDate": "2021-07-26 16:01:08 +0530", "message": "fix https://github.com/wso2/product-apim/issues/11408."}, {"oid": "70bf97249e8794a10a466e6377822c900490aee3", "committedDate": "2021-07-26 18:25:44 +0530", "message": "fix https://github.com/wso2/product-apim/issues/11249"}, {"oid": "f172ff7017fa1a6b4f72ddb726a9b325b87e3fde", "committedDate": "2021-08-04 11:11:17 +0530", "message": "Formatting changes"}, {"oid": "fd14aaadf59448928517d16cade88f13cc6b365c", "committedDate": "2021-08-04 11:23:41 +0530", "message": "Formatting changes"}, {"oid": "702575d7cfa729474323d197c703230d5594df82", "committedDate": "2021-08-04 17:21:54 +0530", "message": "duplicate primary key issue"}, {"oid": "6c3b2427436375aff7328fa8a34cd9c0b9038fea", "committedDate": "2021-08-04 18:12:49 +0530", "message": "add review suggestion"}, {"oid": "a28aaf5e8b9fdb843f76574f9c45e84209b0e0bb", "committedDate": "2021-08-11 13:48:43 +0530", "message": "Remove tier permissions record when deleting subscription policies"}, {"oid": "15303ad78c5bd7dc6305878bdb6bc36461827194", "committedDate": "2021-08-13 13:29:38 +0530", "message": "Fix DB timezone issue"}, {"oid": "856ac64b5f1ec0ebf84177cd2e6ebe7e377ca8c1", "committedDate": "2021-08-13 15:00:37 +0530", "message": "Merge pull request #10734 from AmaliMatharaarachchi/revision-master"}, {"oid": "8fe8f92d750fd1790cf1de86c57d533d964d6871", "committedDate": "2021-08-13 15:26:33 +0530", "message": "[Org Cleanup Feature] Adding missing foreign keys and Org Column (#10724)"}, {"oid": "928582da2614b9dbe4c98f8730988e8f3c4134c2", "committedDate": "2021-08-13 21:49:28 +0530", "message": "Revert \"Fix DB timezone issue\""}, {"oid": "f1c0ede6f6695baffb63d2ce31bc250f3479d6a6", "committedDate": "2021-08-13 22:51:12 +0530", "message": "Fix DB timezone issue"}, {"oid": "68ada76c9f13edc9c67008f88d3e4df16634b409", "committedDate": "2021-08-18 16:20:31 +0530", "message": "Remove aggregate functions from db query"}, {"oid": "1db740dde3f3b48793c49750e284b64c693e416e", "committedDate": "2021-08-26 14:05:12 +0530", "message": "Adding Organization cleanup core Changes (#10753)"}, {"oid": "2521ede223b4a6954f8db2a7a048bc3cb093c1ac", "committedDate": "2021-08-30 16:52:31 +0530", "message": "Deprecating usage of email of subscriber"}, {"oid": "7ee5fd93df6f1c250c92c67b4dbd086cafe26383", "committedDate": "2021-08-30 17:25:46 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into master-fixes"}, {"oid": "7a958bbf2115ef5f888f0e7bb9087a8021e01bf8", "committedDate": "2021-08-31 19:48:49 +0530", "message": "Merge pull request #10695 from Shehanir/master"}, {"oid": "f98dd42ba0e7bf0dce28aba97b6a50c0af4568e7", "committedDate": "2021-09-07 18:43:47 +0530", "message": "fix AM_REVOKED_JWT table not cleaning issue"}, {"oid": "64da2c63ca4900c0fa26f337da1c2cec6fce01a9", "committedDate": "2021-09-09 10:52:31 +0530", "message": "Merge pull request #10749 from YasasRangika/master"}, {"oid": "d6db550b9d6ee878a26aa572b7964105a1e4cd80", "committedDate": "2021-09-15 20:42:39 +0530", "message": "Merge remote-tracking branch 'upstream/master' into APIMPatch1007PublicFix"}, {"oid": "d0ac314714df38c99b4b29facc6fc115b73ca3dc", "committedDate": "2021-09-16 10:23:11 +0530", "message": "Store RESTful API Fixes - API listing call returns \"ORA-01795\" ERROR when the limit is more than 1000 Fix"}, {"oid": "8167b43898a1ad12a6924779c0cc3c04e18fdc65", "committedDate": "2021-09-16 21:54:50 +0530", "message": "remove AuthManager usage refactor unwanted code"}, {"oid": "e801d55f90b76b6832524adaf656ee16792ec831", "committedDate": "2021-09-17 01:27:13 +0530", "message": "Merge remote-tracking branch 'upstream/master' into PATCH-1333-FIxes"}, {"oid": "0c77c49f5319f4d0feab1bdda661f171a7089f5c", "committedDate": "2021-09-17 01:28:57 +0530", "message": "Merge remote-tracking branch 'upstream/master' into APIMPatch1007PublicFix"}, {"oid": "61078a63e4f442fdd6c21ca10815dff350981b61", "committedDate": "2021-09-21 19:53:27 +0530", "message": "Merge remote-tracking branch 'upstream/master' into APIMPatch1007PublicFix"}, {"oid": "7955e0ea1db9e5d1421cf3a76501097a04488680", "committedDate": "2021-09-23 14:14:59 +0530", "message": "Update change application owner flow"}, {"oid": "afdfa75713bf6403763083fcaac16e33efc34ebc", "committedDate": "2021-09-30 13:40:10 +0530", "message": "Adding method required to IDP validation"}, {"oid": "95d7f55d4b6308523e34af1caeb83e43f2616ff7", "committedDate": "2021-10-05 16:28:14 +0530", "message": "Merge remote-tracking branch 'upstream/master' into APIMPatch1007PublicFix"}, {"oid": "1302f4f13425dd3bb3b4cab8c7e72df71329cdf1", "committedDate": "2021-10-05 16:48:50 +0530", "message": "Refactoring application sharing related code changes"}, {"oid": "099a09faf8d0905a0204c360b86e99fd3fb47852", "committedDate": "2021-10-05 17:54:42 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into update-change-app-owner"}, {"oid": "0a114211c40cc0b9fa262ff69e3a245937cbea4f", "committedDate": "2021-10-05 18:09:30 +0530", "message": "Fix review comments"}, {"oid": "b49a913d201408bc71bb6ac0e995300faa4b7d1b", "committedDate": "2021-10-06 16:01:16 +0530", "message": "Merge pull request #10807 from chathuranga95/update-change-app-owner"}, {"oid": "d82dfa83796231ae8cfd4fff95c13c286917cb7f", "committedDate": "2021-10-09 20:27:03 +0530", "message": "fix test case"}, {"oid": "aff14cba4262dd5da37bfc70f1c984d81319c262", "committedDate": "2021-10-10 21:29:25 +0530", "message": "Add resource level security granularity for API key based authentication"}, {"oid": "c63355b436832ae7cdc21857b6e8b6108bd3dfbe", "committedDate": "2021-10-12 15:14:49 +0530", "message": "Add Vhost related changes"}, {"oid": "c1e7508cb177a66fc85fa668625aa9d36e1efcd8", "committedDate": "2021-10-13 12:46:47 +0530", "message": "Update some queries in SQLConstants"}, {"oid": "67f7e26bab82ee714f21fe1d159bff192a588e14", "committedDate": "2021-10-22 08:08:36 +0530", "message": "Fix issue with API Product Revision restore - 11886"}, {"oid": "389ae2d1ab81a1b4122d73b204d743dae00d9eaf", "committedDate": "2021-10-28 17:56:46 +0530", "message": "Fix the null pointer issue when adding the same local scope"}, {"oid": "1a54560d52af333d6d480bdb10befcec7674e359", "committedDate": "2021-11-02 17:41:36 +0530", "message": "Fixing #11884 #11858 and #11859"}, {"oid": "ecbb7cd537c45f4bea9b56947c52f2ad0f4d693e", "committedDate": "2021-11-06 05:48:35 +0530", "message": "devportal api visualization improvement(pagination)"}, {"oid": "773b40ee73b373fd5bded7c3d64af5378c9be558", "committedDate": "2021-11-12 10:08:17 +0530", "message": "add version timestamp to api products"}, {"oid": "a83daa29388bd89c7c3802262707f3e869e6769c", "committedDate": "2021-11-19 15:03:33 +0530", "message": "Merge pull request #10850 from Sarangan0219/master_fix_patch"}, {"oid": "a085014db9db977c6752981aaa5d33ff8cc0b2b0", "committedDate": "2021-11-21 05:11:15 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into pagination-devportal-4.x"}, {"oid": "4be54a2884b44853e0457ed4d180836ca9bd9965", "committedDate": "2021-11-26 08:36:50 +0530", "message": "Add gateway vendor property to database API table"}, {"oid": "e505061ceb93a892cbf4e7fa989b762b4dd24290", "committedDate": "2021-11-26 08:36:50 +0530", "message": "Add gatewayVendor property to APIProduct DB queries"}, {"oid": "a2ddc3c84b1249e3329433973ca97dacb73b525f", "committedDate": "2021-11-26 08:36:50 +0530", "message": "Address review comments"}, {"oid": "bc15502587cf47c58461897d9dee731e40b530a5", "committedDate": "2021-11-26 08:36:50 +0530", "message": "Address code review comments"}, {"oid": "ea947d263b9266f00f5291552322056ab0f3baf5", "committedDate": "2021-11-26 08:36:50 +0530", "message": "Remove unused variable"}, {"oid": "6c3bd6ea621ad0a30d8c1888dff90d98912a91c6", "committedDate": "2021-11-26 08:36:50 +0530", "message": "Fixing test failures"}, {"oid": "463184d8fd0f031693a95b8df1d55d99f879b040", "committedDate": "2021-11-27 23:58:27 +0530", "message": "Fix app registration workflow errors"}, {"oid": "5ad22bd5c9519639211e4141d6de4069b5644c78", "committedDate": "2021-11-30 10:11:37 +0530", "message": "Add Provider property to DB"}, {"oid": "5b0bd72e7ced16015be9e7615abeaf493f80c181", "committedDate": "2021-11-30 11:35:33 +0530", "message": "Merge branch 'master' into lasith_updating_vhosting"}, {"oid": "2f3cece321fdab9208a31b1651b54f42eaf512e2", "committedDate": "2021-11-30 13:31:07 +0530", "message": "fix cross-tenant subscription related issues"}, {"oid": "810f3779098d3b6c285d7948329764702a177220", "committedDate": "2021-11-30 13:31:07 +0530", "message": "fix review comments"}, {"oid": "0276e4512141cdd0cd87c2894b15bb7e54aeb3db", "committedDate": "2021-12-03 10:25:19 +0530", "message": "Merge pull request #10934 from Chamindu36/add_provider_to_env"}, {"oid": "68f4864f9c031a04c21fef1c6663e18c02c77461", "committedDate": "2021-12-04 11:10:00 +0530", "message": "refactor subscription block unblock"}, {"oid": "4b2765a14db209bc39958e873c2337f49df3bb80", "committedDate": "2021-12-06 13:14:29 +0530", "message": "Merge pull request #10937 from tharindu1st/cross-tenant"}, {"oid": "54ebf8365c3865c4d58d1246e394bd337c4463d7", "committedDate": "2021-12-07 10:19:04 +0530", "message": "Merge branch 'master' into lasith_updating_vhosting"}, {"oid": "8ada80de52ff13e90890685207e2f6ab452713fc", "committedDate": "2021-12-08 10:00:54 +0530", "message": "Refactor API LC state change impl"}, {"oid": "8b5a1296373f1a4102f408261464dad09f7fcd4e", "committedDate": "2021-12-08 10:08:25 +0530", "message": "Refactor getAPILifecycleHistory impl"}, {"oid": "2760d1e13fde02fcb264107296487cfe10a70019", "committedDate": "2021-12-08 10:08:25 +0530", "message": "Implement REST API to fetch APIProduct LC history"}, {"oid": "72ef4e3491ece7ebdcb44bd0516db58b7ac1e444", "committedDate": "2021-12-08 10:08:25 +0530", "message": "Refactor getAPILifecycleState impl"}, {"oid": "0aaaae30fddd16e0bfbd89b1ccb3e17dbcf3c185", "committedDate": "2021-12-08 10:08:25 +0530", "message": "Add entry in AM_API_LC_EVENT when creating product"}, {"oid": "d9cbb0f0421eabda3aeb017de6402ede94238ca0", "committedDate": "2021-12-08 10:16:39 +0530", "message": "Fix issue in create versions with checklist items"}, {"oid": "774b0514e82e1d816451f64fa59bb83e3f2bf9c8", "committedDate": "2021-12-08 10:16:40 +0530", "message": "Removed unused method/import"}, {"oid": "7e5d6b56129fa7b51b13b25562a2257a29b844e4", "committedDate": "2021-12-08 10:16:40 +0530", "message": "Refactored SQL to get the lifecycle events"}, {"oid": "edfa61021565d3e7074126509079c2a453d30726", "committedDate": "2021-12-08 10:16:40 +0530", "message": "Check permission before retrieving lc events"}, {"oid": "b95963e25e7a9e12d6e1d6c34379cb9086f0dd75", "committedDate": "2021-12-08 10:16:41 +0530", "message": "Modify APIProvider interface method deleteWorkflowTask"}, {"oid": "36649dd398d198e5d33abeb7e372c9f62edcf5fe", "committedDate": "2021-12-14 21:14:36 +0530", "message": "fix exchange token feature"}, {"oid": "72cec9e6c8812728aa9cb439cba50323306d1eac", "committedDate": "2022-01-04 16:51:42 +0530", "message": "resolve conflicts"}, {"oid": "dcebfdd4a45b2dfed1a56f01befd34d9e5039787", "committedDate": "2022-01-10 16:43:07 +0530", "message": "Fix creating high #cursors in a session"}, {"oid": "c0feb4c34437c0821cc1817e096eabac307ff609", "committedDate": "2022-01-26 12:17:21 +0530", "message": "Merge pull request #10974 from binodmx/master-patch-016"}, {"oid": "b4710382363176b1c2d73a31cef87faa3f861949", "committedDate": "2022-02-01 21:40:56 +0530", "message": "Fix MySQL query error when retrieving latest revision of an API"}, {"oid": "daa2d6f6c93aa828fc228da524ffcd677d5a6358", "committedDate": "2022-02-07 08:12:58 +0530", "message": "Fix update funtionality of the service entry in the API"}, {"oid": "81fbdf350d3765d42b8f2a304e0a0915bcc152d2", "committedDate": "2022-02-07 13:03:57 +0530", "message": "Add a method without tenanid to retrieve service info of API"}, {"oid": "caf16e0b4485ce391e0107da752c4eb5d93573c9", "committedDate": "2022-02-08 12:49:46 +0530", "message": "Handle the exception properly and remove the APIId search"}, {"oid": "5b8969835f40d818285ec14927e2c44039e8ac4a", "committedDate": "2022-02-08 13:00:40 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into top-down-api-development"}, {"oid": "7a5247b5f1abf03422e6e560ffbdd651ce3e0aa7", "committedDate": "2022-02-09 02:36:38 +0530", "message": "Fixes subscription view for app sharing"}, {"oid": "f28c29459efed7c47989f735230374f77a9bdeb8", "committedDate": "2022-02-09 11:12:35 +0530", "message": "Resolve tenant id in addservicemapping method"}, {"oid": "9baf5f1d46c3cf0b58fee52319f52f97abb988ef", "committedDate": "2022-02-09 17:32:39 +0530", "message": "Fixing issue with APIs with nested comments deletion"}, {"oid": "5fa1aaa7a9889374a50910bf6d2eb85ba36a7f10", "committedDate": "2022-02-09 17:48:16 +0530", "message": "Merge branch 'master' of https://github.com/wso2/carbon-apimgt into top-down-api-development"}, {"oid": "03225384dc07b6883b1c9d729d6aac536cee1d84", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Add support for operation policies in API create and update flows"}, {"oid": "7e43ae9fb38c6055fff2f929242c3c6b8c5cd108", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Add support for operation policies in API revisions"}, {"oid": "408818a67f9d5b52ef71a9074ede52dbf8a112b0", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Add support for operation policies in API Products"}, {"oid": "cd2111c8235586948e2e0da72744c7f8e00f4c01", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Add support for resource-endpoint basic operations"}, {"oid": "b5c981c89a3a41fdf309e5676a9cdfe41c27e87c", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Add support to attach change endpoint policies to APIs"}, {"oid": "63225478cc8703d27a887e77a66b7e25569a3adb", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Fix issue : API can have multiple change_ep policies attached to different resources"}, {"oid": "0b48b481e7c9fd513915a0532efb02d40b5612d2", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Add resource-endpoint details to export api artifact"}, {"oid": "c23f28db3fa63dfe33b46b20cbea370e5cfefd98", "committedDate": "2022-02-09 19:18:37 +0530", "message": "Add a usageCount field to ResourceEndpoint schema"}, {"oid": "cfd0acb9d6bc3cedde5065e058d7666e0d634a03", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Add revision support for Resource Endpoints"}, {"oid": "45fe58215eccd9bdf813f66dc15e7c3f34d0b224", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Add change_endpoint policy support for API Products"}, {"oid": "a7c894e3f8a2226d2425c43f20203e9d2bfd6e54", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Add change_endpoint policy support for API Product Revision Creation"}, {"oid": "da617bf2c87452055993d6cd9c87598eb49c2265", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Refactor code"}, {"oid": "cf722971801dae70824779679aeaa14e7be18c71", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Add support for header and query param remap"}, {"oid": "ee711c78a4e525acb451412e21253dc5ee3ebee9", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Add support for mock_reponse policy headers"}, {"oid": "a16f78fdb9f304497f05e28e1adb6b644b69c020", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Fix API Product import flow when there are resource endpoints in dependent APIs"}, {"oid": "6d511da4f4c01c377448b6a2b42388c6ab561cb4", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Support operation policies and resource endpoints in API product revision restore"}, {"oid": "3b79c8fbba3ef8524921d5f7d337aced2a49fbc4", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Format Code"}, {"oid": "ddcdc677f9d481e11edeccebb27ba4f5345506d2", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Add review changes"}, {"oid": "dd974c9eba76c4f051674b977c1e1a9d500f6eea", "committedDate": "2022-02-09 19:18:38 +0530", "message": "Remove tenantId from resource endpoints"}, {"oid": "382762a2d3bc0ca4a6b92fc987248266ccab1970", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Set autocommit to false"}, {"oid": "2a4ffda78c5af729b57c99abfaf0ef593290b19d", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Remove CHANGE_ENDPOINT policy"}, {"oid": "c87eb83a5b409dab69b879a0f9a6c8ff4371f20e", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Remove implementation for resource-endpoints"}, {"oid": "be0e70bec607e70da96a0b824aa8c533569bf1dc", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Refactor code"}, {"oid": "85de0adab40a447958263043b936d60118f81ef8", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Add the initial changes for policies features"}, {"oid": "ebd1298ef5ce9b8ed419b58333c65ce9a04f114a", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Commit latest fixes"}, {"oid": "c7e14d1607d7898b940d1ad4d38742ba2a4d8a32", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Fix policy update flow with order"}, {"oid": "8e51c0dafa3efca6e9d233d4a30462c0e342dc33", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Implmenet the policy export flow"}, {"oid": "0d220f8896e2226914c8856db140ec6ac0178c27", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Implement the import API flow for operation policies"}, {"oid": "b82ce8f814d8f585de7ece160962869252585f83", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Add revision support for operation policies"}, {"oid": "068e121a0426bcf1e464dc041584b04ae49502b0", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Fix the api product policy issues"}, {"oid": "6955f26ea62e4a2af38040e465a7d124eb973588", "committedDate": "2022-02-09 19:18:39 +0530", "message": "Fix the product revision flow with operation policies"}, {"oid": "6e33b04a51d40751b604d195b70831fb23eb775e", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Remove the url mapping table entries when product and revision is deleted"}, {"oid": "b59d4107fe54172b6cebbc9242f71f08592a781b", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Refactored and added java docs for better understanding"}, {"oid": "8b2517a78db983906267990b0dfee651f89c9366", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Refactored for better understanding"}, {"oid": "991901b323e69bdc146a33daaaa962838c2c54bb", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Minor fixes"}, {"oid": "97d5d8609fbeb8d0ac6a6a6c8763d922bde8c8a0", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Refactored policy data holder"}, {"oid": "3b056b4e541275686f7ee65d2f9a8caf3255b1b3", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Fixed several bugs in operation policies"}, {"oid": "fa0c41ebe065ce90522750a53fd678fb4deea0ec", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Minor changes in db scripts"}, {"oid": "0e5f9e0c2357dc69058a7cda6f6bdf3fa2782763", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Change the template and policy IDs to UUIDs"}, {"oid": "7fa78c52f305863f1daec32055e9a57ca9f30675", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Refactored policy templates to shared policies"}, {"oid": "f1b234427b22e2921b33201852ab39be3e253096", "committedDate": "2022-02-09 19:18:40 +0530", "message": "Refactor templates to shared policies"}, {"oid": "bd1e04308a090935b42f300d3b0f9b37be2c0754", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Add the tenant domain to the db, implement the remaining methods for rest API"}, {"oid": "7972cea24158de986d1cb5170129b3ffcabb5f0d", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Minro bug fixes"}, {"oid": "379e167018f4ddc7087cd1cfbab7daa0f2ab7ab7", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Add the validation schema, refactored policy spec and added new fields"}, {"oid": "1712274b5df77252d6b2d0d02f7f68c765551ed7", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Minor bug fixes and comments"}, {"oid": "e1692244927a73d213df06b6d4e709b418f3db12", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Changed the architecture to record all policiesi in one table"}, {"oid": "22ff83e0f037d30b5380f551e20fb397b69ff175", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Fix the import export paths of the policies and minor fixes to rest APIs"}, {"oid": "7a2445554e825d8ebbc7e67d43c1640279d11301", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Changed the policies feature with new db structure"}, {"oid": "c1b59908340ffcb74c0e9e9715ac1e9d923f9377", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Fixes in the api product flow for operation policies"}, {"oid": "4178afd1404fd9ffbfe4d843b7a02c7bdf66adc3", "committedDate": "2022-02-09 19:18:41 +0530", "message": "Added java docs, comments and handled exceptions properly"}, {"oid": "4f596f31627be02e9c373a1095ecf0e459265149", "committedDate": "2022-02-09 19:18:42 +0530", "message": "Minor bug fixes"}, {"oid": "80c3e23958ba94ae8672d81549603d401e57f773", "committedDate": "2022-02-09 19:18:42 +0530", "message": "Reformatted the code"}, {"oid": "c1fc823fef9e889413f540714cd014d957ff6eb6", "committedDate": "2022-02-09 19:18:42 +0530", "message": "Add implementation of multiple definition support for a policy spec and minor bug fixes"}, {"oid": "753fcb445aa6ba3faa53291cbd17f509cd3c8ab7", "committedDate": "2022-02-09 19:18:42 +0530", "message": "Add the implementation of importing common policies at the first startup and tenant creation"}, {"oid": "2a15054184792e6af30c7be4f940029bdce72e2c", "committedDate": "2022-02-10 12:16:43 +0530", "message": "Remove adding apiId to the serivice catelog entry"}, {"oid": "3182ba9177804659b14256e13abde9e4786c92e8", "committedDate": "2022-02-10 18:59:50 +0530", "message": "Rename VERSION_TIMESTAMP"}, {"oid": "d637fb80499cd64006f273ad8a3e5525dd9f0068", "committedDate": "2022-02-10 19:17:42 +0530", "message": "Merge pull request #11031 from Krishanx92/master"}, {"oid": "a54c0b446696b5e5058ad383d29d8a4b54a5a5de", "committedDate": "2022-02-11 10:27:12 +0530", "message": "Merge branch 'operation-policies-feature' into rebased-policies-final"}, {"oid": "da33a8924e3ac2b08450db69b5134ec6b0958f8d", "committedDate": "2022-02-11 14:02:25 +0530", "message": "Merge pull request #11022 from Arshardh/subscription-fix"}, {"oid": "8683de3dde50b90f9cd609f3242a7aa63ea2d009", "committedDate": "2022-02-14 15:28:26 +0530", "message": "Fix policy restore error when a common policy is deleted"}, {"oid": "b0865e91c3716e810d1b508907d908dfd1f321bb", "committedDate": "2022-02-14 23:54:01 +0530", "message": "fix create new version with operation policy"}, {"oid": "be92fdb6a93c38d7a8a954e4a363aff66aae2b5c", "committedDate": "2022-02-14 23:59:06 +0530", "message": "Merge pull request #11050 from tharindu1st/operation-policies-feature"}, {"oid": "9dc47117fd52484f0c896630afd0af9c9a1bd4c9", "committedDate": "2022-02-15 10:05:03 +0530", "message": "Merge pull request #11047 from wso2/master"}, {"oid": "f571b104d294fa213a06440c0af90c5c6fa3ce38", "committedDate": "2022-02-15 10:31:39 +0530", "message": "Replace a quoted value with a constant"}, {"oid": "a0c7481bedcb7fe94acdff624a072920db0f0e1b", "committedDate": "2022-02-15 13:37:18 +0530", "message": "Add suggested changes"}, {"oid": "7716e365de7b207dda7c209a9d97aba8dd863328", "committedDate": "2022-02-15 13:38:39 +0530", "message": "Merge pull request #11051 from Lasith650/lasith_adding_suggested_changes"}, {"oid": "248029e694a3eed74a27250284c684d59ac83292", "committedDate": "2022-02-17 15:37:51 +0530", "message": "Remove rendundant subscription event trigger"}, {"oid": "a9e29465f770d977bd1cb7352dbec09f6ba0f2f5", "committedDate": "2022-02-22 15:07:33 +0530", "message": "Add the validations for policy deletion if usages exists"}, {"oid": "bbe9c67a3547be4c07a7f0b9999df7b2deb6b030", "committedDate": "2022-02-24 13:26:15 +0530", "message": "Update column names and queries for h2 upgrade"}, {"oid": "cbd242d836d08e762c5de64581e37f1b6b9a22b7", "committedDate": "2022-02-24 13:26:15 +0530", "message": "Add schema changes for h2 upgrade"}, {"oid": "3592210100ea67926177873c1ddf177d30b8680e", "committedDate": "2022-02-25 23:31:53 +0530", "message": "Fix the bug in deleting API specific operation policy"}, {"oid": "6482cf3472f4648ed280b5833d2bf8066623ad10", "committedDate": "2022-03-01 16:02:51 +0530", "message": "Fixing attribute inconsistency (#11084)"}, {"oid": "4708e0543959f5f112cc6232f5869f74781329b3", "committedDate": "2022-03-01 20:27:33 +0530", "message": "Merge pull request #10977 from RakhithaRR/h2-upgrade"}, {"oid": "ef6c99231378e2a2f95a2b9feaa2881f12a708c2", "committedDate": "2022-03-02 08:17:16 +0530", "message": "Revert \"Fixing attribute inconsistency (#11084)\""}, {"oid": "9cac0b0463d798fe1db219fd64041f4c56b9d4e6", "committedDate": "2022-03-02 09:46:54 +0530", "message": "Remove the multipleAllowed field from policy spec"}, {"oid": "af39fc8901687c256acb1354c4223b35fdccad08", "committedDate": "2022-03-02 09:46:54 +0530", "message": "Add the support to add more commen policies at the startup"}, {"oid": "ab7091fc7f1d1537c3c60dd085aff32606212b47", "committedDate": "2022-03-03 18:54:40 +0530", "message": "fixing get revision deployments query for postgres"}, {"oid": "83350fc65ec5beb7690e79d6275034c253eb0a3d", "committedDate": "2022-03-04 14:00:57 +0530", "message": "Removing tenant-domain from AM_GATEWAY_ENVIRONMENT"}, {"oid": "bd98c545f12b093c8770169673a689e58a6a34c6", "committedDate": "2022-03-14 19:32:22 +0530", "message": "gateway type db level handling changes."}, {"oid": "cd03a0ca3f419b269b02041972bc621fc313d623", "committedDate": "2022-03-14 22:24:11 +0530", "message": "Add the versioning support for operation policies"}, {"oid": "77d2e49a3490aa67349314241c9fae2ce45a4f91", "committedDate": "2022-03-15 10:12:12 +0530", "message": "mapper implemenations for gateway type"}, {"oid": "a16218f8c5ed823f4e0677637e727d803de71ed6", "committedDate": "2022-03-15 12:27:42 +0530", "message": "Add cleanup logic for subscription update workflow"}, {"oid": "b9c4c3907654d0b66c27d95be4abbbf484d59559", "committedDate": "2022-03-15 17:37:28 +0530", "message": "Merge pull request #11155 from chamilaadhi/sub-update-wf"}, {"oid": "309ae3a2fa7fd8098a17ac293b3ff37d42344b43", "committedDate": "2022-03-15 18:08:44 +0530", "message": "addition of review suggestions for method names"}, {"oid": "afe7b325e5f9afefe0c03d7493960bdb22362b48", "committedDate": "2022-03-16 09:22:53 +0530", "message": "Merge pull request #11125 from slahirucd7/gatewayTypeAddition"}, {"oid": "98b6aca65155f40ab08a1f61d27a994f00126d9b", "committedDate": "2022-03-18 13:51:45 +0530", "message": "Fixing product-apim/issues/12628 and product-apim/issues/11897"}, {"oid": "99b6118d3d34298870fe95dbcce94bcf011a328a", "committedDate": "2022-03-18 13:53:34 +0530", "message": "Removing extra new lines"}, {"oid": "6838cb30ee10826e15a674e46221d794e7d4081e", "committedDate": "2022-03-19 17:27:05 +0530", "message": "fix remove throttle policy from other tenant breaks"}, {"oid": "8cc90b41273db996093fb1ede2f8335e7700f61e", "committedDate": "2022-03-21 09:47:32 +0530", "message": "Merge pull request #11176 from mushthaq33/master-aws-ctl"}, {"oid": "3260dea9a534afd81f251581b0ba743e545d28e1", "committedDate": "2022-03-24 18:14:24 +0530", "message": "Retrieve subscriber info using application"}, {"oid": "05212e231e5801ca76f3d34db14d7d5e1a9cb148", "committedDate": "2022-03-28 00:08:33 +0530", "message": "fix sending events to new version related subs"}, {"oid": "3d9753e97836261668697d3c3a234aea1cb2b33e", "committedDate": "2022-03-29 10:45:48 +0530", "message": "Add application attributes to get applications method"}, {"oid": "bea122af5c74f9d9f8024f26e6c05ad6ce1cce70", "committedDate": "2022-03-30 21:01:31 +0530", "message": "Fix API state change issue with workflows applied"}, {"oid": "8deb13922435187c46447223d22f352af7e4166e", "committedDate": "2022-05-04 14:16:19 +0530", "message": "Add created time and updated time for applications"}, {"oid": "a2dac4fddb225064addb79049fa200bced44d1f7", "committedDate": "2022-05-06 12:38:31 +0530", "message": "Fix a test failure"}, {"oid": "1b5ccead97f5853be9cc56813ee70714ea9a9cf3", "committedDate": "2022-05-06 17:46:21 +0530", "message": "remove deprecated searchapi"}, {"oid": "01b17c45aaad0ac06217b3bac0888fbebde29e05", "committedDate": "2022-05-06 17:46:21 +0530", "message": "remove deprecated registry methods"}, {"oid": "2e6785784782d66c4265b07be95d00f76b13d151", "committedDate": "2022-05-09 11:42:55 +0530", "message": "remove more registry base methods"}, {"oid": "58296f48cb30567ca0fde54012a2ba19745d8cb8", "committedDate": "2022-05-18 09:45:49 +0530", "message": "Setting org ID to the SubscribedAPI"}, {"oid": "a4e2fa31a5d87d10affd1025d8f725a34573e4e7", "committedDate": "2022-05-31 10:08:40 +0530", "message": "Add organization Id filter for internal service API"}, {"oid": "57ded03d1fb3c2ae07bf3953e2f5feb98989c857", "committedDate": "2022-06-15 15:36:48 +0530", "message": "Merge pull request #11250 from ShalkiWenushika/application_date_fix_master"}, {"oid": "dc007c6935a6e6668c65a8823970cb455c45587d", "committedDate": "2022-06-16 00:51:46 +0530", "message": "Add organization to the validate api call"}, {"oid": "893ea91be023a30dee8936a4d97acac421f2d4d5", "committedDate": "2022-06-17 09:59:05 +0530", "message": "Set deployed time as NULL for undeployed revisions"}, {"oid": "a9b781a16e071634d6ba63c011ee7809418e2e39", "committedDate": "2022-06-24 13:24:37 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt"}, {"oid": "5e05cfeb555cdbbae0a3d270aaa2490e09f66cf5", "committedDate": "2022-06-24 16:53:13 +0530", "message": "Resolve conflict and adding remaning changes related to #11221"}, {"oid": "a2d6ecc34b60d78c606cab836105bc2a7ba4bc30", "committedDate": "2022-06-28 11:21:21 +0530", "message": "Merge pull request #11292 from shanakama/master"}, {"oid": "15359fd9f361111b336e281d068281cbbde694bc", "committedDate": "2022-06-29 10:22:08 +0530", "message": "Merge pull request #11269 from ruks/master"}, {"oid": "dd802aec12d8ca0288329346e20bf47bdf36be47", "committedDate": "2022-06-29 11:18:06 +0530", "message": "Resolved conflicts"}, {"oid": "cffbd6b95d121a76cc5ea17785cb50ea11778d78", "committedDate": "2022-06-30 09:15:12 +0530", "message": "Merge branch 'master' of github.com:wso2/carbon-apimgt into orgs-event"}, {"oid": "b987c2bc3c4c4dbeb31e4689d9bf04522e1fa3b5", "committedDate": "2022-06-30 09:38:00 +0530", "message": "Merge pull request #11301 from shanakama/master-new"}, {"oid": "544dc73af6a1b8d92cb77608c653e45e15eb43aa", "committedDate": "2022-07-06 12:21:52 +0530", "message": "Merge pull request #11296 from ruks/orgs-event"}, {"oid": "16bd658a357d088a9da24d552433554b5a8717fc", "committedDate": "2022-07-12 18:54:19 +0530", "message": "app deletion, subscription deletion workflow improvements"}, {"oid": "8c9b4024a3e7425c1ec96261620c79ea8261ae8d", "committedDate": "2022-08-15 14:36:53 +0530", "message": "fix sonar issues"}, {"oid": "ee5428ae23fbad3cde63d772f3c3f4866eff4b04", "committedDate": "2022-08-15 20:37:22 +0530", "message": "fix sonar issues"}, {"oid": "b913c4f2b92c53e8097a94f9c2c13227ad9d925f", "committedDate": "2022-08-18 14:45:54 +0530", "message": "Sonar fixes 3."}, {"oid": "d718ea987127d0a5e780eb548213841d1a3e6a85", "committedDate": "2022-08-18 14:59:54 +0530", "message": "PR changes."}, {"oid": "39ffd88eafb92321cdcea8b46976b637469859b0", "committedDate": "2022-08-19 18:53:24 +0530", "message": "Add REST APIs for common operation policies"}, {"oid": "6a6e4299c7878e24e4c3db279a982d1b4299174f", "committedDate": "2022-08-23 10:56:27 +0530", "message": "Merge pull request #11218 from HeshanSudarshana/master-app-attribute-issue"}, {"oid": "0d9ab41110b83dd0c6acf008af5f6d279d83f371", "committedDate": "2022-08-31 12:24:38 +0530", "message": "sonar issue fixes for workflow development"}, {"oid": "6285dabbade850522d7a4fe8387e5c763bf68c60", "committedDate": "2022-09-28 12:48:04 +0530", "message": "Fixed - Database is hanging when saving API after adding multiple policies in MSSQL"}, {"oid": "e47fd4a979499d7f9544cd7bcd593f615ba72bc0", "committedDate": "2022-10-12 09:46:16 +0530", "message": "ClonePolicyDetails method revamped"}, {"oid": "1e2365624424d958165c502a2b01938e0682611b", "committedDate": "2022-10-27 12:46:00 +0530", "message": "Fixing subscription loading issues in webhook APIs in postgresql DB"}, {"oid": "b0455473eb3644f7e3f55d7d9067615133797b1b", "committedDate": "2022-11-03 13:25:49 +0530", "message": "changed the toBeClonedSinglePolicyData to OperationPolicyData object and reformatted the code."}, {"oid": "8a5d1d0b687f4578e2cff3fc1a0443edb45c2818", "committedDate": "2022-11-07 11:07:59 +0530", "message": "Removed toBeClonedPolicyId param from addOperationPolicyContent method"}, {"oid": "4666f36adefbf7bb376f9457b87e30f0f3549351", "committedDate": "2022-11-12 16:57:37 +0530", "message": "Intergration test failures fixed"}, {"oid": "977ab422bda4ad7af760bc1c25c3801438eca752", "committedDate": "2022-11-16 11:29:02 +0530", "message": "Porting fixes to public branch ( adding tokenType to application collection get payload - improvement )"}, {"oid": "a9d6d7452c18634bfb6a29c2121f74130509f9af", "committedDate": "2022-11-18 00:11:53 +0530", "message": "Fixing oracle issue in GET_CLIENT_CERTIFICATES query (#5214)"}, {"oid": "89c143aa9c820c3542909928a10a8189ffee0d02", "committedDate": "2022-11-18 07:42:15 +0530", "message": "Changes done"}, {"oid": "19fdd991724d5f9f932bb540c83dd71b205ec6e2", "committedDate": "2022-11-18 14:24:52 +0530", "message": "Changes done - removed to beClonedPolicyId variable"}, {"oid": "54903e4be611f15bc66409fe76f10a26678a3a7a", "committedDate": "2022-11-21 09:31:50 +0530", "message": "Merge pull request #11495 from shnrndk/PolicyBugFix"}, {"oid": "b55a68a86fe4abf32311a311ee244461afbb85d9", "committedDate": "2022-11-22 10:09:45 +0530", "message": "Merge pull request #11646 from chanaka3d/master22"}, {"oid": "d5782b479657bc21e87c2d95e692c5ead7dc4185", "committedDate": "2022-11-22 19:49:26 +0530", "message": "Add fixes to APIM codebase for migration"}, {"oid": "e8d262813a414cb25ce349d57df5c18bc1492a9c", "committedDate": "2022-12-02 17:22:04 +0530", "message": "formatting and imports fixes"}, {"oid": "a126b1cac2e228d29ca7bf7be8cc4fbbdda538d9", "committedDate": "2022-12-09 13:54:20 +0530", "message": "Added changes to reflect in API revision"}, {"oid": "d6dca5e3df22f1005992568e0eba248f4331e5bf", "committedDate": "2022-12-09 14:02:26 +0530", "message": "Updated the getClientCertificatesQuery variable"}, {"oid": "d7efbb74f71001dc3b1ddd4c5248a440a3fd3cf2", "committedDate": "2022-12-15 09:14:00 +0530", "message": "Merge pull request #11652 from prasa7/wso2_master_new"}, {"oid": "bf04730a82ed4eb79b69474deb9815d5151a5559", "committedDate": "2022-12-19 15:29:58 +0530", "message": "Fix not setting token type when workflows enabled"}, {"oid": "16731c96d5065f69ead2acbb94b0b9f6551fe9a6", "committedDate": "2023-02-02 23:19:55 +0530", "message": "fixes: https://github.com/wso2/api-manager/issues/1318"}, {"oid": "3643dfdd088f823ebc0fb8cce84855008875e8ab", "committedDate": "2023-02-06 22:18:56 +0530", "message": "use same db connection during product resource addition. Commit old common policy uuid as cloned policy id when creating API/API product revisioning."}, {"oid": "0ab36a61c2a9f7e15d624370945a78c8754b77ac", "committedDate": "2023-02-14 17:44:28 +0530", "message": "Fix few issues caused by disabling unlimited throttling"}, {"oid": "754f70d23463661578e5fd87814fd4e7461d1cfa", "committedDate": "2023-02-15 09:01:45 +0530", "message": "fixes: https://github.com/wso2/api-manager/issues/1390"}, {"oid": "2c2644cc6de1d66e5fa7f6e1ec7f1a53ec2b8897", "committedDate": "2023-02-17 15:37:42 +0530", "message": "Fix operation policy clone logic to remove deadlocks"}, {"oid": "dea0e883ebfb11ac4bf2060161fe284ef00aa545", "committedDate": "2023-02-17 15:44:37 +0530", "message": "Close the RS and PS with the query"}, {"oid": "b67813a68834e2cb43001d0d38cd9c7ff4d364bd", "committedDate": "2023-02-17 15:48:44 +0530", "message": "Fix the deadlock issues when saving API products"}, {"oid": "a7330eb51359ce2c3cf3be15431c47e07de0a5e5", "committedDate": "2023-02-17 15:48:59 +0530", "message": "Fix API product restore changing the policy name issue"}, {"oid": "5578ae5947fb7924808a783138f097ec7a4ab7c0", "committedDate": "2023-02-17 15:49:07 +0530", "message": "Address review comments"}, {"oid": "aa8be7c6f059108529341ad427a9e1256d4eea46", "committedDate": "2023-02-20 10:24:44 +0530", "message": "Merge pull request #11870 from lakshithagunasekara/policies-deadlock"}, {"oid": "22dec941f3b30a3e99fb93641abd570496bd3a15", "committedDate": "2023-03-02 09:36:58 +0530", "message": "Merge pull request #11859 from BLasan/fix-multiple-notifications-per-sub"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MDMwMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386860301", "body": "remove spaces", "bodyText": "remove spaces", "bodyHTML": "<p dir=\"auto\">remove spaces</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:26:07Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] byteData1;\n+\n+                if(blob1 != null) {\n+                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n+                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    workflow.setProperties(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);\n+                }\n+\n+                workflowsList.add(workflow);\n+            }\n+            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n+        } catch (SQLException e) {\n+            handleException(\"Error when retrieve all the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflows;\n+\n+    }\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status , String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAIL_REFER_BY_EXTERNALWORKFLOWREFERENCE;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externelWorkflowRef);\n+            prepStmt.setString(2, status);\n+            prepStmt.setString(3, tenantDomain);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14793,11 +14844,8 @@ public class ApiMgtDAO {\n             prepStmt.setString(2, status);\n             prepStmt.setString(3, tenantDomain);\n \n-\n             rs = prepStmt.executeQuery();\n \n-\n-\n             while (rs.next()) {\n \n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14819,45 +14790,35 @@ public class ApiMgtDAO {\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n-     *\n-     * @param externelWorkflowRef\n-     * @param status\n-     * @param tenantDomain\n-     * @return\n+     * @param externelWorkflowRef of pending workflow request\n+     * @param status workflow status of workflow pending process\n+     * @param tenantDomain tenant domain of user\n+     * @return workflow pending request\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n                                                                       String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n+        Workflow workflow = new Workflow();\n         String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n-\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externelWorkflowRef);\n             prepStmt.setString(2, status);\n             prepStmt.setString(3, tenantDomain);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n-                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                String workflowstatus = rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MDM3Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386860373", "body": "add meaningful variable name", "bodyText": "add meaningful variable name", "bodyHTML": "<p dir=\"auto\">add meaningful variable name</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:26:19Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] byteData1;\n+\n+                if(blob1 != null) {\n+                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n+                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    workflow.setProperties(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);\n+                }\n+\n+                workflowsList.add(workflow);\n+            }\n+            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n+        } catch (SQLException e) {\n+            handleException(\"Error when retrieve all the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflows;\n+\n+    }\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status , String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAIL_REFER_BY_EXTERNALWORKFLOWREFERENCE;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externelWorkflowRef);\n+            prepStmt.setString(2, status);\n+            prepStmt.setString(3, tenantDomain);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14814,50 +14862,44 @@ public class ApiMgtDAO {\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n                 workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n-                Blob blob = rs.getBlob(\"WF_METADATA\");\n-                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n-                byte[] byteData;\n+                byte[] metadataByte;\n \n-                if(blob != null) {\n-                    byteData = blob.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream = new ByteArrayInputStream(byteData);\n-                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n                     Gson g = new Gson();\n \n-                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n                     workflow.setMetadata(json);\n-                }\n-                else{\n+                } else {\n                     JSONObject json=new JSONObject();\n                     workflow.setMetadata(json);\n                 }\n \n-                byte[] byteData1;\n+                byte[] propertiesByte;\n \n-                if(blob != null) {\n-                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n-                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n-                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n                     Gson g = new Gson();\n-\n-                    JSONObject json1 = g.fromJson(data1, JSONObject.class);\n+                    JSONObject json1 = g.fromJson(properties, JSONObject.class);\n                     workflow.setProperties(json1);\n-                }\n-                else{\n+                } else {\n                     JSONObject json1=new JSONObject();\n                     workflow.setProperties(json1);\n                 }\n-\n-\n-\n             }\n-\n         } catch (SQLException e) {\n             handleException(\"Error when retriving the workflow details\" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflow;\n+>>>>>>> Added workflowExecutors for ApprovalWorkflowExecutor and two rest APIs.\n     }\n }\n", "next_change": {"commit": "31f6f67b8a13bf657c46f4e2f9730d7b472c9b72", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..b2a7ba61a62 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14900,6 +14885,6 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflow;\n->>>>>>> Added workflowExecutors for ApprovalWorkflowExecutor and two rest APIs.\n+\n     }\n }\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b2a7ba61a62..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14851,40 +14827,36 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json1 = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json1);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json1=new JSONObject();\n-                    workflow.setProperties(json1);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \", e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflow;\n-\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MTM5NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386861395", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:28:33Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java", "diffHunk": "@@ -1869,6 +1869,27 @@\n     public static final String GET_ALL_WORKFLOW_ENTRY_FROM_INTERNAL_REF_SQL =\n             \"SELECT * FROM AM_WORKFLOWS WHERE WF_REFERENCE=? AND WF_TYPE=?\";\n \n+    public static final String ADD_PAYLOAD_SQL =\n+            \" UPDATE AM_WORKFLOWS \" +\n+                    \" SET \" +\n+                    \"   WF_METADATA = ?, \" +\n+                    \"   WF_PROPERTIES = ?, \" +\n+                    \"   WF_STATUS_DESC = ? \" +\n+                    \" WHERE \" +\n+                    \"    WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String DELETE_WORKFLOW_REQUEST_SQL=", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MTIwMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410791203", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-04-19T01:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MTM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\nindex 4dc7eb0d53e..1c8534b9389 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n", "chunk": "@@ -1881,14 +1881,21 @@ public class SQLConstants {\n     public static final String DELETE_WORKFLOW_REQUEST_SQL=\n             \" DELETE FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS_NO_TYPE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n \n \n-    public static final String GET_ALL_WORKFLOW_DETAIL_REFER_BY_EXTERNALWORKFLOWREFERENCE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ? AND WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE =\n+            \" SELECT  * FROM AM_WORKFLOWS \" +\n+            \" WHERE WF_EXTERNAL_REFERENCE = ? \" +\n+            \" AND WF_STATUS = ? \" +\n+            \" AND TENANT_DOMAIN = ?\";\n \n     public static final String UPDATE_PUBLISHED_DEFAULT_VERSION_SQL =\n             \" UPDATE AM_API_DEFAULT_VERSION \" +\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3MTkwNA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386871904", "body": "format and add method description", "bodyText": "format and add method description", "bodyHTML": "<p dir=\"auto\">format and add method description</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:50:05Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14576,4 +14580,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return userID;\n     }\n+\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+\n+        }\n+    }\n+\n+    public Workflow getworkflowReferenceByEWR(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+\n+\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+\n+\n+            }\n+\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+        else{\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_NO_TYPE;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            }\n+            else{\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+\n+\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob blob = rs.getBlob(\"WF_METADATA\");\n+                Blob blob1 = rs.getBlob(\"WF_PROPERTIES\");\n+\n+\n+                byte[] byteData;\n+\n+                if(blob != null) {\n+                    byteData = blob.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(byteData);\n+                    String data = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] byteData1;\n+\n+                if(blob1 != null) {\n+                    byteData1 = blob1.getBytes(1L, (int) blob.length());\n+                    InputStream targetStream1 = new ByteArrayInputStream(byteData1);\n+                    String data1 = APIMgtDBUtil.getStringFromInputStream(targetStream1);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(data1, JSONObject.class);\n+                    workflow.setProperties(json);\n+                }\n+                else{\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);\n+                }\n+\n+                workflowsList.add(workflow);\n+            }\n+            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n+        } catch (SQLException e) {\n+            handleException(\"Error when retrieve all the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflows;\n+\n+    }\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status , String tenantDomain) throws APIManagementException {\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMDgxMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r387600813", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-03-04T11:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3MTkwNA=="}], "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex b25d82b29f3..d1b86fe2c24 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14773,10 +14815,19 @@ public class ApiMgtDAO {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflows;\n-\n     }\n \n-    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status , String tenantDomain) throws APIManagementException {\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n+                                                                      String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex d1b86fe2c24..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14819,45 +14790,35 @@ public class ApiMgtDAO {\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n-     *\n-     * @param externelWorkflowRef\n-     * @param status\n-     * @param tenantDomain\n-     * @return\n+     * @param externelWorkflowRef of pending workflow request\n+     * @param status workflow status of workflow pending process\n+     * @param tenantDomain tenant domain of user\n+     * @return workflow pending request\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n                                                                       String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n+        Workflow workflow = new Workflow();\n         String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n-\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externelWorkflowRef);\n             prepStmt.setString(2, status);\n             prepStmt.setString(3, tenantDomain);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n-                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                String workflowstatus = rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3MzgxMg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386873812", "body": "lets rename to GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE", "bodyText": "lets rename to GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE", "bodyHTML": "<p dir=\"auto\">lets rename to GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:53:46Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java", "diffHunk": "@@ -1869,6 +1869,27 @@\n     public static final String GET_ALL_WORKFLOW_ENTRY_FROM_INTERNAL_REF_SQL =\n             \"SELECT * FROM AM_WORKFLOWS WHERE WF_REFERENCE=? AND WF_TYPE=?\";\n \n+    public static final String ADD_PAYLOAD_SQL =\n+            \" UPDATE AM_WORKFLOWS \" +\n+                    \" SET \" +\n+                    \"   WF_METADATA = ?, \" +\n+                    \"   WF_PROPERTIES = ?, \" +\n+                    \"   WF_STATUS_DESC = ? \" +\n+                    \" WHERE \" +\n+                    \"    WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String DELETE_WORKFLOW_REQUEST_SQL=\n+            \" DELETE FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String GET_ALL_WORKFLOW_DETAILS = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+\n+    public static final String GET_ALL_WORKFLOW_DETAILS_NO_TYPE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+\n+\n+    public static final String GET_ALL_WORKFLOW_DETAIL_REFER_BY_EXTERNALWORKFLOWREFERENCE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ? AND WF_STATUS = ? AND TENANT_DOMAIN = ?\";", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\nindex 4dc7eb0d53e..1c8534b9389 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n", "chunk": "@@ -1881,14 +1881,21 @@ public class SQLConstants {\n     public static final String DELETE_WORKFLOW_REQUEST_SQL=\n             \" DELETE FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS_NO_TYPE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n \n \n-    public static final String GET_ALL_WORKFLOW_DETAIL_REFER_BY_EXTERNALWORKFLOWREFERENCE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ? AND WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE =\n+            \" SELECT  * FROM AM_WORKFLOWS \" +\n+            \" WHERE WF_EXTERNAL_REFERENCE = ? \" +\n+            \" AND WF_STATUS = ? \" +\n+            \" AND TENANT_DOMAIN = ?\";\n \n     public static final String UPDATE_PUBLISHED_DEFAULT_VERSION_SQL =\n             \" UPDATE AM_API_DEFAULT_VERSION \" +\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3NDAxMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386874010", "body": "not clear enough (meaning)", "bodyText": "not clear enough (meaning)", "bodyHTML": "<p dir=\"auto\">not clear enough (meaning)</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:54:09Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java", "diffHunk": "@@ -1869,6 +1869,27 @@\n     public static final String GET_ALL_WORKFLOW_ENTRY_FROM_INTERNAL_REF_SQL =\n             \"SELECT * FROM AM_WORKFLOWS WHERE WF_REFERENCE=? AND WF_TYPE=?\";\n \n+    public static final String ADD_PAYLOAD_SQL =\n+            \" UPDATE AM_WORKFLOWS \" +\n+                    \" SET \" +\n+                    \"   WF_METADATA = ?, \" +\n+                    \"   WF_PROPERTIES = ?, \" +\n+                    \"   WF_STATUS_DESC = ? \" +\n+                    \" WHERE \" +\n+                    \"    WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String DELETE_WORKFLOW_REQUEST_SQL=\n+            \" DELETE FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String GET_ALL_WORKFLOW_DETAILS = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+\n+    public static final String GET_ALL_WORKFLOW_DETAILS_NO_TYPE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\nindex 4dc7eb0d53e..1c8534b9389 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n", "chunk": "@@ -1881,14 +1881,21 @@ public class SQLConstants {\n     public static final String DELETE_WORKFLOW_REQUEST_SQL=\n             \" DELETE FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_TYPE = ? AND  WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS_NO_TYPE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS =\n+            \" SELECT  * FROM AM_WORKFLOWS WHERE WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n \n \n-    public static final String GET_ALL_WORKFLOW_DETAIL_REFER_BY_EXTERNALWORKFLOWREFERENCE = \"SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ? AND WF_STATUS = ? AND TENANT_DOMAIN = ?\";\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE =\n+            \" SELECT  * FROM AM_WORKFLOWS \" +\n+            \" WHERE WF_EXTERNAL_REFERENCE = ? \" +\n+            \" AND WF_STATUS = ? \" +\n+            \" AND TENANT_DOMAIN = ?\";\n \n     public static final String UPDATE_PUBLISHED_DEFAULT_VERSION_SQL =\n             \" UPDATE AM_API_DEFAULT_VERSION \" +\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3NDE2Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386874163", "body": "format and remove space", "bodyText": "format and remove space", "bodyHTML": "<p dir=\"auto\">format and remove space</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:54:28Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dto/WorkflowDTO.java", "diffHunk": "@@ -56,7 +57,26 @@\n     private String externalWorkflowReference;\n \n     private String callbackUrl;\n-    \n+\n+    private JSONObject metadata;\n+\n+    private JSONObject properties;\n+\n+    public WorkflowDTO(){\n+        metadata =new JSONObject();\n+        properties =new JSONObject();\n+    }\n+", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc2NDY3MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406764671", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-04-10T13:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3NDE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dto/WorkflowDTO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dto/WorkflowDTO.java\nindex 797ebcaa318..ab961ba3fac 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dto/WorkflowDTO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dto/WorkflowDTO.java\n", "chunk": "@@ -63,12 +63,10 @@ public class WorkflowDTO implements Serializable {\n     private JSONObject properties;\n \n     public WorkflowDTO(){\n-        metadata =new JSONObject();\n-        properties =new JSONObject();\n+        metadata = new JSONObject();\n+        properties = new JSONObject();\n     }\n \n-\n-\n     public String getProperties(String key) {\n         return properties.get(key).toString();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3NDQyMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r386874421", "body": "this is not needed", "bodyText": "this is not needed", "bodyHTML": "<p dir=\"auto\">this is not needed</p>", "author": "chamilaadhi", "createdAt": "2020-03-03T08:54:55Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final String RUNTIME_INSTANCE_RESOURCE_PATH = \"/runtime/process-instances\";", "originalCommit": "6e7d63f0cbce7821d881557b6f804ffd9f00caf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMDQ5NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r387600494", "bodyText": "fixed with 1be4d86", "author": "SahanHerath", "createdAt": "2020-03-04T11:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3NDQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e5f1ca8c0c731ff296553a3776fe7937da125395", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex 770c95d310d..b18c28630f1 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -20,7 +20,6 @@ import java.util.*;\n \n public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n \n-    private static final String RUNTIME_INSTANCE_RESOURCE_PATH = \"/runtime/process-instances\";\n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n     private String stateList;\n \n", "next_change": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -15,9 +32,16 @@ import org.wso2.carbon.context.PrivilegedCarbonContext;\n import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n import org.wso2.carbon.registry.core.Registry;\n import org.wso2.carbon.registry.core.exceptions.RegistryException;\n-\n-import java.util.*;\n-\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+\n+/**\n+ * Approval workflow for API state change.\n+ *\n+ */\n public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex cb79bf0aaf2..1f581dbc8b4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -42,7 +42,7 @@ import java.util.ArrayList;\n  * Approval workflow for API state change.\n  *\n  */\n-public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor {\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n     private String stateList;\n", "next_change": null}]}}]}}]}}, {"oid": "63aac0ce60d89723bf51b15c7f9f35b420b3e7cc", "url": "https://github.com/wso2/carbon-apimgt/commit/63aac0ce60d89723bf51b15c7f9f35b420b3e7cc", "message": "Added workflowExecutors for ApprovalWorkflowExecutor and two rest APIs.", "committedDate": "2020-04-01T07:02:11Z", "type": "commit"}, {"oid": "e5f1ca8c0c731ff296553a3776fe7937da125395", "url": "https://github.com/wso2/carbon-apimgt/commit/e5f1ca8c0c731ff296553a3776fe7937da125395", "message": "Reformatted workflowExecutors for ApprovalWorkflowExecutor and two rest APIs", "committedDate": "2020-04-01T07:02:12Z", "type": "commit"}, {"oid": "8b030289aca2777f2d9be37fd3330df4e6ce1002", "url": "https://github.com/wso2/carbon-apimgt/commit/8b030289aca2777f2d9be37fd3330df4e6ce1002", "message": "Added database changes to the sql files", "committedDate": "2020-04-01T07:02:12Z", "type": "commit"}, {"oid": "31f6f67b8a13bf657c46f4e2f9730d7b472c9b72", "url": "https://github.com/wso2/carbon-apimgt/commit/31f6f67b8a13bf657c46f4e2f9730d7b472c9b72", "message": "Added workflowExecutors for ApprovalWorkflowExecutor and two rest APIs.", "committedDate": "2020-04-01T07:28:36Z", "type": "commit"}, {"oid": "63814cb85271ac3852fd12470cc7a81669d844ca", "url": "https://github.com/wso2/carbon-apimgt/commit/63814cb85271ac3852fd12470cc7a81669d844ca", "message": "Changes in the workflow executors", "committedDate": "2020-04-01T07:28:37Z", "type": "commit"}, {"oid": "63814cb85271ac3852fd12470cc7a81669d844ca", "url": "https://github.com/wso2/carbon-apimgt/commit/63814cb85271ac3852fd12470cc7a81669d844ca", "message": "Changes in the workflow executors", "committedDate": "2020-04-01T07:28:37Z", "type": "forcePushed"}, {"oid": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "url": "https://github.com/wso2/carbon-apimgt/commit/6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "message": "Changes in add workflow entry ApiMgtDAO.java", "committedDate": "2020-04-03T05:48:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxNjkxMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406616911", "body": "Missing license header", "bodyText": "Missing license header", "bodyHTML": "<p dir=\"auto\">Missing license header</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:06:36Z", "path": "components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package org.wso2.carbon.apimgt.api.model;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MTQzNg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410791436", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T01:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxNjkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5NjgxOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410796818", "bodyText": "changed year with 3719d98", "author": "SahanHerath", "createdAt": "2020-04-19T02:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxNjkxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\nindex 36dedcda1ef..480fdc5fedc 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.api/src/main/java/org/wso2/carbon/apimgt/api/model/Workflow.java\n", "chunk": "@@ -1,3 +1,20 @@\n+/*\n+ *  Copyright (c) 2005-2011, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n package org.wso2.carbon.apimgt.api.model;\n \n import org.json.simple.JSONObject;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxODE5MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406618190", "body": "seems like this method is still not formated. please format every new method you include. Ex: there is no space between '=', I can see some other issues as well", "bodyText": "seems like this method is still not formated. please format every new method you include. Ex: there is no space between '=', I can see some other issues as well", "bodyHTML": "<p dir=\"auto\">seems like this method is still not formated. please format every new method you include. Ex: there is no space between '=', I can see some other issues as well</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:12:04Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java", "diffHunk": "@@ -349,4 +346,22 @@ private int isCategoryAttached(APICategory category, String username) throws API\n         int length = (Integer) result.get(\"length\");\n         return length;\n     }\n+\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n+\n+        return apiMgtDAO.getworkflows(workflowType, status , tenantDomain );\n+    }\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status,\n+                                                                      String tenantDomain) throws APIManagementException {\n+\n+        Workflow workflow=apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef, status ,tenantDomain );\n+\n+        if (workflow == null) {\n+            String msg=\"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n+            throw new APIMgtResourceNotFoundException(msg);\n+        }\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\nindex 9ddab09bfa4..bbaddc0a067 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n", "chunk": "@@ -347,21 +347,37 @@ public class APIAdminImpl implements APIAdmin {\n         return length;\n     }\n \n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow[]\n+     * @throws APIManagementException\n+     */\n     public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n-\n-        return apiMgtDAO.getworkflows(workflowType, status , tenantDomain );\n+        return apiMgtDAO.getworkflows(workflowType, status, tenantDomain);\n     }\n \n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow\n+     * @throws APIManagementException\n+     */\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status,\n                                                                       String tenantDomain) throws APIManagementException {\n \n         Workflow workflow=apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef, status ,tenantDomain );\n \n         if (workflow == null) {\n-            String msg=\"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n+            String msg = \"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n             throw new APIMgtResourceNotFoundException(msg);\n         }\n-\n         return workflow;\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxODIzMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406618230", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:12:16Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java", "diffHunk": "@@ -349,4 +346,22 @@ private int isCategoryAttached(APICategory category, String username) throws API\n         int length = (Integer) result.get(\"length\");\n         return length;\n     }\n+\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n+\n+        return apiMgtDAO.getworkflows(workflowType, status , tenantDomain );", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\nindex 9ddab09bfa4..bbaddc0a067 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n", "chunk": "@@ -347,21 +347,37 @@ public class APIAdminImpl implements APIAdmin {\n         return length;\n     }\n \n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow[]\n+     * @throws APIManagementException\n+     */\n     public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n-\n-        return apiMgtDAO.getworkflows(workflowType, status , tenantDomain );\n+        return apiMgtDAO.getworkflows(workflowType, status, tenantDomain);\n     }\n \n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow\n+     * @throws APIManagementException\n+     */\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status,\n                                                                       String tenantDomain) throws APIManagementException {\n \n         Workflow workflow=apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef, status ,tenantDomain );\n \n         if (workflow == null) {\n-            String msg=\"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n+            String msg = \"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n             throw new APIMgtResourceNotFoundException(msg);\n         }\n-\n         return workflow;\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxODMyMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406618323", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:12:38Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -5937,10 +5934,24 @@ public void addWorkflowEntry(WorkflowDTO workflow) throws APIManagementException\n             prepStmt.setString(7, workflow.getTenantDomain());\n             prepStmt.setString(8, workflow.getExternalWorkflowReference());\n \n+            if(workflow.getMetadata()!=null){\n+                byte[] metadataByte = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MTc2Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410791762", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T01:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxODMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -5934,22 +5934,21 @@ public class ApiMgtDAO {\n             prepStmt.setString(7, workflow.getTenantDomain());\n             prepStmt.setString(8, workflow.getExternalWorkflowReference());\n \n-            if(workflow.getMetadata()!=null){\n+            if(workflow.getMetadata() != null) {\n                 byte[] metadataByte = workflow.getMetadata().toJSONString().getBytes(\"UTF-8\");\n                 prepStmt.setBlob(9, new ByteArrayInputStream(metadataByte) );\n             } else {\n-                prepStmt.setNull(9, java.sql.Types.BLOB);\n+                prepStmt.setBlob(9, (Blob)null);\n             }\n \n             if(workflow.getProperties() != null) {\n                 byte[] propertiesByte = workflow.getProperties().toJSONString().getBytes(\"UTF-8\");\n                 prepStmt.setBlob(10, new ByteArrayInputStream(propertiesByte));\n             } else {\n-                prepStmt.setNull(10, java.sql.Types.BLOB);\n+                //prepStmt.setNull(10, java.sql.Types.BLOB);\n+                prepStmt.setBlob(10, (Blob)null);\n             }\n-\n             prepStmt.execute();\n-\n             connection.commit();\n         } catch (SQLException | UnsupportedEncodingException e) {\n             handleException(\"Error while adding Workflow : \" + workflow.getExternalWorkflowReference() + \" to the \" +\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxODg0OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406618849", "body": "close the db connection once finished \r\n    finally {\r\n                APIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\r\n            }", "bodyText": "close the db connection once finished\nfinally {\nAPIMgtDBUtil.closeAllConnections(ps, conn, resultSet);\n}", "bodyHTML": "<p dir=\"auto\">close the db connection once finished<br>\nfinally {<br>\nAPIMgtDBUtil.closeAllConnections(ps, conn, resultSet);<br>\n}</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:14:52Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MTc4Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410791783", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T01:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxODg0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTA1OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406619059", "body": "add missing docs", "bodyText": "add missing docs", "bodyHTML": "<p dir=\"auto\">add missing docs</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:15:48Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTE3MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406619171", "body": "add missing docs", "bodyText": "add missing docs", "bodyHTML": "<p dir=\"auto\">add missing docs</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:16:20Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MTg0Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410791847", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTE3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTI2Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406619262", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:16:49Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MTg4Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410791887", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTI2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTM5Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406619397", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:17:28Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTYwMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406619603", "body": "EWR?? please use a readable parameters", "bodyText": "EWR?? please use a readable parameters", "bodyHTML": "<p dir=\"auto\">EWR?? please use a readable parameters</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:18:18Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTgzOQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406619839", "body": "remove unnecessary gaps between each statement", "bodyText": "remove unnecessary gaps between each statement", "bodyHTML": "<p dir=\"auto\">remove unnecessary gaps between each statement</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:19:02Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjAwMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792001", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14691,21 +14679,20 @@ public class ApiMgtDAO {\n                 Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n \n                 byte[] metadataByte;\n-\n                 if(metadatablob != null) {\n                     metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTk0OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406619949", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:19:33Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjA4Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792082", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxOTk0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14624,66 +14623,55 @@ public class ApiMgtDAO {\n \n     /**\n      * Remove the Pending workflow Requests using ExternalWorkflowReference\n-     *\n-     * @param workflowExtRef\n-     * @return\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n      */\n-\n     public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n-\n         String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             connection.setAutoCommit(false);\n-\n             prepStmt = connection.prepareStatement(query);\n             prepStmt.setString(1, workflowExtRef);\n             prepStmt.executeUpdate();\n             connection.commit();\n         }\n         catch (SQLException e) {\n-            handleException(\"Failed to delete the workflow request \", e);\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n         }\n     }\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference\n-     *\n      * @param externalWorkflowRef\n-     * @return\n+     * @return workflow pending request\n+     * @throws APIManagementException\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n-        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n-\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externalWorkflowRef);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n                 String workflowstatus =rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDAzNg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406620036", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:19:57Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14691,21 +14679,20 @@ public class ApiMgtDAO {\n                 Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n \n                 byte[] metadataByte;\n-\n                 if(metadatablob != null) {\n                     metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDA4Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406620087", "body": "format", "bodyText": "format", "bodyHTML": "<p dir=\"auto\">format</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:20:12Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjEyOQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792129", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14691,21 +14679,20 @@ public class ApiMgtDAO {\n                 Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n \n                 byte[] metadataByte;\n-\n                 if(metadatablob != null) {\n                     metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDI5MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406620290", "body": "don't use g as a variable name", "bodyText": "don't use g as a variable name", "bodyHTML": "<p dir=\"auto\">don't use g as a variable name</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:21:00Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14691,21 +14679,20 @@ public class ApiMgtDAO {\n                 Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n \n                 byte[] metadataByte;\n-\n                 if(metadatablob != null) {\n                     metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDUyMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406620520", "body": "add a space at the end of the message", "bodyText": "add a space at the end of the message", "bodyHTML": "<p dir=\"auto\">add a space at the end of the message</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:21:57Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14691,21 +14679,20 @@ public class ApiMgtDAO {\n                 Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n \n                 byte[] metadataByte;\n-\n                 if(metadatablob != null) {\n                     metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \" , e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDYyMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406620623", "body": "describe these", "bodyText": "describe these", "bodyHTML": "<p dir=\"auto\">describe these</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:22:20Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Requests using WorkflowType for a particular tenant\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14714,29 +14701,24 @@ public class ApiMgtDAO {\n \n     /**\n      * Get the Pending workflow Requests using WorkflowType for a particular tenant\n-     *\n-     * @param workflowType\n-     * @param status\n-     * @param tenantDomain\n-     * @return\n+     * @param workflowType Type of the workflow pending request\n+     * @param status workflow status of workflow pending request\n+     * @param tenantDomain tenantDomain of the user\n+     * @return List of workflow pending request\n+     * @throws APIManagementException\n      */\n-\n-    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n         Workflow[] workflows = null;\n-\n         String sqlQuery;\n-\n-        if (workflowType != null){\n+        if (workflowType != null) {\n             sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE;\n         } else {\n             sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n         }\n-\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDg5Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406620892", "body": "format this whole method.  remove any unnecessary spaces", "bodyText": "format this whole method.  remove any unnecessary spaces", "bodyHTML": "<p dir=\"auto\">format this whole method.  remove any unnecessary spaces</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:23:19Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Requests using WorkflowType for a particular tenant\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE;\n+        } else {\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            } else {\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14745,12 +14727,10 @@ public class ApiMgtDAO {\n                 prepStmt.setString(1, workflowType);\n                 prepStmt.setString( 2, status);\n                 prepStmt.setString( 3, tenantDomain);\n-\n             } else {\n                 prepStmt.setString( 1, status);\n                 prepStmt.setString( 2, tenantDomain);\n             }\n-\n             rs = prepStmt.executeQuery();\n \n             ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTI4Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406621287", "body": "format whole method and remove unnecessary spaces", "bodyText": "format whole method and remove unnecessary spaces", "bodyHTML": "<p dir=\"auto\">format whole method and remove unnecessary spaces</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:24:41Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Requests using WorkflowType for a particular tenant\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE;\n+        } else {\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            } else {\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] propertiesByte;\n+\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(json);\n+                } else {\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);\n+                }\n+\n+                workflowsList.add(workflow);\n+            }\n+            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n+        } catch (SQLException e) {\n+            handleException(\"Error when retrieve all the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflows;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n+                                                                      String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n+\n+        try {", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjE3Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792172", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14818,45 +14790,35 @@ public class ApiMgtDAO {\n \n     /**\n      * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n-     *\n-     * @param externelWorkflowRef\n-     * @param status\n-     * @param tenantDomain\n-     * @return\n+     * @param externelWorkflowRef of pending workflow request\n+     * @param status workflow status of workflow pending process\n+     * @param tenantDomain tenant domain of user\n+     * @return workflow pending request\n      */\n-\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n                                                                       String tenantDomain) throws APIManagementException {\n \n         Connection connection = null;\n         PreparedStatement prepStmt = null;\n         ResultSet rs = null;\n-\n-        Workflow workflow=new Workflow();\n-\n+        Workflow workflow = new Workflow();\n         String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n-\n         try {\n             connection = APIMgtDBUtil.getConnection();\n             prepStmt = connection.prepareStatement(sqlQuery);\n             prepStmt.setString(1, externelWorkflowRef);\n             prepStmt.setString(2, status);\n             prepStmt.setString(3, tenantDomain);\n-\n             rs = prepStmt.executeQuery();\n \n             while (rs.next()) {\n-\n                 workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n                 workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n                 workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n-\n-                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                String workflowstatus = rs.getString(\"WF_STATUS\");\n                 workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n-\n                 workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n                 workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n-\n                 workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n                 workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n                 workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTU2Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406621563", "body": "put a meaningful names to the variables. don't use g, json, json1", "bodyText": "put a meaningful names to the variables. don't use g, json, json1", "bodyHTML": "<p dir=\"auto\">put a meaningful names to the variables. don't use g, json, json1</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:25:51Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Requests using WorkflowType for a particular tenant\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE;\n+        } else {\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            } else {\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] propertiesByte;\n+\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(json);\n+                } else {\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);\n+                }\n+\n+                workflowsList.add(workflow);\n+            }\n+            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n+        } catch (SQLException e) {\n+            handleException(\"Error when retrieve all the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflows;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n+                                                                      String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externelWorkflowRef);\n+            prepStmt.setString(2, status);\n+            prepStmt.setString(3, tenantDomain);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14865,40 +14827,36 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json1 = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json1);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json1=new JSONObject();\n-                    workflow.setProperties(json1);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \", e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflow;\n-\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTY1MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406621651", "body": "use meaningful variable names", "bodyText": "use meaningful variable names", "bodyHTML": "<p dir=\"auto\">use meaningful variable names</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:26:14Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14621,284 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     *\n+     * @param workflowExtRef\n+     * @return\n+     */\n+\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request \", e);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EWR;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Requests using WorkflowType for a particular tenant\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow[] getworkflows(String workflowType ,String status ,String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow[] workflows = null;\n+\n+        String sqlQuery;\n+\n+        if (workflowType != null){\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE;\n+        } else {\n+            sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS;\n+        }\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+\n+            if (workflowType != null){\n+                prepStmt.setString(1, workflowType);\n+                prepStmt.setString( 2, status);\n+                prepStmt.setString( 3, tenantDomain);\n+\n+            } else {\n+                prepStmt.setString( 1, status);\n+                prepStmt.setString( 2, tenantDomain);\n+            }\n+\n+            rs = prepStmt.executeQuery();\n+\n+            ArrayList<Workflow> workflowsList = new ArrayList<Workflow>();\n+            Workflow workflow;\n+            while (rs.next()) {\n+                workflow = new Workflow();\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json = new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] propertiesByte;\n+\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(json);\n+                } else {\n+                    JSONObject json = new JSONObject();\n+                    workflow.setProperties(json);\n+                }\n+\n+                workflowsList.add(workflow);\n+            }\n+            workflows = workflowsList.toArray(new Workflow[workflowsList.size()]);\n+        } catch (SQLException e) {\n+            handleException(\"Error when retrieve all the workflow details\" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflows;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference for a particular tenant\n+     *\n+     * @param externelWorkflowRef\n+     * @param status\n+     * @param tenantDomain\n+     * @return\n+     */\n+\n+    public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status ,\n+                                                                      String tenantDomain) throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+\n+        Workflow workflow=new Workflow();\n+\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNAL_WORKFLOW_REFERENCE;\n+\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externelWorkflowRef);\n+            prepStmt.setString(2, status);\n+            prepStmt.setString(3, tenantDomain);\n+\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+\n+                workflow.setWorkflowDescription(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadataBlob = rs.getBlob(\"WF_METADATA\");\n+                Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n+\n+                byte[] metadataByte;\n+\n+                if(metadataBlob != null) {\n+                    metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson g = new Gson();\n+\n+                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(json);\n+                } else {\n+                    JSONObject json=new JSONObject();\n+                    workflow.setMetadata(json);\n+                }\n+\n+                byte[] propertiesByte;\n+\n+                if(propertiesBlob != null) {\n+                    propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n+                    InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n+                    String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n+                    Gson g = new Gson();\n+                    JSONObject json1 = g.fromJson(properties, JSONObject.class);", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\nindex be9b41b3956..c19a17b31df 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java\n", "chunk": "@@ -14865,40 +14827,36 @@ public class ApiMgtDAO {\n                 Blob propertiesBlob = rs.getBlob(\"WF_PROPERTIES\");\n \n                 byte[] metadataByte;\n-\n                 if(metadataBlob != null) {\n                     metadataByte = metadataBlob.getBytes(1L, (int) metadataBlob.length());\n                     InputStream targetStream = new ByteArrayInputStream(metadataByte);\n                     String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n-                    Gson g = new Gson();\n-\n-                    JSONObject json = g.fromJson(metadata, JSONObject.class);\n-                    workflow.setMetadata(json);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n                 } else {\n-                    JSONObject json=new JSONObject();\n-                    workflow.setMetadata(json);\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n                 }\n \n                 byte[] propertiesByte;\n-\n                 if(propertiesBlob != null) {\n                     propertiesByte = propertiesBlob.getBytes(1L, (int) propertiesBlob.length());\n                     InputStream propertiesTargetStream = new ByteArrayInputStream(propertiesByte);\n                     String properties = APIMgtDBUtil.getStringFromInputStream(propertiesTargetStream);\n-                    Gson g = new Gson();\n-                    JSONObject json1 = g.fromJson(properties, JSONObject.class);\n-                    workflow.setProperties(json1);\n+                    Gson propertiesGson = new Gson();\n+                    JSONObject propertiesJson = propertiesGson.fromJson(properties, JSONObject.class);\n+                    workflow.setProperties(propertiesJson);\n                 } else {\n-                    JSONObject json1=new JSONObject();\n-                    workflow.setProperties(json1);\n+                    JSONObject propertiesJson = new JSONObject();\n+                    workflow.setProperties(propertiesJson);\n                 }\n             }\n         } catch (SQLException e) {\n-            handleException(\"Error when retriving the workflow details\" , e);\n+            handleException(\"Error when retriving the workflow details. \", e);\n         } finally {\n             APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n         }\n         return workflow;\n-\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTc3MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406621770", "body": "put a meaningful variable name", "bodyText": "put a meaningful variable name", "bodyHTML": "<p dir=\"auto\">put a meaningful variable name</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:26:46Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java", "diffHunk": "@@ -1869,6 +1869,34 @@\n     public static final String GET_ALL_WORKFLOW_ENTRY_FROM_INTERNAL_REF_SQL =\n             \"SELECT * FROM AM_WORKFLOWS WHERE WF_REFERENCE=? AND WF_TYPE=?\";\n \n+    public static final String ADD_PAYLOAD_SQL =\n+            \" UPDATE AM_WORKFLOWS \" +\n+                    \" SET \" +\n+                    \"   WF_METADATA = ?, \" +\n+                    \"   WF_PROPERTIES = ?, \" +\n+                    \"   WF_STATUS_DESC = ? \" +\n+                    \" WHERE \" +\n+                    \"    WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String DELETE_WORKFLOW_REQUEST_SQL=\n+            \" DELETE FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n+\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR =", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\nindex 1c8534b9389..92c3f4ffb18 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/constants/SQLConstants.java\n", "chunk": "@@ -1881,7 +1881,7 @@ public class SQLConstants {\n     public static final String DELETE_WORKFLOW_REQUEST_SQL=\n             \" DELETE FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n-    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EWR =\n+    public static final String GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF =\n             \" SELECT  * FROM AM_WORKFLOWS WHERE WF_EXTERNAL_REFERENCE = ?\";\n \n     public static final String GET_ALL_WORKFLOW_DETAILS_BY_WORKFLOW_TYPE =\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTg4OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406621889", "body": "Add license header", "bodyText": "Add license header", "bodyHTML": "<p dir=\"auto\">Add license header</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:27:16Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjI0MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792241", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5NjI3NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410796275", "bodyText": "changed year with 68b7419", "author": "SahanHerath", "createdAt": "2020-04-19T02:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMTg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -1,3 +1,20 @@\n+/*\n+ *  Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n package org.wso2.carbon.apimgt.impl.workflow;\n \n import org.apache.commons.logging.Log;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjA2Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406622063", "body": "don't use wildcard import.", "bodyText": "don't use wildcard import.", "bodyHTML": "<p dir=\"auto\">don't use wildcard import.</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:27:50Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -15,9 +32,16 @@ import org.wso2.carbon.context.PrivilegedCarbonContext;\n import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n import org.wso2.carbon.registry.core.Registry;\n import org.wso2.carbon.registry.core.exceptions.RegistryException;\n-\n-import java.util.*;\n-\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+\n+/**\n+ * Approval workflow for API state change.\n+ *\n+ */\n public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex cb79bf0aaf2..1f581dbc8b4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -42,7 +42,7 @@ import java.util.ArrayList;\n  * Approval workflow for API state change.\n  *\n  */\n-public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor {\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n     private String stateList;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjE0MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406622140", "body": "where is the class description???", "bodyText": "where is the class description???", "bodyHTML": "<p dir=\"auto\">where is the class description???</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:28:08Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjQ3NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792474", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjE0MA=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -15,9 +32,16 @@ import org.wso2.carbon.context.PrivilegedCarbonContext;\n import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n import org.wso2.carbon.registry.core.Registry;\n import org.wso2.carbon.registry.core.exceptions.RegistryException;\n-\n-import java.util.*;\n-\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+\n+/**\n+ * Approval workflow for API state change.\n+ *\n+ */\n public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex cb79bf0aaf2..1f581dbc8b4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -42,7 +42,7 @@ import java.util.ArrayList;\n  * Approval workflow for API state change.\n  *\n  */\n-public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor {\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n     private String stateList;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjM1Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406622352", "body": "format the whole class and remove unnecessary spaces between statements ", "bodyText": "format the whole class and remove unnecessary spaces between statements", "bodyHTML": "<p dir=\"auto\">format the whole class and remove unnecessary spaces between statements</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:28:52Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjUyMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792523", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -15,9 +32,16 @@ import org.wso2.carbon.context.PrivilegedCarbonContext;\n import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n import org.wso2.carbon.registry.core.Registry;\n import org.wso2.carbon.registry.core.exceptions.RegistryException;\n-\n-import java.util.*;\n-\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ArrayList;\n+\n+/**\n+ * Approval workflow for API state change.\n+ *\n+ */\n public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex cb79bf0aaf2..1f581dbc8b4 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -42,7 +42,7 @@ import java.util.ArrayList;\n  * Approval workflow for API state change.\n  *\n  */\n-public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor {\n \n     private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n     private String stateList;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjU3Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406622572", "body": "lets put one debug log", "bodyText": "lets put one debug log", "bodyHTML": "<p dir=\"auto\">lets put one debug log</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:29:30Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -42,14 +65,16 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n         return Collections.emptyList();\n     }\n \n+    /**\n+     * Execute the API state change workflow approval process.\n+     * @param workflowDTO\n+     */\n     @Override\n     public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n \n         if (log.isDebugEnabled()) {\n             log.debug(\"Executing API State change Workflow.\");\n-            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n         }\n-\n         if (stateList != null) {\n             Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n             APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMjg3Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406622873", "body": "use simple s in 'State' ", "bodyText": "use simple s in 'State'", "bodyHTML": "<p dir=\"auto\">use simple s in 'State'</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:30:46Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n+        }\n+\n+        if (stateList != null) {\n+            Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n+            APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n+\n+            if (stateActionMap.containsKey(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    && stateActionMap.get(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n+\n+                String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n+                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -59,35 +84,20 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                     .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n \n                 String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n-                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                String message = \"Approval request for API state change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n                         + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n                         + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n                         + apiStateWorkFlowDTO.getApiProvider() + \"\";\n \n                 apiStateWorkFlowDTO.setWorkflowDescription(message);\n-\n-                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n-                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n-                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n-                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n                 apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n                 apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n-                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n                 apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n                 apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n-                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n-\n                 super.execute(workflowDTO);\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"APIStateChange payload: \");\n-                }\n-\n             } else {\n                 // For any other states, act as simple workflow executor.\n                 workflowDTO.setStatus(WorkflowStatus.APPROVED);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMzM5Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406623397", "body": "this property is not needed. you don't have to set any . don't set any value", "bodyText": "this property is not needed. you don't have to set any . don't set any value", "bodyHTML": "<p dir=\"auto\">this property is not needed. you don't have to set any . don't set any value</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:33:05Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n+        }\n+\n+        if (stateList != null) {\n+            Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n+            APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n+\n+            if (stateActionMap.containsKey(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    && stateActionMap.get(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n+\n+                String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n+                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                        + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n+                        + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n+                        + apiStateWorkFlowDTO.getApiProvider() + \"\";\n+\n+                apiStateWorkFlowDTO.setWorkflowDescription(message);\n+\n+                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n+                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n+                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n+                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n+                apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n+                apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n+                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n+                apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n+                apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n+                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -59,35 +84,20 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                     .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n \n                 String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n-                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                String message = \"Approval request for API state change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n                         + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n                         + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n                         + apiStateWorkFlowDTO.getApiProvider() + \"\";\n \n                 apiStateWorkFlowDTO.setWorkflowDescription(message);\n-\n-                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n-                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n-                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n-                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n                 apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n                 apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n-                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n                 apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n                 apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n-                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n-\n                 super.execute(workflowDTO);\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"APIStateChange payload: \");\n-                }\n-\n             } else {\n                 // For any other states, act as simple workflow executor.\n                 workflowDTO.setStatus(WorkflowStatus.APPROVED);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMzU4NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406623584", "body": "Error message is not complete. see the end of the message", "bodyText": "Error message is not complete. see the end of the message", "bodyHTML": "<p dir=\"auto\">Error message is not complete. see the end of the message</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:33:49Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n+        }\n+\n+        if (stateList != null) {\n+            Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n+            APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n+\n+            if (stateActionMap.containsKey(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    && stateActionMap.get(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n+\n+                String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n+                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                        + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n+                        + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n+                        + apiStateWorkFlowDTO.getApiProvider() + \"\";\n+\n+                apiStateWorkFlowDTO.setWorkflowDescription(message);\n+\n+                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n+                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n+                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n+                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n+                apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n+                apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n+                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n+                apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n+                apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n+                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n+\n+                super.execute(workflowDTO);\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"APIStateChange payload: \");\n+                }\n+\n+            } else {\n+                // For any other states, act as simple workflow executor.\n+                workflowDTO.setStatus(WorkflowStatus.APPROVED);\n+                // calling super.complete() instead of complete() to act as the simpleworkflow executor\n+                super.complete(workflowDTO);\n+            }\n+        } else {\n+            String msg = \"State change list is not provided. Please check <stateList> element in \";", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -59,35 +84,20 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                     .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n \n                 String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n-                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                String message = \"Approval request for API state change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n                         + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n                         + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n                         + apiStateWorkFlowDTO.getApiProvider() + \"\";\n \n                 apiStateWorkFlowDTO.setWorkflowDescription(message);\n-\n-                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n-                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n-                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n-                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n                 apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n                 apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n-                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n                 apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n                 apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n-                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n-\n                 super.execute(workflowDTO);\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"APIStateChange payload: \");\n-                }\n-\n             } else {\n                 // For any other states, act as simple workflow executor.\n                 workflowDTO.setStatus(WorkflowStatus.APPROVED);\n", "next_change": null}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -95,42 +105,37 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                 super.complete(workflowDTO);\n             }\n         } else {\n-            String msg = \"State change list is not provided. Please check <stateList> element in \";\n+            String msg = \"State change list is not provided. Please check <stateList> element in workflow-extensions.xml\";\n             log.error(msg);\n             throw new WorkflowException(msg);\n         }\n-\n         return new GeneralWorkflowResponse();\n     }\n \n     /**\n-     * Complete the API state change workflow process.\n+     * Complete the API state change workflow approval process.\n+     * @param workflowDTO\n      */\n     @Override\n-    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException{\n+    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException {\n         if (log.isDebugEnabled()) {\n             log.debug(\"Completing API State change Workflow..\");\n-            log.debug(\"response: \" + workflowDTO.toString());\n         }\n-\n         workflowDTO.setUpdatedTime(System.currentTimeMillis());\n         super.complete(workflowDTO);\n-\n         String externalWorkflowRef=workflowDTO.getExternalWorkflowReference();\n \n         try {\n-            ApiMgtDAO apiMgtDAO1 = ApiMgtDAO.getInstance();\n-            Workflow workflow = apiMgtDAO1.getworkflowReferenceByExternalWorkflowReference(externalWorkflowRef);\n-\n+            ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n+            Workflow workflow = apiMgtDAO.getworkflowReferenceByExternalWorkflowReference(externalWorkflowRef);\n             String apiName = workflow.getMetadata(\"ApiName\");\n             String action = workflow.getMetadata(\"Action\");\n             String providerName = workflow.getMetadata(\"ApiProvider\");\n             String version = workflow.getMetadata(\"ApiVersion\");\n             String invoker = workflow.getMetadata(\"Invoker\");\n             String currentStatus = workflow.getMetadata(\"CurrentState\");\n-\n             int tenantId = workflowDTO.getTenantId();\n-            ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n+            //ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n             try {\n                 //tenant flow is already started from the rest api service impl. no need to start from here\n                 PrivilegedCarbonContext.getThreadLocalCarbonContext().setUsername(invoker);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMzY3Ng==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406623676", "body": "where is the payload??", "bodyText": "where is the payload??", "bodyHTML": "<p dir=\"auto\">where is the payload??</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:34:07Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n+        }\n+\n+        if (stateList != null) {\n+            Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n+            APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n+\n+            if (stateActionMap.containsKey(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    && stateActionMap.get(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n+\n+                String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n+                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                        + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n+                        + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n+                        + apiStateWorkFlowDTO.getApiProvider() + \"\";\n+\n+                apiStateWorkFlowDTO.setWorkflowDescription(message);\n+\n+                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n+                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n+                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n+                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n+                apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n+                apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n+                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n+                apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n+                apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n+                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n+\n+                super.execute(workflowDTO);\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"APIStateChange payload: \");", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -59,35 +84,20 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                     .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n \n                 String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n-                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                String message = \"Approval request for API state change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n                         + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n                         + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n                         + apiStateWorkFlowDTO.getApiProvider() + \"\";\n \n                 apiStateWorkFlowDTO.setWorkflowDescription(message);\n-\n-                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n-                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n-                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n-                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n                 apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n                 apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n-                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n                 apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n                 apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n-                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n-\n                 super.execute(workflowDTO);\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"APIStateChange payload: \");\n-                }\n-\n             } else {\n                 // For any other states, act as simple workflow executor.\n                 workflowDTO.setStatus(WorkflowStatus.APPROVED);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDYxNg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406624616", "body": "You don't have to set all this information as metadata. ClientId, ClientSecret, Scope, TokenAPI, workflowExternalRef, callBackURL are not needed. plz remove them", "bodyText": "You don't have to set all this information as metadata. ClientId, ClientSecret, Scope, TokenAPI, workflowExternalRef, callBackURL are not needed. plz remove them", "bodyHTML": "<p dir=\"auto\">You don't have to set all this information as metadata. ClientId, ClientSecret, Scope, TokenAPI, workflowExternalRef, callBackURL are not needed. plz remove them</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:37:51Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n+        }\n+\n+        if (stateList != null) {\n+            Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n+            APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n+\n+            if (stateActionMap.containsKey(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    && stateActionMap.get(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n+\n+                String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n+                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                        + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n+                        + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n+                        + apiStateWorkFlowDTO.getApiProvider() + \"\";\n+\n+                apiStateWorkFlowDTO.setWorkflowDescription(message);\n+\n+                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n+                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n+                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n+                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n+                apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n+                apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n+                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n+                apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n+                apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n+                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -59,35 +84,20 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                     .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n \n                 String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n-                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                String message = \"Approval request for API state change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n                         + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n                         + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n                         + apiStateWorkFlowDTO.getApiProvider() + \"\";\n \n                 apiStateWorkFlowDTO.setWorkflowDescription(message);\n-\n-                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n-                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n-                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n-                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n                 apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n                 apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n                 apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n-                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n                 apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n                 apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n-                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n-\n                 super.execute(workflowDTO);\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"APIStateChange payload: \");\n-                }\n-\n             } else {\n                 // For any other states, act as simple workflow executor.\n                 workflowDTO.setStatus(WorkflowStatus.APPROVED);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDgxMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406624811", "body": "rename the variable name. don't use 1 ", "bodyText": "rename the variable name. don't use 1", "bodyHTML": "<p dir=\"auto\">rename the variable name. don't use 1</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:38:35Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n+        }\n+\n+        if (stateList != null) {\n+            Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n+            APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n+\n+            if (stateActionMap.containsKey(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    && stateActionMap.get(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n+\n+                String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n+                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                        + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n+                        + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n+                        + apiStateWorkFlowDTO.getApiProvider() + \"\";\n+\n+                apiStateWorkFlowDTO.setWorkflowDescription(message);\n+\n+                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n+                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n+                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n+                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n+                apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n+                apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n+                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n+                apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n+                apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n+                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n+\n+                super.execute(workflowDTO);\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"APIStateChange payload: \");\n+                }\n+\n+            } else {\n+                // For any other states, act as simple workflow executor.\n+                workflowDTO.setStatus(WorkflowStatus.APPROVED);\n+                // calling super.complete() instead of complete() to act as the simpleworkflow executor\n+                super.complete(workflowDTO);\n+            }\n+        } else {\n+            String msg = \"State change list is not provided. Please check <stateList> element in \";\n+            log.error(msg);\n+            throw new WorkflowException(msg);\n+        }\n+\n+        return new GeneralWorkflowResponse();\n+    }\n+\n+    /**\n+     * Complete the API state change workflow process.\n+     */\n+    @Override\n+    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException{\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Completing API State change Workflow..\");\n+            log.debug(\"response: \" + workflowDTO.toString());\n+        }\n+\n+        workflowDTO.setUpdatedTime(System.currentTimeMillis());\n+        super.complete(workflowDTO);\n+\n+        String externalWorkflowRef=workflowDTO.getExternalWorkflowReference();\n+\n+        try {\n+            ApiMgtDAO apiMgtDAO1 = ApiMgtDAO.getInstance();", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -95,42 +105,37 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                 super.complete(workflowDTO);\n             }\n         } else {\n-            String msg = \"State change list is not provided. Please check <stateList> element in \";\n+            String msg = \"State change list is not provided. Please check <stateList> element in workflow-extensions.xml\";\n             log.error(msg);\n             throw new WorkflowException(msg);\n         }\n-\n         return new GeneralWorkflowResponse();\n     }\n \n     /**\n-     * Complete the API state change workflow process.\n+     * Complete the API state change workflow approval process.\n+     * @param workflowDTO\n      */\n     @Override\n-    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException{\n+    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException {\n         if (log.isDebugEnabled()) {\n             log.debug(\"Completing API State change Workflow..\");\n-            log.debug(\"response: \" + workflowDTO.toString());\n         }\n-\n         workflowDTO.setUpdatedTime(System.currentTimeMillis());\n         super.complete(workflowDTO);\n-\n         String externalWorkflowRef=workflowDTO.getExternalWorkflowReference();\n \n         try {\n-            ApiMgtDAO apiMgtDAO1 = ApiMgtDAO.getInstance();\n-            Workflow workflow = apiMgtDAO1.getworkflowReferenceByExternalWorkflowReference(externalWorkflowRef);\n-\n+            ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n+            Workflow workflow = apiMgtDAO.getworkflowReferenceByExternalWorkflowReference(externalWorkflowRef);\n             String apiName = workflow.getMetadata(\"ApiName\");\n             String action = workflow.getMetadata(\"Action\");\n             String providerName = workflow.getMetadata(\"ApiProvider\");\n             String version = workflow.getMetadata(\"ApiVersion\");\n             String invoker = workflow.getMetadata(\"Invoker\");\n             String currentStatus = workflow.getMetadata(\"CurrentState\");\n-\n             int tenantId = workflowDTO.getTenantId();\n-            ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n+            //ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n             try {\n                 //tenant flow is already started from the rest api service impl. no need to start from here\n                 PrivilegedCarbonContext.getThreadLocalCarbonContext().setUsername(invoker);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTAyOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406625028", "body": "use the previous apiMgtDAO instead of creating a new variable", "bodyText": "use the previous apiMgtDAO instead of creating a new variable", "bodyHTML": "<p dir=\"auto\">use the previous apiMgtDAO instead of creating a new variable</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:39:17Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.APIIdentifier;\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.governance.api.generic.dataobjects.GenericArtifact;\n+import org.wso2.carbon.registry.core.Registry;\n+import org.wso2.carbon.registry.core.exceptions.RegistryException;\n+\n+import java.util.*;\n+\n+public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(APIStateChangeWSWorkflowExecutor.class);\n+    private String stateList;\n+\n+    public String getStateList() {\n+        return stateList;\n+    }\n+\n+    public void setStateList(String stateList) {\n+        this.stateList = stateList;\n+    }\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_API_STATE;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing API State change Workflow.\");\n+            log.debug(\"Execute workflowDTO \" + workflowDTO.toString());\n+        }\n+\n+        if (stateList != null) {\n+            Map<String, List<String>> stateActionMap = getSelectedStatesToApprove();\n+            APIStateWorkflowDTO apiStateWorkFlowDTO = (APIStateWorkflowDTO) workflowDTO;\n+\n+            if (stateActionMap.containsKey(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    && stateActionMap.get(apiStateWorkFlowDTO.getApiCurrentState().toUpperCase())\n+                    .contains(apiStateWorkFlowDTO.getApiLCAction())) {\n+\n+                String callBackURL = apiStateWorkFlowDTO.getCallbackUrl();\n+                String message = \"Approval request for API State change action '\" + apiStateWorkFlowDTO.getApiLCAction()\n+                        + \"' from '\" + apiStateWorkFlowDTO.getApiCurrentState() + \"' state for the API '\"\n+                        + apiStateWorkFlowDTO.getApiName() + \" : \" + apiStateWorkFlowDTO.getApiVersion() + \"' by \"\n+                        + apiStateWorkFlowDTO.getApiProvider() + \"\";\n+\n+                apiStateWorkFlowDTO.setWorkflowDescription(message);\n+\n+                apiStateWorkFlowDTO.setMetadata(\"ClientId\", apiStateWorkFlowDTO.getClientId());\n+                apiStateWorkFlowDTO.setMetadata(\"ClientSecret\", apiStateWorkFlowDTO.getClientSecret());\n+                apiStateWorkFlowDTO.setMetadata(\"Scope\", apiStateWorkFlowDTO.getScope());\n+                apiStateWorkFlowDTO.setMetadata(\"TokenAPI\", apiStateWorkFlowDTO.getTokenAPI());\n+                apiStateWorkFlowDTO.setMetadata(\"CurrentState\", apiStateWorkFlowDTO.getApiCurrentState());\n+                apiStateWorkFlowDTO.setMetadata(\"Action\", apiStateWorkFlowDTO.getApiLCAction());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiName\", apiStateWorkFlowDTO.getApiName());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiVersion\", apiStateWorkFlowDTO.getApiVersion());\n+                apiStateWorkFlowDTO.setMetadata(\"ApiProvider\", apiStateWorkFlowDTO.getApiProvider());\n+                apiStateWorkFlowDTO.setMetadata(\"workflowExternalRef\", apiStateWorkFlowDTO.getExternalWorkflowReference());\n+                apiStateWorkFlowDTO.setMetadata(\"Invoker\", apiStateWorkFlowDTO.getInvoker());\n+                apiStateWorkFlowDTO.setMetadata(\"TenantId\", String.valueOf(apiStateWorkFlowDTO.getTenantId()));\n+                apiStateWorkFlowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+                apiStateWorkFlowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n+\n+                super.execute(workflowDTO);\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"APIStateChange payload: \");\n+                }\n+\n+            } else {\n+                // For any other states, act as simple workflow executor.\n+                workflowDTO.setStatus(WorkflowStatus.APPROVED);\n+                // calling super.complete() instead of complete() to act as the simpleworkflow executor\n+                super.complete(workflowDTO);\n+            }\n+        } else {\n+            String msg = \"State change list is not provided. Please check <stateList> element in \";\n+            log.error(msg);\n+            throw new WorkflowException(msg);\n+        }\n+\n+        return new GeneralWorkflowResponse();\n+    }\n+\n+    /**\n+     * Complete the API state change workflow process.\n+     */\n+    @Override\n+    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException{\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Completing API State change Workflow..\");\n+            log.debug(\"response: \" + workflowDTO.toString());\n+        }\n+\n+        workflowDTO.setUpdatedTime(System.currentTimeMillis());\n+        super.complete(workflowDTO);\n+\n+        String externalWorkflowRef=workflowDTO.getExternalWorkflowReference();\n+\n+        try {\n+            ApiMgtDAO apiMgtDAO1 = ApiMgtDAO.getInstance();\n+            Workflow workflow = apiMgtDAO1.getworkflowReferenceByExternalWorkflowReference(externalWorkflowRef);\n+\n+            String apiName = workflow.getMetadata(\"ApiName\");\n+            String action = workflow.getMetadata(\"Action\");\n+            String providerName = workflow.getMetadata(\"ApiProvider\");\n+            String version = workflow.getMetadata(\"ApiVersion\");\n+            String invoker = workflow.getMetadata(\"Invoker\");\n+            String currentStatus = workflow.getMetadata(\"CurrentState\");\n+\n+            int tenantId = workflowDTO.getTenantId();\n+            ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\nindex b18c28630f1..cb79bf0aaf2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/APIStateChangeApprovalWorkflowExecutor.java\n", "chunk": "@@ -95,42 +105,37 @@ public class APIStateChangeApprovalWorkflowExecutor extends WorkflowExecutor{\n                 super.complete(workflowDTO);\n             }\n         } else {\n-            String msg = \"State change list is not provided. Please check <stateList> element in \";\n+            String msg = \"State change list is not provided. Please check <stateList> element in workflow-extensions.xml\";\n             log.error(msg);\n             throw new WorkflowException(msg);\n         }\n-\n         return new GeneralWorkflowResponse();\n     }\n \n     /**\n-     * Complete the API state change workflow process.\n+     * Complete the API state change workflow approval process.\n+     * @param workflowDTO\n      */\n     @Override\n-    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException{\n+    public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException {\n         if (log.isDebugEnabled()) {\n             log.debug(\"Completing API State change Workflow..\");\n-            log.debug(\"response: \" + workflowDTO.toString());\n         }\n-\n         workflowDTO.setUpdatedTime(System.currentTimeMillis());\n         super.complete(workflowDTO);\n-\n         String externalWorkflowRef=workflowDTO.getExternalWorkflowReference();\n \n         try {\n-            ApiMgtDAO apiMgtDAO1 = ApiMgtDAO.getInstance();\n-            Workflow workflow = apiMgtDAO1.getworkflowReferenceByExternalWorkflowReference(externalWorkflowRef);\n-\n+            ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n+            Workflow workflow = apiMgtDAO.getworkflowReferenceByExternalWorkflowReference(externalWorkflowRef);\n             String apiName = workflow.getMetadata(\"ApiName\");\n             String action = workflow.getMetadata(\"Action\");\n             String providerName = workflow.getMetadata(\"ApiProvider\");\n             String version = workflow.getMetadata(\"ApiVersion\");\n             String invoker = workflow.getMetadata(\"Invoker\");\n             String currentStatus = workflow.getMetadata(\"CurrentState\");\n-\n             int tenantId = workflowDTO.getTenantId();\n-            ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n+            //ApiMgtDAO apiMgtDAO = ApiMgtDAO.getInstance();\n             try {\n                 //tenant flow is already started from the rest api service impl. no need to start from here\n                 PrivilegedCarbonContext.getThreadLocalCarbonContext().setUsername(invoker);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTMyMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406625321", "body": "license header", "bodyText": "license header", "bodyHTML": "<p dir=\"auto\">license header</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:40:26Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.wso2.carbon.apimgt.impl.workflow;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjU4OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792588", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5NjM0OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410796348", "bodyText": "changed year with 68b7419", "author": "SahanHerath", "createdAt": "2020-04-19T02:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 94da0ac8a1c..642be06b446 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -1,3 +1,20 @@\n+/*\n+ *  Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n package org.wso2.carbon.apimgt.impl.workflow;\n \n import org.apache.commons.logging.Log;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTM5Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406625393", "body": "class description", "bodyText": "class description", "bodyHTML": "<p dir=\"auto\">class description</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:40:39Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.Application;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.ApplicationWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjYzMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792630", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMxMDE4OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414310189", "bodyText": "formatting issue.", "author": "chamilaadhi", "createdAt": "2020-04-24T05:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTM5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 94da0ac8a1c..642be06b446 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -9,12 +26,14 @@ import org.wso2.carbon.apimgt.impl.APIConstants;\n import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n import org.wso2.carbon.apimgt.impl.dto.ApplicationWorkflowDTO;\n import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n-\n import java.util.List;\n \n+/**\n+ * Approval workflow for Application Creation.\n+ *\n+ */\n public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n \n-\n     private static final Log log = LogFactory.getLog(ApplicationCreationApprovalWorkflowExecutor.class);\n \n     @Override\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 642be06b446..8b7487218af 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -32,7 +32,7 @@ import java.util.List;\n  * Approval workflow for Application Creation.\n  *\n  */\n-public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n+public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor {\n \n     private static final Log log = LogFactory.getLog(ApplicationCreationApprovalWorkflowExecutor.class);\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTQ4MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406625480", "body": "format whole class and remove spaces", "bodyText": "format whole class and remove spaces", "bodyHTML": "<p dir=\"auto\">format whole class and remove spaces</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:41:00Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.Application;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.ApplicationWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 94da0ac8a1c..642be06b446 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -9,12 +26,14 @@ import org.wso2.carbon.apimgt.impl.APIConstants;\n import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n import org.wso2.carbon.apimgt.impl.dto.ApplicationWorkflowDTO;\n import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n-\n import java.util.List;\n \n+/**\n+ * Approval workflow for Application Creation.\n+ *\n+ */\n public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n \n-\n     private static final Log log = LogFactory.getLog(ApplicationCreationApprovalWorkflowExecutor.class);\n \n     @Override\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 642be06b446..8b7487218af 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -32,7 +32,7 @@ import java.util.List;\n  * Approval workflow for Application Creation.\n  *\n  */\n-public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n+public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor {\n \n     private static final Log log = LogFactory.getLog(ApplicationCreationApprovalWorkflowExecutor.class);\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTYwOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406625608", "body": "no need to set this", "bodyText": "no need to set this", "bodyHTML": "<p dir=\"auto\">no need to set this</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:41:32Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.Application;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.ApplicationWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+\n+    private static final Log log = LogFactory.getLog(ApplicationCreationApprovalWorkflowExecutor.class);\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_APPLICATION_CREATION;\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing Application creation Workflow.\");\n+        }\n+\n+        ApplicationWorkflowDTO appWorkFlowDTO = (ApplicationWorkflowDTO) workflowDTO;\n+        Application application = appWorkFlowDTO.getApplication();\n+        String callBackURL = appWorkFlowDTO.getCallbackUrl();\n+\n+        String message=\"Approve application [\"+ application.getName() +\"] creation request from application creator -\"\n+                +appWorkFlowDTO.getUserName()+\" with throttling tier - \"+application.getTier();\n+\n+        workflowDTO.setWorkflowDescription(message);\n+\n+        workflowDTO.setMetadata(\"applicationName\", application.getName());\n+        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n+        workflowDTO.setMetadata(\"applicationCallbackUrl\", application.getCallbackUrl());\n+        workflowDTO.setMetadata(\"applicationDescription\", application.getDescription());\n+        workflowDTO.setMetadata(\"tenantDomain\", appWorkFlowDTO.getTenantDomain());\n+        workflowDTO.setMetadata(\"userName\", appWorkFlowDTO.getUserName());\n+        workflowDTO.setMetadata(\"workflowExternalRef\", appWorkFlowDTO.getExternalWorkflowReference());\n+        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+        workflowDTO.setProperties(\"Workflow Process\",\"Application Creation\");", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 94da0ac8a1c..642be06b446 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -31,34 +54,18 @@ public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecuto\n         ApplicationWorkflowDTO appWorkFlowDTO = (ApplicationWorkflowDTO) workflowDTO;\n         Application application = appWorkFlowDTO.getApplication();\n         String callBackURL = appWorkFlowDTO.getCallbackUrl();\n-\n         String message=\"Approve application [\"+ application.getName() +\"] creation request from application creator -\"\n                 +appWorkFlowDTO.getUserName()+\" with throttling tier - \"+application.getTier();\n \n         workflowDTO.setWorkflowDescription(message);\n-\n-        workflowDTO.setMetadata(\"applicationName\", application.getName());\n-        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n-        workflowDTO.setMetadata(\"applicationCallbackUrl\", application.getCallbackUrl());\n-        workflowDTO.setMetadata(\"applicationDescription\", application.getDescription());\n-        workflowDTO.setMetadata(\"tenantDomain\", appWorkFlowDTO.getTenantDomain());\n-        workflowDTO.setMetadata(\"userName\", appWorkFlowDTO.getUserName());\n-        workflowDTO.setMetadata(\"workflowExternalRef\", appWorkFlowDTO.getExternalWorkflowReference());\n-        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-        workflowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n-\n         super.execute(workflowDTO);\n \n         return new GeneralWorkflowResponse();\n     }\n \n     /**\n-     * Complete the external process status.\n-     * Based on the workflow , we will update the status column of the\n-     * Application table\n-     *\n-     * @param workFlowDTO object\n+     * Complete the Application creation approval workflow peocess.\n+     * @param workFlowDTO\n      */\n     @Override\n     public WorkflowResponse complete(WorkflowDTO workFlowDTO) throws WorkflowException {\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 642be06b446..8b7487218af 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -65,6 +64,7 @@ public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecuto\n \n     /**\n      * Complete the Application creation approval workflow peocess.\n+     *\n      * @param workFlowDTO\n      */\n     @Override\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjAyNw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406626027", "body": "you don't have to set any metadata. Only set them if you need to get it from the complete() method. seems like any of the above are not needed", "bodyText": "you don't have to set any metadata. Only set them if you need to get it from the complete() method. seems like any of the above are not needed", "bodyHTML": "<p dir=\"auto\">you don't have to set any metadata. Only set them if you need to get it from the complete() method. seems like any of the above are not needed</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:43:04Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.Application;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.ApplicationWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+\n+    private static final Log log = LogFactory.getLog(ApplicationCreationApprovalWorkflowExecutor.class);\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_APPLICATION_CREATION;\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing Application creation Workflow.\");\n+        }\n+\n+        ApplicationWorkflowDTO appWorkFlowDTO = (ApplicationWorkflowDTO) workflowDTO;\n+        Application application = appWorkFlowDTO.getApplication();\n+        String callBackURL = appWorkFlowDTO.getCallbackUrl();\n+\n+        String message=\"Approve application [\"+ application.getName() +\"] creation request from application creator -\"\n+                +appWorkFlowDTO.getUserName()+\" with throttling tier - \"+application.getTier();\n+\n+        workflowDTO.setWorkflowDescription(message);\n+\n+        workflowDTO.setMetadata(\"applicationName\", application.getName());\n+        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n+        workflowDTO.setMetadata(\"applicationCallbackUrl\", application.getCallbackUrl());\n+        workflowDTO.setMetadata(\"applicationDescription\", application.getDescription());\n+        workflowDTO.setMetadata(\"tenantDomain\", appWorkFlowDTO.getTenantDomain());\n+        workflowDTO.setMetadata(\"userName\", appWorkFlowDTO.getUserName());\n+        workflowDTO.setMetadata(\"workflowExternalRef\", appWorkFlowDTO.getExternalWorkflowReference());\n+        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 94da0ac8a1c..642be06b446 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -31,34 +54,18 @@ public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecuto\n         ApplicationWorkflowDTO appWorkFlowDTO = (ApplicationWorkflowDTO) workflowDTO;\n         Application application = appWorkFlowDTO.getApplication();\n         String callBackURL = appWorkFlowDTO.getCallbackUrl();\n-\n         String message=\"Approve application [\"+ application.getName() +\"] creation request from application creator -\"\n                 +appWorkFlowDTO.getUserName()+\" with throttling tier - \"+application.getTier();\n \n         workflowDTO.setWorkflowDescription(message);\n-\n-        workflowDTO.setMetadata(\"applicationName\", application.getName());\n-        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n-        workflowDTO.setMetadata(\"applicationCallbackUrl\", application.getCallbackUrl());\n-        workflowDTO.setMetadata(\"applicationDescription\", application.getDescription());\n-        workflowDTO.setMetadata(\"tenantDomain\", appWorkFlowDTO.getTenantDomain());\n-        workflowDTO.setMetadata(\"userName\", appWorkFlowDTO.getUserName());\n-        workflowDTO.setMetadata(\"workflowExternalRef\", appWorkFlowDTO.getExternalWorkflowReference());\n-        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-        workflowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n-\n         super.execute(workflowDTO);\n \n         return new GeneralWorkflowResponse();\n     }\n \n     /**\n-     * Complete the external process status.\n-     * Based on the workflow , we will update the status column of the\n-     * Application table\n-     *\n-     * @param workFlowDTO object\n+     * Complete the Application creation approval workflow peocess.\n+     * @param workFlowDTO\n      */\n     @Override\n     public WorkflowResponse complete(WorkflowDTO workFlowDTO) throws WorkflowException {\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 642be06b446..8b7487218af 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -65,6 +64,7 @@ public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecuto\n \n     /**\n      * Complete the Application creation approval workflow peocess.\n+     *\n      * @param workFlowDTO\n      */\n     @Override\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjIzOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406626238", "body": "remove + ", "bodyText": "remove +", "bodyHTML": "<p dir=\"auto\">remove +</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:43:44Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.Application;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.ApplicationWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+\n+    private static final Log log = LogFactory.getLog(ApplicationCreationApprovalWorkflowExecutor.class);\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_APPLICATION_CREATION;\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing Application creation Workflow.\");\n+        }\n+\n+        ApplicationWorkflowDTO appWorkFlowDTO = (ApplicationWorkflowDTO) workflowDTO;\n+        Application application = appWorkFlowDTO.getApplication();\n+        String callBackURL = appWorkFlowDTO.getCallbackUrl();\n+\n+        String message=\"Approve application [\"+ application.getName() +\"] creation request from application creator -\"\n+                +appWorkFlowDTO.getUserName()+\" with throttling tier - \"+application.getTier();\n+\n+        workflowDTO.setWorkflowDescription(message);\n+\n+        workflowDTO.setMetadata(\"applicationName\", application.getName());\n+        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n+        workflowDTO.setMetadata(\"applicationCallbackUrl\", application.getCallbackUrl());\n+        workflowDTO.setMetadata(\"applicationDescription\", application.getDescription());\n+        workflowDTO.setMetadata(\"tenantDomain\", appWorkFlowDTO.getTenantDomain());\n+        workflowDTO.setMetadata(\"userName\", appWorkFlowDTO.getUserName());\n+        workflowDTO.setMetadata(\"workflowExternalRef\", appWorkFlowDTO.getExternalWorkflowReference());\n+        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+        workflowDTO.setProperties(\"Workflow Process\",\"Application Creation\");\n+\n+        super.execute(workflowDTO);\n+\n+        return new GeneralWorkflowResponse();\n+    }\n+\n+    /**\n+     * Complete the external process status.\n+     * Based on the workflow , we will update the status column of the\n+     * Application table\n+     *\n+     * @param workFlowDTO object\n+     */\n+    @Override\n+    public WorkflowResponse complete(WorkflowDTO workFlowDTO) throws WorkflowException {\n+\n+        workFlowDTO.setUpdatedTime(System.currentTimeMillis());\n+        ApiMgtDAO dao = ApiMgtDAO.getInstance();\n+        try {\n+            if (dao.getApplicationById(Integer.parseInt(workFlowDTO.getWorkflowReference())) != null) {\n+\n+                super.complete(workFlowDTO);\n+                log.info(\"Application Creation [Complete] Workflow Invoked. Workflow ID : \" + workFlowDTO\n+                        .getExternalWorkflowReference() + \"Workflow State : \" + workFlowDTO.getStatus());\n+\n+                String status = null;\n+                if (WorkflowStatus.CREATED.equals(workFlowDTO.getStatus())) {\n+                    status = APIConstants.ApplicationStatus.APPLICATION_CREATED;\n+                } else if (WorkflowStatus.REJECTED.equals(workFlowDTO.getStatus())) {\n+                    status = APIConstants.ApplicationStatus.APPLICATION_REJECTED;\n+                } else if (WorkflowStatus.APPROVED.equals(workFlowDTO.getStatus())) {\n+                    status = APIConstants.ApplicationStatus.APPLICATION_APPROVED;\n+                }\n+\n+                try {\n+                    dao.updateApplicationStatus(Integer.parseInt(workFlowDTO.getWorkflowReference()), status);\n+                } catch (APIManagementException e) {\n+                    String msg = \"Error occurred when updating the status of the Application creation \" + \"process\";\n+                    log.error(msg, e);", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjY5NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792694", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjIzOA=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\nindex 94da0ac8a1c..642be06b446 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -84,11 +90,10 @@ public class ApplicationCreationApprovalWorkflowExecutor extends WorkflowExecuto\n                 try {\n                     dao.updateApplicationStatus(Integer.parseInt(workFlowDTO.getWorkflowReference()), status);\n                 } catch (APIManagementException e) {\n-                    String msg = \"Error occurred when updating the status of the Application creation \" + \"process\";\n+                    String msg = \"Error occurred when updating the status of the Application creation process\";\n                     log.error(msg, e);\n                     throw new WorkflowException(msg, e);\n                 }\n-\n             } else {\n                 String msg = \"Application does not exist\";\n                 throw new WorkflowException(msg);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjQ4Ng==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406626486", "body": "License header, class description and format the whole class", "bodyText": "License header, class description and format the whole class", "bodyHTML": "<p dir=\"auto\">License header, class description and format the whole class</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:44:40Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.wso2.carbon.apimgt.impl.workflow;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjcwNA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792704", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5NjQwMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410796400", "bodyText": "changed year with 68b7419", "author": "SahanHerath", "createdAt": "2020-04-19T02:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMxMDkwMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414310900", "bodyText": "your haven't formatted the class .", "author": "chamilaadhi", "createdAt": "2020-04-24T05:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\nindex 0b28026a7e7..3e64b3dc376 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n", "chunk": "@@ -1,3 +1,20 @@\n+/*\n+ *  Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n package org.wso2.carbon.apimgt.impl.workflow;\n \n import org.apache.commons.logging.Log;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNjgwOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406626808", "body": "metadata and properties are not needed.", "bodyText": "metadata and properties are not needed.", "bodyHTML": "<p dir=\"auto\">metadata and properties are not needed.</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:45:43Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.Application;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.ApplicationRegistrationWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class ApplicationRegistrationApprovalWorkflowExecutor extends AbstractApplicationRegistrationWorkflowExecutor{\n+\n+\n+    private static final Log log = LogFactory.getLog(ApplicationRegistrationApprovalWorkflowExecutor.class);\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing Application registration Workflow..\");\n+        }\n+\n+        ApplicationRegistrationWorkflowDTO appRegDTO = (ApplicationRegistrationWorkflowDTO) workflowDTO;\n+        Application application = appRegDTO.getApplication();\n+        String callBackURL = appRegDTO.getCallbackUrl();\n+        String applicationCallbackUrl = application.getCallbackUrl();\n+        String applicationDescription = application.getDescription();\n+\n+        String message=\"Approve request to create \"+appRegDTO.getKeyType()+\" keys for [ \"+application.getName()+\n+                \" ] from application creator - \"+appRegDTO.getUserName()+\" with throttling tier - \"+application.getTier() ;\n+\n+        workflowDTO.setWorkflowDescription(message);\n+\n+        workflowDTO.setMetadata(\"applicationName\", application.getName());\n+        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n+        workflowDTO.setMetadata(\"applicationCallbackUrl\", applicationCallbackUrl != null ? applicationCallbackUrl : \"?\");\n+        workflowDTO.setMetadata(\"applicationDescription\", applicationDescription != null ? applicationDescription : \"?\");\n+        workflowDTO.setMetadata(\"TenantDomain\", appRegDTO.getTenantDomain());\n+        workflowDTO.setMetadata(\"UserName\", appRegDTO.getUserName());\n+        workflowDTO.setMetadata(\"workflowExternalRef\", appRegDTO.getExternalWorkflowReference());\n+        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+        workflowDTO.setMetadata(\"KeyType\", appRegDTO.getKeyType());\n+\n+        workflowDTO.setProperties(\"Workflow Process\",\"Registration Creation\");\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\nindex 0b28026a7e7..3e64b3dc376 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n", "chunk": "@@ -8,53 +25,40 @@ import org.wso2.carbon.apimgt.api.model.Application;\n import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n import org.wso2.carbon.apimgt.impl.dto.ApplicationRegistrationWorkflowDTO;\n import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n-\n import java.util.List;\n \n+/**\n+ * Approval workflow for Application Registration key generation.\n+ */\n public class ApplicationRegistrationApprovalWorkflowExecutor extends AbstractApplicationRegistrationWorkflowExecutor{\n \n-\n     private static final Log log = LogFactory.getLog(ApplicationRegistrationApprovalWorkflowExecutor.class);\n \n+    /**\n+     * Execute the Application Creation workflow approval process.\n+     * @param workflowDTO\n+     */\n     @Override\n     public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n         if (log.isDebugEnabled()) {\n             log.debug(\"Executing Application registration Workflow..\");\n         }\n-\n         ApplicationRegistrationWorkflowDTO appRegDTO = (ApplicationRegistrationWorkflowDTO) workflowDTO;\n         Application application = appRegDTO.getApplication();\n         String callBackURL = appRegDTO.getCallbackUrl();\n         String applicationCallbackUrl = application.getCallbackUrl();\n         String applicationDescription = application.getDescription();\n-\n         String message=\"Approve request to create \"+appRegDTO.getKeyType()+\" keys for [ \"+application.getName()+\n                 \" ] from application creator - \"+appRegDTO.getUserName()+\" with throttling tier - \"+application.getTier() ;\n \n         workflowDTO.setWorkflowDescription(message);\n-\n-        workflowDTO.setMetadata(\"applicationName\", application.getName());\n-        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n-        workflowDTO.setMetadata(\"applicationCallbackUrl\", applicationCallbackUrl != null ? applicationCallbackUrl : \"?\");\n-        workflowDTO.setMetadata(\"applicationDescription\", applicationDescription != null ? applicationDescription : \"?\");\n-        workflowDTO.setMetadata(\"TenantDomain\", appRegDTO.getTenantDomain());\n-        workflowDTO.setMetadata(\"UserName\", appRegDTO.getUserName());\n-        workflowDTO.setMetadata(\"workflowExternalRef\", appRegDTO.getExternalWorkflowReference());\n-        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-        workflowDTO.setMetadata(\"KeyType\", appRegDTO.getKeyType());\n-\n-        workflowDTO.setProperties(\"Workflow Process\",\"Registration Creation\");\n-\n         super.execute(workflowDTO);\n \n         return new GeneralWorkflowResponse();\n     }\n \n     /**\n-     * Complete the external process status.\n-     * Based on the workflow , we will update the status column of the\n-     * AM_APPLICATION_KEY_MAPPING table\n-     *\n+     * Complete the Approval workflow executor for application key generation.\n      * @param workFlowDTO\n      */\n     @Override\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\nindex 3e64b3dc376..22197955c19 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n", "chunk": "@@ -59,6 +59,7 @@ public class ApplicationRegistrationApprovalWorkflowExecutor extends AbstractApp\n \n     /**\n      * Complete the Approval workflow executor for application key generation.\n+     *\n      * @param workFlowDTO\n      */\n     @Override\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzAwMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406627000", "body": "remove 'TODO Auto-generated method stub' and add a valid comment", "bodyText": "remove 'TODO Auto-generated method stub' and add a valid comment", "bodyHTML": "<p dir=\"auto\">remove 'TODO Auto-generated method stub' and add a valid comment</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:46:34Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.api.model.Application;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.ApplicationRegistrationWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class ApplicationRegistrationApprovalWorkflowExecutor extends AbstractApplicationRegistrationWorkflowExecutor{\n+\n+\n+    private static final Log log = LogFactory.getLog(ApplicationRegistrationApprovalWorkflowExecutor.class);\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing Application registration Workflow..\");\n+        }\n+\n+        ApplicationRegistrationWorkflowDTO appRegDTO = (ApplicationRegistrationWorkflowDTO) workflowDTO;\n+        Application application = appRegDTO.getApplication();\n+        String callBackURL = appRegDTO.getCallbackUrl();\n+        String applicationCallbackUrl = application.getCallbackUrl();\n+        String applicationDescription = application.getDescription();\n+\n+        String message=\"Approve request to create \"+appRegDTO.getKeyType()+\" keys for [ \"+application.getName()+\n+                \" ] from application creator - \"+appRegDTO.getUserName()+\" with throttling tier - \"+application.getTier() ;\n+\n+        workflowDTO.setWorkflowDescription(message);\n+\n+        workflowDTO.setMetadata(\"applicationName\", application.getName());\n+        workflowDTO.setMetadata(\"applicationTier\", application.getTier());\n+        workflowDTO.setMetadata(\"applicationCallbackUrl\", applicationCallbackUrl != null ? applicationCallbackUrl : \"?\");\n+        workflowDTO.setMetadata(\"applicationDescription\", applicationDescription != null ? applicationDescription : \"?\");\n+        workflowDTO.setMetadata(\"TenantDomain\", appRegDTO.getTenantDomain());\n+        workflowDTO.setMetadata(\"UserName\", appRegDTO.getUserName());\n+        workflowDTO.setMetadata(\"workflowExternalRef\", appRegDTO.getExternalWorkflowReference());\n+        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+        workflowDTO.setMetadata(\"KeyType\", appRegDTO.getKeyType());\n+\n+        workflowDTO.setProperties(\"Workflow Process\",\"Registration Creation\");\n+\n+        super.execute(workflowDTO);\n+\n+        return new GeneralWorkflowResponse();\n+    }\n+\n+    /**\n+     * Complete the external process status.\n+     * Based on the workflow , we will update the status column of the\n+     * AM_APPLICATION_KEY_MAPPING table\n+     *\n+     * @param workFlowDTO\n+     */\n+    @Override\n+    public WorkflowResponse complete(WorkflowDTO workFlowDTO) throws WorkflowException {\n+        workFlowDTO.setUpdatedTime(System.currentTimeMillis());\n+        super.complete(workFlowDTO);\n+        log.info(\"Application Registration [Complete] Workflow Invoked. Workflow ID : \" + workFlowDTO\n+                .getExternalWorkflowReference() + \"Workflow State : \" + workFlowDTO.getStatus());\n+\n+        if (WorkflowStatus.APPROVED.equals(workFlowDTO.getStatus())) {\n+            try {\n+                generateKeysForApplication((ApplicationRegistrationWorkflowDTO) workFlowDTO);\n+            } catch (APIManagementException e) {\n+                String msg = \"Error occurred when updating the status of the Application Registration process\";\n+                log.error(msg, e);\n+                throw new WorkflowException(msg, e);\n+            }\n+        }\n+        return new GeneralWorkflowResponse();\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        // TODO Auto-generated method stub\n+        return null;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5Mjc0OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792748", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzAwMA=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\nindex 0b28026a7e7..3e64b3dc376 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n", "chunk": "@@ -78,10 +81,15 @@ public class ApplicationRegistrationApprovalWorkflowExecutor extends AbstractApp\n \n     @Override\n     public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n-        // TODO Auto-generated method stub\n+        // implemetation is not provided in this version\n         return null;\n     }\n \n+    /**\n+     * Handle cleanup task for application registration Approval workflow executor.\n+     * Use workflow external reference  to delete the pending workflow request\n+     * @param workflowExtRef Workflow external reference of pending workflow request\n+     */\n     @Override\n     public void cleanUpPendingTask(String workflowExtRef) throws WorkflowException {\n         super.cleanUpPendingTask(workflowExtRef);\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\nindex 3e64b3dc376..22197955c19 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/ApplicationRegistrationApprovalWorkflowExecutor.java\n", "chunk": "@@ -88,6 +89,7 @@ public class ApplicationRegistrationApprovalWorkflowExecutor extends AbstractApp\n     /**\n      * Handle cleanup task for application registration Approval workflow executor.\n      * Use workflow external reference  to delete the pending workflow request\n+     *\n      * @param workflowExtRef Workflow external reference of pending workflow request\n      */\n     @Override\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzM5OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406627398", "body": "missing license header, class description. Also format the class", "bodyText": "missing license header, class description. Also format the class", "bodyHTML": "<p dir=\"auto\">missing license header, class description. Also format the class</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:48:09Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.wso2.carbon.apimgt.impl.workflow;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5Mjg5NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792895", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5NjQ2OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410796468", "bodyText": "changed year with 68b7419", "author": "SahanHerath", "createdAt": "2020-04-19T02:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMxMDgwNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414310805", "bodyText": "your haven't formatted the class .", "author": "chamilaadhi", "createdAt": "2020-04-24T05:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzM5OA=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\nindex 03b03653437..65c058d7ff2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -1,3 +1,20 @@\n+/*\n+ *  Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n package org.wso2.carbon.apimgt.impl.workflow;\n \n import org.apache.commons.logging.Log;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzUzNw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406627537", "body": "remove properties and metadata since they are not needed", "bodyText": "remove properties and metadata since they are not needed", "bodyHTML": "<p dir=\"auto\">remove properties and metadata since they are not needed</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:48:33Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.SubscriptionWorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+\n+import java.util.List;\n+\n+public class SubscriptionCreationApprovalWorkflowExecutor extends WorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(SubscriptionCreationApprovalWorkflowExecutor.class);\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_SUBSCRIPTION_CREATION;\n+    }\n+\n+    @Override\n+    public List<WorkflowDTO> getWorkflowDetails(String workflowStatus) throws WorkflowException {\n+        return null;\n+    }\n+\n+    /**\n+     * This method is used to execute the workflow without giving a workflow response back to the caller to execute\n+     * some other task after completing the workflow\n+     *\n+     * @param workflowDTO - The WorkflowDTO which contains workflow contextual information related to the workflow.\n+     * @throws WorkflowException\n+     */\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing Subscription Creation Webservice Workflow.. \");\n+        }\n+\n+        SubscriptionWorkflowDTO subsWorkflowDTO = (SubscriptionWorkflowDTO) workflowDTO;\n+        String callBackURL = subsWorkflowDTO.getCallbackUrl();\n+\n+        String message=\"Approve API [\"+ subsWorkflowDTO.getApiName()+\" - \"+subsWorkflowDTO.getApiVersion()+\n+                \"] subscription creation request from subscriber - \"+subsWorkflowDTO.getSubscriber()+\n+                \" for the application - \"+subsWorkflowDTO.getApplicationName();\n+\n+        workflowDTO.setWorkflowDescription(message);\n+\n+        workflowDTO.setMetadata(\"apiName\", subsWorkflowDTO.getApiName());\n+        workflowDTO.setMetadata(\"apiVersion\", subsWorkflowDTO.getApiVersion());\n+        workflowDTO.setMetadata(\"apiContext\", subsWorkflowDTO.getApiContext());\n+        workflowDTO.setMetadata(\"apiProvider\", subsWorkflowDTO.getApiProvider());\n+        workflowDTO.setMetadata(\"apiSubscriber\", subsWorkflowDTO.getSubscriber());\n+        workflowDTO.setMetadata(\"applicationName\", subsWorkflowDTO.getApplicationName());\n+        workflowDTO.setMetadata(\"TierName\", subsWorkflowDTO.getTierName());\n+        workflowDTO.setMetadata(\"workflowExternalRef\", subsWorkflowDTO.getExternalWorkflowReference());\n+        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+        workflowDTO.setProperties(\"Workflow Process\",\"Subscription Creation\");\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\nindex 03b03653437..65c058d7ff2 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -39,33 +55,22 @@ public class SubscriptionCreationApprovalWorkflowExecutor extends WorkflowExecut\n         if (log.isDebugEnabled()) {\n             log.debug(\"Executing Subscription Creation Webservice Workflow.. \");\n         }\n-\n         SubscriptionWorkflowDTO subsWorkflowDTO = (SubscriptionWorkflowDTO) workflowDTO;\n         String callBackURL = subsWorkflowDTO.getCallbackUrl();\n-\n         String message=\"Approve API [\"+ subsWorkflowDTO.getApiName()+\" - \"+subsWorkflowDTO.getApiVersion()+\n                 \"] subscription creation request from subscriber - \"+subsWorkflowDTO.getSubscriber()+\n                 \" for the application - \"+subsWorkflowDTO.getApplicationName();\n \n         workflowDTO.setWorkflowDescription(message);\n-\n-        workflowDTO.setMetadata(\"apiName\", subsWorkflowDTO.getApiName());\n-        workflowDTO.setMetadata(\"apiVersion\", subsWorkflowDTO.getApiVersion());\n-        workflowDTO.setMetadata(\"apiContext\", subsWorkflowDTO.getApiContext());\n-        workflowDTO.setMetadata(\"apiProvider\", subsWorkflowDTO.getApiProvider());\n-        workflowDTO.setMetadata(\"apiSubscriber\", subsWorkflowDTO.getSubscriber());\n-        workflowDTO.setMetadata(\"applicationName\", subsWorkflowDTO.getApplicationName());\n-        workflowDTO.setMetadata(\"TierName\", subsWorkflowDTO.getTierName());\n-        workflowDTO.setMetadata(\"workflowExternalRef\", subsWorkflowDTO.getExternalWorkflowReference());\n-        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-        workflowDTO.setProperties(\"Workflow Process\",\"Subscription Creation\");\n-\n         super.execute(workflowDTO);\n \n         return new GeneralWorkflowResponse();\n     }\n \n+    /**\n+     * Complete the Approval workflow executor for Subscription creation.\n+     * @param workflowDTO\n+     */\n     @Override\n     public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException {\n         workflowDTO.setUpdatedTime(System.currentTimeMillis());\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\nindex 65c058d7ff2..b59f877bb2b 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/SubscriptionCreationApprovalWorkflowExecutor.java\n", "chunk": "@@ -69,6 +69,7 @@ public class SubscriptionCreationApprovalWorkflowExecutor extends WorkflowExecut\n \n     /**\n      * Complete the Approval workflow executor for Subscription creation.\n+     *\n      * @param workflowDTO\n      */\n     @Override\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzk0NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406627945", "body": "missing license header, class description. Also format the class\r\n\r\n", "bodyText": "missing license header, class description. Also format the class", "bodyHTML": "<p dir=\"auto\">missing license header, class description. Also format the class</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:49:57Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.wso2.carbon.apimgt.impl.workflow;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MjkzMg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410792932", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5NjQ5Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410796493", "bodyText": "changed year with 68b7419", "author": "SahanHerath", "createdAt": "2020-04-19T02:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMxMDcxNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414310715", "bodyText": "your haven't formatted the class .", "author": "chamilaadhi", "createdAt": "2020-04-24T05:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNzk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\nindex 6a137762ca8..edb190aaf99 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\n", "chunk": "@@ -1,3 +1,20 @@\n+/*\n+ *  Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n package org.wso2.carbon.apimgt.impl.workflow;\n \n import org.apache.commons.logging.Log;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyODI4NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406628284", "body": "metadata and properties are not needed", "bodyText": "metadata and properties are not needed", "bodyHTML": "<p dir=\"auto\">metadata and properties are not needed</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:51:20Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.wso2.carbon.apimgt.impl.workflow;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.wso2.carbon.apimgt.api.APIManagementException;\n+import org.wso2.carbon.apimgt.api.WorkflowResponse;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.APIManagerConfiguration;\n+import org.wso2.carbon.apimgt.impl.dao.ApiMgtDAO;\n+import org.wso2.carbon.apimgt.impl.dto.UserRegistrationConfigDTO;\n+import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n+import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n+import org.wso2.carbon.apimgt.impl.utils.SelfSignUpUtil;\n+import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n+\n+import java.util.List;\n+\n+public class UserSignUpApprovalWorkflowExecutor extends UserSignUpWorkflowExecutor{\n+\n+    private static final Log log = LogFactory.getLog(UserSignUpWSWorkflowExecutor.class);\n+\n+\n+    @Override\n+    public String getWorkflowType() {\n+        return WorkflowConstants.WF_TYPE_AM_USER_SIGNUP;\n+    }\n+\n+    @Override\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException  {\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Executing User SignUp Webservice Workflow for \" + workflowDTO.getWorkflowReference());\n+        }\n+\n+\n+        String callBackURL = workflowDTO.getCallbackUrl();\n+        String tenantAwareUserName = MultitenantUtils.getTenantAwareUsername(workflowDTO.getWorkflowReference());\n+\n+        String message=\"Approve APIStore signup request done by \"+tenantAwareUserName  +\" from the tenant domain \"+workflowDTO.getTenantDomain();\n+\n+        workflowDTO.setWorkflowDescription(message);\n+\n+        workflowDTO.setMetadata(\"TenantUserName\", tenantAwareUserName);\n+        workflowDTO.setMetadata(\"TenantDomain\", workflowDTO.getTenantDomain());\n+        workflowDTO.setMetadata(\"workflowExternalRef\", workflowDTO.getExternalWorkflowReference());\n+        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n+\n+        workflowDTO.setProperties(\"Workflow Process\",\"User Self Sign Up\");\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\nindex 6a137762ca8..edb190aaf99 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\n", "chunk": "@@ -12,68 +29,60 @@ import org.wso2.carbon.apimgt.impl.dto.WorkflowDTO;\n import org.wso2.carbon.apimgt.impl.internal.ServiceReferenceHolder;\n import org.wso2.carbon.apimgt.impl.utils.SelfSignUpUtil;\n import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n-\n import java.util.List;\n \n+/**\n+ * Approval workflow for User Self Sign Up.\n+ *\n+ */\n public class UserSignUpApprovalWorkflowExecutor extends UserSignUpWorkflowExecutor{\n \n     private static final Log log = LogFactory.getLog(UserSignUpWSWorkflowExecutor.class);\n \n-\n     @Override\n     public String getWorkflowType() {\n         return WorkflowConstants.WF_TYPE_AM_USER_SIGNUP;\n     }\n \n+    /**\n+     * Execute the User self sign up workflow approval process.\n+     * @param workflowDTO\n+     */\n     @Override\n-    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException  {\n+    public WorkflowResponse execute(WorkflowDTO workflowDTO) throws WorkflowException {\n \n         if (log.isDebugEnabled()) {\n             log.debug(\"Executing User SignUp Webservice Workflow for \" + workflowDTO.getWorkflowReference());\n         }\n-\n-\n         String callBackURL = workflowDTO.getCallbackUrl();\n         String tenantAwareUserName = MultitenantUtils.getTenantAwareUsername(workflowDTO.getWorkflowReference());\n-\n         String message=\"Approve APIStore signup request done by \"+tenantAwareUserName  +\" from the tenant domain \"+workflowDTO.getTenantDomain();\n \n         workflowDTO.setWorkflowDescription(message);\n-\n-        workflowDTO.setMetadata(\"TenantUserName\", tenantAwareUserName);\n-        workflowDTO.setMetadata(\"TenantDomain\", workflowDTO.getTenantDomain());\n-        workflowDTO.setMetadata(\"workflowExternalRef\", workflowDTO.getExternalWorkflowReference());\n-        workflowDTO.setMetadata(\"callBackURL\", callBackURL != null ? callBackURL : \"?\");\n-\n-        workflowDTO.setProperties(\"Workflow Process\",\"User Self Sign Up\");\n-\n         super.execute(workflowDTO);\n-\n         return new GeneralWorkflowResponse();\n     }\n \n+    /**\n+     * Complete the Approval workflow executor for User self sign up.\n+     * @param workflowDTO\n+     */\n     @Override\n     public WorkflowResponse complete(WorkflowDTO workflowDTO) throws WorkflowException {\n \n         workflowDTO.setUpdatedTime(System.currentTimeMillis());\n-\n         if (log.isDebugEnabled()) {\n             log.debug(\"User Sign Up [Complete] Workflow Invoked. Workflow ID : \" +\n                     workflowDTO.getExternalWorkflowReference() + \"Workflow State : \" +\n                     workflowDTO.getStatus());\n         }\n-\n         super.complete(workflowDTO);\n-\n         APIManagerConfiguration config = ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService()\n                 .getAPIManagerConfiguration();\n         String serverURL = config.getFirstProperty(APIConstants.AUTH_MANAGER_URL);\n-\n         String tenantDomain = workflowDTO.getTenantDomain();\n         try {\n-\n             UserRegistrationConfigDTO signupConfig = SelfSignUpUtil.getSignupConfiguration(tenantDomain);\n-\n             String adminUsername = signupConfig.getAdminUserName();\n             String adminPassword = signupConfig.getAdminPassword();\n             if (serverURL == null) {\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\nindex edb190aaf99..e8840ce751f 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/workflow/UserSignUpApprovalWorkflowExecutor.java\n", "chunk": "@@ -87,9 +89,9 @@ public class UserSignUpApprovalWorkflowExecutor extends UserSignUpWorkflowExecut\n             String adminPassword = signupConfig.getAdminPassword();\n             if (serverURL == null) {\n                 throw new WorkflowException(\"Can't connect to the authentication manager. serverUrl is missing\");\n-            } else if(adminUsername == null) {\n+            } else if (adminUsername == null) {\n                 throw new WorkflowException(\"Can't connect to the authentication manager. adminUsername is missing\");\n-            } else if(adminPassword == null) {\n+            } else if (adminPassword == null) {\n                 throw new WorkflowException(\"Can't connect to the authentication manager. adminPassword is missing\");\n             }\n             String tenantAwareUserName = MultitenantUtils.getTenantAwareUsername(workflowDTO.getWorkflowReference());\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTIwOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406629208", "body": "why catch a NPE here? fromWorkflowsToInfoDTO() method is not throwing it either. please remove this", "bodyText": "why catch a NPE here? fromWorkflowsToInfoDTO() method is not throwing it either. please remove this", "bodyHTML": "<p dir=\"auto\">why catch a NPE here? fromWorkflowsToInfoDTO() method is not throwing it either. please remove this</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:54:33Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java", "diffHunk": "@@ -42,6 +48,87 @@\n \n     private static final Log log = LogFactory.getLog(WorkflowsApiService.class);\n \n+\n+    /**\n+     * This is used to get the workflow pending request according to ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef is the unique identifier for workflow request\n+     * @param ifNoneMatch If-None-Match header value\n+     * @return\n+     */\n+\n+    @Override\n+    public Response workflowsExternalWorkflowRefGet(String externalWorkflowRef, String ifNoneMatch) {\n+        WorkflowInfoDTO workflowinfoDTO;\n+        try {\n+            Workflow workflow;\n+\n+            String status=\"CREATED\";\n+            String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+            APIAdmin apiAdmin = new APIAdminImpl();\n+            workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n+\n+            try {\n+                workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n+                return Response.ok().entity(workflowinfoDTO).build();\n+            }\n+            catch(NullPointerException e){", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 396bd8a8955..505e9a9d913 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -65,21 +63,13 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n \n             String status=\"CREATED\";\n             String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n-\n             APIAdmin apiAdmin = new APIAdminImpl();\n             workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n-\n-            try {\n-                workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n-                return Response.ok().entity(workflowinfoDTO).build();\n-            }\n-            catch(NullPointerException e){\n-                RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e,log);\n-            }\n+            workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n+            return Response.ok().entity(workflowinfoDTO).build();\n         }\n-\n-        catch(APIManagementException e){\n-            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e, log);\n+        catch(APIManagementException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference. \", e, log);\n         }\n         return null;\n     }\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -60,16 +60,15 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n         WorkflowInfoDTO workflowinfoDTO;\n         try {\n             Workflow workflow;\n-\n-            String status=\"CREATED\";\n+            String status = \"CREATED\";\n             String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n             APIAdmin apiAdmin = new APIAdminImpl();\n-            workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n+            workflow = apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status, tenantDomain);\n             workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n             return Response.ok().entity(workflowinfoDTO).build();\n-        }\n-        catch(APIManagementException e) {\n-            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference. \", e, log);\n+        } catch (APIManagementException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the \" +\n+                    \"external workflow reference. \", e, log);\n         }\n         return null;\n     }\n", "next_change": null}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -77,10 +76,10 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n     /**\n      * This is used to get the workflow pending requests\n      *\n-     * @param limit       maximum number of workflow returns\n-     * @param offset      starting index\n-     * @param accept      accept header value\n-     * @param ifNoneMatch If-None-Match header value\n+     * @param limit        maximum number of workflow returns\n+     * @param offset       starting index\n+     * @param accept       accept header value\n+     * @param ifNoneMatch  If-None-Match header value\n      * @param workflowType is the the type of the workflow request. (e.g: Application Creation, Application Subscription etc.)\n      * @return\n      */\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTI2Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406629262", "body": "format this whole method", "bodyText": "format this whole method", "bodyHTML": "<p dir=\"auto\">format this whole method</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:54:45Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java", "diffHunk": "@@ -42,6 +48,87 @@\n \n     private static final Log log = LogFactory.getLog(WorkflowsApiService.class);\n \n+\n+    /**\n+     * This is used to get the workflow pending request according to ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef is the unique identifier for workflow request\n+     * @param ifNoneMatch If-None-Match header value\n+     * @return\n+     */\n+\n+    @Override\n+    public Response workflowsExternalWorkflowRefGet(String externalWorkflowRef, String ifNoneMatch) {\n+        WorkflowInfoDTO workflowinfoDTO;\n+        try {", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MzAzOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410793038", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:09:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMxMTQ4NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414311485", "bodyText": "your haven't formatted the method . see that there are no spaces between the '='", "author": "chamilaadhi", "createdAt": "2020-04-24T05:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTI2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 396bd8a8955..505e9a9d913 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -56,7 +55,6 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n      * @param ifNoneMatch If-None-Match header value\n      * @return\n      */\n-\n     @Override\n     public Response workflowsExternalWorkflowRefGet(String externalWorkflowRef, String ifNoneMatch) {\n         WorkflowInfoDTO workflowinfoDTO;\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -52,7 +52,7 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n      * This is used to get the workflow pending request according to ExternalWorkflowReference\n      *\n      * @param externalWorkflowRef is the unique identifier for workflow request\n-     * @param ifNoneMatch If-None-Match header value\n+     * @param ifNoneMatch         If-None-Match header value\n      * @return\n      */\n     @Override\n", "next_change": null}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -60,16 +60,15 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n         WorkflowInfoDTO workflowinfoDTO;\n         try {\n             Workflow workflow;\n-\n-            String status=\"CREATED\";\n+            String status = \"CREATED\";\n             String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n             APIAdmin apiAdmin = new APIAdminImpl();\n-            workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n+            workflow = apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status, tenantDomain);\n             workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n             return Response.ok().entity(workflowinfoDTO).build();\n-        }\n-        catch(APIManagementException e) {\n-            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference. \", e, log);\n+        } catch (APIManagementException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the \" +\n+                    \"external workflow reference. \", e, log);\n         }\n         return null;\n     }\n", "next_change": null}]}}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 396bd8a8955..505e9a9d913 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -65,21 +63,13 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n \n             String status=\"CREATED\";\n             String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n-\n             APIAdmin apiAdmin = new APIAdminImpl();\n             workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n-\n-            try {\n-                workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n-                return Response.ok().entity(workflowinfoDTO).build();\n-            }\n-            catch(NullPointerException e){\n-                RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e,log);\n-            }\n+            workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n+            return Response.ok().entity(workflowinfoDTO).build();\n         }\n-\n-        catch(APIManagementException e){\n-            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e, log);\n+        catch(APIManagementException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference. \", e, log);\n         }\n         return null;\n     }\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -60,16 +60,15 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n         WorkflowInfoDTO workflowinfoDTO;\n         try {\n             Workflow workflow;\n-\n-            String status=\"CREATED\";\n+            String status = \"CREATED\";\n             String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n             APIAdmin apiAdmin = new APIAdminImpl();\n-            workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n+            workflow = apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status, tenantDomain);\n             workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n             return Response.ok().entity(workflowinfoDTO).build();\n-        }\n-        catch(APIManagementException e) {\n-            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference. \", e, log);\n+        } catch (APIManagementException e) {\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the \" +\n+                    \"external workflow reference. \", e, log);\n         }\n         return null;\n     }\n", "next_change": null}, {"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -77,10 +76,10 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n     /**\n      * This is used to get the workflow pending requests\n      *\n-     * @param limit       maximum number of workflow returns\n-     * @param offset      starting index\n-     * @param accept      accept header value\n-     * @param ifNoneMatch If-None-Match header value\n+     * @param limit        maximum number of workflow returns\n+     * @param offset       starting index\n+     * @param accept       accept header value\n+     * @param ifNoneMatch  If-None-Match header value\n      * @param workflowType is the the type of the workflow request. (e.g: Application Creation, Application Subscription etc.)\n      * @return\n      */\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTY3NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406629675", "body": "format whole method. remove unnecessary spaces ", "bodyText": "format whole method. remove unnecessary spaces", "bodyHTML": "<p dir=\"auto\">format whole method. remove unnecessary spaces</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:56:15Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java", "diffHunk": "@@ -42,6 +48,87 @@\n \n     private static final Log log = LogFactory.getLog(WorkflowsApiService.class);\n \n+\n+    /**\n+     * This is used to get the workflow pending request according to ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef is the unique identifier for workflow request\n+     * @param ifNoneMatch If-None-Match header value\n+     * @return\n+     */\n+\n+    @Override\n+    public Response workflowsExternalWorkflowRefGet(String externalWorkflowRef, String ifNoneMatch) {\n+        WorkflowInfoDTO workflowinfoDTO;\n+        try {\n+            Workflow workflow;\n+\n+            String status=\"CREATED\";\n+            String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+            APIAdmin apiAdmin = new APIAdminImpl();\n+            workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n+\n+            try {\n+                workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n+                return Response.ok().entity(workflowinfoDTO).build();\n+            }\n+            catch(NullPointerException e){\n+                RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e,log);\n+            }\n+        }\n+\n+        catch(APIManagementException e){\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This is used to get the workflow pending requests\n+     *\n+     * @param limit       maximum number of workflow returns\n+     * @param offset      starting index\n+     * @param accept      accept header value\n+     * @param ifNoneMatch If-None-Match header value\n+     * @param workflowType is the the type of the workflow request. (e.g: Application Creation, Application Subscription etc.)\n+     * @return\n+     */\n+\n+    @Override\n+    public Response workflowsGet(Integer limit, Integer offset, String accept, String ifNoneMatch, String workflowType) {\n+\n+        limit = limit != null ? limit : RestApiConstants.PAGINATION_LIMIT_DEFAULT;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MzIyOQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410793229", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMxMTgyMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414311820", "bodyText": "your haven't formatted the class .", "author": "chamilaadhi", "createdAt": "2020-04-24T05:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 396bd8a8955..505e9a9d913 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -94,37 +84,25 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n      * @param workflowType is the the type of the workflow request. (e.g: Application Creation, Application Subscription etc.)\n      * @return\n      */\n-\n     @Override\n     public Response workflowsGet(Integer limit, Integer offset, String accept, String ifNoneMatch, String workflowType) {\n \n         limit = limit != null ? limit : RestApiConstants.PAGINATION_LIMIT_DEFAULT;\n         offset = offset != null ? offset : RestApiConstants.PAGINATION_OFFSET_DEFAULT;\n-\n-\n         String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n-\n         WorkflowListDTO workflowListDTO;\n         try {\n             Workflow[] workflows;\n             String status=\"CREATED\";\n-\n             APIAdmin apiAdmin = new APIAdminImpl();\n             workflows=apiAdmin.getworkflows(workflowType, status ,tenantDomain);\n-\n-\n-            try {\n-                workflowListDTO = WorkflowMappingUtil.fromWorkflowsToDTO(workflows, limit, offset);\n-                WorkflowMappingUtil.setPaginationParams(workflowListDTO, limit, offset,\n+            workflowListDTO = WorkflowMappingUtil.fromWorkflowsToDTO(workflows, limit, offset);\n+            WorkflowMappingUtil.setPaginationParams(workflowListDTO, limit, offset,\n                         workflows.length);\n-                return Response.ok().entity(workflowListDTO).build();\n-            }\n-            catch( NullPointerException e){\n-                RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests\" , e, log);\n-            }\n+            return Response.ok().entity(workflowListDTO).build();\n         }\n         catch(APIManagementException e){\n-            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests\" , e, log);\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests. \", e, log);\n         }\n         return null;\n     }\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -93,15 +92,14 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n         WorkflowListDTO workflowListDTO;\n         try {\n             Workflow[] workflows;\n-            String status=\"CREATED\";\n+            String status = \"CREATED\";\n             APIAdmin apiAdmin = new APIAdminImpl();\n-            workflows=apiAdmin.getworkflows(workflowType, status ,tenantDomain);\n+            workflows = apiAdmin.getworkflows(workflowType, status, tenantDomain);\n             workflowListDTO = WorkflowMappingUtil.fromWorkflowsToDTO(workflows, limit, offset);\n             WorkflowMappingUtil.setPaginationParams(workflowListDTO, limit, offset,\n-                        workflows.length);\n+                    workflows.length);\n             return Response.ok().entity(workflowListDTO).build();\n-        }\n-        catch(APIManagementException e){\n+        } catch (APIManagementException e) {\n             RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests. \", e, log);\n         }\n         return null;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTcyMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406629720", "body": "why???", "bodyText": "why???", "bodyHTML": "<p dir=\"auto\">why???</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:56:27Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java", "diffHunk": "@@ -42,6 +48,87 @@\n \n     private static final Log log = LogFactory.getLog(WorkflowsApiService.class);\n \n+\n+    /**\n+     * This is used to get the workflow pending request according to ExternalWorkflowReference\n+     *\n+     * @param externalWorkflowRef is the unique identifier for workflow request\n+     * @param ifNoneMatch If-None-Match header value\n+     * @return\n+     */\n+\n+    @Override\n+    public Response workflowsExternalWorkflowRefGet(String externalWorkflowRef, String ifNoneMatch) {\n+        WorkflowInfoDTO workflowinfoDTO;\n+        try {\n+            Workflow workflow;\n+\n+            String status=\"CREATED\";\n+            String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+            APIAdmin apiAdmin = new APIAdminImpl();\n+            workflow=apiAdmin.getworkflowReferenceByExternalWorkflowReferenceID(externalWorkflowRef, status ,tenantDomain);\n+\n+            try {\n+                workflowinfoDTO = WorkflowMappingUtil.fromWorkflowsToInfoDTO(workflow);\n+                return Response.ok().entity(workflowinfoDTO).build();\n+            }\n+            catch(NullPointerException e){\n+                RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e,log);\n+            }\n+        }\n+\n+        catch(APIManagementException e){\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow request by the external workflow reference\" , e, log);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This is used to get the workflow pending requests\n+     *\n+     * @param limit       maximum number of workflow returns\n+     * @param offset      starting index\n+     * @param accept      accept header value\n+     * @param ifNoneMatch If-None-Match header value\n+     * @param workflowType is the the type of the workflow request. (e.g: Application Creation, Application Subscription etc.)\n+     * @return\n+     */\n+\n+    @Override\n+    public Response workflowsGet(Integer limit, Integer offset, String accept, String ifNoneMatch, String workflowType) {\n+\n+        limit = limit != null ? limit : RestApiConstants.PAGINATION_LIMIT_DEFAULT;\n+        offset = offset != null ? offset : RestApiConstants.PAGINATION_OFFSET_DEFAULT;\n+\n+\n+        String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n+\n+        WorkflowListDTO workflowListDTO;\n+        try {\n+            Workflow[] workflows;\n+            String status=\"CREATED\";\n+\n+            APIAdmin apiAdmin = new APIAdminImpl();\n+            workflows=apiAdmin.getworkflows(workflowType, status ,tenantDomain);\n+\n+\n+            try {\n+                workflowListDTO = WorkflowMappingUtil.fromWorkflowsToDTO(workflows, limit, offset);\n+                WorkflowMappingUtil.setPaginationParams(workflowListDTO, limit, offset,\n+                        workflows.length);\n+                return Response.ok().entity(workflowListDTO).build();\n+            }\n+            catch( NullPointerException e){\n+                RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests\" , e, log);", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 396bd8a8955..505e9a9d913 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -94,37 +84,25 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n      * @param workflowType is the the type of the workflow request. (e.g: Application Creation, Application Subscription etc.)\n      * @return\n      */\n-\n     @Override\n     public Response workflowsGet(Integer limit, Integer offset, String accept, String ifNoneMatch, String workflowType) {\n \n         limit = limit != null ? limit : RestApiConstants.PAGINATION_LIMIT_DEFAULT;\n         offset = offset != null ? offset : RestApiConstants.PAGINATION_OFFSET_DEFAULT;\n-\n-\n         String tenantDomain = RestApiUtil.getLoggedInUserTenantDomain();\n-\n         WorkflowListDTO workflowListDTO;\n         try {\n             Workflow[] workflows;\n             String status=\"CREATED\";\n-\n             APIAdmin apiAdmin = new APIAdminImpl();\n             workflows=apiAdmin.getworkflows(workflowType, status ,tenantDomain);\n-\n-\n-            try {\n-                workflowListDTO = WorkflowMappingUtil.fromWorkflowsToDTO(workflows, limit, offset);\n-                WorkflowMappingUtil.setPaginationParams(workflowListDTO, limit, offset,\n+            workflowListDTO = WorkflowMappingUtil.fromWorkflowsToDTO(workflows, limit, offset);\n+            WorkflowMappingUtil.setPaginationParams(workflowListDTO, limit, offset,\n                         workflows.length);\n-                return Response.ok().entity(workflowListDTO).build();\n-            }\n-            catch( NullPointerException e){\n-                RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests\" , e, log);\n-            }\n+            return Response.ok().entity(workflowListDTO).build();\n         }\n         catch(APIManagementException e){\n-            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests\" , e, log);\n+            RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests. \", e, log);\n         }\n         return null;\n     }\n", "next_change": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\nindex 505e9a9d913..9e13fe0a323 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/impl/WorkflowsApiServiceImpl.java\n", "chunk": "@@ -93,15 +92,14 @@ public class WorkflowsApiServiceImpl extends WorkflowsApiService {\n         WorkflowListDTO workflowListDTO;\n         try {\n             Workflow[] workflows;\n-            String status=\"CREATED\";\n+            String status = \"CREATED\";\n             APIAdmin apiAdmin = new APIAdminImpl();\n-            workflows=apiAdmin.getworkflows(workflowType, status ,tenantDomain);\n+            workflows = apiAdmin.getworkflows(workflowType, status, tenantDomain);\n             workflowListDTO = WorkflowMappingUtil.fromWorkflowsToDTO(workflows, limit, offset);\n             WorkflowMappingUtil.setPaginationParams(workflowListDTO, limit, offset,\n-                        workflows.length);\n+                    workflows.length);\n             return Response.ok().entity(workflowListDTO).build();\n-        }\n-        catch(APIManagementException e){\n+        } catch (APIManagementException e) {\n             RestApiUtil.handleInternalServerError(\"Error while retrieving workflow requests. \", e, log);\n         }\n         return null;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTk4Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406629987", "body": "License header missing", "bodyText": "License header missing", "bodyHTML": "<p dir=\"auto\">License header missing</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:57:25Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.wso2.carbon.apimgt.rest.api.admin.utils.mappings;", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MzMzMQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410793331", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5NjU4MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410796580", "bodyText": "changed year with 68b7419", "author": "SahanHerath", "createdAt": "2020-04-19T02:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTk4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\nindex 82a505c15e6..bc30ec6dd12 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\n", "chunk": "@@ -1,3 +1,21 @@\n+/*\n+ *   Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *   WSO2 Inc. licenses this file to you under the Apache License,\n+ *   Version 2.0 (the \"License\"); you may not use this file except\n+ *   in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ *\n+ */\n package org.wso2.carbon.apimgt.rest.api.admin.utils.mappings;\n \n import org.wso2.carbon.apimgt.api.model.Workflow;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzMDE3NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406630174", "body": "class description missing. also format the whole class", "bodyText": "class description missing. also format the whole class", "bodyHTML": "<p dir=\"auto\">class description missing. also format the whole class</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:57:54Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.wso2.carbon.apimgt.rest.api.admin.utils.mappings;\n+\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.rest.api.admin.dto.WorkflowInfoDTO;\n+import org.wso2.carbon.apimgt.rest.api.admin.dto.WorkflowListDTO;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class WorkflowMappingUtil {", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc5MzM4Ng==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r410793386", "bodyText": "fixed with e00fe40", "author": "SahanHerath", "createdAt": "2020-04-19T02:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzMDE3NA=="}], "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\nindex 82a505c15e6..bc30ec6dd12 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\n", "chunk": "@@ -10,12 +28,13 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n \n+/**\n+ * This class manage mapping to DTO of  workflow requests\n+ */\n public class WorkflowMappingUtil {\n \n     private static Object WorkflowTypeEnum;\n \n-\n-\n     public enum WorkflowTypeEnum {\n         AM_APPLICATION_CREATION,  AM_SUBSCRIPTION_CREATION,  AM_USER_SIGNUP,  AM_APPLICATION_REGISTRATION_PRODUCTION,  AM_APPLICATION_REGISTRATION_SANDBOX,  AM_APPLICATION_DELETION,  AM_API_STATE,  AM_SUBSCRIPTION_DELETION,\n     };\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzMDI0Ng==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r406630246", "body": "remove unnecessary spaces", "bodyText": "remove unnecessary spaces", "bodyHTML": "<p dir=\"auto\">remove unnecessary spaces</p>", "author": "chamilaadhi", "createdAt": "2020-04-10T06:58:06Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.wso2.carbon.apimgt.rest.api.admin.utils.mappings;\n+\n+import org.wso2.carbon.apimgt.api.model.Workflow;\n+import org.wso2.carbon.apimgt.rest.api.admin.dto.WorkflowInfoDTO;\n+import org.wso2.carbon.apimgt.rest.api.admin.dto.WorkflowListDTO;\n+import org.wso2.carbon.apimgt.rest.api.util.RestApiConstants;\n+import org.wso2.carbon.apimgt.rest.api.util.utils.RestApiUtil;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class WorkflowMappingUtil {\n+\n+    private static Object WorkflowTypeEnum;\n+\n+\n+", "originalCommit": "6bf3e5572d4f5d21b3b4f4cb596a1eeea3348002", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\nindex 82a505c15e6..bc30ec6dd12 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.rest.api.admin/src/main/java/org/wso2/carbon/apimgt/rest/api/admin/utils/mappings/WorkflowMappingUtil.java\n", "chunk": "@@ -10,12 +28,13 @@ import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n \n+/**\n+ * This class manage mapping to DTO of  workflow requests\n+ */\n public class WorkflowMappingUtil {\n \n     private static Object WorkflowTypeEnum;\n \n-\n-\n     public enum WorkflowTypeEnum {\n         AM_APPLICATION_CREATION,  AM_SUBSCRIPTION_CREATION,  AM_USER_SIGNUP,  AM_APPLICATION_REGISTRATION_PRODUCTION,  AM_APPLICATION_REGISTRATION_SANDBOX,  AM_APPLICATION_DELETION,  AM_API_STATE,  AM_SUBSCRIPTION_DELETION,\n     };\n", "next_change": null}]}}, {"oid": "e00fe40f5ef809f1ac81dc7c22faacda062adfab", "url": "https://github.com/wso2/carbon-apimgt/commit/e00fe40f5ef809f1ac81dc7c22faacda062adfab", "message": "Reformatted the approval workflow executor and rest APIs", "committedDate": "2020-04-15T10:56:04Z", "type": "commit"}, {"oid": "68b7419e6cbaa0784e59e60fbdbe77dbb27eb484", "url": "https://github.com/wso2/carbon-apimgt/commit/68b7419e6cbaa0784e59e60fbdbe77dbb27eb484", "message": "Changed the licence header in Approval Workflow Executor tests", "committedDate": "2020-04-19T01:46:12Z", "type": "commit"}, {"oid": "3719d98f3d2faba218147e15535025aa6169e371", "url": "https://github.com/wso2/carbon-apimgt/commit/3719d98f3d2faba218147e15535025aa6169e371", "message": "Change the licence header of Workflow.java", "committedDate": "2020-04-19T02:28:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNzI2NQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414307265", "body": "formatting issue", "bodyText": "formatting issue", "bodyHTML": "<p dir=\"auto\">formatting issue</p>", "author": "chamilaadhi", "createdAt": "2020-04-24T05:39:14Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java", "diffHunk": "@@ -349,4 +346,38 @@ private int isCategoryAttached(APICategory category, String username) throws API\n         int length = (Integer) result.get(\"length\");\n         return length;\n     }\n+\n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param workflowType\n+     * @param status\n+     * @param tenantDomain\n+     * @return Workflow[]\n+     * @throws APIManagementException\n+     */\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {", "originalCommit": "3719d98f3d2faba218147e15535025aa6169e371", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\nindex bbaddc0a067..a75bc0f2a0a 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n", "chunk": "@@ -350,29 +350,30 @@ public class APIAdminImpl implements APIAdmin {\n     /**\n      * The method converts the date into timestamp\n      *\n-     * @param workflowType\n-     * @param status\n-     * @param tenantDomain\n-     * @return Workflow[]\n+     * @param workflowType workflow Type of workflow pending request\n+     * @param status       Workflow status of workflow pending request\n+     * @param tenantDomain tenant domain of user\n+     * @return Workflow[]  list of workflow pending requests\n      * @throws APIManagementException\n      */\n-    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain)\n+            throws APIManagementException {\n         return apiMgtDAO.getworkflows(workflowType, status, tenantDomain);\n     }\n \n     /**\n      * The method converts the date into timestamp\n      *\n-     * @param externelWorkflowRef\n-     * @param status\n-     * @param tenantDomain\n-     * @return Workflow\n+     * @param externelWorkflowRef External Workflow Reference of workflow pending request\n+     * @param status              Workflow status of workflow pending request\n+     * @param tenantDomain        tenant domain of user\n+     * @return Workflow           Workflow pending request\n      * @throws APIManagementException\n      */\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status,\n                                                                       String tenantDomain) throws APIManagementException {\n-\n-        Workflow workflow=apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef, status ,tenantDomain );\n+        Workflow workflow = apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef,\n+                status, tenantDomain);\n \n         if (workflow == null) {\n             String msg = \"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNzQxOQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414307419", "body": "add a description for each parameter", "bodyText": "add a description for each parameter", "bodyHTML": "<p dir=\"auto\">add a description for each parameter</p>", "author": "chamilaadhi", "createdAt": "2020-04-24T05:39:39Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java", "diffHunk": "@@ -349,4 +346,38 @@ private int isCategoryAttached(APICategory category, String username) throws API\n         int length = (Integer) result.get(\"length\");\n         return length;\n     }\n+\n+    /**\n+     * The method converts the date into timestamp\n+     *\n+     * @param workflowType", "originalCommit": "3719d98f3d2faba218147e15535025aa6169e371", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b48a01776745e4804aee0554f67dde112e0ccdd", "changed_code": [{"header": "diff --git a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\nindex bbaddc0a067..a75bc0f2a0a 100644\n--- a/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n+++ b/components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIAdminImpl.java\n", "chunk": "@@ -350,29 +350,30 @@ public class APIAdminImpl implements APIAdmin {\n     /**\n      * The method converts the date into timestamp\n      *\n-     * @param workflowType\n-     * @param status\n-     * @param tenantDomain\n-     * @return Workflow[]\n+     * @param workflowType workflow Type of workflow pending request\n+     * @param status       Workflow status of workflow pending request\n+     * @param tenantDomain tenant domain of user\n+     * @return Workflow[]  list of workflow pending requests\n      * @throws APIManagementException\n      */\n-    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain ) throws APIManagementException {\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain)\n+            throws APIManagementException {\n         return apiMgtDAO.getworkflows(workflowType, status, tenantDomain);\n     }\n \n     /**\n      * The method converts the date into timestamp\n      *\n-     * @param externelWorkflowRef\n-     * @param status\n-     * @param tenantDomain\n-     * @return Workflow\n+     * @param externelWorkflowRef External Workflow Reference of workflow pending request\n+     * @param status              Workflow status of workflow pending request\n+     * @param tenantDomain        tenant domain of user\n+     * @return Workflow           Workflow pending request\n      * @throws APIManagementException\n      */\n     public Workflow getworkflowReferenceByExternalWorkflowReferenceID(String externelWorkflowRef, String status,\n                                                                       String tenantDomain) throws APIManagementException {\n-\n-        Workflow workflow=apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef, status ,tenantDomain );\n+        Workflow workflow = apiMgtDAO.getworkflowReferenceByExternalWorkflowReferenceID(externelWorkflowRef,\n+                status, tenantDomain);\n \n         if (workflow == null) {\n             String msg = \"External workflow Reference: \" + externelWorkflowRef + \" was not found.\";\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNzk3OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8293#discussion_r414307979", "body": "this method is not formatted", "bodyText": "this method is not formatted", "bodyHTML": "<p dir=\"auto\">this method is not formatted</p>", "author": "chamilaadhi", "createdAt": "2020-04-24T05:41:07Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/dao/ApiMgtDAO.java", "diffHunk": "@@ -14610,4 +14620,243 @@ public String getUserID(String userName) throws APIManagementException {\n         }\n         return list;\n     }\n+\n+    /**\n+     * Remove the Pending workflow Requests using ExternalWorkflowReference\n+     * @param workflowExtRef External Workflow Reference of Workflow Pending Request\n+     * @throws APIManagementException\n+     */\n+    public void deleteWorkflowRequest(String workflowExtRef) throws APIManagementException {\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        String query = SQLConstants.DELETE_WORKFLOW_REQUEST_SQL;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            connection.setAutoCommit(false);\n+            prepStmt = connection.prepareStatement(query);\n+            prepStmt.setString(1, workflowExtRef);\n+            prepStmt.executeUpdate();\n+            connection.commit();\n+        }\n+        catch (SQLException e) {\n+            handleException(\"Failed to delete the workflow request. \", e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, null);\n+        }\n+    }\n+\n+    /**\n+     * Get the Pending workflow Request using ExternalWorkflowReference\n+     * @param externalWorkflowRef\n+     * @return workflow pending request\n+     * @throws APIManagementException\n+     */\n+    public Workflow getworkflowReferenceByExternalWorkflowReference(String externalWorkflowRef)throws APIManagementException {\n+\n+        Connection connection = null;\n+        PreparedStatement prepStmt = null;\n+        ResultSet rs = null;\n+        Workflow workflow = new Workflow();\n+        String sqlQuery = SQLConstants.GET_ALL_WORKFLOW_DETAILS_BY_EXTERNALWORKFLOWREF;\n+        try {\n+            connection = APIMgtDBUtil.getConnection();\n+            prepStmt = connection.prepareStatement(sqlQuery);\n+            prepStmt.setString(1, externalWorkflowRef);\n+            rs = prepStmt.executeQuery();\n+\n+            while (rs.next()) {\n+                workflow.setWorkflowId(rs.getInt(\"WF_ID\"));\n+                workflow.setWorkflowReference(rs.getString(\"WF_REFERENCE\"));\n+                workflow.setWorkflowType(rs.getString(\"WF_TYPE\"));\n+                String workflowstatus =rs.getString(\"WF_STATUS\");\n+                workflow.setStatus(org.wso2.carbon.apimgt.api.WorkflowStatus.valueOf(workflowstatus));\n+                workflow.setCreatedTime(rs.getTimestamp(\"WF_CREATED_TIME\").toString());\n+                workflow.setUpdatedTime(rs.getTimestamp(\"WF_UPDATED_TIME\").toString());\n+                workflow.setWorkflowStatusDesc(rs.getString(\"WF_STATUS_DESC\"));\n+                workflow.setTenantId(rs.getInt(\"TENANT_ID\"));\n+                workflow.setTenantDomain(rs.getString(\"TENANT_DOMAIN\"));\n+                workflow.setExternalWorkflowReference(rs.getString(\"WF_EXTERNAL_REFERENCE\"));\n+                Blob metadatablob = rs.getBlob(\"WF_METADATA\");\n+\n+                byte[] metadataByte;\n+                if(metadatablob != null) {\n+                    metadataByte = metadatablob.getBytes(1L, (int) metadatablob.length());\n+                    InputStream targetStream = new ByteArrayInputStream(metadataByte);\n+                    String metadata = APIMgtDBUtil.getStringFromInputStream(targetStream);\n+                    Gson metadataGson = new Gson();\n+                    JSONObject metadataJson = metadataGson.fromJson(metadata, JSONObject.class);\n+                    workflow.setMetadata(metadataJson);\n+                } else {\n+                    JSONObject metadataJson = new JSONObject();\n+                    workflow.setMetadata(metadataJson);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            handleException(\"Error when retriving the workflow details. \" , e);\n+        } finally {\n+            APIMgtDBUtil.closeAllConnections(prepStmt, connection, rs);\n+        }\n+        return workflow;\n+    }\n+\n+    /**\n+     * Get the Pending workflow Requests using WorkflowType for a particular tenant\n+     * @param workflowType Type of the workflow pending request\n+     * @param status workflow status of workflow pending request\n+     * @param tenantDomain tenantDomain of the user\n+     * @return List of workflow pending request\n+     * @throws APIManagementException\n+     */\n+    public Workflow[] getworkflows(String workflowType, String status, String tenantDomain) throws APIManagementException {", "originalCommit": "3719d98f3d2faba218147e15535025aa6169e371", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "9b48a01776745e4804aee0554f67dde112e0ccdd", "url": "https://github.com/wso2/carbon-apimgt/commit/9b48a01776745e4804aee0554f67dde112e0ccdd", "message": "Reformtted the previous commits and removed unwanted files", "committedDate": "2020-04-24T09:47:33Z", "type": "commit"}, {"oid": "56d859aa06815de769c0130c450c2764150312fc", "url": "https://github.com/wso2/carbon-apimgt/commit/56d859aa06815de769c0130c450c2764150312fc", "message": "Changed the admin-api.yaml and beans.xml in org.wso2.carbon.apimgt.rest.api.admin", "committedDate": "2020-04-28T10:11:28Z", "type": "commit"}]}