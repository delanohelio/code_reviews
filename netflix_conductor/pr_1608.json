{"pr_number": 1608, "pr_title": "change nonterminal task statuses to SKIPPED when a TERMINATE task executes", "pr_author": "rickfish", "pr_createdAt": "2020-03-27T13:23:32Z", "pr_url": "https://github.com/Netflix/conductor/pull/1608", "timeline": [{"oid": "39e74f6114b22d1c6b99a9019753b04ced751bb5", "url": "https://github.com/Netflix/conductor/commit/39e74f6114b22d1c6b99a9019753b04ced751bb5", "message": "change non-terminal task statuses to SKIPPED when a TERMINATE task executes", "committedDate": "2020-03-27T13:14:19Z", "type": "commit"}, {"oid": "b677f8a64ea26e33cfa28fd08b3de248adc69466", "url": "https://github.com/Netflix/conductor/commit/b677f8a64ea26e33cfa28fd08b3de248adc69466", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-03-31T11:36:58Z", "type": "commit"}, {"oid": "7a180038382566254439838054500c1a9439d63f", "url": "https://github.com/Netflix/conductor/commit/7a180038382566254439838054500c1a9439d63f", "message": "handle subworkflows that are still running when TERMINATE task executes in parent workflow", "committedDate": "2020-03-31T11:42:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r402694138", "body": "In the case of sub workflows, would it be better to terminate the sub workflow instead? The reason could be that the parent workflow was terminated using TERMINATE task.", "bodyText": "In the case of sub workflows, would it be better to terminate the sub workflow instead? The reason could be that the parent workflow was terminated using TERMINATE task.", "bodyHTML": "<p dir=\"auto\">In the case of sub workflows, would it be better to terminate the sub workflow instead? The reason could be that the parent workflow was terminated using TERMINATE task.</p>", "author": "apanicker-nflx", "createdAt": "2020-04-03T01:55:30Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,6 +987,26 @@ public boolean decide(String workflowId) {\n                                 workflow.setStatus(workflowInstance.getStatus());\n                                 workflow.setOutput(workflowInstance.getOutput());\n                                 deciderService.externalizeWorkflowData(workflow);\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\ttasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped", "originalCommit": "7a180038382566254439838054500c1a9439d63f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2Njk4OA==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r402966988", "bodyText": "There are a couple of issues that make terminating the subworkflows problematic (I think). Firstly, I think if the terminate task specifies COMPLETED as the terminationStatus and the subworkflow is terminated, the termination of the subworkflow would actually cause the ultimate status of the parent workflow to be FAILED which wouldn't honor the contract of the terminate task.\nAlso, I tried the below code and there is a StackOverflowError because WorkflowExecutor.decide() would call terminateWorkflow() which would call decide() to terminate the parent workflow, etc.\nif (TERMINATE.name().equals(task.getTaskType())) {\n\tworkflow.setStatus(workflowInstance.getStatus());\n\tworkflow.setOutput(workflowInstance.getOutput());\n\tdeciderService.externalizeWorkflowData(workflow);\n\t/*\n\t * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n\t */\n\tfor(Task workflowTask : workflow.getTasks()) {\n\t\tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n\t\t\tworkflowTask.setStatus(SKIPPED);\n\t\t\ttasksToBeUpdated.add(workflowTask);\n\t\t}\n\t}\n\t/*\n\t * Now find nested subworkflows that also need to have their tasks skipped\n\t */\n\tfor(Task workflowTask : workflow.getTasks()) {\n\t\tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n\t\t\tterminateWorkflow(workflowTask.getSubWorkflowId(), \"Parent workflow was terminated with a TERMINATE task\");\n\t\t/*                                \t\t\n\t\t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n\t\t\tif(subWorkflow != null) {\n\t\t\t\tskipTasksAffectedByTerminateTask(subWorkflow);                                \t\t\n\t\t\t}\n\t\t*/                                \t\t\n\t\t}\n\t}\n}\n\n\nThat said, I could probably make it work but that would involve a lot of changes that might create unforeseen problems elsewhere.\nWhat are your thoughts?", "author": "rickfish", "createdAt": "2020-04-03T12:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNzU5OA==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408517598", "bodyText": "f the terminate task specifies COMPLETED as the terminationStatus and the subworkflow is terminated, the termination of the subworkflow would actually cause the ultimate status of the parent workflow to be FAILED\n\nThis observation is correct. Agreed with the reasoning and implementation.", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "4059393e455e6d96564375c6919523793f702221", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 58fde4bc..757200ef 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -984,16 +984,17 @@ public class WorkflowExecutor {\n                         if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n                             // FIXME: temporary hack to workaround TERMINATE task\n                             if (TERMINATE.name().equals(task.getTaskType())) {\n-                                workflow.setStatus(workflowInstance.getStatus());\n-                                workflow.setOutput(workflowInstance.getOutput());\n                                 deciderService.externalizeWorkflowData(workflow);\n+                                executionDAOFacade.updateTask(task);\n+                                workflow.setOutput(workflowInstance.getOutput());\n+                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n                                 /*\n                                  * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n                                  */\n                                 for(Task workflowTask : workflow.getTasks()) {\n                                 \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n                                 \t\tworkflowTask.setStatus(SKIPPED);\n-                                \t\ttasksToBeUpdated.add(workflowTask);\n+                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n                                 \t}\n                                 }\n                                 /*\n", "next_change": {"commit": "43491539bbb1bdee7ec88ac22c647cab4eef5619", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 757200ef..35bcea9f 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -984,36 +984,13 @@ public class WorkflowExecutor {\n                         if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n                             // FIXME: temporary hack to workaround TERMINATE task\n                             if (TERMINATE.name().equals(task.getTaskType())) {\n-                                deciderService.externalizeWorkflowData(workflow);\n+                                deciderService.externalizeTaskData(task);\n                                 executionDAOFacade.updateTask(task);\n-                                workflow.setOutput(workflowInstance.getOutput());\n-                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n-                                /*\n-                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n-                                \t\tworkflowTask.setStatus(SKIPPED);\n-                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n-                                \t}\n-                                }\n-                                /*\n-                                 * Now find nested subworkflows that also need to have their tasks skipped\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n-                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n-                                \t\tif(subWorkflow != null) {\n-                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);                                \t\t\n-                                \t\t}\n-                                \t}\n-                                }\n-                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n-                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                \tcompleteWorkflow(workflow);\n+                                if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                    completeWorkflow(workflow);\n                                 } else {\n                                     workflow.setStatus(workflowInstance.getStatus());\n-                                \tterminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n+                                    terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n                                 }\n                                 return true;\n                             }\n", "next_change": {"commit": "5b816dbd76011bf02aae22d0070ead7bc5cc7859", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 35bcea9f..757200ef 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -984,13 +984,36 @@ public class WorkflowExecutor {\n                         if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n                             // FIXME: temporary hack to workaround TERMINATE task\n                             if (TERMINATE.name().equals(task.getTaskType())) {\n-                                deciderService.externalizeTaskData(task);\n+                                deciderService.externalizeWorkflowData(workflow);\n                                 executionDAOFacade.updateTask(task);\n-                                if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                    completeWorkflow(workflow);\n+                                workflow.setOutput(workflowInstance.getOutput());\n+                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n+                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n+                                \t\tif(subWorkflow != null) {\n+                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);                                \t\t\n+                                \t\t}\n+                                \t}\n+                                }\n+                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n+                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                \tcompleteWorkflow(workflow);\n                                 } else {\n                                     workflow.setStatus(workflowInstance.getStatus());\n-                                    terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n+                                \tterminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n                                 }\n                                 return true;\n                             }\n", "next_change": {"commit": "48cc0783553b643d53d594afd873ae6526aa79ea", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 757200ef..51071362 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -1013,13 +1007,20 @@ public class WorkflowExecutor {\n                                 \tcompleteWorkflow(workflow);\n                                 } else {\n                                     workflow.setStatus(workflowInstance.getStatus());\n-                                \tterminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n+                                \t  terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n                                 }\n                                 return true;\n                             }\n                             deciderService.externalizeTaskData(task);\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n+                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                            // and continues with the current decide.\n+                            if (updateParentWorkflow(task, workflow)) {\n+                                tasksToBeUpdated.add(task);\n+                                stateChanged = true;\n+                            }\n                         }\n                     } catch (Exception e) {\n                         throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n", "next_change": {"commit": "78682a73c5eda54f52a765a1ddcedbba464245e3", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 51071362..011b31f0 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -1007,20 +1013,13 @@ public class WorkflowExecutor {\n                                 \tcompleteWorkflow(workflow);\n                                 } else {\n                                     workflow.setStatus(workflowInstance.getStatus());\n-                                \t  terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n+                                \tterminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n                                 }\n                                 return true;\n                             }\n                             deciderService.externalizeTaskData(task);\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n-                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                            // and continues with the current decide.\n-                            if (updateParentWorkflow(task, workflow)) {\n-                                tasksToBeUpdated.add(task);\n-                                stateChanged = true;\n-                            }\n                         }\n                     } catch (Exception e) {\n                         throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n", "next_change": {"commit": "8579a60ea3d108ca525e2c93fda2ceddb322bdad", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 011b31f0..09ceb707 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -1013,13 +1007,20 @@ public class WorkflowExecutor {\n                                 \tcompleteWorkflow(workflow);\n                                 } else {\n                                     workflow.setStatus(workflowInstance.getStatus());\n-                                \tterminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n+                                \t  terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n                                 }\n                                 return true;\n                             }\n                             deciderService.externalizeTaskData(task);\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n+                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                            // and continues with the current decide.\n+                            if (updateParentWorkflow(task, workflow)) {\n+                                tasksToBeUpdated.add(task);\n+                                stateChanged = true;\n+                            }\n                         }\n                     } catch (Exception e) {\n                         throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n", "next_change": {"commit": "26f6bb75870e2904ebbc154d8291c2f2bfa66dda", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 09ceb707..862d2cd3 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -974,56 +985,29 @@ public class WorkflowExecutor {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    try {\n-                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                            // FIXME: temporary hack to workaround TERMINATE task\n-                            if (TERMINATE.name().equals(task.getTaskType())) {\n-                                deciderService.externalizeTaskData(task);\n-                                executionDAOFacade.updateTask(task);\n-                                workflow.setOutput(workflowInstance.getOutput());\n-                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n-                                /*\n-                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n-                                \t\tworkflowTask.setStatus(SKIPPED);\n-                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n-                                \t}\n-                                }\n-                                /*\n-                                 * Now find nested subworkflows that also need to have their tasks skipped\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n-                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n-                                \t\tif(subWorkflow != null) {\n-                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);                                \t\t\n-                                \t\t}\n-                                \t}\n-                                }\n-                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n-                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                \tcompleteWorkflow(workflow);\n-                                } else {\n-                                    workflow.setStatus(workflowInstance.getStatus());\n-                                \t  terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n-                                }\n-                                return true;\n-                            }\n+                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                        // FIXME: temporary hack to workaround TERMINATE task\n+                        if (TERMINATE.name().equals(task.getTaskType())) {\n                             deciderService.externalizeTaskData(task);\n+                            executionDAOFacade.updateTask(task);\n+                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                completeWorkflow(workflow);\n+                            } else {\n+                                workflow.setStatus(workflowInstance.getStatus());\n+                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                            }\n+                            return true;\n+                        }\n+                        deciderService.externalizeTaskData(task);\n+                        tasksToBeUpdated.add(task);\n+                        stateChanged = true;\n+                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                        // and continues with the current decide.\n+                        if (updateParentWorkflow(task, workflow)) {\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n-                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                            // and continues with the current decide.\n-                            if (updateParentWorkflow(task, workflow)) {\n-                                tasksToBeUpdated.add(task);\n-                                stateChanged = true;\n-                            }\n                         }\n-                    } catch (Exception e) {\n-                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n                     }\n                 }\n             }\n", "next_change": {"commit": "342abee796c9f06def4a7c1b6478d85e011bcbbe", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 862d2cd3..7f2c2be5 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -985,29 +986,56 @@ public class WorkflowExecutor {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                        // FIXME: temporary hack to workaround TERMINATE task\n-                        if (TERMINATE.name().equals(task.getTaskType())) {\n-                            deciderService.externalizeTaskData(task);\n-                            executionDAOFacade.updateTask(task);\n-                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                completeWorkflow(workflow);\n-                            } else {\n-                                workflow.setStatus(workflowInstance.getStatus());\n-                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                    try {\n+                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                            // FIXME: temporary hack to workaround TERMINATE task\n+                            if (TERMINATE.name().equals(task.getTaskType())) {\n+                                deciderService.externalizeTaskData(task);\n+                                executionDAOFacade.updateTask(task);\n+                                workflow.setOutput(workflowInstance.getOutput());\n+                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n+                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n+                                \t\tif(subWorkflow != null) {\n+                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);\n+                                \t\t}\n+                                \t}\n+                                }\n+                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n+                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                \tcompleteWorkflow(workflow);\n+                                } else {\n+                                    workflow.setStatus(workflowInstance.getStatus());\n+                                \t  terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n+                                }\n+                                return true;\n                             }\n-                            return true;\n-                        }\n-                        deciderService.externalizeTaskData(task);\n-                        tasksToBeUpdated.add(task);\n-                        stateChanged = true;\n-                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                        // and continues with the current decide.\n-                        if (updateParentWorkflow(task, workflow)) {\n+                            deciderService.externalizeTaskData(task);\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n+                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                            // and continues with the current decide.\n+                            if (updateParentWorkflow(task, workflow)) {\n+                                tasksToBeUpdated.add(task);\n+                                stateChanged = true;\n+                            }\n                         }\n+                    } catch (Exception e) {\n+                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n                     }\n                 }\n             }\n", "next_change": {"commit": "49f25ef2072688e52a48f1ee95ca2d42a4fd3a72", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 7f2c2be5..762ca72e 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -986,56 +992,29 @@ public class WorkflowExecutor {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    try {\n-                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                            // FIXME: temporary hack to workaround TERMINATE task\n-                            if (TERMINATE.name().equals(task.getTaskType())) {\n-                                deciderService.externalizeTaskData(task);\n-                                executionDAOFacade.updateTask(task);\n-                                workflow.setOutput(workflowInstance.getOutput());\n-                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n-                                /*\n-                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n-                                \t\tworkflowTask.setStatus(SKIPPED);\n-                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n-                                \t}\n-                                }\n-                                /*\n-                                 * Now find nested subworkflows that also need to have their tasks skipped\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n-                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n-                                \t\tif(subWorkflow != null) {\n-                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);\n-                                \t\t}\n-                                \t}\n-                                }\n-                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n-                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                \tcompleteWorkflow(workflow);\n-                                } else {\n-                                    workflow.setStatus(workflowInstance.getStatus());\n-                                \t  terminateWorkflow(workflow, \"Workflow is FAILED by TERMINATE task: \" + task.getTaskId(), null);\n-                                }\n-                                return true;\n-                            }\n+                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                        // FIXME: temporary hack to workaround TERMINATE task\n+                        if (TERMINATE.name().equals(task.getTaskType())) {\n                             deciderService.externalizeTaskData(task);\n+                            executionDAOFacade.updateTask(task);\n+                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                completeWorkflow(workflow);\n+                            } else {\n+                                workflow.setStatus(workflowInstance.getStatus());\n+                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                            }\n+                            return true;\n+                        }\n+                        deciderService.externalizeTaskData(task);\n+                        tasksToBeUpdated.add(task);\n+                        stateChanged = true;\n+                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                        // and continues with the current decide.\n+                        if (updateParentWorkflow(task, workflow)) {\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n-                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                            // and continues with the current decide.\n-                            if (updateParentWorkflow(task, workflow)) {\n-                                tasksToBeUpdated.add(task);\n-                                stateChanged = true;\n-                            }\n                         }\n-                    } catch (Exception e) {\n-                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n                     }\n                 }\n             }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "b68abd4d979a3d14325dc90c088b529490fb4b4a", "url": "https://github.com/Netflix/conductor/commit/b68abd4d979a3d14325dc90c088b529490fb4b4a", "message": "Merge branch 'master' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-04-09T17:06:10Z", "type": "commit"}, {"oid": "8e066d95c6cee046913eabdb26ad66ff8f638269", "url": "https://github.com/Netflix/conductor/commit/8e066d95c6cee046913eabdb26ad66ff8f638269", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-04-09T17:34:27Z", "type": "commit"}, {"oid": "e20ff1b40c3d1ea22d617e8c9b88a34f5d251fa1", "url": "https://github.com/Netflix/conductor/commit/e20ff1b40c3d1ea22d617e8c9b88a34f5d251fa1", "message": "added subworkflow testing to the terminate task testcase", "committedDate": "2020-04-09T20:22:01Z", "type": "commit"}, {"oid": "cda751672c4657707378f89f51df1d64ee9cf4ca", "url": "https://github.com/Netflix/conductor/commit/cda751672c4657707378f89f51df1d64ee9cf4ca", "message": "added testing that the subworkflow has a valid status and its task also has a valid statusin the terminate task testcase", "committedDate": "2020-04-09T23:38:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408515896", "body": "Since this is a workflow with wait task, this method can be named `createWorkflowWithWaitTask()` for better clarity.", "bodyText": "Since this is a workflow with wait task, this method can be named createWorkflowWithWaitTask() for better clarity.", "bodyHTML": "<p dir=\"auto\">Since this is a workflow with wait task, this method can be named <code>createWorkflowWithWaitTask()</code> for better clarity.</p>", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:41:58Z", "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5272,64 +5274,43 @@ public void testLambda() {\n \n     @Test\n     public void testTerminateTaskWithCompletedStatus() {\n-        WorkflowDef workflowDef = new WorkflowDef();\n-        workflowDef.setName(\"test_terminate_task_wf\");\n-        workflowDef.setSchemaVersion(2);\n-\n-        Map<String, Object> lambdaTaskInputParams = new HashMap<>();\n-        lambdaTaskInputParams.put(\"input\", \"${workflow.input}\");\n-        lambdaTaskInputParams.put(\"scriptExpression\", \"if ($.input.a==1){return {testvalue: true}} else{return {testvalue: false}}\");\n+    \ttestTerminateTask(WorkflowStatus.COMPLETED);\n+    }\n \n-        WorkflowTask lambdaWorkflowTask = new WorkflowTask();\n-        lambdaWorkflowTask.setWorkflowTaskType(TaskType.LAMBDA);\n-        lambdaWorkflowTask.setName(\"lambda\");\n-        lambdaWorkflowTask.setInputParameters(lambdaTaskInputParams);\n-        lambdaWorkflowTask.setTaskReferenceName(\"lambda0\");\n+    @Test\n+    public void testTerminateTaskWithFailedStatus() {\n+    \ttestTerminateTask(WorkflowStatus.FAILED);\n+    }\n \n-        Map<String, Object> terminateTaskInputParams = new HashMap<>();\n-        terminateTaskInputParams.put(Terminate.getTerminationStatusParameter(), \"COMPLETED\");\n-        terminateTaskInputParams.put(Terminate.getTerminationWorkflowOutputParameter(), \"${lambda0.output}\");\n+    private WorkflowDef createSubworkflowDefWithWaitTask() {", "originalCommit": "cda751672c4657707378f89f51df1d64ee9cf4ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxODE0NQ==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408518145", "bodyText": "Also, please add another task after the wait task in this workflow, and check that this task is not scheduled when parent workflow is completed using terminate.", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyODI3NQ==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408928275", "bodyText": "made the requested changes", "author": "rickfish", "createdAt": "2020-04-15T15:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "81052d4c6ee0a95b62bf6ed919dc54df82264d25", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex 2b2773ba..aa796f9e 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5282,7 +5282,7 @@ public abstract class AbstractWorkflowServiceTest {\n     \ttestTerminateTask(WorkflowStatus.FAILED);\n     }\n \n-    private WorkflowDef createSubworkflowDefWithWaitTask() {\n+    private WorkflowDef createWorkflowWithWaitTask() {\n         WorkflowDef workflowDef = new WorkflowDef();\n         workflowDef.setName(\"test_subworkflow_task_wf\");\n         workflowDef.setSchemaVersion(2);\n", "next_change": {"commit": "26f6bb75870e2904ebbc154d8291c2f2bfa66dda", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex aa796f9e..f44c3856 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5274,55 +5348,66 @@ public abstract class AbstractWorkflowServiceTest {\n \n     @Test\n     public void testTerminateTaskWithCompletedStatus() {\n-    \ttestTerminateTask(WorkflowStatus.COMPLETED);\n-    }\n-\n-    @Test\n-    public void testTerminateTaskWithFailedStatus() {\n-    \ttestTerminateTask(WorkflowStatus.FAILED);\n-    }\n-\n-    private WorkflowDef createWorkflowWithWaitTask() {\n         WorkflowDef workflowDef = new WorkflowDef();\n-        workflowDef.setName(\"test_subworkflow_task_wf\");\n+        workflowDef.setName(\"test_terminate_task_wf\");\n         workflowDef.setSchemaVersion(2);\n \n-        Map<String, Object> waitTaskInputParams = new HashMap<>();\n-        waitTaskInputParams.put(\"input\", \"${workflow.input}\");\n+        Map<String, Object> lambdaTaskInputParams = new HashMap<>();\n+        lambdaTaskInputParams.put(\"input\", \"${workflow.input}\");\n+        lambdaTaskInputParams.put(\"scriptExpression\", \"if ($.input.a==1){return {testvalue: true}} else{return {testvalue: false}}\");\n \n-        WorkflowTask waitWorkflowTask = new WorkflowTask();\n-        waitWorkflowTask.setWorkflowTaskType(TaskType.WAIT);\n-        waitWorkflowTask.setName(\"wait\");\n-        waitWorkflowTask.setInputParameters(waitTaskInputParams);\n-        waitWorkflowTask.setTaskReferenceName(\"subworkflow-wait0\");\n+        WorkflowTask lambdaWorkflowTask = new WorkflowTask();\n+        lambdaWorkflowTask.setWorkflowTaskType(TaskType.LAMBDA);\n+        lambdaWorkflowTask.setName(\"lambda\");\n+        lambdaWorkflowTask.setInputParameters(lambdaTaskInputParams);\n+        lambdaWorkflowTask.setTaskReferenceName(\"lambda0\");\n \n-        String taskName = \"junit_task_1\";\n-        TaskDef taskDef = notFoundSafeGetTaskDef(taskName);\n-        taskDef.setRetryCount(0);\n-        taskDef.setTimeoutSeconds(0);\n-        metadataService.updateTaskDef(taskDef);\n+        Map<String, Object> terminateTaskInputParams = new HashMap<>();\n+        terminateTaskInputParams.put(Terminate.getTerminationStatusParameter(), \"COMPLETED\");\n+        terminateTaskInputParams.put(Terminate.getTerminationWorkflowOutputParameter(), \"${lambda0.output}\");\n \n-        WorkflowTask simpleWorkflowTask = new WorkflowTask();\n-        simpleWorkflowTask.setWorkflowTaskType(TaskType.SIMPLE);\n-        simpleWorkflowTask.setName(taskName);\n-        simpleWorkflowTask.setTaskReferenceName(taskName);\n+        WorkflowTask terminateWorkflowTask = new WorkflowTask();\n+        terminateWorkflowTask.setType(TaskType.TASK_TYPE_TERMINATE);\n+        terminateWorkflowTask.setName(\"terminate\");\n+        terminateWorkflowTask.setInputParameters(terminateTaskInputParams);\n+        terminateWorkflowTask.setTaskReferenceName(\"terminate0\");\n \n-        workflowDef.getTasks().add(waitWorkflowTask);\n-        workflowDef.getTasks().add(simpleWorkflowTask);\n+        WorkflowTask workflowTask2 = new WorkflowTask();\n+        workflowTask2.setName(\"junit_task_2\");\n+        workflowTask2.setTaskReferenceName(\"t2\");\n+\n+        workflowDef.getTasks().addAll(Arrays.asList(lambdaWorkflowTask, terminateWorkflowTask, workflowTask2));\n \n         assertNotNull(workflowDef);\n         metadataService.registerWorkflowDef(workflowDef);\n-        return workflowDef;\n+\n+        Map<String, Object> wfInput = new HashMap<>();\n+        wfInput.put(\"a\", 1);\n+        String workflowId = startOrLoadWorkflowExecution(workflowDef.getName(), workflowDef.getVersion(), \"\", wfInput, null, null);\n+        Workflow workflow = workflowExecutor.getWorkflow(workflowId, true);\n+\n+        assertNotNull(workflow);\n+        assertEquals(2, workflow.getTasks().size());\n+\n+        workflowExecutor.decide(workflowId);\n+        workflow = workflowExecutionService.getExecutionStatus(workflowId, true);\n+\n+        assertNotNull(workflow);\n+        assertEquals(\"tasks:\" + workflow.getTasks(), WorkflowStatus.COMPLETED, workflow.getStatus());\n+        assertEquals(TaskType.TASK_TYPE_LAMBDA, workflow.getTasks().get(0).getTaskType());\n+        assertEquals(TaskType.TASK_TYPE_TERMINATE, workflow.getTasks().get(1).getTaskType());\n+        assertEquals(workflow.getTasks().get(1).getOutputData(), workflow.getOutput());\n+\n+        metadataService.unregisterWorkflowDef(\"test_terminate_task_wf\", 1);\n     }\n \n-    private void testTerminateTask(WorkflowStatus terminationStatus) {\n-        WorkflowDef subworkflowDef = this.createWorkflowWithWaitTask();\n-        \n-        WorkflowTask fanoutTask = new WorkflowTask();\n-        fanoutTask.setType(TaskType.FORK_JOIN.name());\n-        fanoutTask.setTaskReferenceName(\"fanouttask\");\n+    @Test\n+    public void testTerminateTaskWithFailedStatus() {\n+        String failureWorkflowName = \"failure_workflow\";\n+        WorkflowDef workflowDef = new WorkflowDef();\n+        workflowDef.setName(\"test_terminate_task_wf\");\n+        workflowDef.setSchemaVersion(2);\n \n-        // left fork\n         Map<String, Object> lambdaTaskInputParams = new HashMap<>();\n         lambdaTaskInputParams.put(\"input\", \"${workflow.input}\");\n         lambdaTaskInputParams.put(\"scriptExpression\", \"if ($.input.a==1){return {testvalue: true}} else{return {testvalue: false}}\");\n", "next_change": {"commit": "3e45cb69f6ad8b843482717a11344cf2447afd70", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex f44c3856..13dbe35b 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5403,7 +5403,6 @@ public abstract class AbstractWorkflowServiceTest {\n \n     @Test\n     public void testTerminateTaskWithFailedStatus() {\n-        String failureWorkflowName = \"failure_workflow\";\n         WorkflowDef workflowDef = new WorkflowDef();\n         workflowDef.setName(\"test_terminate_task_wf\");\n         workflowDef.setSchemaVersion(2);\n", "next_change": {"commit": "09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex 13dbe35b..b35ff865 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5403,6 +5403,7 @@ public abstract class AbstractWorkflowServiceTest {\n \n     @Test\n     public void testTerminateTaskWithFailedStatus() {\n+        String failureWorkflowName = \"failure_workflow\";\n         WorkflowDef workflowDef = new WorkflowDef();\n         workflowDef.setName(\"test_terminate_task_wf\");\n         workflowDef.setSchemaVersion(2);\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNjczMw==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408516733", "body": "The last task in the left fork is the terminate task, however, the join is set to an intermediate task (wait). This looks incorrect.", "bodyText": "The last task in the left fork is the terminate task, however, the join is set to an intermediate task (wait). This looks incorrect.", "bodyHTML": "<p dir=\"auto\">The last task in the left fork is the terminate task, however, the join is set to an intermediate task (wait). This looks incorrect.</p>", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:45:01Z", "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5350,11 +5337,28 @@ public void testTerminateTaskWithFailedStatus() {\n         terminateWorkflowTask.setInputParameters(terminateTaskInputParams);\n         terminateWorkflowTask.setTaskReferenceName(\"terminate0\");\n \n-        WorkflowTask workflowTask2 = new WorkflowTask();\n-        workflowTask2.setName(\"junit_task_2\");\n-        workflowTask2.setTaskReferenceName(\"t2\");\n+        // right fork\n+        WorkflowTask subWorkflow = new WorkflowTask();\n+        subWorkflow.setType(SUB_WORKFLOW.name());\n+        SubWorkflowParams sw = new SubWorkflowParams();\n+        sw.setName(subworkflowDef.getName());\n+        subWorkflow.setSubWorkflowParam(sw);\n+        subWorkflow.setTaskReferenceName(\"sw1\");\n+\n+        fanoutTask.getForkTasks().add(Arrays.asList(subWorkflow));\n+        fanoutTask.getForkTasks().add(Arrays.asList(lambdaWorkflowTask, waitWorkflowTask, terminateWorkflowTask));\n+\n+        // join task\n+        WorkflowTask joinTask = new WorkflowTask();\n+        joinTask.setType(TaskType.JOIN.name());\n+        joinTask.setTaskReferenceName(\"fanouttask_join\");\n+        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"leftfork-wait0\"));", "originalCommit": "cda751672c4657707378f89f51df1d64ee9cf4ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyODQ0MQ==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408928441", "bodyText": "made the requested change", "author": "rickfish", "createdAt": "2020-04-15T15:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNjczMw=="}], "type": "inlineReview", "revised_code": {"commit": "81052d4c6ee0a95b62bf6ed919dc54df82264d25", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex 2b2773ba..aa796f9e 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5352,7 +5364,7 @@ public abstract class AbstractWorkflowServiceTest {\n         WorkflowTask joinTask = new WorkflowTask();\n         joinTask.setType(TaskType.JOIN.name());\n         joinTask.setTaskReferenceName(\"fanouttask_join\");\n-        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"leftfork-wait0\"));\n+        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"terminate0\"));\n         \n         WorkflowDef workflowDef = new WorkflowDef();\n         workflowDef.setName(\"test_terminate_task_wf\");\n", "next_change": {"commit": "26f6bb75870e2904ebbc154d8291c2f2bfa66dda", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex aa796f9e..f44c3856 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5349,78 +5428,50 @@ public abstract class AbstractWorkflowServiceTest {\n         terminateWorkflowTask.setInputParameters(terminateTaskInputParams);\n         terminateWorkflowTask.setTaskReferenceName(\"terminate0\");\n \n-        // right fork\n-        WorkflowTask subWorkflow = new WorkflowTask();\n-        subWorkflow.setType(SUB_WORKFLOW.name());\n-        SubWorkflowParams sw = new SubWorkflowParams();\n-        sw.setName(subworkflowDef.getName());\n-        subWorkflow.setSubWorkflowParam(sw);\n-        subWorkflow.setTaskReferenceName(\"sw1\");\n+        WorkflowTask workflowTask2 = new WorkflowTask();\n+        workflowTask2.setName(\"junit_task_2\");\n+        workflowTask2.setTaskReferenceName(\"t2\");\n \n-        fanoutTask.getForkTasks().add(Arrays.asList(subWorkflow));\n-        fanoutTask.getForkTasks().add(Arrays.asList(lambdaWorkflowTask, waitWorkflowTask, terminateWorkflowTask));\n+        workflowDef.getTasks().addAll(Arrays.asList(lambdaWorkflowTask, terminateWorkflowTask, workflowTask2));\n \n-        // join task\n-        WorkflowTask joinTask = new WorkflowTask();\n-        joinTask.setType(TaskType.JOIN.name());\n-        joinTask.setTaskReferenceName(\"fanouttask_join\");\n-        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"terminate0\"));\n-        \n-        WorkflowDef workflowDef = new WorkflowDef();\n-        workflowDef.setName(\"test_terminate_task_wf\");\n-        workflowDef.setSchemaVersion(2);\n+        WorkflowDef failureWorkflowDef = new WorkflowDef();\n+        failureWorkflowDef.setName(failureWorkflowName);\n+        failureWorkflowDef.setTasks(Collections.singletonList(lambdaWorkflowTask));\n \n-        workflowDef.getTasks().addAll(Arrays.asList(fanoutTask, joinTask));\n+        workflowDef.setFailureWorkflow(failureWorkflowName);\n \n-        assertNotNull(workflowDef);\n+        metadataService.registerWorkflowDef(failureWorkflowDef);\n         metadataService.registerWorkflowDef(workflowDef);\n \n-        Map wfInput = Collections.singletonMap(\"a\", 1);\n-        //noinspection unchecked\n+        Map<String, Object> wfInput = new HashMap<>();\n+        wfInput.put(\"a\", 1);\n         String workflowId = startOrLoadWorkflowExecution(workflowDef.getName(), workflowDef.getVersion(), \"\", wfInput, null, null);\n         Workflow workflow = workflowExecutor.getWorkflow(workflowId, true);\n-        Optional<Task> optionalTask = workflow.getTasks().stream().filter(t -> \"sw1\".equals(t.getReferenceTaskName())).findFirst();\n-        assertTrue(optionalTask.isPresent());\n-        \n-        SubWorkflow subWorkflowSystemTask = new SubWorkflow();\n-        String subWorkflowTaskId = optionalTask.get().getTaskId();\n-        workflowExecutor.executeSystemTask(subWorkflowSystemTask, subWorkflowTaskId, 1);\n-\n-        workflowExecutor.decide(workflowId);\n-        workflow = workflowExecutionService.getExecutionStatus(workflowId, true);\n \n         assertNotNull(workflow);\n-        optionalTask = workflow.getTasks().stream().filter(t -> \"leftfork-wait0\".equals(t.getReferenceTaskName())).findFirst();\n-        assertTrue(optionalTask.isPresent());\n+        assertEquals(2, workflow.getTasks().size());\n \n-        TaskResult taskResult = new TaskResult(optionalTask.get());\n-        taskResult.setStatus(TaskResult.Status.COMPLETED);\n-        workflowExecutionService.updateTask(taskResult);\n         workflowExecutor.decide(workflowId);\n         workflow = workflowExecutionService.getExecutionStatus(workflowId, true);\n \n         assertNotNull(workflow);\n-        assertEquals(\"tasks:\" + workflow.getTasks(), terminationStatus, workflow.getStatus());\n-\n-        optionalTask = workflow.getTasks().stream().filter(t -> SUB_WORKFLOW.name().equals(t.getTaskType())).findFirst();\n-        assertTrue(optionalTask.isPresent());\n-        Task subworkflowTask = optionalTask.get();\n-        assertTrue(SKIPPED == subworkflowTask.getStatus());\n-        \n-        assertNotNull(subworkflowTask.getSubWorkflowId());\n-        workflow = workflowExecutor.getWorkflow(subworkflowTask.getSubWorkflowId(), true);\n-        assertNotNull(workflow);\n-        assertTrue(TERMINATED == workflow.getStatus());\n-        optionalTask = workflow.getTasks().stream().filter(t -> \"subworkflow-wait0\".equals(t.getReferenceTaskName())).findFirst();\n-        assertTrue(optionalTask.isPresent());\n-        Task waitTask = optionalTask.get();\n-        assertTrue(SKIPPED == waitTask.getStatus());\n+        assertEquals(\"tasks:\" + workflow.getTasks(), WorkflowStatus.FAILED, workflow.getStatus());\n+        assertEquals(TaskType.TASK_TYPE_LAMBDA, workflow.getTasks().get(0).getTaskType());\n+        assertEquals(TaskType.TASK_TYPE_TERMINATE, workflow.getTasks().get(1).getTaskType());\n+        assertNotNull(workflow.getOutput());\n+        assertNotNull(workflow.getOutput().get(\"conductor.failure_workflow\"));\n \n-        optionalTask = workflow.getTasks().stream().filter(t -> \"junit_task_1\".equals(t.getReferenceTaskName())).findFirst();\n-        assertFalse(optionalTask.isPresent());\n+        String failureWorkflowId = (String)workflow.getOutput().get(\"conductor.failure_workflow\");\n+        Workflow failureWorkflow = workflowExecutionService.getExecutionStatus(failureWorkflowId, true);\n+        assertNotNull(failureWorkflow);\n+        assertEquals(failureWorkflowName, failureWorkflow.getWorkflowName());\n+        assertEquals(workflowId, failureWorkflow.getInput().get(\"workflowId\"));\n+        assertEquals(WorkflowStatus.COMPLETED, failureWorkflow.getStatus());\n+        assertEquals(1, failureWorkflow.getTasks().size());\n+        assertEquals(TaskType.TASK_TYPE_LAMBDA, failureWorkflow.getTasks().get(0).getTaskType());\n \n         metadataService.unregisterWorkflowDef(\"test_terminate_task_wf\", 1);\n-        metadataService.unregisterWorkflowDef(subworkflowDef.getName(), 1);\n+        metadataService.unregisterWorkflowDef(failureWorkflowName, 1);\n     }\n \n     @Test\n", "next_change": {"commit": "92d2b36bf9aa03876ffacecf1085ec0fe7dad2e6", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex f44c3856..62cd3e91 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5454,20 +5454,32 @@ public abstract class AbstractWorkflowServiceTest {\n         workflowExecutor.decide(workflowId);\n         workflow = workflowExecutionService.getExecutionStatus(workflowId, true);\n \n+System.out.println(\"assert 1\");\n         assertNotNull(workflow);\n+System.out.println(\"assert 2\");\n         assertEquals(\"tasks:\" + workflow.getTasks(), WorkflowStatus.FAILED, workflow.getStatus());\n+System.out.println(\"assert 3\");\n         assertEquals(TaskType.TASK_TYPE_LAMBDA, workflow.getTasks().get(0).getTaskType());\n+System.out.println(\"assert 4\");\n         assertEquals(TaskType.TASK_TYPE_TERMINATE, workflow.getTasks().get(1).getTaskType());\n+System.out.println(\"assert 5\");\n         assertNotNull(workflow.getOutput());\n+System.out.println(\"assert 6\");\n         assertNotNull(workflow.getOutput().get(\"conductor.failure_workflow\"));\n \n         String failureWorkflowId = (String)workflow.getOutput().get(\"conductor.failure_workflow\");\n         Workflow failureWorkflow = workflowExecutionService.getExecutionStatus(failureWorkflowId, true);\n+System.out.println(\"assert 7\");\n         assertNotNull(failureWorkflow);\n+System.out.println(\"assert 8\");\n         assertEquals(failureWorkflowName, failureWorkflow.getWorkflowName());\n+System.out.println(\"assert 9\");\n         assertEquals(workflowId, failureWorkflow.getInput().get(\"workflowId\"));\n+System.out.println(\"assert 10\");\n         assertEquals(WorkflowStatus.COMPLETED, failureWorkflow.getStatus());\n+System.out.println(\"assert 11\");\n         assertEquals(1, failureWorkflow.getTasks().size());\n+System.out.println(\"assert 12\");\n         assertEquals(TaskType.TASK_TYPE_LAMBDA, failureWorkflow.getTasks().get(0).getTaskType());\n \n         metadataService.unregisterWorkflowDef(\"test_terminate_task_wf\", 1);\n", "next_change": {"commit": "bfe93c84e96ad1545277bed8751882bb1685c669", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex 62cd3e91..b35ff865 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5454,32 +5454,20 @@ public abstract class AbstractWorkflowServiceTest {\n         workflowExecutor.decide(workflowId);\n         workflow = workflowExecutionService.getExecutionStatus(workflowId, true);\n \n-System.out.println(\"assert 1\");\n         assertNotNull(workflow);\n-System.out.println(\"assert 2\");\n         assertEquals(\"tasks:\" + workflow.getTasks(), WorkflowStatus.FAILED, workflow.getStatus());\n-System.out.println(\"assert 3\");\n         assertEquals(TaskType.TASK_TYPE_LAMBDA, workflow.getTasks().get(0).getTaskType());\n-System.out.println(\"assert 4\");\n         assertEquals(TaskType.TASK_TYPE_TERMINATE, workflow.getTasks().get(1).getTaskType());\n-System.out.println(\"assert 5\");\n         assertNotNull(workflow.getOutput());\n-System.out.println(\"assert 6\");\n         assertNotNull(workflow.getOutput().get(\"conductor.failure_workflow\"));\n \n         String failureWorkflowId = (String)workflow.getOutput().get(\"conductor.failure_workflow\");\n         Workflow failureWorkflow = workflowExecutionService.getExecutionStatus(failureWorkflowId, true);\n-System.out.println(\"assert 7\");\n         assertNotNull(failureWorkflow);\n-System.out.println(\"assert 8\");\n         assertEquals(failureWorkflowName, failureWorkflow.getWorkflowName());\n-System.out.println(\"assert 9\");\n         assertEquals(workflowId, failureWorkflow.getInput().get(\"workflowId\"));\n-System.out.println(\"assert 10\");\n         assertEquals(WorkflowStatus.COMPLETED, failureWorkflow.getStatus());\n-System.out.println(\"assert 11\");\n         assertEquals(1, failureWorkflow.getTasks().size());\n-System.out.println(\"assert 12\");\n         assertEquals(TaskType.TASK_TYPE_LAMBDA, failureWorkflow.getTasks().get(0).getTaskType());\n \n         metadataService.unregisterWorkflowDef(\"test_terminate_task_wf\", 1);\n", "next_change": {"commit": "3e45cb69f6ad8b843482717a11344cf2447afd70", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex b35ff865..13dbe35b 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5459,19 +5451,8 @@ public abstract class AbstractWorkflowServiceTest {\n         assertEquals(TaskType.TASK_TYPE_LAMBDA, workflow.getTasks().get(0).getTaskType());\n         assertEquals(TaskType.TASK_TYPE_TERMINATE, workflow.getTasks().get(1).getTaskType());\n         assertNotNull(workflow.getOutput());\n-        assertNotNull(workflow.getOutput().get(\"conductor.failure_workflow\"));\n-\n-        String failureWorkflowId = (String)workflow.getOutput().get(\"conductor.failure_workflow\");\n-        Workflow failureWorkflow = workflowExecutionService.getExecutionStatus(failureWorkflowId, true);\n-        assertNotNull(failureWorkflow);\n-        assertEquals(failureWorkflowName, failureWorkflow.getWorkflowName());\n-        assertEquals(workflowId, failureWorkflow.getInput().get(\"workflowId\"));\n-        assertEquals(WorkflowStatus.COMPLETED, failureWorkflow.getStatus());\n-        assertEquals(1, failureWorkflow.getTasks().size());\n-        assertEquals(TaskType.TASK_TYPE_LAMBDA, failureWorkflow.getTasks().get(0).getTaskType());\n \n         metadataService.unregisterWorkflowDef(\"test_terminate_task_wf\", 1);\n-        metadataService.unregisterWorkflowDef(failureWorkflowName, 1);\n     }\n \n     @Test\n", "next_change": {"commit": "09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "changed_code": [{"header": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex 13dbe35b..b35ff865 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n", "chunk": "@@ -5451,8 +5459,19 @@ public abstract class AbstractWorkflowServiceTest {\n         assertEquals(TaskType.TASK_TYPE_LAMBDA, workflow.getTasks().get(0).getTaskType());\n         assertEquals(TaskType.TASK_TYPE_TERMINATE, workflow.getTasks().get(1).getTaskType());\n         assertNotNull(workflow.getOutput());\n+        assertNotNull(workflow.getOutput().get(\"conductor.failure_workflow\"));\n+\n+        String failureWorkflowId = (String)workflow.getOutput().get(\"conductor.failure_workflow\");\n+        Workflow failureWorkflow = workflowExecutionService.getExecutionStatus(failureWorkflowId, true);\n+        assertNotNull(failureWorkflow);\n+        assertEquals(failureWorkflowName, failureWorkflow.getWorkflowName());\n+        assertEquals(workflowId, failureWorkflow.getInput().get(\"workflowId\"));\n+        assertEquals(WorkflowStatus.COMPLETED, failureWorkflow.getStatus());\n+        assertEquals(1, failureWorkflow.getTasks().size());\n+        assertEquals(TaskType.TASK_TYPE_LAMBDA, failureWorkflow.getTasks().get(0).getTaskType());\n \n         metadataService.unregisterWorkflowDef(\"test_terminate_task_wf\", 1);\n+        metadataService.unregisterWorkflowDef(failureWorkflowName, 1);\n     }\n \n     @Test\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "4c00498dcd2571ad794ee88b335b1d0d5bf29df5", "url": "https://github.com/Netflix/conductor/commit/4c00498dcd2571ad794ee88b335b1d0d5bf29df5", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-04-15T14:16:55Z", "type": "commit"}, {"oid": "81052d4c6ee0a95b62bf6ed919dc54df82264d25", "url": "https://github.com/Netflix/conductor/commit/81052d4c6ee0a95b62bf6ed919dc54df82264d25", "message": "for terminate task testing, add simple task to subworkflow and make the join task wait on the terminate task", "committedDate": "2020-04-15T15:21:11Z", "type": "commit"}, {"oid": "4059393e455e6d96564375c6919523793f702221", "url": "https://github.com/Netflix/conductor/commit/4059393e455e6d96564375c6919523793f702221", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T17:00:08Z", "type": "commit"}, {"oid": "43491539bbb1bdee7ec88ac22c647cab4eef5619", "url": "https://github.com/Netflix/conductor/commit/43491539bbb1bdee7ec88ac22c647cab4eef5619", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T17:06:21Z", "type": "commit"}, {"oid": "5b816dbd76011bf02aae22d0070ead7bc5cc7859", "url": "https://github.com/Netflix/conductor/commit/5b816dbd76011bf02aae22d0070ead7bc5cc7859", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T17:07:35Z", "type": "commit"}, {"oid": "48cc0783553b643d53d594afd873ae6526aa79ea", "url": "https://github.com/Netflix/conductor/commit/48cc0783553b643d53d594afd873ae6526aa79ea", "message": "Merge branch 'dev' into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-05-04T17:39:36Z", "type": "commit"}, {"oid": "78682a73c5eda54f52a765a1ddcedbba464245e3", "url": "https://github.com/Netflix/conductor/commit/78682a73c5eda54f52a765a1ddcedbba464245e3", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T21:41:38Z", "type": "commit"}, {"oid": "8579a60ea3d108ca525e2c93fda2ceddb322bdad", "url": "https://github.com/Netflix/conductor/commit/8579a60ea3d108ca525e2c93fda2ceddb322bdad", "message": "Merge branch 'terminate-task-handle-nonterminal-tasks' of https://github.com/rickfish/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-05-04T21:42:36Z", "type": "commit"}, {"oid": "f05fba9a015ff9e8940d18f3bc34d8fe2e47c805", "url": "https://github.com/Netflix/conductor/commit/f05fba9a015ff9e8940d18f3bc34d8fe2e47c805", "message": "add workflow defs", "committedDate": "2020-07-01T20:14:08Z", "type": "commit"}, {"oid": "6cb53c0575b097c4405c0953b891cbcef7ac82af", "url": "https://github.com/Netflix/conductor/commit/6cb53c0575b097c4405c0953b891cbcef7ac82af", "message": "deleted sample json files", "committedDate": "2020-07-02T11:42:48Z", "type": "commit"}, {"oid": "26f6bb75870e2904ebbc154d8291c2f2bfa66dda", "url": "https://github.com/Netflix/conductor/commit/26f6bb75870e2904ebbc154d8291c2f2bfa66dda", "message": "prepare for merge of current dev", "committedDate": "2020-07-02T12:03:07Z", "type": "commit"}, {"oid": "1db5b7aafd1307fc4f4de577e9d4135e9114e25a", "url": "https://github.com/Netflix/conductor/commit/1db5b7aafd1307fc4f4de577e9d4135e9114e25a", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-07-02T12:04:12Z", "type": "commit"}, {"oid": "342abee796c9f06def4a7c1b6478d85e011bcbbe", "url": "https://github.com/Netflix/conductor/commit/342abee796c9f06def4a7c1b6478d85e011bcbbe", "message": "fix subworkflows when TERMINATE task is executed and there is a nonterminal subworkflow", "committedDate": "2020-07-02T12:23:15Z", "type": "commit"}, {"oid": "82d88f21cf2b59c0849b60723e61cfb715b15093", "url": "https://github.com/Netflix/conductor/commit/82d88f21cf2b59c0849b60723e61cfb715b15093", "message": "Added back ending curly brace - not sure how it got deleted", "committedDate": "2020-07-03T13:59:36Z", "type": "commit"}, {"oid": "92d2b36bf9aa03876ffacecf1085ec0fe7dad2e6", "url": "https://github.com/Netflix/conductor/commit/92d2b36bf9aa03876ffacecf1085ec0fe7dad2e6", "message": "add logging to see what test failed", "committedDate": "2020-07-03T14:41:31Z", "type": "commit"}, {"oid": "bfe93c84e96ad1545277bed8751882bb1685c669", "url": "https://github.com/Netflix/conductor/commit/bfe93c84e96ad1545277bed8751882bb1685c669", "message": "remove logging to see what test failed", "committedDate": "2020-07-03T15:14:54Z", "type": "commit"}, {"oid": "3e45cb69f6ad8b843482717a11344cf2447afd70", "url": "https://github.com/Netflix/conductor/commit/3e45cb69f6ad8b843482717a11344cf2447afd70", "message": "alter the test for a failure workflow where the workflow was terminated with a TERMINATE task", "committedDate": "2020-07-03T18:23:16Z", "type": "commit"}, {"oid": "09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "url": "https://github.com/Netflix/conductor/commit/09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "message": "changed the way to terminate the parent workflow and added back the failureWorkflow tests", "committedDate": "2020-07-03T20:01:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MzMxMw==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r452093313", "body": "This exception message: ```Unable to start system task:``` is not relevant, as we're not starting any system tasks here.", "bodyText": "This exception message: Unable to start system task: is not relevant, as we're not starting any system tasks here.", "bodyHTML": "<p dir=\"auto\">This exception message: <code>Unable to start system task:</code> is not relevant, as we're not starting any system tasks here.</p>", "author": "kishorebanala", "createdAt": "2020-07-09T09:39:31Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,29 +986,56 @@ public boolean decide(String workflowId) {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                        // FIXME: temporary hack to workaround TERMINATE task\n-                        if (TERMINATE.name().equals(task.getTaskType())) {\n-                            deciderService.externalizeTaskData(task);\n-                            executionDAOFacade.updateTask(task);\n-                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                completeWorkflow(workflow);\n-                            } else {\n-                                workflow.setStatus(workflowInstance.getStatus());\n-                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                    try {\n+                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                            // FIXME: temporary hack to workaround TERMINATE task\n+                            if (TERMINATE.name().equals(task.getTaskType())) {\n+                                deciderService.externalizeTaskData(task);\n+                                executionDAOFacade.updateTask(task);\n+                                workflow.setOutput(workflowInstance.getOutput());\n+                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n+                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n+                                \t\tif(subWorkflow != null) {\n+                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);\n+                                \t\t}\n+                                \t}\n+                                }\n+                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n+                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                \tcompleteWorkflow(workflow);\n+                                } else {\n+                                    workflow.setStatus(workflowInstance.getStatus());\n+                                \tterminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                                }\n+                                return true;\n                             }\n-                            return true;\n-                        }\n-                        deciderService.externalizeTaskData(task);\n-                        tasksToBeUpdated.add(task);\n-                        stateChanged = true;\n-                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                        // and continues with the current decide.\n-                        if (updateParentWorkflow(task, workflow)) {\n+                            deciderService.externalizeTaskData(task);\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n+                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                            // and continues with the current decide.\n+                            if (updateParentWorkflow(task, workflow)) {\n+                                tasksToBeUpdated.add(task);\n+                                stateChanged = true;\n+                            }\n                         }\n+                    } catch (Exception e) {\n+                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);", "originalCommit": "09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49f25ef2072688e52a48f1ee95ca2d42a4fd3a72", "changed_code": [{"header": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 8b84afcc..762ca72e 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n", "chunk": "@@ -986,56 +992,29 @@ public class WorkflowExecutor {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    try {\n-                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                            // FIXME: temporary hack to workaround TERMINATE task\n-                            if (TERMINATE.name().equals(task.getTaskType())) {\n-                                deciderService.externalizeTaskData(task);\n-                                executionDAOFacade.updateTask(task);\n-                                workflow.setOutput(workflowInstance.getOutput());\n-                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n-                                /*\n-                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n-                                \t\tworkflowTask.setStatus(SKIPPED);\n-                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n-                                \t}\n-                                }\n-                                /*\n-                                 * Now find nested subworkflows that also need to have their tasks skipped\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n-                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n-                                \t\tif(subWorkflow != null) {\n-                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);\n-                                \t\t}\n-                                \t}\n-                                }\n-                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n-                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                \tcompleteWorkflow(workflow);\n-                                } else {\n-                                    workflow.setStatus(workflowInstance.getStatus());\n-                                \tterminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n-                                }\n-                                return true;\n-                            }\n+                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                        // FIXME: temporary hack to workaround TERMINATE task\n+                        if (TERMINATE.name().equals(task.getTaskType())) {\n                             deciderService.externalizeTaskData(task);\n+                            executionDAOFacade.updateTask(task);\n+                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                completeWorkflow(workflow);\n+                            } else {\n+                                workflow.setStatus(workflowInstance.getStatus());\n+                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                            }\n+                            return true;\n+                        }\n+                        deciderService.externalizeTaskData(task);\n+                        tasksToBeUpdated.add(task);\n+                        stateChanged = true;\n+                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                        // and continues with the current decide.\n+                        if (updateParentWorkflow(task, workflow)) {\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n-                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                            // and continues with the current decide.\n-                            if (updateParentWorkflow(task, workflow)) {\n-                                tasksToBeUpdated.add(task);\n-                                stateChanged = true;\n-                            }\n                         }\n-                    } catch (Exception e) {\n-                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n                     }\n                 }\n             }\n", "next_change": null}]}}, {"oid": "49f25ef2072688e52a48f1ee95ca2d42a4fd3a72", "url": "https://github.com/Netflix/conductor/commit/49f25ef2072688e52a48f1ee95ca2d42a4fd3a72", "message": "prepare for merge", "committedDate": "2020-07-09T12:38:10Z", "type": "commit"}]}