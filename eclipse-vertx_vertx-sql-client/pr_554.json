{"pr_number": 554, "pr_title": "Fluent queries", "pr_createdAt": "2020-03-24T13:54:20Z", "pr_url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554", "merge_commit": "68469731cdd522bc963799e548ddd45bd18c62c6", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE5MDUwNA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397190504", "body": "can these changes really be ported to 3.9? Isn't this a breaking change that would need to wait until 4.0?", "bodyText": "can these changes really be ported to 3.9? Isn't this a breaking change that would need to wait until 4.0?", "bodyHTML": "<p dir=\"auto\">can these changes really be ported to 3.9? Isn't this a breaking change that would need to wait until 4.0?</p>", "author": "aguibert", "createdAt": "2020-03-24T14:22:40Z", "path": "vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java", "diffHunk": "@@ -84,56 +81,25 @@ static void connect(Vertx vertx, MSSQLConnectOptions connectOptions, Handler<Asy\n   @Override\n   MSSQLConnection preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n \n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @GenIgnore\n-  @Override\n-  <R> MSSQLConnection preparedQuery(String s, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);", "originalCommit": "883f92d3351935788df1a89fc3f832179732a90c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyMTAyNA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397221024", "bodyText": "yes it is breaking but in 3.x SQL client is in tech preview mode and can break.", "author": "vietj", "createdAt": "2020-03-24T15:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE5MDUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "9c618a9af5765d8030963c937a939e9081328f13", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\nindex b1ebc0e0..af49cf77 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n", "chunk": "@@ -74,32 +69,4 @@ public interface MSSQLConnection extends SqlConnection {\n   @Override\n   MSSQLConnection closeHandler(Handler<Void> handler);\n \n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection query(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection preparedQuery(String s, Tuple tuple, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n }\n", "next_change": {"commit": "34cf9bdfd455b2c4fe4ed478249f328e5b14f06f", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\nindex af49cf77..42470776 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n", "chunk": "@@ -69,4 +77,63 @@ public interface MSSQLConnection extends SqlConnection {\n   @Override\n   MSSQLConnection closeHandler(Handler<Void> handler);\n \n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLConnection preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLConnection preparedQuery(String s, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLConnection query(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLConnection query(String s, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLConnection preparedQuery(String s, Tuple tuple, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLConnection preparedQuery(String s, Tuple tuple, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLConnection preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLConnection preparedBatch(String s, List<Tuple> list, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n }\n", "next_change": {"commit": "ab2c13580ac596b3e4bbcd2cc950c651f40d8be4", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\nindex 42470776..231b7b6b 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n", "chunk": "@@ -129,11 +102,4 @@ public interface MSSQLConnection extends SqlConnection {\n   @Override\n   MSSQLConnection preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n \n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @GenIgnore\n-  @Override\n-  <R> MSSQLConnection preparedBatch(String s, List<Tuple> list, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n }\n", "next_change": {"commit": "71789de0412a13aaab4d0d2d5070c933025c5df5", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\nindex 231b7b6b..af49cf77 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLConnection.java\n", "chunk": "@@ -74,32 +69,4 @@ public interface MSSQLConnection extends SqlConnection {\n   @Override\n   MSSQLConnection closeHandler(Handler<Void> handler);\n \n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection query(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection preparedQuery(String s, Tuple tuple, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLConnection preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIwMDkyMA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397200920", "body": "I think these one-shot operations should be removed also. I know these are intended as \"convenience methods\" but my initial impression of using this library was I found it very confusing there were so many different ways to do the same thing. IMO we should only provide the user 1 API path where possible. \r\nThe only benefit of these one-shot commands is that it is slightly less typing:\r\n```java\r\n// One-shot way\r\npool.preparedQuery(SQL, ar -> this::processRows);\r\n\r\n// Regular way\r\npool.createPreparedQuery().execute(ar -> this::processRows);\r\n```\r\n\r\nIf we get rid of the one-shot methods, it will significantly reduce the API surface and make the overall API much quicker for users to grasp.", "bodyText": "I think these one-shot operations should be removed also. I know these are intended as \"convenience methods\" but my initial impression of using this library was I found it very confusing there were so many different ways to do the same thing. IMO we should only provide the user 1 API path where possible.\nThe only benefit of these one-shot commands is that it is slightly less typing:\n// One-shot way\npool.preparedQuery(SQL, ar -> this::processRows);\n\n// Regular way\npool.createPreparedQuery().execute(ar -> this::processRows);\nIf we get rid of the one-shot methods, it will significantly reduce the API surface and make the overall API much quicker for users to grasp.", "bodyHTML": "<p dir=\"auto\">I think these one-shot operations should be removed also. I know these are intended as \"convenience methods\" but my initial impression of using this library was I found it very confusing there were so many different ways to do the same thing. IMO we should only provide the user 1 API path where possible.<br>\nThe only benefit of these one-shot commands is that it is slightly less typing:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// One-shot way\npool.preparedQuery(SQL, ar -&gt; this::processRows);\n\n// Regular way\npool.createPreparedQuery().execute(ar -&gt; this::processRows);\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> One-shot way</span>\npool<span class=\"pl-k\">.</span>preparedQuery(<span class=\"pl-c1\">SQL</span>, ar <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">::</span>processRows);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Regular way</span>\npool<span class=\"pl-k\">.</span>createPreparedQuery()<span class=\"pl-k\">.</span>execute(ar <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">::</span>processRows);</pre></div>\n<p dir=\"auto\">If we get rid of the one-shot methods, it will significantly reduce the API surface and make the overall API much quicker for users to grasp.</p>", "author": "aguibert", "createdAt": "2020-03-24T14:35:50Z", "path": "vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java", "diffHunk": "@@ -60,56 +58,25 @@ static MSSQLPool pool(Vertx vertx, MSSQLConnectOptions connectOptions, PoolOptio\n   @Override\n   MSSQLPool preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);", "originalCommit": "883f92d3351935788df1a89fc3f832179732a90c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIxNzgzOA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397217838", "bodyText": "please see step 5.", "author": "vietj", "createdAt": "2020-03-24T14:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIwMDkyMA=="}], "type": "inlineReview", "revised_code": {"commit": "9c618a9af5765d8030963c937a939e9081328f13", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\nindex e8b6ccba..4d17a620 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n", "chunk": "@@ -51,32 +46,4 @@ public interface MSSQLPool extends Pool {\n     return new MSSQLPoolImpl((ContextInternal) vertx.getOrCreateContext(), false, connectOptions, poolOptions);\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool query(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool preparedQuery(String s, Tuple tuple, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n }\n", "next_change": {"commit": "34cf9bdfd455b2c4fe4ed478249f328e5b14f06f", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\nindex 4d17a620..c0054ab4 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n", "chunk": "@@ -46,4 +53,63 @@ public interface MSSQLPool extends Pool {\n     return new MSSQLPoolImpl((ContextInternal) vertx.getOrCreateContext(), false, connectOptions, poolOptions);\n   }\n \n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLPool preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLPool preparedQuery(String s, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLPool query(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLPool query(String s, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLPool preparedQuery(String s, Tuple tuple, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLPool preparedQuery(String s, Tuple tuple, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @Override\n+  MSSQLPool preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Fluent\n+  @GenIgnore\n+  @Override\n+  <R> MSSQLPool preparedBatch(String s, List<Tuple> list, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n }\n", "next_change": {"commit": "ab2c13580ac596b3e4bbcd2cc950c651f40d8be4", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\nindex c0054ab4..e8b6ccba 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n", "chunk": "@@ -105,11 +79,4 @@ public interface MSSQLPool extends Pool {\n   @Override\n   MSSQLPool preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n \n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @GenIgnore\n-  @Override\n-  <R> MSSQLPool preparedBatch(String s, List<Tuple> list, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n }\n", "next_change": {"commit": "71789de0412a13aaab4d0d2d5070c933025c5df5", "changed_code": [{"header": "diff --git a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\nindex e8b6ccba..4d17a620 100644\n--- a/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n+++ b/vertx-mssql-client/src/main/java/io/vertx/mssqlclient/MSSQLPool.java\n", "chunk": "@@ -51,32 +46,4 @@ public interface MSSQLPool extends Pool {\n     return new MSSQLPoolImpl((ContextInternal) vertx.getOrCreateContext(), false, connectOptions, poolOptions);\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool preparedQuery(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool query(String s, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool preparedQuery(String s, Tuple tuple, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Fluent\n-  @Override\n-  MSSQLPool preparedBatch(String s, List<Tuple> list, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIwNjg2MA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397206860", "body": "Since `cursor()` and `createStream()` are both different flavors of executing queries, it seems that they would be better suited on the `Query` interface. \r\n\r\nBasically there are 4 ways that a user can retrieve results from their query:\r\n - RowSet<Row> (default way)\r\n - Function<Row,U>\r\n - Collector\r\n - Cursor (prepared statement only)\r\n - RowStream<Row> (prepared statement only)\r\n\r\nI think it would be good if we only had 1 way of executing a query (via `execute` on the `Query` interface) and the result type could be selected prior to execution. For example:\r\n - (nothing needed to get the default RowSet)\r\n - `Query#mapping(Function<Row,U>)`\r\n - `Query#collecting(Collector)`\r\n - `Query#streaming(int fetchSize)` (proposed)\r\n - `Query#withCursor()` (proposed)", "bodyText": "Since cursor() and createStream() are both different flavors of executing queries, it seems that they would be better suited on the Query interface.\nBasically there are 4 ways that a user can retrieve results from their query:\n\nRowSet (default way)\nFunction<Row,U>\nCollector\nCursor (prepared statement only)\nRowStream (prepared statement only)\n\nI think it would be good if we only had 1 way of executing a query (via execute on the Query interface) and the result type could be selected prior to execution. For example:\n\n(nothing needed to get the default RowSet)\nQuery#mapping(Function<Row,U>)\nQuery#collecting(Collector)\nQuery#streaming(int fetchSize) (proposed)\nQuery#withCursor() (proposed)", "bodyHTML": "<p dir=\"auto\">Since <code>cursor()</code> and <code>createStream()</code> are both different flavors of executing queries, it seems that they would be better suited on the <code>Query</code> interface.</p>\n<p dir=\"auto\">Basically there are 4 ways that a user can retrieve results from their query:</p>\n<ul dir=\"auto\">\n<li>RowSet (default way)</li>\n<li>Function&lt;Row,U&gt;</li>\n<li>Collector</li>\n<li>Cursor (prepared statement only)</li>\n<li>RowStream (prepared statement only)</li>\n</ul>\n<p dir=\"auto\">I think it would be good if we only had 1 way of executing a query (via <code>execute</code> on the <code>Query</code> interface) and the result type could be selected prior to execution. For example:</p>\n<ul dir=\"auto\">\n<li>(nothing needed to get the default RowSet)</li>\n<li><code>Query#mapping(Function&lt;Row,U&gt;)</code></li>\n<li><code>Query#collecting(Collector)</code></li>\n<li><code>Query#streaming(int fetchSize)</code> (proposed)</li>\n<li><code>Query#withCursor()</code> (proposed)</li>\n</ul>", "author": "aguibert", "createdAt": "2020-03-24T14:43:25Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/PreparedStatement.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (C) 2017 Julien Viet\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.vertx.sqlclient;\n+\n+import io.vertx.core.Future;\n+import io.vertx.sqlclient.impl.ArrayTuple;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A prepared statement, the statement is pre-compiled and\n+ * it's more efficient to execute the statement for multiple times.\n+ * In addition, this kind of statement provides protection against SQL injection attacks.\n+ *\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+@VertxGen\n+public interface PreparedStatement {\n+\n+  /**\n+   * Create a query.\n+   *\n+   * @return the query\n+   */\n+  Query<RowSet<Row>> query();\n+\n+  /**\n+   * @return create a query cursor with a {@code fetch} size and empty arguments\n+   */\n+  default Cursor cursor() {\n+    return cursor(ArrayTuple.EMPTY);\n+  }\n+\n+  /**\n+   * Create a cursor with the provided {@code arguments}.\n+   *\n+   * @param args the list of arguments\n+   * @return the query\n+   */\n+  Cursor cursor(Tuple args);\n+\n+  /**\n+   * Execute the prepared query with a cursor and createStream the result. The createStream opens a cursor\n+   * with a {@code fetch} size to fetch the results.\n+   * <p/>\n+   * Note: this requires to be in a transaction, since cursors require it.\n+   *\n+   * @param fetch the cursor fetch size\n+   * @param args the prepared query arguments\n+   * @return the createStream\n+   */\n+  RowStream<Row> createStream(int fetch, Tuple args);", "originalCommit": "883f92d3351935788df1a89fc3f832179732a90c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyMDAyOQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397220029", "bodyText": "Cursor and stream should be kept away from Query as they can require transaction isolation (in PG at least) and they should be handled only from SqlConnection and PreparedStatement and are not one shot operations (i.e they span several interactions).\nProviding cursor on Query would make it available from a pool without acquiring a connection.", "author": "vietj", "createdAt": "2020-03-24T14:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIwNjg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNTE5NA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397235194", "bodyText": "Providing cursor on Query would make it available from a pool without acquiring a connection.\n\nI was suggesting that the proposed streaming and withCursor() methods would alter the result type once execute is eventually invoked, so it would still require a connection. Example usage might look like:\npool.createPreparedQuery(SQL)\n       .withCursor()\n       .execute(ar -> { \n         Cursor c = ar.result();\n         // do stuff with cursor\n       });\nSo this way execute would be the only terminal operation in the API (for executing queries). Otherwise we have 3 terminal operations (execute, cursor, and stream).", "author": "aguibert", "createdAt": "2020-03-24T15:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIwNjg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MTQ3MA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397241470", "bodyText": "As I said, using this from a pool is error prone. A cursor is an advanced feature and the user should use a connection to interact with a Cursor and it does not fit well with the SqlClient interface that provides exclusively one-shot operation that do not require any close operation to release the resource.", "author": "vietj", "createdAt": "2020-03-24T15:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIwNjg2MA=="}], "type": "inlineReview", "revised_code": {"commit": "34cf9bdfd455b2c4fe4ed478249f328e5b14f06f", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/PreparedStatement.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/PreparedQuery.java\nsimilarity index 58%\nrename from vertx-sql-client/src/main/java/io/vertx/sqlclient/PreparedStatement.java\nrename to vertx-sql-client/src/main/java/io/vertx/sqlclient/PreparedQuery.java\nindex 570557db..a8f569d3 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/PreparedStatement.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/PreparedQuery.java\n", "chunk": "@@ -67,6 +102,18 @@ public interface PreparedStatement {\n    */\n   RowStream<Row> createStream(int fetch, Tuple args);\n \n+  /**\n+   * Execute a batch.\n+   *\n+   * @param argsList the list of tuple for the batch\n+   */\n+  void batch(List<Tuple> argsList, Handler<AsyncResult<T>> handler);\n+\n+  /**\n+   * Like {@link #batch(List, Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<T> batch(List<Tuple> argsList);\n+\n   /**\n    * Close the prepared query and release its resources.\n    */\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyNzY3MQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397227671", "body": "I'm afraid users would be confused here especially those who have used client side prepared statement before, if someone writes code like this\r\n```\r\nconn.createQuery(\"SELECT * FROM users WHERE id = ?\")\r\n        .execute(Tuple.of(1));\r\n```\r\n\r\nThey will get wrong sql syntax error but what they expect is executing a query with a param.\r\n\r\nAnd even this kind of query can also be executed\r\n```\r\nconn.createQuery(\"SELECT * FROM users\")\r\n        .execute(Tuple.of(1, 2, 3));\r\n```", "bodyText": "I'm afraid users would be confused here especially those who have used client side prepared statement before, if someone writes code like this\nconn.createQuery(\"SELECT * FROM users WHERE id = ?\")\n        .execute(Tuple.of(1));\n\nThey will get wrong sql syntax error but what they expect is executing a query with a param.\nAnd even this kind of query can also be executed\nconn.createQuery(\"SELECT * FROM users\")\n        .execute(Tuple.of(1, 2, 3));", "bodyHTML": "<p dir=\"auto\">I'm afraid users would be confused here especially those who have used client side prepared statement before, if someone writes code like this</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"conn.createQuery(&quot;SELECT * FROM users WHERE id = ?&quot;)\n        .execute(Tuple.of(1));\"><pre><code>conn.createQuery(\"SELECT * FROM users WHERE id = ?\")\n        .execute(Tuple.of(1));\n</code></pre></div>\n<p dir=\"auto\">They will get wrong sql syntax error but what they expect is executing a query with a param.</p>\n<p dir=\"auto\">And even this kind of query can also be executed</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"conn.createQuery(&quot;SELECT * FROM users&quot;)\n        .execute(Tuple.of(1, 2, 3));\"><pre><code>conn.createQuery(\"SELECT * FROM users\")\n        .execute(Tuple.of(1, 2, 3));\n</code></pre></div>", "author": "BillyYccc", "createdAt": "2020-03-24T15:09:13Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (C) 2017 Julien Viet\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.vertx.sqlclient.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.impl.command.BiCommand;\n+import io.vertx.sqlclient.impl.command.PrepareStatementCommand;\n+\n+import java.util.List;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class QueryImpl<T, R extends SqlResult<T>> extends QueryBase<T, R> {\n+\n+  static Query<RowSet<Row>> create(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql) {\n+    SqlResultBuilder<RowSet<Row>, RowSetImpl<Row>, RowSet<Row>> builder = new SqlResultBuilder<>(RowSetImpl.FACTORY, RowSetImpl.COLLECTOR);\n+    return new QueryImpl<>(client, autoCommit, singleton, prepared, sql, builder);\n+  }\n+\n+  private final SqlClientBase<?> scheduler;\n+  private final boolean singleton;\n+  private final boolean prepared;\n+  private final String sql;\n+\n+  public QueryImpl(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql, SqlResultBuilder<T, ?, R> builder) {\n+    super(autoCommit, builder);\n+    this.scheduler = client;\n+    this.singleton = singleton;\n+    this.prepared = prepared;\n+    this.sql = sql;\n+  }\n+\n+  @Override\n+  protected <T2, R2 extends SqlResult<T2>> QueryBase<T2, R2> copy(SqlResultBuilder<T2, ?, R2> builder) {\n+    return new QueryImpl<>(scheduler, autoCommit, singleton, prepared, sql, builder);\n+  }\n+\n+  private void execute(Tuple arguments, Promise<R> promise) {\n+    SqlResultHandler handler = builder.createHandler(promise);\n+    if (prepared) {\n+      BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n+        String msg = ps.prepare((TupleInternal) arguments);\n+        if (msg != null) {\n+          return Future.failedFuture(msg);\n+        }\n+        return Future.succeededFuture(builder.createCommand(ps, autoCommit, arguments, handler));\n+      });\n+      scheduler.schedule(abc, handler);\n+    } else {\n+      builder.execute(scheduler, sql, autoCommit, singleton, handler);", "originalCommit": "883f92d3351935788df1a89fc3f832179732a90c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyODg3OQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397228879", "bodyText": "it is not cleat what you mean, you are commenting on QueryImpl which is not the API", "author": "vietj", "createdAt": "2020-03-24T15:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyNzY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzMjA0MQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397232041", "bodyText": "I mean the API allows that a simple query could be executed or batched with parameters but it's implicitly executed without any parameters", "author": "BillyYccc", "createdAt": "2020-03-24T15:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyNzY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzOTI3Mg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397239272", "bodyText": "Can you clarify your concern here @BillyYccc ?\nIf a user just does conn.createQuery(\"SELECT * FROM users WHERE id = ?\") no interaction with the DB would occur until execute() is invoked. So the first code example you showed will work fine.\nFor the second code example, users can already use incorrect SQL and params with the current API like this:\n// blows up because SQL has 0 params but 3 were passed in\nconn.preparedQuery(\"SELECT * FROM users\", Tuple.of(1, 2, 3));", "author": "aguibert", "createdAt": "2020-03-24T15:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyNzY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3NDgyMQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397274821", "bodyText": "I think they are different in terms of a user's intuitions.\nMy first example shows a scene where users wants to execute a client side prepared statement which is commonly used in JDBC drivers, but we don't support this in all clients so users will get an error of wrong sql syntax, this looks strange for those users but it's OK once users know we don't support this kind of queries.\nMy second example shows a usecase when users accidently writes a sql of no placeholders but execute with several parameters, the query could be executed and parameters are ignored but in my opinion using simple query with parameters should be forbidden rather than executing the simple query implicitly while ignoring params if we don't support client side prepared statement.\nAs for the prepared statement example, it's different because the prepared statement has been pre-compiled, when you execute the prepared statement, the params count and even types will be validated with param metadata locally so users will quickly get an error signal without executing it in reality.", "author": "BillyYccc", "createdAt": "2020-03-24T16:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyNzY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NDg4Mw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397284883", "bodyText": "Ah, I think I see what you are getting at. For the first example, it is a syntax error because the user is doing con.createQuery(SQL) as opposed to con.createPreparedQuery()?\nThis does indeed seem like an issue. Since Query is used for both prepared and non-prepared queries.", "author": "aguibert", "createdAt": "2020-03-24T16:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIyNzY3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "9c618a9af5765d8030963c937a939e9081328f13", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java\ndeleted file mode 100644\nindex 3fcd8a17..00000000\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,119 +0,0 @@\n-/*\n- * Copyright (C) 2017 Julien Viet\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- */\n-\n-package io.vertx.sqlclient.impl;\n-\n-import io.vertx.core.AsyncResult;\n-import io.vertx.core.Future;\n-import io.vertx.core.Handler;\n-import io.vertx.core.Promise;\n-import io.vertx.sqlclient.Query;\n-import io.vertx.sqlclient.Row;\n-import io.vertx.sqlclient.RowSet;\n-import io.vertx.sqlclient.SqlResult;\n-import io.vertx.sqlclient.Tuple;\n-import io.vertx.sqlclient.impl.command.BiCommand;\n-import io.vertx.sqlclient.impl.command.PrepareStatementCommand;\n-\n-import java.util.List;\n-\n-/**\n- * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n- */\n-public class QueryImpl<T, R extends SqlResult<T>> extends QueryBase<T, R> {\n-\n-  static Query<RowSet<Row>> create(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql) {\n-    SqlResultBuilder<RowSet<Row>, RowSetImpl<Row>, RowSet<Row>> builder = new SqlResultBuilder<>(RowSetImpl.FACTORY, RowSetImpl.COLLECTOR);\n-    return new QueryImpl<>(client, autoCommit, singleton, prepared, sql, builder);\n-  }\n-\n-  private final SqlClientBase<?> scheduler;\n-  private final boolean singleton;\n-  private final boolean prepared;\n-  private final String sql;\n-\n-  public QueryImpl(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql, SqlResultBuilder<T, ?, R> builder) {\n-    super(autoCommit, builder);\n-    this.scheduler = client;\n-    this.singleton = singleton;\n-    this.prepared = prepared;\n-    this.sql = sql;\n-  }\n-\n-  @Override\n-  protected <T2, R2 extends SqlResult<T2>> QueryBase<T2, R2> copy(SqlResultBuilder<T2, ?, R2> builder) {\n-    return new QueryImpl<>(scheduler, autoCommit, singleton, prepared, sql, builder);\n-  }\n-\n-  private void execute(Tuple arguments, Promise<R> promise) {\n-    SqlResultHandler handler = builder.createHandler(promise);\n-    if (prepared) {\n-      BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n-        String msg = ps.prepare((TupleInternal) arguments);\n-        if (msg != null) {\n-          return Future.failedFuture(msg);\n-        }\n-        return Future.succeededFuture(builder.createCommand(ps, autoCommit, arguments, handler));\n-      });\n-      scheduler.schedule(abc, handler);\n-    } else {\n-      builder.execute(scheduler, sql, autoCommit, singleton, handler);\n-    }\n-  }\n-\n-  @Override\n-  public void execute(Tuple tuple, Handler<AsyncResult<R>> handler) {\n-    execute(tuple, scheduler.promise(handler));\n-  }\n-\n-  @Override\n-  public Future<R> execute(Tuple tuple) {\n-    Promise<R> promise = scheduler.promise();\n-    execute(tuple, promise);\n-    return promise.future();\n-  }\n-\n-  @Override\n-  public void batch(List<Tuple> batch, Handler<AsyncResult<R>> handler) {\n-    batch(batch, scheduler.promise(handler));\n-  }\n-\n-  @Override\n-  public Future<R> batch(List<Tuple> batch) {\n-    Promise<R> promise = scheduler.promise();\n-    batch(batch, promise);\n-    return promise.future();\n-  }\n-\n-  private void batch(List<Tuple> batch, Promise<R> promise) {\n-    SqlResultHandler handler = builder.createHandler(promise);\n-    if (prepared) {\n-      BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n-        for  (Tuple args : batch) {\n-          String msg = ps.prepare((TupleInternal) args);\n-          if (msg != null) {\n-            return Future.failedFuture(msg);\n-          }\n-        }\n-        return Future.succeededFuture(builder.createBatchCommand(ps, autoCommit, batch, handler));\n-      });\n-      scheduler.schedule(abc, handler);\n-    } else {\n-      builder.execute(scheduler, sql, autoCommit, singleton, handler);\n-    }\n-  }\n-}\n", "next_change": {"commit": "ab2c13580ac596b3e4bbcd2cc950c651f40d8be4", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java\nnew file mode 100644\nindex 00000000..952a45f1\n--- /dev/null\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java\n", "chunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright (C) 2017 Julien Viet\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.vertx.sqlclient.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.impl.command.BiCommand;\n+import io.vertx.sqlclient.impl.command.PrepareStatementCommand;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class QueryImpl<T, R extends SqlResult<T>> implements Query<R> {\n+\n+  static Query<RowSet<Row>> create(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql) {\n+    SqlResultBuilder<RowSet<Row>, RowSetImpl<Row>, RowSet<Row>> builder = new SqlResultBuilder<>(RowSetImpl.FACTORY, RowSetImpl.COLLECTOR);\n+    return new QueryImpl<>(client, autoCommit, singleton, prepared, sql, builder);\n+  }\n+\n+  private final SqlClientBase<?> scheduler;\n+  private final boolean autoCommit;\n+  private final boolean singleton;\n+  private final boolean prepared;\n+  private final String sql;\n+  private final SqlResultBuilder<T, ?, R> builder;\n+\n+  public QueryImpl(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql, SqlResultBuilder<T, ?, R> builder) {\n+    this.scheduler = client;\n+    this.autoCommit = autoCommit;\n+    this.singleton = singleton;\n+    this.prepared = prepared;\n+    this.sql = sql;\n+    this.builder = builder;\n+  }\n+\n+  @Override\n+  public void execute(Handler<AsyncResult<R>> handler) {\n+    execute(ArrayTuple.EMPTY, handler);\n+  }\n+\n+  @Override\n+  public Future<R> execute() {\n+    return execute(ArrayTuple.EMPTY);\n+  }\n+\n+  private void execute(Tuple arguments, Promise<R> promise) {\n+    SqlResultHandler handler = builder.createHandler(promise);\n+    if (prepared) {\n+      BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n+        String msg = ps.prepare((TupleInternal) arguments);\n+        if (msg != null) {\n+          return Future.failedFuture(msg);\n+        }\n+        return Future.succeededFuture(builder.createCommand(ps, autoCommit, arguments, handler));\n+      });\n+      scheduler.schedule(abc, handler);\n+    } else {\n+      builder.execute(scheduler, sql, autoCommit, singleton, handler);\n+    }\n+  }\n+\n+  @Override\n+  public void execute(Tuple tuple, Handler<AsyncResult<R>> handler) {\n+    execute(tuple, scheduler.promise(handler));\n+  }\n+\n+  @Override\n+  public Future<R> execute(Tuple tuple) {\n+    Promise<R> promise = scheduler.promise();\n+    execute(tuple, promise);\n+    return promise.future();\n+  }\n+\n+  @Override\n+  public <U> Query<SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    SqlResultBuilder<U, SqlResultImpl<U>, SqlResult<U>> builder = new SqlResultBuilder<>(SqlResultImpl::new, collector);\n+    return new QueryImpl<>(scheduler, autoCommit, singleton, prepared, sql, builder);\n+  }\n+\n+  @Override\n+  public <U> Query<RowSet<U>> mapping(Function<Row, U> mapper) {\n+    SqlResultBuilder<RowSet<U>, RowSetImpl<U>, RowSet<U>> builder = new SqlResultBuilder<>(RowSetImpl.factory(), RowSetImpl.collector(mapper));\n+    return new QueryImpl<>(scheduler, autoCommit, singleton, prepared, sql, builder);\n+  }\n+\n+  @Override\n+  public void batch(List<Tuple> batch, Handler<AsyncResult<R>> handler) {\n+    batch(batch, scheduler.promise(handler));\n+  }\n+\n+  @Override\n+  public Future<R> batch(List<Tuple> batch) {\n+    Promise<R> promise = scheduler.promise();\n+    batch(batch, promise);\n+    return promise.future();\n+  }\n+\n+  private void batch(List<Tuple> batch, Promise<R> promise) {\n+    SqlResultHandler handler = builder.createHandler(promise);\n+    if (prepared) {\n+      BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n+        for  (Tuple args : batch) {\n+          String msg = ps.prepare((TupleInternal) args);\n+          if (msg != null) {\n+            return Future.failedFuture(msg);\n+          }\n+        }\n+        return Future.succeededFuture(builder.createBatchCommand(ps, autoCommit, batch, handler));\n+      });\n+      scheduler.schedule(abc, handler);\n+    } else {\n+      builder.execute(scheduler, sql, autoCommit, singleton, handler);\n+    }\n+  }\n+}\n", "next_change": {"commit": "a0afbc43cd9f77b3cb5742dbac7a224adbaa0cb5", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java\ndeleted file mode 100644\nindex 952a45f1..00000000\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryImpl.java\n+++ /dev/null\n", "chunk": "@@ -1,141 +0,0 @@\n-/*\n- * Copyright (C) 2017 Julien Viet\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- */\n-\n-package io.vertx.sqlclient.impl;\n-\n-import io.vertx.core.AsyncResult;\n-import io.vertx.core.Future;\n-import io.vertx.core.Handler;\n-import io.vertx.core.Promise;\n-import io.vertx.sqlclient.Query;\n-import io.vertx.sqlclient.Row;\n-import io.vertx.sqlclient.RowSet;\n-import io.vertx.sqlclient.SqlResult;\n-import io.vertx.sqlclient.Tuple;\n-import io.vertx.sqlclient.impl.command.BiCommand;\n-import io.vertx.sqlclient.impl.command.PrepareStatementCommand;\n-\n-import java.util.List;\n-import java.util.function.Function;\n-import java.util.stream.Collector;\n-\n-/**\n- * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n- */\n-public class QueryImpl<T, R extends SqlResult<T>> implements Query<R> {\n-\n-  static Query<RowSet<Row>> create(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql) {\n-    SqlResultBuilder<RowSet<Row>, RowSetImpl<Row>, RowSet<Row>> builder = new SqlResultBuilder<>(RowSetImpl.FACTORY, RowSetImpl.COLLECTOR);\n-    return new QueryImpl<>(client, autoCommit, singleton, prepared, sql, builder);\n-  }\n-\n-  private final SqlClientBase<?> scheduler;\n-  private final boolean autoCommit;\n-  private final boolean singleton;\n-  private final boolean prepared;\n-  private final String sql;\n-  private final SqlResultBuilder<T, ?, R> builder;\n-\n-  public QueryImpl(SqlClientBase<?> client, boolean autoCommit, boolean singleton, boolean prepared, String sql, SqlResultBuilder<T, ?, R> builder) {\n-    this.scheduler = client;\n-    this.autoCommit = autoCommit;\n-    this.singleton = singleton;\n-    this.prepared = prepared;\n-    this.sql = sql;\n-    this.builder = builder;\n-  }\n-\n-  @Override\n-  public void execute(Handler<AsyncResult<R>> handler) {\n-    execute(ArrayTuple.EMPTY, handler);\n-  }\n-\n-  @Override\n-  public Future<R> execute() {\n-    return execute(ArrayTuple.EMPTY);\n-  }\n-\n-  private void execute(Tuple arguments, Promise<R> promise) {\n-    SqlResultHandler handler = builder.createHandler(promise);\n-    if (prepared) {\n-      BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n-        String msg = ps.prepare((TupleInternal) arguments);\n-        if (msg != null) {\n-          return Future.failedFuture(msg);\n-        }\n-        return Future.succeededFuture(builder.createCommand(ps, autoCommit, arguments, handler));\n-      });\n-      scheduler.schedule(abc, handler);\n-    } else {\n-      builder.execute(scheduler, sql, autoCommit, singleton, handler);\n-    }\n-  }\n-\n-  @Override\n-  public void execute(Tuple tuple, Handler<AsyncResult<R>> handler) {\n-    execute(tuple, scheduler.promise(handler));\n-  }\n-\n-  @Override\n-  public Future<R> execute(Tuple tuple) {\n-    Promise<R> promise = scheduler.promise();\n-    execute(tuple, promise);\n-    return promise.future();\n-  }\n-\n-  @Override\n-  public <U> Query<SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n-    SqlResultBuilder<U, SqlResultImpl<U>, SqlResult<U>> builder = new SqlResultBuilder<>(SqlResultImpl::new, collector);\n-    return new QueryImpl<>(scheduler, autoCommit, singleton, prepared, sql, builder);\n-  }\n-\n-  @Override\n-  public <U> Query<RowSet<U>> mapping(Function<Row, U> mapper) {\n-    SqlResultBuilder<RowSet<U>, RowSetImpl<U>, RowSet<U>> builder = new SqlResultBuilder<>(RowSetImpl.factory(), RowSetImpl.collector(mapper));\n-    return new QueryImpl<>(scheduler, autoCommit, singleton, prepared, sql, builder);\n-  }\n-\n-  @Override\n-  public void batch(List<Tuple> batch, Handler<AsyncResult<R>> handler) {\n-    batch(batch, scheduler.promise(handler));\n-  }\n-\n-  @Override\n-  public Future<R> batch(List<Tuple> batch) {\n-    Promise<R> promise = scheduler.promise();\n-    batch(batch, promise);\n-    return promise.future();\n-  }\n-\n-  private void batch(List<Tuple> batch, Promise<R> promise) {\n-    SqlResultHandler handler = builder.createHandler(promise);\n-    if (prepared) {\n-      BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n-        for  (Tuple args : batch) {\n-          String msg = ps.prepare((TupleInternal) args);\n-          if (msg != null) {\n-            return Future.failedFuture(msg);\n-          }\n-        }\n-        return Future.succeededFuture(builder.createBatchCommand(ps, autoCommit, batch, handler));\n-      });\n-      scheduler.schedule(abc, handler);\n-    } else {\n-      builder.execute(scheduler, sql, autoCommit, singleton, handler);\n-    }\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NzQ4NQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397287485", "body": "I think we need to have a separate `PreparedQuery` interface, because the methods that accept a `Tuple` argument are only for prepared queries.\r\nCurrently both `createQuery()` and `createPreparedQuery()` return type `Query`. As @BillyYccc pointed out a user could try to send in params to a non-prepared query, which is invalid:\r\n```java\r\n// Error: cannot set params on a non-prepared query\r\nclient.createQuery(SQL).execute(Tuple.of(\"foo\"));\r\n```", "bodyText": "I think we need to have a separate PreparedQuery interface, because the methods that accept a Tuple argument are only for prepared queries.\nCurrently both createQuery() and createPreparedQuery() return type Query. As @BillyYccc pointed out a user could try to send in params to a non-prepared query, which is invalid:\n// Error: cannot set params on a non-prepared query\nclient.createQuery(SQL).execute(Tuple.of(\"foo\"));", "bodyHTML": "<p dir=\"auto\">I think we need to have a separate <code>PreparedQuery</code> interface, because the methods that accept a <code>Tuple</code> argument are only for prepared queries.<br>\nCurrently both <code>createQuery()</code> and <code>createPreparedQuery()</code> return type <code>Query</code>. As <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/BillyYccc/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/BillyYccc\">@BillyYccc</a> pointed out a user could try to send in params to a non-prepared query, which is invalid:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// Error: cannot set params on a non-prepared query\nclient.createQuery(SQL).execute(Tuple.of(&quot;foo&quot;));\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Error: cannot set params on a non-prepared query</span>\nclient<span class=\"pl-k\">.</span>createQuery(<span class=\"pl-c1\">SQL</span>)<span class=\"pl-k\">.</span>execute(<span class=\"pl-smi\">Tuple</span><span class=\"pl-k\">.</span>of(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>foo<span class=\"pl-pds\">\"</span></span>));</pre></div>", "author": "aguibert", "createdAt": "2020-03-24T16:24:32Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (C) 2017 Julien Viet\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.vertx.sqlclient;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A query.\n+ *\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+@VertxGen\n+public interface Query<T> {\n+\n+  /**\n+   * Execute the query.\n+   *\n+   * @param handler the handler receiving the response\n+   */\n+  void execute(Handler<AsyncResult<T>> handler);\n+\n+  /**\n+   * Like {@link #execute(Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<T> execute();\n+\n+  /**\n+   * Execute the query.\n+   *\n+   * @param handler the handler receiving the response\n+   */\n+  void execute(Tuple tuple, Handler<AsyncResult<T>> handler);\n+\n+  /**\n+   * Like {@link #execute(Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<T> execute(Tuple tuple);\n+\n+  /**\n+   * Execute the query.\n+   *\n+   * @param batch the batch of tuples\n+   * @param handler the handler receiving the response\n+   */\n+  void batch(List<Tuple> batch, Handler<AsyncResult<T>> handler);\n+\n+  /**\n+   * Like {@link #batch(List, Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<T> batch(List<Tuple> batch);", "originalCommit": "883f92d3351935788df1a89fc3f832179732a90c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5MDg5NQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397290895", "bodyText": "I think it's fine like that and we do not need to over engineer this", "author": "vietj", "createdAt": "2020-03-24T16:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NzQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5NjczNQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397296735", "bodyText": "My point is that the PreparedQuery would be very similar to Query with only the execute method that changes and we would have two interfaces expressing the same concern for a very small gain.", "author": "vietj", "createdAt": "2020-03-24T16:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NzQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Nzg1NA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397297854", "bodyText": "What is the opposition to having a separate PreparedQuery interface that extends the base Query interface? It seems like a good improvement to make the API more type-safe. We could catch these errors at compile-time as opposed to blowing up at runtime.", "author": "aguibert", "createdAt": "2020-03-24T16:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NzQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5ODIzNg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397298236", "bodyText": "that remains a valid point though, perhaps we could have PreparedQuery that extends Query and add execute(Tuple) and executeBatch(List<Tuple>) because execute() would mean execute with the empty tuple where users might want to execute a prepared statement with an empty tuple for performance reason.", "author": "vietj", "createdAt": "2020-03-24T16:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NzQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwNDM2MA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397304360", "bodyText": "Agreed with @vietj here, and that would make sense to specialize Query here.", "author": "jponge", "createdAt": "2020-03-24T16:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NzQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzNzQ4OA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397337488", "bodyText": "yes, that's essentially what I was suggesting. PreparedQuery would extend Query and PreparedQuery would add the Tuple-overloaded execute methods.\nSounds like we are on the same page now \ud83d\udc4d", "author": "aguibert", "createdAt": "2020-03-24T17:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NzQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9c618a9af5765d8030963c937a939e9081328f13", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java\nindex 60c8e90b..90c58abe 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java\n", "chunk": "@@ -47,31 +46,6 @@ public interface Query<T> {\n    */\n   Future<T> execute();\n \n-  /**\n-   * Execute the query.\n-   *\n-   * @param handler the handler receiving the response\n-   */\n-  void execute(Tuple tuple, Handler<AsyncResult<T>> handler);\n-\n-  /**\n-   * Like {@link #execute(Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  Future<T> execute(Tuple tuple);\n-\n-  /**\n-   * Execute the query.\n-   *\n-   * @param batch the batch of tuples\n-   * @param handler the handler receiving the response\n-   */\n-  void batch(List<Tuple> batch, Handler<AsyncResult<T>> handler);\n-\n-  /**\n-   * Like {@link #batch(List, Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  Future<T> batch(List<Tuple> batch);\n-\n   /**\n    * Use the specified {@code collector} for collecting the query result to {@code <R>}.\n    */\n", "next_change": {"commit": "34cf9bdfd455b2c4fe4ed478249f328e5b14f06f", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java\ndeleted file mode 100644\nindex 90c58abe..00000000\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java\n+++ /dev/null\n", "chunk": "@@ -1,60 +0,0 @@\n-/*\n- * Copyright (C) 2017 Julien Viet\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- */\n-\n-package io.vertx.sqlclient;\n-\n-import io.vertx.codegen.annotations.GenIgnore;\n-import io.vertx.codegen.annotations.VertxGen;\n-import io.vertx.core.AsyncResult;\n-import io.vertx.core.Future;\n-import io.vertx.core.Handler;\n-\n-import java.util.function.Function;\n-import java.util.stream.Collector;\n-\n-/**\n- * A query.\n- *\n- * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n- */\n-@VertxGen\n-public interface Query<T> {\n-\n-  /**\n-   * Execute the query.\n-   *\n-   * @param handler the handler receiving the response\n-   */\n-  void execute(Handler<AsyncResult<T>> handler);\n-\n-  /**\n-   * Like {@link #execute(Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  Future<T> execute();\n-\n-  /**\n-   * Use the specified {@code collector} for collecting the query result to {@code <R>}.\n-   */\n-  @GenIgnore\n-  <R> Query<SqlResult<R>> collecting(Collector<Row, ?, R> collector);\n-\n-  /**\n-   * Use the specified {@code mapper} for mapping {@link Row} to {@code <U>}.\n-   */\n-  <U> Query<RowSet<U>> mapping(Function<Row, U> mapper);\n-\n-}\n", "next_change": {"commit": "ab2c13580ac596b3e4bbcd2cc950c651f40d8be4", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java\nnew file mode 100644\nindex 00000000..60c8e90b\n--- /dev/null\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/Query.java\n", "chunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright (C) 2017 Julien Viet\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.vertx.sqlclient;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A query.\n+ *\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+@VertxGen\n+public interface Query<T> {\n+\n+  /**\n+   * Execute the query.\n+   *\n+   * @param handler the handler receiving the response\n+   */\n+  void execute(Handler<AsyncResult<T>> handler);\n+\n+  /**\n+   * Like {@link #execute(Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<T> execute();\n+\n+  /**\n+   * Execute the query.\n+   *\n+   * @param handler the handler receiving the response\n+   */\n+  void execute(Tuple tuple, Handler<AsyncResult<T>> handler);\n+\n+  /**\n+   * Like {@link #execute(Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<T> execute(Tuple tuple);\n+\n+  /**\n+   * Execute the query.\n+   *\n+   * @param batch the batch of tuples\n+   * @param handler the handler receiving the response\n+   */\n+  void batch(List<Tuple> batch, Handler<AsyncResult<T>> handler);\n+\n+  /**\n+   * Like {@link #batch(List, Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<T> batch(List<Tuple> batch);\n+\n+  /**\n+   * Use the specified {@code collector} for collecting the query result to {@code <R>}.\n+   */\n+  @GenIgnore\n+  <R> Query<SqlResult<R>> collecting(Collector<Row, ?, R> collector);\n+\n+  /**\n+   * Use the specified {@code mapper} for mapping {@link Row} to {@code <U>}.\n+   */\n+  <U> Query<RowSet<U>> mapping(Function<Row, U> mapper);\n+\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwNTQzOA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397305438", "body": "I like the statement / query / {collector}? / execution API flow.", "bodyText": "I like the statement / query / {collector}? / execution API flow.", "bodyHTML": "<p dir=\"auto\">I like the statement / query / {collector}? / execution API flow.</p>", "author": "jponge", "createdAt": "2020-03-24T16:47:53Z", "path": "vertx-db2-client/src/main/java/examples/SqlClientExamples.java", "diffHunk": "@@ -151,8 +151,8 @@ public void usingConnections01(Vertx vertx, Pool pool) {\n   public void usingConnections02(SqlConnection connection) {\n     connection.prepare(\"SELECT * FROM users WHERE first_name LIKE $1\", ar1 -> {\n       if (ar1.succeeded()) {\n-        PreparedQuery pq = ar1.result();\n-        pq.execute(Tuple.of(\"andy\"), ar2 -> {\n+        PreparedStatement pq = ar1.result();\n+        pq.query().execute(Tuple.of(\"andy\"), ar2 -> {", "originalCommit": "883f92d3351935788df1a89fc3f832179732a90c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34cf9bdfd455b2c4fe4ed478249f328e5b14f06f", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex b84f6773..1074e86b 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -151,8 +151,8 @@ public class SqlClientExamples {\n   public void usingConnections02(SqlConnection connection) {\n     connection.prepare(\"SELECT * FROM users WHERE first_name LIKE $1\", ar1 -> {\n       if (ar1.succeeded()) {\n-        PreparedStatement pq = ar1.result();\n-        pq.query().execute(Tuple.of(\"andy\"), ar2 -> {\n+        PreparedQuery<RowSet<Row>> pq = ar1.result();\n+        pq.execute(Tuple.of(\"andy\"), ar2 -> {\n           if (ar2.succeeded()) {\n             // All rows\n             RowSet<Row> rows = ar2.result();\n", "next_change": {"commit": "8c25be37883e3c268b7fa8c93072125aee03dc38", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex 1074e86b..fa4b3a51 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -151,7 +151,7 @@ public class SqlClientExamples {\n   public void usingConnections02(SqlConnection connection) {\n     connection.prepare(\"SELECT * FROM users WHERE first_name LIKE $1\", ar1 -> {\n       if (ar1.succeeded()) {\n-        PreparedQuery<RowSet<Row>> pq = ar1.result();\n+        PreparedStatement<RowSet<Row>> pq = ar1.result();\n         pq.execute(Tuple.of(\"andy\"), ar2 -> {\n           if (ar2.succeeded()) {\n             // All rows\n", "next_change": {"commit": "121bb8ea16362e91eeb93460076c7861b48aed59", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex fa4b3a51..b84f6773 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -151,8 +151,8 @@ public class SqlClientExamples {\n   public void usingConnections02(SqlConnection connection) {\n     connection.prepare(\"SELECT * FROM users WHERE first_name LIKE $1\", ar1 -> {\n       if (ar1.succeeded()) {\n-        PreparedStatement<RowSet<Row>> pq = ar1.result();\n-        pq.execute(Tuple.of(\"andy\"), ar2 -> {\n+        PreparedStatement pq = ar1.result();\n+        pq.query().execute(Tuple.of(\"andy\"), ar2 -> {\n           if (ar2.succeeded()) {\n             // All rows\n             RowSet<Row> rows = ar2.result();\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "f8755dc812191130cea8a1b3558957806386ba1e", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex b84f6773..83793ce3 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -121,174 +133,167 @@ public class SqlClientExamples {\n     });\n   }\n \n-  public void queries09(Vertx vertx, SqlConnectOptions connectOptions, PoolOptions poolOptions) {\n+  public void queries09(SqlClient client, SqlConnectOptions connectOptions) {\n \n     // Enable prepare statements caching\n     connectOptions.setCachePreparedStatements(true);\n+    client\n+      .preparedQuery(\"SELECT * FROM users WHERE id = ?\")\n+      .execute(Tuple.of(\"julien\"), ar -> {\n+        if (ar.succeeded()) {\n+          RowSet<Row> rows = ar.result();\n+          System.out.println(\"Got \" + rows.size() + \" rows \");\n+        } else {\n+          System.out.println(\"Failure: \" + ar.cause().getMessage());\n+        }\n+      });\n   }\n \n-  public void usingConnections01(Vertx vertx, Pool pool) {\n+  public void queries10(SqlConnection sqlConnection) {\n+    sqlConnection\n+      .prepare(\"SELECT * FROM users WHERE id= ?\", ar -> {\n+        if (ar.succeeded()) {\n+          PreparedStatement preparedStatement = ar.result();\n+          preparedStatement.query()\n+            .execute(Tuple.of(\"julien\"), ar2 -> {\n+              if (ar2.succeeded()) {\n+                RowSet<Row> rows = ar2.result();\n+                System.out.println(\"Got \" + rows.size() + \" rows \");\n+                preparedStatement.close();\n+              } else {\n+                System.out.println(\"Failure: \" + ar2.cause().getMessage());\n+              }\n+            });\n+        } else {\n+          System.out.println(\"Failure: \" + ar.cause().getMessage());\n+        }\n+      });\n+  }\n \n-    pool.getConnection(ar1 -> {\n-      if (ar1.succeeded()) {\n-        SqlConnection connection = ar1.result();\n+  public void usingConnections01(Vertx vertx, Pool pool) {\n \n-        connection.query(\"SELECT * FROM users WHERE id='andy'\", ar2 -> {\n-          if (ar1.succeeded()) {\n-            connection.query(\"SELECT * FROM users WHERE id='julien'\", ar3 -> {\n-              // Do something with rows and return the connection to the pool\n-              connection.close();\n-            });\n-          } else {\n-            // Return the connection to the pool\n-            connection.close();\n-          }\n-        });\n-      }\n+    pool\n+      .getConnection()\n+      .compose(connection ->\n+        connection\n+          .preparedQuery(\"INSERT INTO Users (first_name,last_name) VALUES (?, ?)\")\n+          .executeBatch(Arrays.asList(\n+            Tuple.of(\"Julien\", \"Viet\"),\n+            Tuple.of(\"Andy\", \"Guibert\")\n+          ))\n+          .compose(res -> connection\n+            // Do something with rows\n+            .query(\"SELECT COUNT(*) FROM Users\")\n+            .execute()\n+            .map(rows -> rows.iterator().next().getInteger(0)))\n+          // Return the connection to the pool\n+          .eventually(v -> connection.close())\n+      ).onSuccess(count -> {\n+      System.out.println(\"Insert users, now the number of users is \" + count);\n     });\n   }\n \n   public void usingConnections02(SqlConnection connection) {\n-    connection.prepare(\"SELECT * FROM users WHERE first_name LIKE $1\", ar1 -> {\n-      if (ar1.succeeded()) {\n-        PreparedStatement pq = ar1.result();\n-        pq.query().execute(Tuple.of(\"andy\"), ar2 -> {\n-          if (ar2.succeeded()) {\n-            // All rows\n-            RowSet<Row> rows = ar2.result();\n-          }\n-        });\n-      }\n+    connection\n+      .prepare(\"SELECT * FROM users WHERE first_name LIKE $1\")\n+      .compose(pq ->\n+        pq.query()\n+          .execute(Tuple.of(\"Andy\"))\n+          .eventually(v -> pq.close())\n+      ).onSuccess(rows -> {\n+      // All rows\n     });\n   }\n \n-  public void usingConnections03(SqlConnection connection) {\n-    connection.prepare(\"INSERT INTO USERS (id, name) VALUES ($1, $2)\", ar1 -> {\n-      if (ar1.succeeded()) {\n-        PreparedStatement prepared = ar1.result();\n-\n-        // Create a query : bind parameters\n-        List<Tuple> batch = new ArrayList();\n-\n-        // Add commands to the createBatch\n-        batch.add(Tuple.of(\"julien\", \"Julien Viet\"));\n-        batch.add(Tuple.of(\"emad\", \"Emad Alblueshi\"));\n-        batch.add(Tuple.of(\"andy\", \"Andy Guibert\"));\n-\n-        prepared.query().batch(batch, res -> {\n-          if (res.succeeded()) {\n-\n-            // Process rows\n-            RowSet<Row> rows = res.result();\n-          } else {\n-            System.out.println(\"Batch failed \" + res.cause());\n-          }\n-        });\n-      }\n+  public void usingConnections03(Pool pool) {\n+    pool.withConnection(connection ->\n+      connection\n+        .preparedQuery(\"INSERT INTO Users (first_name,last_name) VALUES (?, ?)\")\n+        .executeBatch(Arrays.asList(\n+          Tuple.of(\"Julien\", \"Viet\"),\n+          Tuple.of(\"Andy\", \"Guibert\")\n+        ))\n+        .compose(res -> connection\n+          // Do something with rows\n+          .query(\"SELECT COUNT(*) FROM Users\")\n+          .execute()\n+          .map(rows -> rows.iterator().next().getInteger(0)))\n+    ).onSuccess(count -> {\n+      System.out.println(\"Insert users, now the number of users is \" + count);\n     });\n   }\n \n   public void transaction01(Pool pool) {\n-    pool.getConnection(res -> {\n-      if (res.succeeded()) {\n-\n-        // Transaction must use a connection\n-        SqlConnection conn = res.result();\n-\n+    pool.getConnection()\n+      // Transaction must use a connection\n+      .onSuccess(conn -> {\n         // Begin the transaction\n-        Transaction tx = conn.begin();\n-\n-        // Various statements\n-        conn.query(\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\", ar1 -> {\n-          if (ar1.succeeded()) {\n-            conn.query(\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\", ar2 -> {\n-              if (ar2.succeeded()) {\n-                // Commit the transaction\n-                tx.commit(ar3 -> {\n-                  if (ar3.succeeded()) {\n-                    System.out.println(\"Transaction succeeded\");\n-                  } else {\n-                    System.out.println(\"Transaction failed \" + ar3.cause().getMessage());\n-                  }\n-                  // Return the connection to the pool\n-                  conn.close();\n-                });\n-              } else {\n-                // Return the connection to the pool\n-                conn.close();\n-              }\n-            });\n-          } else {\n-            // Return the connection to the pool\n-            conn.close();\n-          }\n-        });\n-      }\n-    });\n+        conn.begin()\n+          .compose(tx -> conn\n+            // Various statements\n+            .query(\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\")\n+            .execute()\n+            .compose(res2 -> conn\n+              .query(\"INSERT INTO Users (first_name,last_name) VALUES ('Andy','Guibert')\")\n+              .execute())\n+            // Commit the transaction\n+            .compose(res3 -> tx.commit()))\n+          // Return the connection to the pool\n+          .eventually(v -> conn.close())\n+          .onSuccess(v -> System.out.println(\"Transaction succeeded\"))\n+          .onFailure(err -> System.out.println(\"Transaction failed: \" + err.getMessage()));\n+      });\n   }\n \n   public void transaction02(Transaction tx) {\n-    tx.abortHandler(v -> {\n-      System.out.println(\"Transaction failed => rollbacked\");\n-    });\n+    tx.completion()\n+      .onFailure(err -> {\n+        System.out.println(\"Transaction failed => rolled back\");\n+      });\n   }\n \n   public void transaction03(Pool pool) {\n \n     // Acquire a transaction and begin the transaction\n-    pool.begin(res -> {\n-      if (res.succeeded()) {\n-\n-        // Get the transaction\n-        Transaction tx = res.result();\n-\n-        // Various statements\n-        tx.query(\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\", ar1 -> {\n-          if (ar1.succeeded()) {\n-            tx.query(\"INSERT INTO Users (first_name,last_name) VALUES ('Emad','Alblueshi')\", ar2 -> {\n-              if (ar2.succeeded()) {\n-                // Commit the transaction\n-                // the connection will automatically return to the pool\n-                tx.commit(ar3 -> {\n-                  if (ar3.succeeded()) {\n-                    System.out.println(\"Transaction succeeded\");\n-                  } else {\n-                    System.out.println(\"Transaction failed \" + ar3.cause().getMessage());\n-                  }\n-                });\n-              }\n-            });\n-          } else {\n-            // No need to close connection as transaction will abort and be returned to the pool\n-          }\n-        });\n-      }\n-    });\n+    pool.withTransaction(client -> client\n+      .query(\"INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')\")\n+      .execute()\n+      .flatMap(res -> client\n+        .query(\"INSERT INTO Users (first_name,last_name) VALUES ('Andy','Guibert')\")\n+        .execute()\n+        // Map to a message result\n+        .map(\"Users inserted\")))\n+      .onSuccess(v -> System.out.println(\"Transaction succeeded\"))\n+      .onFailure(err -> System.out.println(\"Transaction failed: \" + err.getMessage()));\n   }\n \n   public void usingCursors01(SqlConnection connection) {\n-    connection.prepare(\"SELECT * FROM users WHERE first_name LIKE $1\", ar1 -> {\n-      if (ar1.succeeded()) {\n-        PreparedStatement pq = ar1.result();\n+    connection.prepare(\"SELECT * FROM users WHERE first_name LIKE $1\", ar0 -> {\n+      if (ar0.succeeded()) {\n+        PreparedStatement pq = ar0.result();\n \n         // Cursors require to run within a transaction\n-        Transaction tx = connection.begin();\n-\n-        // Create a cursor\n-        Cursor cursor = pq.cursor(Tuple.of(\"julien\"));\n+        connection.begin(ar1 -> {\n+          if (ar1.succeeded()) {\n+            Transaction tx = ar1.result();\n \n-        // Read 50 rows\n-        cursor.read(50, ar2 -> {\n-          if (ar2.succeeded()) {\n-            RowSet<Row> rows = ar2.result();\n+            // Create a cursor\n+            Cursor cursor = pq.cursor(Tuple.of(\"julien\"));\n \n-            // Check for more ?\n-            if (cursor.hasMore()) {\n-              // Repeat the process...\n-            } else {\n-              // No more rows - commit the transaction\n-              tx.commit();\n-            }\n+            // Read 50 rows\n+            cursor.read(50, ar2 -> {\n+              if (ar2.succeeded()) {\n+                RowSet<Row> rows = ar2.result();\n+\n+                // Check for more ?\n+                if (cursor.hasMore()) {\n+                  // Repeat the process...\n+                } else {\n+                  // No more rows - commit the transaction\n+                  tx.commit();\n+                }\n+              }\n+            });\n           }\n         });\n       }\n", "next_change": {"commit": "dcef9e6499cb325519208d5fddb4f498fc27b8c7", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex 83793ce3..fe9e08cf 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -301,7 +319,9 @@ public class SqlClientExamples {\n   }\n \n   public void usingCursors02(Cursor cursor) {\n-    cursor.read(50, ar2 -> {\n+    cursor\n+      .read(50)\n+      .onComplete(ar2 -> {\n       if (ar2.succeeded()) {\n         // Close the cursor\n         cursor.close();\n", "next_change": {"commit": "6577aabd0b5f2f6707789d901ebb783e6dd65a42", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex fe9e08cf..14864547 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -319,9 +305,7 @@ public class SqlClientExamples {\n   }\n \n   public void usingCursors02(Cursor cursor) {\n-    cursor\n-      .read(50)\n-      .onComplete(ar2 -> {\n+    cursor.read(50, ar2 -> {\n       if (ar2.succeeded()) {\n         // Close the cursor\n         cursor.close();\n", "next_change": {"commit": "0934c803c0d283899589bca029b326ba42311554", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex 14864547..fe9e08cf 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -305,7 +319,9 @@ public class SqlClientExamples {\n   }\n \n   public void usingCursors02(Cursor cursor) {\n-    cursor.read(50, ar2 -> {\n+    cursor\n+      .read(50)\n+      .onComplete(ar2 -> {\n       if (ar2.succeeded()) {\n         // Close the cursor\n         cursor.close();\n", "next_change": null}, {"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex 14864547..fe9e08cf 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -314,12 +330,16 @@ public class SqlClientExamples {\n   }\n \n   public void usingCursors03(SqlConnection connection) {\n-    connection.prepare(\"SELECT * FROM users WHERE first_name LIKE ?\", ar0 -> {\n+    connection\n+      .prepare(\"SELECT * FROM users WHERE first_name LIKE ?\")\n+      .onComplete(ar0 -> {\n       if (ar0.succeeded()) {\n         PreparedStatement pq = ar0.result();\n \n         // Streams require to run within a transaction\n-        connection.begin(ar1 -> {\n+        connection\n+          .begin()\n+          .onComplete(ar1 -> {\n           if (ar1.succeeded()) {\n             Transaction tx = ar1.result();\n \n", "next_change": null}]}}, {"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex fe9e08cf..14864547 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -330,16 +314,12 @@ public class SqlClientExamples {\n   }\n \n   public void usingCursors03(SqlConnection connection) {\n-    connection\n-      .prepare(\"SELECT * FROM users WHERE first_name LIKE ?\")\n-      .onComplete(ar0 -> {\n+    connection.prepare(\"SELECT * FROM users WHERE first_name LIKE ?\", ar0 -> {\n       if (ar0.succeeded()) {\n         PreparedStatement pq = ar0.result();\n \n         // Streams require to run within a transaction\n-        connection\n-          .begin()\n-          .onComplete(ar1 -> {\n+        connection.begin(ar1 -> {\n           if (ar1.succeeded()) {\n             Transaction tx = ar1.result();\n \n", "next_change": {"commit": "0934c803c0d283899589bca029b326ba42311554", "changed_code": [{"header": "diff --git a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\nindex 14864547..fe9e08cf 100644\n--- a/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n+++ b/vertx-db2-client/src/main/java/examples/SqlClientExamples.java\n", "chunk": "@@ -314,12 +330,16 @@ public class SqlClientExamples {\n   }\n \n   public void usingCursors03(SqlConnection connection) {\n-    connection.prepare(\"SELECT * FROM users WHERE first_name LIKE ?\", ar0 -> {\n+    connection\n+      .prepare(\"SELECT * FROM users WHERE first_name LIKE ?\")\n+      .onComplete(ar0 -> {\n       if (ar0.succeeded()) {\n         PreparedStatement pq = ar0.result();\n \n         // Streams require to run within a transaction\n-        connection.begin(ar1 -> {\n+        connection\n+          .begin()\n+          .onComplete(ar1 -> {\n           if (ar1.succeeded()) {\n             Transaction tx = ar1.result();\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "68469731cdd522bc963799e548ddd45bd18c62c6", "message": "Merge commit", "committedDate": null}, {"oid": "b170bdc05859ced53d1eb02a2a629e8053fe72db", "committedDate": "2020-04-11 09:11:59 +0200", "message": "Simplified transaction API improvements (#574)"}, {"oid": "e53235cbe2bc2fd96aabe35350ab05ba840b164f", "committedDate": "2020-04-22 21:34:11 +0800", "message": "Prepared statement created by SqlConnection#prepare should not be cached  (#578)"}, {"oid": "ce85ec3396a721b82a0f477cd82b14857facda05", "committedDate": "2020-05-12 10:41:49 -0500", "message": "Apply source formatting for DB2 module"}, {"oid": "c869c319a523f18df092326c51f90d9620b7cb72", "committedDate": "2020-09-25 14:33:20 +0200", "message": "Change Pool.withTransaction to provide an SqlConnection in order to allow prepared queries and stream possible. Added withConnection that is similar but does not demarcate a transaction"}, {"oid": "e70cad7e106d7bc95769c7d45fe98217bef578d1", "committedDate": "2020-10-30 15:53:27 +0100", "message": "Tracing documentation"}, {"oid": "f8755dc812191130cea8a1b3558957806386ba1e", "committedDate": "2020-12-11 22:29:00 +0100", "message": "Improve examples using future composition"}, {"oid": "abd48edd49699934c1fed7ab98d5489bb69ac5f8", "committedDate": "2021-06-22 17:53:12 +0200", "message": "Documentation"}, {"oid": "ae93de11e1c346358657801fad0b408274a0bd77", "committedDate": "2021-06-23 16:10:41 +0200", "message": "Make the server provider async"}, {"oid": "f8d03eb92ca2a32f586680b4a281e0ea300dc4ab", "committedDate": "2021-06-24 15:16:31 +0200", "message": "Rewrite the API differently"}, {"oid": "a439953b4fa8941308b572a251fc60fee6852763", "committedDate": "2021-12-08 12:06:39 +0100", "message": "Implement reference counted pools - fixes #1094"}, {"oid": "27f8a745e8a487137356c512fff45997298cfe16", "committedDate": "2021-12-08 12:07:13 +0100", "message": "A pool can declare a number of event loop to use instead of using borrower's event loop - fixes #1095"}, {"oid": "76c6083ebce9670c55c5b91fa006bbb4bf5dcf8c", "committedDate": "2023-02-03 17:14:16 +0100", "message": "DB2 Client documentation uses wrong parameter placeholder"}, {"oid": "dcef9e6499cb325519208d5fddb4f498fc27b8c7", "committedDate": "2023-03-12 22:33:20 +0100", "message": "Remove callback usage from examples"}, {"oid": "6577aabd0b5f2f6707789d901ebb783e6dd65a42", "committedDate": "2023-03-13 12:56:43 +0100", "message": "Revert \"Remove callback usage from examples\""}, {"oid": "0934c803c0d283899589bca029b326ba42311554", "committedDate": "2023-03-13 13:08:23 +0100", "message": "Remove callback usage from examples"}]}, {"oid": "9c618a9af5765d8030963c937a939e9081328f13", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/9c618a9af5765d8030963c937a939e9081328f13", "message": "Rename createQuery -> query, createPreparedQuery -> preparedQuery, batch -> executeBatch", "committedDate": "2020-03-24T23:18:27Z", "type": "forcePushed"}, {"oid": "34cf9bdfd455b2c4fe4ed478249f328e5b14f06f", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/34cf9bdfd455b2c4fe4ed478249f328e5b14f06f", "message": "Rework PreparedQuery to carry a generic result and collector queries are now PreparedQuery mutators", "committedDate": "2020-03-25T07:45:49Z", "type": "commit"}, {"oid": "ab2c13580ac596b3e4bbcd2cc950c651f40d8be4", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/ab2c13580ac596b3e4bbcd2cc950c651f40d8be4", "message": "Add fluent queries for the SqlClient interface", "committedDate": "2020-03-25T07:45:49Z", "type": "commit"}, {"oid": "8c25be37883e3c268b7fa8c93072125aee03dc38", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/8c25be37883e3c268b7fa8c93072125aee03dc38", "message": "Rename PreparedQuery -> PreparedStatement", "committedDate": "2020-03-25T07:45:49Z", "type": "commit"}, {"oid": "121bb8ea16362e91eeb93460076c7861b48aed59", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/121bb8ea16362e91eeb93460076c7861b48aed59", "message": "PreparedStatement won't execute anymore, instead the new query() method returns a Query for execution or batching", "committedDate": "2020-03-25T07:45:49Z", "type": "commit"}, {"oid": "a0afbc43cd9f77b3cb5742dbac7a224adbaa0cb5", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/a0afbc43cd9f77b3cb5742dbac7a224adbaa0cb5", "message": "Introduce PreparedQuery extending Query for the tuple defining executing methods", "committedDate": "2020-03-25T07:45:49Z", "type": "commit"}, {"oid": "71789de0412a13aaab4d0d2d5070c933025c5df5", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/71789de0412a13aaab4d0d2d5070c933025c5df5", "message": "Rename createQuery -> query, createPreparedQuery -> preparedQuery, batch -> executeBatch", "committedDate": "2020-03-25T07:46:37Z", "type": "commit"}, {"oid": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/65b900c22b2823ca867442d7c8fb41b54e4ed82d", "message": "Complete javadoc", "committedDate": "2020-03-25T07:46:37Z", "type": "commit"}, {"oid": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/65b900c22b2823ca867442d7c8fb41b54e4ed82d", "message": "Complete javadoc", "committedDate": "2020-03-25T07:46:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyMzI5NA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397823294", "body": "we could add null check for these methods", "bodyText": "we could add null check for these methods", "bodyHTML": "<p dir=\"auto\">we could add null check for these methods</p>", "author": "BillyYccc", "createdAt": "2020-03-25T12:42:32Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryBase.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (C) 2017 Julien Viet\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.vertx.sqlclient.impl;\n+\n+import io.vertx.sqlclient.Query;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlResult;\n+\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+abstract class QueryBase<T, R extends SqlResult<T>> implements Query<R> {\n+\n+  protected final SqlResultBuilder<T, ?, R> builder;\n+\n+  public QueryBase(SqlResultBuilder<T, ?, R> builder) {\n+    this.builder = builder;\n+  }\n+\n+  protected abstract <T2, R2  extends SqlResult<T2>> QueryBase<T2, R2> copy(SqlResultBuilder<T2, ?, R2> builder);\n+\n+  @Override\n+  public <U> Query<SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return copy(new SqlResultBuilder<>(SqlResultImpl::new, collector));\n+  }\n+\n+  @Override\n+  public <U> Query<RowSet<U>> mapping(Function<Row, U> mapper) {\n+    return copy(new SqlResultBuilder<>(RowSetImpl.factory(), RowSetImpl.collector(mapper)));\n+  }", "originalCommit": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "320c94e1fdbf8d32ab366cd947a19a127b024bf3", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryBase.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryBase.java\nindex d61623bb..7575e261 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryBase.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/QueryBase.java\n", "chunk": "@@ -40,11 +41,13 @@ abstract class QueryBase<T, R extends SqlResult<T>> implements Query<R> {\n \n   @Override\n   public <U> Query<SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    Objects.requireNonNull(collector, \"Supplied collector must not be null\");\n     return copy(new SqlResultBuilder<>(SqlResultImpl::new, collector));\n   }\n \n   @Override\n   public <U> Query<RowSet<U>> mapping(Function<Row, U> mapper) {\n+    Objects.requireNonNull(mapper, \"Supplied mapper must not be null\");\n     return copy(new SqlResultBuilder<>(RowSetImpl.factory(), RowSetImpl.collector(mapper)));\n   }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNDM1NA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397824354", "body": "this method could be removed", "bodyText": "this method could be removed", "bodyHTML": "<p dir=\"auto\">this method could be removed</p>", "author": "BillyYccc", "createdAt": "2020-03-25T12:44:28Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java", "diffHunk": "@@ -175,7 +61,7 @@ public C preparedBatch(String sql, List<Tuple> batch, Handler<AsyncResult<RowSet\n     Function<R1, R2> factory,\n     Collector<Row, ?, R1> collector,\n     Promise<R3> handler) {", "originalCommit": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "320c94e1fdbf8d32ab366cd947a19a127b024bf3", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java\nindex d36344a4..49f60ce5 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java\n", "chunk": "@@ -55,31 +55,6 @@ public abstract class SqlClientBase<C extends SqlClient> implements SqlClient, C\n     return new PreparedQueryImpl<>(autoCommit(), false, sql, builder);\n   }\n \n-  private <R1, R2 extends SqlResultBase<R1>, R3 extends SqlResult<R1>> C preparedBatch(\n-    String sql,\n-    List<Tuple> batch,\n-    Function<R1, R2> factory,\n-    Collector<Row, ?, R1> collector,\n-    Promise<R3> handler) {\n-    SqlResultHandler<R1, R2, R3> builder = new SqlResultHandler<>(factory, handler);\n-    BiCommand<PreparedStatement, Boolean> abc = new BiCommand<>(new PrepareStatementCommand(sql), ps -> {\n-      for  (Tuple args : batch) {\n-        String msg = ps.prepare((TupleInternal) args);\n-        if (msg != null) {\n-          return Future.failedFuture(msg);\n-        }\n-      }\n-      return Future.succeededFuture(new ExtendedBatchQueryCommand<>(\n-        ps,\n-        batch,\n-        autoCommit(),\n-        collector,\n-        builder));\n-    });\n-    schedule(abc, builder);\n-    return (C) this;\n-  }\n-\n   boolean autoCommit() {\n     return true;\n   }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNjI1MA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397826250", "body": "useless import", "bodyText": "useless import", "bodyHTML": "<p dir=\"auto\">useless import</p>", "author": "BillyYccc", "createdAt": "2020-03-25T12:47:44Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java", "diffHunk": "@@ -17,15 +17,9 @@\n \n package io.vertx.sqlclient;\n \n-import io.vertx.codegen.annotations.Fluent;\n-import io.vertx.codegen.annotations.GenIgnore;\n import io.vertx.codegen.annotations.VertxGen;\n-import io.vertx.core.AsyncResult;\n-import io.vertx.core.Future;\n-import io.vertx.core.Handler;\n \n import java.util.List;", "originalCommit": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "320c94e1fdbf8d32ab366cd947a19a127b024bf3", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\nindex 931f98f8..11d3d711 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n", "chunk": "@@ -19,8 +19,6 @@ package io.vertx.sqlclient;\n \n import io.vertx.codegen.annotations.VertxGen;\n \n-import java.util.List;\n-\n /**\n  * Defines common SQL client operations with a database server.\n  *\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNjQ0OQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397826449", "body": "duplicated documentation", "bodyText": "duplicated documentation", "bodyHTML": "<p dir=\"auto\">duplicated documentation</p>", "author": "BillyYccc", "createdAt": "2020-03-25T12:48:05Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java", "diffHunk": "@@ -36,136 +30,21 @@\n public interface SqlClient {\n \n   /**\n-   * Execute a simple query using the given {@code sql} string, the asynchronous result is represented as a {@link RowSet}.\n+   * Create a query, the {@link Query#execute} method must be called to execute the query.\n    *\n-   * @param sql the query SQL\n-   * @param handler the handler notified with the execution result\n-   * @return a reference to this, so the API can be used fluently\n-   */\n-  @Fluent\n-  SqlClient query(String sql, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * Like {@link #query(String, Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  Future<RowSet<Row>> query(String sql);\n-\n-  /**\n-   * Execute a simple query using the given {@code sql} string, the asynchronous result is represented as a collection of elements transformed by the provided {@link java.util.stream.Collector}.\n-   *\n-   * @param sql the query SQL\n-   * @param collector the collector\n-   * @param handler the handler notified with the execution result\n-   * @return a reference to this, so the API can be used fluently\n-   */\n-  @GenIgnore\n-  <R> SqlClient query(String sql, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n-\n-  /**\n-   * Like {@link #query(String, Collector, Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  @GenIgnore\n-  <R> Future<SqlResult<R>> query(String sql, Collector<Row, ?, R> collector);\n-\n-  /**\n-   * Execute the given {@code sql} string using a prepared statement without any parameter, the asynchronous result is represented as a {@link RowSet}.\n-   *\n-   * @param sql the prepared query SQL\n-   * @param handler the handler notified with the execution result\n-   * @return a reference to this, so the API can be used fluently\n-   */\n-  @Fluent\n-  SqlClient preparedQuery(String sql, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * Like {@link #preparedQuery(String, Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  Future<RowSet<Row>> preparedQuery(String sql);\n-\n-  /**\n-   * Execute the given {@code sql} string using a prepared statement without any parameter, the asynchronous result is represented as a collection of elements transformed by the provided {@link java.util.stream.Collector}.\n+   * Create a query.", "originalCommit": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "320c94e1fdbf8d32ab366cd947a19a127b024bf3", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\nindex 931f98f8..11d3d711 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n", "chunk": "@@ -32,14 +30,12 @@ public interface SqlClient {\n   /**\n    * Create a query, the {@link Query#execute} method must be called to execute the query.\n    *\n-   * Create a query.\n-   *\n    * @return the query\n    */\n   Query<RowSet<Row>> query(String sql);\n \n   /**\n-   * Create a prepared query, one of the {@link PreparedQuery#execute}, {@link PreparedQuery#executeBatch}\n+   * Create a prepared query, one of the {@link PreparedQuery#execute} or {@link PreparedQuery#executeBatch}\n    * methods must be called to execute the query.\n    *\n    * @return the prepared query\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNzgxMA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397827810", "body": "the created object is actually not a **prepared** query, how about writing as \r\n> Create a prepared query request, ...", "bodyText": "the created object is actually not a prepared query, how about writing as\n\nCreate a prepared query request, ...", "bodyHTML": "<p dir=\"auto\">the created object is actually not a <strong>prepared</strong> query, how about writing as</p>\n<blockquote>\n<p dir=\"auto\">Create a prepared query request, ...</p>\n</blockquote>", "author": "BillyYccc", "createdAt": "2020-03-25T12:50:28Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java", "diffHunk": "@@ -36,136 +30,21 @@\n public interface SqlClient {\n \n   /**\n-   * Execute a simple query using the given {@code sql} string, the asynchronous result is represented as a {@link RowSet}.\n+   * Create a query, the {@link Query#execute} method must be called to execute the query.\n    *\n-   * @param sql the query SQL\n-   * @param handler the handler notified with the execution result\n-   * @return a reference to this, so the API can be used fluently\n-   */\n-  @Fluent\n-  SqlClient query(String sql, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * Like {@link #query(String, Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  Future<RowSet<Row>> query(String sql);\n-\n-  /**\n-   * Execute a simple query using the given {@code sql} string, the asynchronous result is represented as a collection of elements transformed by the provided {@link java.util.stream.Collector}.\n-   *\n-   * @param sql the query SQL\n-   * @param collector the collector\n-   * @param handler the handler notified with the execution result\n-   * @return a reference to this, so the API can be used fluently\n-   */\n-  @GenIgnore\n-  <R> SqlClient query(String sql, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n-\n-  /**\n-   * Like {@link #query(String, Collector, Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  @GenIgnore\n-  <R> Future<SqlResult<R>> query(String sql, Collector<Row, ?, R> collector);\n-\n-  /**\n-   * Execute the given {@code sql} string using a prepared statement without any parameter, the asynchronous result is represented as a {@link RowSet}.\n-   *\n-   * @param sql the prepared query SQL\n-   * @param handler the handler notified with the execution result\n-   * @return a reference to this, so the API can be used fluently\n-   */\n-  @Fluent\n-  SqlClient preparedQuery(String sql, Handler<AsyncResult<RowSet<Row>>> handler);\n-\n-  /**\n-   * Like {@link #preparedQuery(String, Handler)} but returns a {@code Future} of the asynchronous result\n-   */\n-  Future<RowSet<Row>> preparedQuery(String sql);\n-\n-  /**\n-   * Execute the given {@code sql} string using a prepared statement without any parameter, the asynchronous result is represented as a collection of elements transformed by the provided {@link java.util.stream.Collector}.\n+   * Create a query.\n    *\n-   * @param sql the prepared query SQL\n-   * @param collector the collector\n-   * @param handler the handler notified with the execution result\n-   * @return a reference to this, so the API can be used fluently\n-   */\n-  @GenIgnore\n-  <R> SqlClient preparedQuery(String sql, Collector<Row, ?, R> collector, Handler<AsyncResult<SqlResult<R>>> handler);\n-\n-  /**\n-   * Like {@link #preparedQuery(String, Collector, Handler)} but returns a {@code Future} of the asynchronous result\n+   * @return the query\n    */\n-  @GenIgnore\n-  <R> Future<SqlResult<R>> preparedQuery(String sql, Collector<Row, ?, R> collector);\n+  Query<RowSet<Row>> query(String sql);\n \n   /**\n-   * Execute the given {@code sql} string using a prepared statement with parameters set in the {@code Tuple}, the asynchronous result is represented as a {@link RowSet}.\n+   * Create a prepared query, one of the {@link PreparedQuery#execute}, {@link PreparedQuery#executeBatch}", "originalCommit": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgzOTY3NQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397839675", "bodyText": "I'm not sure to understand here", "author": "vietj", "createdAt": "2020-03-25T13:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNzgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg1MjE2OQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397852169", "bodyText": "I mean we could clarify in the documentation that this created PreparedQuery object is not prepared indeed and is only a request handle for one-shot executing a prepared query.", "author": "BillyYccc", "createdAt": "2020-03-25T13:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNzgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg1NTEyOQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397855129", "bodyText": "I think it does not matter because it is the same from the user perspective as he will get a single callback that encompass both query validation and query execution which is what makes the difference and the doc says that execute must be called to execute the query", "author": "vietj", "createdAt": "2020-03-25T13:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNzgxMA=="}], "type": "inlineReview", "revised_code": {"commit": "320c94e1fdbf8d32ab366cd947a19a127b024bf3", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\nindex 931f98f8..11d3d711 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n", "chunk": "@@ -32,14 +30,12 @@ public interface SqlClient {\n   /**\n    * Create a query, the {@link Query#execute} method must be called to execute the query.\n    *\n-   * Create a query.\n-   *\n    * @return the query\n    */\n   Query<RowSet<Row>> query(String sql);\n \n   /**\n-   * Create a prepared query, one of the {@link PreparedQuery#execute}, {@link PreparedQuery#executeBatch}\n+   * Create a prepared query, one of the {@link PreparedQuery#execute} or {@link PreparedQuery#executeBatch}\n    * methods must be called to execute the query.\n    *\n    * @return the prepared query\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyODAwOQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397828009", "body": "how about writing as \r\n> Create a query request, ...", "bodyText": "how about writing as\n\nCreate a query request, ...", "bodyHTML": "<p dir=\"auto\">how about writing as</p>\n<blockquote>\n<p dir=\"auto\">Create a query request, ...</p>\n</blockquote>", "author": "BillyYccc", "createdAt": "2020-03-25T12:50:51Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java", "diffHunk": "@@ -36,136 +30,21 @@\n public interface SqlClient {\n \n   /**\n-   * Execute a simple query using the given {@code sql} string, the asynchronous result is represented as a {@link RowSet}.\n+   * Create a query, the {@link Query#execute} method must be called to execute the query.", "originalCommit": "65b900c22b2823ca867442d7c8fb41b54e4ed82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgzOTk1MA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/554#discussion_r397839950", "bodyText": "I don't understand", "author": "vietj", "createdAt": "2020-03-25T13:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyODAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "320c94e1fdbf8d32ab366cd947a19a127b024bf3", "changed_code": [{"header": "diff --git a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\nindex 931f98f8..11d3d711 100644\n--- a/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n+++ b/vertx-sql-client/src/main/java/io/vertx/sqlclient/SqlClient.java\n", "chunk": "@@ -32,14 +30,12 @@ public interface SqlClient {\n   /**\n    * Create a query, the {@link Query#execute} method must be called to execute the query.\n    *\n-   * Create a query.\n-   *\n    * @return the query\n    */\n   Query<RowSet<Row>> query(String sql);\n \n   /**\n-   * Create a prepared query, one of the {@link PreparedQuery#execute}, {@link PreparedQuery#executeBatch}\n+   * Create a prepared query, one of the {@link PreparedQuery#execute} or {@link PreparedQuery#executeBatch}\n    * methods must be called to execute the query.\n    *\n    * @return the prepared query\n", "next_change": null}]}}, {"oid": "8892007b532178f74ca202715c272c96c56ec48e", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/8892007b532178f74ca202715c272c96c56ec48e", "message": "Update breaking tests", "committedDate": "2020-03-25T12:58:31Z", "type": "commit"}, {"oid": "320c94e1fdbf8d32ab366cd947a19a127b024bf3", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/320c94e1fdbf8d32ab366cd947a19a127b024bf3", "message": "PR feedback (to backport)", "committedDate": "2020-03-25T13:10:51Z", "type": "commit"}]}