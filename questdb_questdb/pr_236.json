{"pr_number": 236, "pr_title": "feat(imports): add partitionBy and timestampIndex", "pr_author": "clickingbuttons", "pr_createdAt": "2020-04-26T19:41:55Z", "pr_url": "https://github.com/questdb/questdb/pull/236", "timeline": [{"oid": "5c64f6af101a7358558be7e8f4386b5d367bbb26", "url": "https://github.com/questdb/questdb/commit/5c64f6af101a7358558be7e8f4386b5d367bbb26", "message": "feat(import): add partitionBy and timestampIndex", "committedDate": "2020-04-26T20:25:32Z", "type": "commit"}, {"oid": "5c64f6af101a7358558be7e8f4386b5d367bbb26", "url": "https://github.com/questdb/questdb/commit/5c64f6af101a7358558be7e8f4386b5d367bbb26", "message": "feat(import): add partitionBy and timestampIndex", "committedDate": "2020-04-26T20:25:32Z", "type": "forcePushed"}, {"oid": "884dc1700f6999fde0f1d2096318c7bfbee89786", "url": "https://github.com/questdb/questdb/commit/884dc1700f6999fde0f1d2096318c7bfbee89786", "message": "prevent shooting self in foot", "committedDate": "2020-04-26T20:42:54Z", "type": "commit"}, {"oid": "a6623a51c7346c18068d9b23ef31167edb060e9c", "url": "https://github.com/questdb/questdb/commit/a6623a51c7346c18068d9b23ef31167edb060e9c", "message": "fix test snapshot", "committedDate": "2020-04-26T21:07:45Z", "type": "commit"}, {"oid": "bb9518708811394ba2067f5d783109b8a3d0419f", "url": "https://github.com/questdb/questdb/commit/bb9518708811394ba2067f5d783109b8a3d0419f", "message": "fix textloader tests", "committedDate": "2020-04-26T22:10:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzQ5Ng==", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416763496", "body": "the name & type check can be done here, here is example:\r\n\r\n```java\r\n        TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) throws TextException {\r\n            this.names = names;\r\n            this.types = types;\r\n            if (timestampIndexCol == null) {\r\n                timestampIndex = -1;\r\n            } else {\r\n                timestampIndex = names.indexOf(timestampIndexCol);\r\n                if (timestampIndex == -1) {\r\n                    throw TextException.$(\"invalid timestamp column '\").put(timestampIndexCol).put('\\'');\r\n                }\r\n                if (types.getQuick(timestampIndex).getType() != ColumnType.TIMESTAMP) {\r\n                    throw TextException.$(\"not a timestamp '\").put(timestampIndexCol).put('\\'');\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n```", "bodyText": "the name & type check can be done here, here is example:\n        TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) throws TextException {\n            this.names = names;\n            this.types = types;\n            if (timestampIndexCol == null) {\n                timestampIndex = -1;\n            } else {\n                timestampIndex = names.indexOf(timestampIndexCol);\n                if (timestampIndex == -1) {\n                    throw TextException.$(\"invalid timestamp column '\").put(timestampIndexCol).put('\\'');\n                }\n                if (types.getQuick(timestampIndex).getType() != ColumnType.TIMESTAMP) {\n                    throw TextException.$(\"not a timestamp '\").put(timestampIndexCol).put('\\'');\n                }\n            }\n            return this;\n        }", "bodyHTML": "<p dir=\"auto\">the name &amp; type check can be done here, here is example:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        TableStructureAdapter of(ObjList&lt;CharSequence&gt; names, ObjList&lt;TypeAdapter&gt; types) throws TextException {\n            this.names = names;\n            this.types = types;\n            if (timestampIndexCol == null) {\n                timestampIndex = -1;\n            } else {\n                timestampIndex = names.indexOf(timestampIndexCol);\n                if (timestampIndex == -1) {\n                    throw TextException.$(&quot;invalid timestamp column '&quot;).put(timestampIndexCol).put('\\'');\n                }\n                if (types.getQuick(timestampIndex).getType() != ColumnType.TIMESTAMP) {\n                    throw TextException.$(&quot;not a timestamp '&quot;).put(timestampIndexCol).put('\\'');\n                }\n            }\n            return this;\n        }\"><pre>        <span class=\"pl-smi\">TableStructureAdapter</span> of(<span class=\"pl-k\">ObjList&lt;<span class=\"pl-smi\">CharSequence</span>&gt;</span> names, <span class=\"pl-k\">ObjList&lt;<span class=\"pl-smi\">TypeAdapter</span>&gt;</span> types) throws <span class=\"pl-smi\">TextException</span> {\n            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>names <span class=\"pl-k\">=</span> names;\n            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>types <span class=\"pl-k\">=</span> types;\n            <span class=\"pl-k\">if</span> (timestampIndexCol <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {\n                timestampIndex <span class=\"pl-k\">=</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>;\n            } <span class=\"pl-k\">else</span> {\n                timestampIndex <span class=\"pl-k\">=</span> names<span class=\"pl-k\">.</span>indexOf(timestampIndexCol);\n                <span class=\"pl-k\">if</span> (timestampIndex <span class=\"pl-k\">==</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>) {\n                    <span class=\"pl-k\">throw</span> <span class=\"pl-smi\">TextException</span><span class=\"pl-k\">.</span>$(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>invalid timestamp column '<span class=\"pl-pds\">\"</span></span>)<span class=\"pl-k\">.</span>put(timestampIndexCol)<span class=\"pl-k\">.</span>put(<span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-cce\">\\'</span><span class=\"pl-pds\">'</span></span>);\n                }\n                <span class=\"pl-k\">if</span> (types<span class=\"pl-k\">.</span>getQuick(timestampIndex)<span class=\"pl-k\">.</span>getType() <span class=\"pl-k\">!=</span> <span class=\"pl-smi\">ColumnType</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>TIMESTAMP</span>) {\n                    <span class=\"pl-k\">throw</span> <span class=\"pl-smi\">TextException</span><span class=\"pl-k\">.</span>$(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>not a timestamp '<span class=\"pl-pds\">\"</span></span>)<span class=\"pl-k\">.</span>put(timestampIndexCol)<span class=\"pl-k\">.</span>put(<span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-cce\">\\'</span><span class=\"pl-pds\">'</span></span>);\n                }\n            }\n            <span class=\"pl-k\">return</span> <span class=\"pl-c1\">this</span>;\n        }</pre></div>", "author": "bluestreak01", "createdAt": "2020-04-28T16:42:27Z", "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "diffHunk": "@@ -320,14 +325,12 @@ public CharSequence getTableName() {\n         }\n \n         @Override\n-        public int getTimestampIndex() {\n-            // not yet on protocol\n-            return -1;\n-        }\n+        public int getTimestampIndex() { return timestampIndex; }\n \n         TableStructureAdapter of(ObjList<CharSequence> names, ObjList<TypeAdapter> types) {\n             this.names = names;\n             this.types = types;\n+            timestampIndex = names.indexOf(timestampIndexCol);", "originalCommit": "bb9518708811394ba2067f5d783109b8a3d0419f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2OTgzNQ==", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416769835", "bodyText": "Additionally at end of prepareTable we could get timestamp adapter only once:\ntimestampAdapter = (TimestampAdapter) types.getQuick(timestampIndex);\nAdditionally i would suggest two lambdas returning Row. One lambda will use timestamp index, the other will get row without timestamp. This will simplify onFields", "author": "bluestreak01", "createdAt": "2020-04-28T16:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTQ2NA==", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416971464", "bodyText": "I didn't even notice prepareTable existed. As for the lambdas, doing the try catch inside a lambda and then having some control flow in onFields seemed more complex than just leaving the check at the start of onFields.", "author": "clickingbuttons", "createdAt": "2020-04-28T22:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc2MzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjE0Nw==", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416772147", "body": "the error handling here needs to either:\r\n\r\n- When atomicity == SKIP_ALL, throw CairoException. There is no need to rollback row, it hasn't been created\r\n- do the logging but exit method via `return`. ", "bodyText": "the error handling here needs to either:\n\nWhen atomicity == SKIP_ALL, throw CairoException. There is no need to rollback row, it hasn't been created\ndo the logging but exit method via return.", "bodyHTML": "<p dir=\"auto\">the error handling here needs to either:</p>\n<ul dir=\"auto\">\n<li>When atomicity == SKIP_ALL, throw CairoException. There is no need to rollback row, it hasn't been created</li>\n<li>do the logging but exit method via <code>return</code>.</li>\n</ul>", "author": "bluestreak01", "createdAt": "2020-04-28T16:54:51Z", "path": "core/src/main/java/io/questdb/cutlass/text/CairoTextWriter.java", "diffHunk": "@@ -118,17 +115,32 @@ public long getWrittenLineCount() {\n         return writer == null ? 0 : writer.size() - _size;\n     }\n \n-    public void of(CharSequence name, boolean overwrite, boolean durable, int atomicity) {\n+    public void of(CharSequence name, boolean overwrite, boolean durable, int atomicity, int partitionBy, CharSequence timestampIndexCol) {\n         this.tableName = name;\n         this.overwrite = overwrite;\n         this.durable = durable;\n         this.atomicity = atomicity;\n+        this.partitionBy = partitionBy;\n+        this.timestampIndexCol = timestampIndexCol;\n     }\n \n     @Override\n     public void onFields(long line, ObjList<DirectByteCharSequence> values, int valuesLength) {\n-        final TableWriter.Row w = writer.newRow();\n+        long timestamp = 0L;\n+        if (timestampIndex != -1 && types.getQuick(timestampIndex).getType() == ColumnType.TIMESTAMP) {\n+            TimestampAdapter adapter = (TimestampAdapter) types.getQuick(timestampIndex);\n+            final DirectByteCharSequence dbcs = values.getQuick(timestampIndex);\n+            try {\n+                timestamp = adapter.getTimestamp(dbcs);\n+            } catch (NumericException e) {\n+                logError(line, timestampIndex, dbcs);", "originalCommit": "bb9518708811394ba2067f5d783109b8a3d0419f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTY2Mw==", "url": "https://github.com/questdb/questdb/pull/236#discussion_r416971663", "bodyText": "I opted for the second.", "author": "clickingbuttons", "createdAt": "2020-04-28T22:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3MjE0Nw=="}], "type": "inlineReview"}, {"oid": "d272600e93f1420551304231db7d04218c514dee", "url": "https://github.com/questdb/questdb/commit/d272600e93f1420551304231db7d04218c514dee", "message": "apply suggested feedback", "committedDate": "2020-04-28T22:53:55Z", "type": "commit"}, {"oid": "0ef18291f3f18f9188d3ec148f9bdf1a1584bd8f", "url": "https://github.com/questdb/questdb/commit/0ef18291f3f18f9188d3ec148f9bdf1a1584bd8f", "message": "fix edge cases", "committedDate": "2020-04-29T21:30:07Z", "type": "commit"}, {"oid": "f142f20a957e22410b7504b1a5a7d943adaa417c", "url": "https://github.com/questdb/questdb/commit/f142f20a957e22410b7504b1a5a7d943adaa417c", "message": "fix copytest", "committedDate": "2020-04-29T23:44:24Z", "type": "commit"}]}