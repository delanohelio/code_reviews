{"pr_number": 594, "pr_title": "CLDR-14016 fix alias rules", "pr_createdAt": "2020-07-30T01:15:23Z", "pr_url": "https://github.com/unicode-org/cldr/pull/594", "merge_commit": "d6fc7eac94df0673ecc6cab071b32efdec5cf18f", "timeline": [{"oid": "88c7325f4e22788f9d1a0bffb5a811f1faf0d440", "url": "https://github.com/unicode-org/cldr/commit/88c7325f4e22788f9d1a0bffb5a811f1faf0d440", "message": "CLDR-14016 fix alias rules", "committedDate": "2020-08-21T23:32:39Z", "type": "forcePushed"}, {"oid": "46cd038d971c2bef8549c73952e558b71e2b35e0", "url": "https://github.com/unicode-org/cldr/commit/46cd038d971c2bef8549c73952e558b71e2b35e0", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-24T19:19:07Z", "type": "forcePushed"}, {"oid": "d81604b90d199ff6219139c291cf212ff0732bf7", "url": "https://github.com/unicode-org/cldr/commit/d81604b90d199ff6219139c291cf212ff0732bf7", "message": "CLDR-14016 Clean up tests", "committedDate": "2020-08-25T00:25:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475877556", "body": "This is a new class that uses the canonicalization of the LSRV part of a locale identifier to verify correctness of the algorithm and test data.", "bodyText": "This is a new class that uses the canonicalization of the LSRV part of a locale identifier to verify correctness of the algorithm and test data.", "bodyHTML": "<p dir=\"auto\">This is a new class that uses the canonicalization of the LSRV part of a locale identifier to verify correctness of the algorithm and test data.</p>", "author": "macchiati", "createdAt": "2020-08-24T20:34:10Z", "path": "tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.unicode.cldr.unittest;", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNTE3Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476415172", "bodyText": "JavaDoc or link to a design doc?", "author": "hagbard", "createdAt": "2020-08-25T12:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5MzIwOA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476593208", "bodyText": "Added to javadoc", "author": "macchiati", "createdAt": "2020-08-25T16:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "changed_code": [{"header": "diff --git a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\nindex 9fdf6e79d2..8bd48dbb39 100644\n--- a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n+++ b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n", "chunk": "@@ -1,20 +1,35 @@\n package org.unicode.cldr.unittest;\n \n import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n \n+import org.unicode.cldr.util.CLDRConfig;\n+import org.unicode.cldr.util.CLDRFile;\n import org.unicode.cldr.util.LsrvCanonicalizer;\n import org.unicode.cldr.util.LsrvCanonicalizer.ReplacementRule;\n import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n import org.unicode.cldr.util.LsrvCanonicalizer.XLanguageTag;\n+import org.unicode.cldr.util.StandardCodes;\n+import org.unicode.cldr.util.StandardCodes.LstrField;\n import org.unicode.cldr.util.StandardCodes.LstrType;\n+import org.unicode.cldr.util.SupplementalDataInfo;\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.ibm.icu.dev.test.TestFmwk;\n+import com.ibm.icu.impl.Row.R2;\n \n+/**\n+ * TestLsrvCanonicalizer is used to verify the correctness of the specification algorithm,\n+ * sanity-check the supplementalMetadata.xml alias data,\n+ * and generate test files for use by implementations.\n+ */\n public class TestLsrvCanonicalizer extends TestFmwk {\n \n     static final LsrvCanonicalizer rrs = LsrvCanonicalizer.getInstance();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d6fc7eac94df0673ecc6cab071b32efdec5cf18f", "changed_code": [{"header": "diff --git a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\nindex 9fdf6e79d2..8bd48dbb39 100644\n--- a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n+++ b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n", "chunk": "@@ -1,20 +1,35 @@\n package org.unicode.cldr.unittest;\n \n import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n \n+import org.unicode.cldr.util.CLDRConfig;\n+import org.unicode.cldr.util.CLDRFile;\n import org.unicode.cldr.util.LsrvCanonicalizer;\n import org.unicode.cldr.util.LsrvCanonicalizer.ReplacementRule;\n import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n import org.unicode.cldr.util.LsrvCanonicalizer.XLanguageTag;\n+import org.unicode.cldr.util.StandardCodes;\n+import org.unicode.cldr.util.StandardCodes.LstrField;\n import org.unicode.cldr.util.StandardCodes.LstrType;\n+import org.unicode.cldr.util.SupplementalDataInfo;\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.ibm.icu.dev.test.TestFmwk;\n+import com.ibm.icu.impl.Row.R2;\n \n+/**\n+ * TestLsrvCanonicalizer is used to verify the correctness of the specification algorithm,\n+ * sanity-check the supplementalMetadata.xml alias data,\n+ * and generate test files for use by implementations.\n+ */\n public class TestLsrvCanonicalizer extends TestFmwk {\n \n     static final LsrvCanonicalizer rrs = LsrvCanonicalizer.getInstance();\n", "next_change": null}]}, "commits_in_main": [{"oid": "d6fc7eac94df0673ecc6cab071b32efdec5cf18f", "message": "Merge commit", "committedDate": null}, {"oid": "5abc968dc05bebab90a9bd9f6581cf604ff75bf8", "committedDate": "2020-10-12 10:14:29 -0700", "message": "CLDR-14226 reduce use of term grandfathered in code (#769)"}, {"oid": "e904e8c42642cbf06cea75cae36209e650dd9ba3", "committedDate": "2020-11-04 09:58:26 -0600", "message": "CLDR-14212 final maven move (#822)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3ODIyMw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475878223", "body": "A new class that generates the test data above.", "bodyText": "A new class that generates the test data above.", "bodyHTML": "<p dir=\"auto\">A new class that generates the test data above.</p>", "author": "macchiati", "createdAt": "2020-08-24T20:35:25Z", "path": "tools/java/org/unicode/cldr/tool/GenerateLocaleTestData.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.unicode.cldr.tool;", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3ODc5Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475878796", "body": "Some small tweaks to add enum values for other elements used in validity (really for other tickets).", "bodyText": "Some small tweaks to add enum values for other elements used in validity (really for other tickets).", "bodyHTML": "<p dir=\"auto\">Some small tweaks to add enum values for other elements used in validity (really for other tickets).</p>", "author": "macchiati", "createdAt": "2020-08-24T20:36:25Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1036,7 +1036,9 @@ private void add(CodeType type, String code, List<String> otherData) {\n         /** specialized codes for validity; TODO: rename LstrType **/\n         currency(false, true, \"XXX\"),\n         subdivision(false, true),\n-        unit(false, true);\n+        unit(false, true),", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475879236", "body": "Utility to account for some older code and data structures using 'territory' instead of 'region'.", "bodyText": "Utility to account for some older code and data structures using 'territory' instead of 'region'.", "bodyHTML": "<p dir=\"auto\">Utility to account for some older code and data structures using 'territory' instead of 'region'.</p>", "author": "macchiati", "createdAt": "2020-08-24T20:37:14Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();\n         }\n+\n+        public static LstrType fromString(String rawType) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTk2Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476411966", "bodyText": "Please comment this to say how it conflates \"territory\" as an alternate identifier for region.", "author": "hagbard", "createdAt": "2020-08-25T12:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5NDg4Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476594882", "bodyText": "done", "author": "macchiati", "createdAt": "2020-08-25T16:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3OTIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "changed_code": [{"header": "diff --git a/tools/java/org/unicode/cldr/util/StandardCodes.java b/tools/java/org/unicode/cldr/util/StandardCodes.java\nindex 9726b5691c..b8245c82fc 100644\n--- a/tools/java/org/unicode/cldr/util/StandardCodes.java\n+++ b/tools/java/org/unicode/cldr/util/StandardCodes.java\n", "chunk": "@@ -1072,14 +1072,25 @@ public class StandardCodes {\n             }\n         }\n \n+        /**\n+         * Generate compatibility string, returning 'territory' instead of 'region', etc.\n+         */\n         public String toCompatString() {\n-            return this == region ? \"territory\" : toString();\n+            switch (this) {\n+            case region: return \"territory\";\n+            case grandfathered: return \"language\";\n+            case redundant: return \"language\";\n+            default: return toString();\n+            }\n         }\n \n+        /**\n+         * Create LstrType from string, allowing the compat string 'territory'.\n+         */\n         public static LstrType fromString(String rawType) {\n             try {\n                 return valueOf(rawType);\n-            } catch (Exception e) {\n+            } catch (IllegalArgumentException e) {\n                 if (\"territory\".equals(rawType)) {\n                     return region;\n                 }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4MDExMA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475880110", "body": "This is used in matching a ReplacementRule. It is here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "bodyText": "This is used in matching a ReplacementRule. It is here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "bodyHTML": "<p dir=\"auto\">This is used in matching a ReplacementRule. It is here instead of on ReplacementRule so we can use in the denormalization utility used in testing.</p>", "author": "macchiati", "createdAt": "2020-08-24T20:38:57Z", "path": "tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.unicode.cldr.util;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ComparisonChain;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.impl.Row.R2;\n+\n+/**\n+ * Provides Unicode Language Identifier canonicalization for use in testing.\n+ * The implementation is designed to be simple, and is not at all optimized for production use.\n+ */\n+public class LsrvCanonicalizer {\n+\n+    public static final Set<LstrType> LSRV = ImmutableSet.of(LstrType.language, LstrType.script, LstrType.region, LstrType.variant);\n+    public static final Joiner UNDERBAR_JOINER = Joiner.on('_');\n+\n+    /**\n+     * A representation of a Unicode Language Identifier in a format that makes it simple to process.\n+     * The LSRV fields are represented as multimaps, though the LSR fields restricted to have only have 0 or 1 element.\n+     */\n+    public static class XLanguageTag {\n+        final Multimap<LstrType, String> data;\n+\n+        private XLanguageTag(Multimap<LstrType, String> result) {\n+            data = ImmutableMultimap.copyOf(result);\n+        }\n+        public Set<LstrType> keys() {\n+            return data.keySet();\n+        }\n+        public Collection<String> get(LstrType lstrType) {\n+            return data.get(lstrType);\n+        }\n+        public String toLocaleString() {\n+            StringBuilder buffer = new StringBuilder();\n+            final Collection<String> region = data.get(LstrType.language);\n+            if (!region.isEmpty()) {\n+                buffer.append(UNDERBAR_JOINER.join(region));\n+            } else {\n+                buffer.append(\"und\");\n+            }\n+            addItem(buffer, LstrType.script, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \"\", \"_\", UNDERBAR_JOINER);\n+\n+            return buffer.toString();\n+        }\n+        @Override\n+        public String toString() {\n+            StringBuilder buffer = new StringBuilder();\n+            addItem(buffer, LstrType.language, \"\", \"L:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.script, \";\", \"S:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \";\", \"R:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \";\", \"V:\", UNDERBAR_JOINER);\n+            return buffer.toString();\n+        }\n+\n+        public void addItem(StringBuilder buffer, LstrType lstrType, String separator, String prefix, final Joiner dashJoiner) {\n+            final Collection<String> region = data.get(lstrType);\n+            if (!region.isEmpty()) {\n+                if (buffer.length() > 0) {\n+                    buffer.append(separator);\n+                }\n+                buffer.append(prefix).append(dashJoiner.join(region));\n+            }\n+        }\n+\n+        public static XLanguageTag fromTag(LstrType lstrType, String tag) {\n+            Multimap<LstrType,String> result = TreeMultimap.create();\n+            LanguageTagParser source = new LanguageTagParser();\n+            final boolean isLanguage = lstrType == LstrType.language;\n+            String prefix = isLanguage ? \"\" : \"und_\";\n+            try {\n+                source.set(prefix + tag);\n+            } catch (Exception e) {\n+                return null;  // skip ill-formed for now\n+//                if (lstrType == LstrType.region && tag.length() == 3) {\n+//                    //result.put(LstrType.language, \"und\");\n+//                    result.put(LstrType.region, tag);\n+//                } else {\n+//                    result.put(LstrType.language, tag);\n+//                }\n+//                //System.out.println(\"ILLEGAL SOURCE\\t\" + lstrType + \":\\t\" + tag + \" \u21d2 \" + result); // for debugging\n+//                return new XLanguageTag(result);\n+            }\n+            if (!source.getLanguage().isEmpty()\n+                && !source.getLanguage().contains(\"und\")) {\n+                result.put(LstrType.language, source.getLanguage());\n+            }\n+            if (!source.getScript().isEmpty()) {\n+                result.put(LstrType.script, source.getScript());\n+            }\n+            if (!source.getRegion().isEmpty()) {\n+                result.put(LstrType.region, source.getRegion());\n+            }\n+            if (!source.getVariants().isEmpty()) {\n+                result.putAll(LstrType.variant, source.getVariants());\n+            }\n+            return new XLanguageTag(result);\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return data.equals(((XLanguageTag)obj).data);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return data.hashCode();\n+        }\n+        public XLanguageTag set(LstrType lstrType, String string) {\n+            Multimap<LstrType,String> result = TreeMultimap.create(data);\n+            if (lstrType != LstrType.variant) {\n+                result.removeAll(lstrType);\n+            }\n+            result.put(lstrType, string);\n+            return new XLanguageTag(result);\n+        }\n+\n+        public boolean containsAll(XLanguageTag type) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "changed_code": [{"header": "diff --git a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\nindex d75727ea55..aa97c15f85 100644\n--- a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n+++ b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n", "chunk": "@@ -133,6 +136,10 @@ public class LsrvCanonicalizer {\n             return new XLanguageTag(result);\n         }\n \n+        /**\n+         * containsAll is used in matching a ReplacementRule.<br>\n+         * It is here instead of on ReplacementRule so we can use in the denormalization utility used in testing.\n+         */\n         public boolean containsAll(XLanguageTag type) {\n             for (LstrType lstrType : LSRV) {\n                 final Collection<String> sources = get(lstrType);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4MTI3Ng==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r475881276", "body": "This actually does the replacement. Also here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "bodyText": "This actually does the replacement. Also here instead of on ReplacementRule so we can use in the denormalization utility used in testing.", "bodyHTML": "<p dir=\"auto\">This actually does the replacement. Also here instead of on ReplacementRule so we can use in the denormalization utility used in testing.</p>", "author": "macchiati", "createdAt": "2020-08-24T20:41:22Z", "path": "tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.unicode.cldr.util;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ComparisonChain;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.TreeMultimap;\n+import com.ibm.icu.impl.Row.R2;\n+\n+/**\n+ * Provides Unicode Language Identifier canonicalization for use in testing.\n+ * The implementation is designed to be simple, and is not at all optimized for production use.\n+ */\n+public class LsrvCanonicalizer {\n+\n+    public static final Set<LstrType> LSRV = ImmutableSet.of(LstrType.language, LstrType.script, LstrType.region, LstrType.variant);\n+    public static final Joiner UNDERBAR_JOINER = Joiner.on('_');\n+\n+    /**\n+     * A representation of a Unicode Language Identifier in a format that makes it simple to process.\n+     * The LSRV fields are represented as multimaps, though the LSR fields restricted to have only have 0 or 1 element.\n+     */\n+    public static class XLanguageTag {\n+        final Multimap<LstrType, String> data;\n+\n+        private XLanguageTag(Multimap<LstrType, String> result) {\n+            data = ImmutableMultimap.copyOf(result);\n+        }\n+        public Set<LstrType> keys() {\n+            return data.keySet();\n+        }\n+        public Collection<String> get(LstrType lstrType) {\n+            return data.get(lstrType);\n+        }\n+        public String toLocaleString() {\n+            StringBuilder buffer = new StringBuilder();\n+            final Collection<String> region = data.get(LstrType.language);\n+            if (!region.isEmpty()) {\n+                buffer.append(UNDERBAR_JOINER.join(region));\n+            } else {\n+                buffer.append(\"und\");\n+            }\n+            addItem(buffer, LstrType.script, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \"\", \"_\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \"\", \"_\", UNDERBAR_JOINER);\n+\n+            return buffer.toString();\n+        }\n+        @Override\n+        public String toString() {\n+            StringBuilder buffer = new StringBuilder();\n+            addItem(buffer, LstrType.language, \"\", \"L:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.script, \";\", \"S:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.region, \";\", \"R:\", UNDERBAR_JOINER);\n+            addItem(buffer, LstrType.variant, \";\", \"V:\", UNDERBAR_JOINER);\n+            return buffer.toString();\n+        }\n+\n+        public void addItem(StringBuilder buffer, LstrType lstrType, String separator, String prefix, final Joiner dashJoiner) {\n+            final Collection<String> region = data.get(lstrType);\n+            if (!region.isEmpty()) {\n+                if (buffer.length() > 0) {\n+                    buffer.append(separator);\n+                }\n+                buffer.append(prefix).append(dashJoiner.join(region));\n+            }\n+        }\n+\n+        public static XLanguageTag fromTag(LstrType lstrType, String tag) {\n+            Multimap<LstrType,String> result = TreeMultimap.create();\n+            LanguageTagParser source = new LanguageTagParser();\n+            final boolean isLanguage = lstrType == LstrType.language;\n+            String prefix = isLanguage ? \"\" : \"und_\";\n+            try {\n+                source.set(prefix + tag);\n+            } catch (Exception e) {\n+                return null;  // skip ill-formed for now\n+//                if (lstrType == LstrType.region && tag.length() == 3) {\n+//                    //result.put(LstrType.language, \"und\");\n+//                    result.put(LstrType.region, tag);\n+//                } else {\n+//                    result.put(LstrType.language, tag);\n+//                }\n+//                //System.out.println(\"ILLEGAL SOURCE\\t\" + lstrType + \":\\t\" + tag + \" \u21d2 \" + result); // for debugging\n+//                return new XLanguageTag(result);\n+            }\n+            if (!source.getLanguage().isEmpty()\n+                && !source.getLanguage().contains(\"und\")) {\n+                result.put(LstrType.language, source.getLanguage());\n+            }\n+            if (!source.getScript().isEmpty()) {\n+                result.put(LstrType.script, source.getScript());\n+            }\n+            if (!source.getRegion().isEmpty()) {\n+                result.put(LstrType.region, source.getRegion());\n+            }\n+            if (!source.getVariants().isEmpty()) {\n+                result.putAll(LstrType.variant, source.getVariants());\n+            }\n+            return new XLanguageTag(result);\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return data.equals(((XLanguageTag)obj).data);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return data.hashCode();\n+        }\n+        public XLanguageTag set(LstrType lstrType, String string) {\n+            Multimap<LstrType,String> result = TreeMultimap.create(data);\n+            if (lstrType != LstrType.variant) {\n+                result.removeAll(lstrType);\n+            }\n+            result.put(lstrType, string);\n+            return new XLanguageTag(result);\n+        }\n+\n+        public boolean containsAll(XLanguageTag type) {\n+            for (LstrType lstrType : LSRV) {\n+                final Collection<String> sources = get(lstrType);\n+                final Collection<String> types = type.get(lstrType);\n+                if (!sources.containsAll(types)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        public XLanguageTag replacePartsFrom(XLanguageTag typeParts, XLanguageTag replacementParts) {", "originalCommit": "46cd038d971c2bef8549c73952e558b71e2b35e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "changed_code": [{"header": "diff --git a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\nindex d75727ea55..aa97c15f85 100644\n--- a/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n+++ b/tools/java/org/unicode/cldr/util/LsrvCanonicalizer.java\n", "chunk": "@@ -143,6 +150,11 @@ public class LsrvCanonicalizer {\n             }\n             return true;\n         }\n+\n+        /**\n+         * Once a rule matches, this actually does the replacement.<br>\n+         * It is here instead of on ReplacementRule so we can use it in the denormalization utility used in testing.\n+         */\n         public XLanguageTag replacePartsFrom(XLanguageTag typeParts, XLanguageTag replacementParts) {\n             Multimap<LstrType,String> result = TreeMultimap.create();\n             for (LstrType lstrType : LSRV) {\n", "next_change": null}]}}, {"oid": "b73c6b164b9e8c2c73a377c4bdc4eff7be9c238d", "url": "https://github.com/unicode-org/cldr/commit/b73c6b164b9e8c2c73a377c4bdc4eff7be9c238d", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T00:44:04Z", "type": "forcePushed"}, {"oid": "414fff6e0ec586b0e09e08d394e6daa578f4476b", "url": "https://github.com/unicode-org/cldr/commit/414fff6e0ec586b0e09e08d394e6daa578f4476b", "message": "CLDR-14016 fix attribute test", "committedDate": "2020-08-25T01:08:59Z", "type": "forcePushed"}, {"oid": "60b3b0972d4b939cc8501d0fab44059b4b76af7e", "url": "https://github.com/unicode-org/cldr/commit/60b3b0972d4b939cc8501d0fab44059b4b76af7e", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T01:11:32Z", "type": "forcePushed"}, {"oid": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "url": "https://github.com/unicode-org/cldr/commit/d3c89c38d85fea2f76b4685371dba74230a9c0f1", "message": "CLDR-14016 fix cel_gaulish", "committedDate": "2020-08-25T01:37:02Z", "type": "forcePushed"}, {"oid": "b4c35c12e85464a5024e08cc6a280504a521e3d1", "url": "https://github.com/unicode-org/cldr/commit/b4c35c12e85464a5024e08cc6a280504a521e3d1", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-25T03:39:46Z", "type": "forcePushed"}, {"oid": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "url": "https://github.com/unicode-org/cldr/commit/d3c89c38d85fea2f76b4685371dba74230a9c0f1", "message": "CLDR-14016 fix cel_gaulish", "committedDate": "2020-08-25T01:37:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwODQ5MA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476408490", "body": "Adding immediately commented out code without any comments declaring its intent is weird.\r\nI mean yes it's sort of clear it's a debug thing, but there's a DEBUG flag above *and* this is test code anyway, so why not leave it in guarded by the debug flag? At least that way it won't rot over time with successive refactorings of the code around it.", "bodyText": "Adding immediately commented out code without any comments declaring its intent is weird.\nI mean yes it's sort of clear it's a debug thing, but there's a DEBUG flag above and this is test code anyway, so why not leave it in guarded by the debug flag? At least that way it won't rot over time with successive refactorings of the code around it.", "bodyHTML": "<p dir=\"auto\">Adding immediately commented out code without any comments declaring its intent is weird.<br>\nI mean yes it's sort of clear it's a debug thing, but there's a DEBUG flag above <em>and</em> this is test code anyway, so why not leave it in guarded by the debug flag? At least that way it won't rot over time with successive refactorings of the code around it.</p>", "author": "hagbard", "createdAt": "2020-08-25T12:27:07Z", "path": "tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.unicode.cldr.unittest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.unicode.cldr.util.LsrvCanonicalizer;\n+import org.unicode.cldr.util.LsrvCanonicalizer.ReplacementRule;\n+import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n+import org.unicode.cldr.util.LsrvCanonicalizer.XLanguageTag;\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Objects;\n+import com.ibm.icu.dev.test.TestFmwk;\n+\n+public class TestLsrvCanonicalizer extends TestFmwk {\n+\n+    static final LsrvCanonicalizer rrs = LsrvCanonicalizer.getInstance();\n+    private static final boolean DEBUG = false;\n+\n+    public static void main(String[] args) {\n+        final TestLsrvCanonicalizer testLocaleCanonicalizer = new TestLsrvCanonicalizer();\n+        testLocaleCanonicalizer.run(args);\n+    }\n+\n+    public void TestCases() {\n+        if (DEBUG) {\n+//          System.out.println(Joiner.on('\\n').join(rrs.filter(LstrType.variant, null)));\n+            System.out.println(Joiner.on('\\n').join(rrs.filter(LstrType.language, \"no\")));\n+        }\n+\n+        List<ReplacementRule> rules = new ArrayList<>();\n+        for (Entry<TestDataTypes, Map<String, String>> mainEntry : rrs.getTestData(null).entrySet()) {\n+            TestDataTypes type = mainEntry.getKey();\n+            for (Entry<String, String> entry : mainEntry.getValue().entrySet()) {\n+                String toTest = entry.getKey();\n+                String expected = entry.getValue();\n+                final XLanguageTag source2 = XLanguageTag.fromTag(LstrType.language, toTest);\n+                XLanguageTag newTag = rrs.canonicalizeToX(source2, rules);\n+                String actual = newTag.toLocaleString();\n+                if (DEBUG && rules.size() > 1) {\n+                    System.out.println(\n+                        \"source: \" + toTest\n+                        + \", expected: \" + expected\n+                        + \", actual: \" + actual\n+                        + \", rules: \" + rules\n+                        );\n+                }\n+                if (!Objects.equal(expected, actual)) {\n+                    errln(\"Error: \"\n+                        + \"source: \" + toTest\n+                        + \", expected: \" + expected\n+                        + \", actual: \" + actual\n+                        + \", rules: \" + rules\n+                        );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+//            if (!rule.regular) {\n+//                System.out.println(\n+//                    rule.lstrType + \"\\t\u2795\\t\" + rule.typeParts + \"\\t\u21d2\\t\"+rule.replacementParts + \"\\t\u2795\\t\" + rule.reason + \"\\t\" + diff(rule.typeParts, rule.replacementParts));\n+//            }\n+//        }\n+//    }\n+\n+\n+\n+//    private static String diff(XLanguageTag tagParts, XLanguageTag replacementParts) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MDc3MA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476850770", "bodyText": "It's gone.", "author": "macchiati", "createdAt": "2020-08-25T23:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwODQ5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "changed_code": [{"header": "diff --git a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\nindex 9fdf6e79d2..8bd48dbb39 100644\n--- a/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n+++ b/tools/cldr-unittest/src/org/unicode/cldr/unittest/TestLsrvCanonicalizer.java\n", "chunk": "@@ -59,32 +74,182 @@ public class TestLsrvCanonicalizer extends TestFmwk {\n             }\n         }\n     }\n-}\n \n+    public void TestAgainstLanguageSubtagRegistry() {\n+        Map<String,String> exceptions = ImmutableMap.<String, String>builder()\n+            .put(\"drh\", \"mn\") // Darkhat => Halh Mongolian\n+            .put(\"drw\", \"fa_af\") // Darwazi => Dari\n+            .put(\"tnf\", \"fa_af\") // Tangshewi => Dari\n+            .put(\"AN\", \"CW SX BQ\") // Netherlands Antilles => list\n+            .put(\"CS\", \"RS ME\") // Serbia and Montenegro => list\n+            .put(\"NT\", \"SA IQ\") // Neutral Zone => ???\n+            .put(\"SU\", \"RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ\") // Union of Soviet Socialist Republics => list\n+            .put(\"YU\", \"RS ME\") // Yugoslavia => list\n+            .put(\"cel-gaulish\", \"xtg\")\n+            .put(\"i-enochian\", \"und_x_i_enochian\")\n+            .put(\"zh-guoyu\", \"zh\") // Mandarin Chinese\n+            .put(\"zh-min\", \"nan_x_zh_min\") // special code\n+            .put(\"sgn-NO\", \"nsi\") // Norwegian Sign Language\n+            .put(\"zh-cmn\", \"zh\") // Chinese\n+            .put(\"zh-cmn-Hans\", \"zh_Hans\") // Simplified Chinese\n+            .put(\"zh-cmn-Hant\", \"zh_Hant\") // Traditional Chinese\n+            .put(\"agp\", \"apf\") // Paranan => ???\n+            .put(\"ais\", \"ami\") // Nataoran Amis => ???\n+            .put(\"baz\", \"nvo\") // Tunen => ???\n+            .put(\"bhk\", \"fbl\") // Albay Bicolano => ???\n+            .put(\"bjq\", \"bzc\") // Southern Betsimisaraka Malagasy => ???\n+            .put(\"bkb\", \"ebk\") // Finallig => ???\n+            .put(\"btb\", \"beb\") // Beti (Cameroon) => ???\n+            .put(\"daf\", \"dnj\") // Dan => ???\n+            .put(\"dap\", \"njz\") // Nisi (India) => ???\n+            .put(\"djl\", \"dze\") // Djiwarli => ???\n+            .put(\"dkl\", \"aqd\") // Kolum So Dogon => ???\n+            .put(\"dud\", \"uth\") // Hun-Saare => ???\n+            .put(\"duj\", \"dwu\") // Dhuwal => ???\n+            .put(\"dwl\", \"dbt\") // Walo Kumbe Dogon => ???\n+            .put(\"elp\", \"amq\") // Elpaputih => ???\n+            .put(\"gbc\", \"wny\") // Garawa => ???\n+            .put(\"ggo\", \"esg\") // Southern Gondi => ???\n+            .put(\"ggr\", \"gtu\") // Aghu Tharnggalu => ???\n+            .put(\"gio\", \"aou\") // Gelao => ???\n+            .put(\"ill\", \"ilm\") // Iranun => ???\n+            .put(\"izi\", \"eza\") // Izi-Ezaa-Ikwo-Mgbo => ???\n+            .put(\"jar\", \"jgk\") // Jarawa (Nigeria) => ???\n+            .put(\"kdv\", \"zkd\") // Kado => ???\n+            .put(\"kgd\", \"ncq\") // Kataang => ???\n+            .put(\"kpp\", \"jkm\") // Paku Karen => ???\n+            .put(\"kzh\", \"dgl\") // Kenuzi-Dongola => ???\n+            .put(\"leg\", \"enl\") // Lengua => ???\n+            .put(\"mgx\", \"jbk\") // Omati => ???\n+            .put(\"mnt\", \"wnn\") // Maykulan => ???\n+            .put(\"mof\", \"xnt\") // Mohegan-Montauk-Narragansett => ???\n+            .put(\"mwd\", \"dmw\") // Mudbura => ???\n+            .put(\"nbf\", \"nru\") // Naxi => ???\n+            .put(\"nbx\", \"ekc\") // Ngura => ???\n+            .put(\"nln\", \"azd\") // Durango Nahuatl => ???\n+            .put(\"nlr\", \"nrk\") // Ngarla => ???\n+            .put(\"noo\", \"dtd\") // Nootka => ???\n+            .put(\"rmr\", \"emx\") // Cal\u00f3 => ???\n+            .put(\"sap\", \"aqt\") // Sanapan\u00e1 => ???\n+            .put(\"sgl\", \"isk\") // Sanglechi-Ishkashimi => ???\n+            .put(\"sul\", \"sgd\") // Surigaonon => ???\n+            .put(\"sum\", \"ulw\") // Sumo-Mayangna => ???\n+            .put(\"tgg\", \"bjp\") // Tangga => ???\n+            .put(\"tid\", \"itd\") // Tidong => ???\n+            .put(\"unp\", \"wro\") // Worora => ???\n+            .put(\"wgw\", \"wgb\") // Wagawaga => ???\n+            .put(\"wit\", \"nol\") // Wintu => ???\n+            .put(\"wiw\", \"nwo\") // Wirangu => ???\n+            .put(\"yen\", \"ynq\") // Yendang => ???\n+            .put(\"yiy\", \"yrm\") // Yir Yoront => ???\n+            .build();\n+        Set<String> SKIP = ImmutableSet.of(\n+            // handled via languageAliases\n+            \"arevela\", \"arevmda\",\n+            // newly added\n+            \"bmy\", \"btl\", \"bxx\", \"byy\", \"cbe\", \"cbh\", \"cum\", \"dha\", \"dzd\", \"emo\", \"iap\", \"ime\", \"kbf\", \"kox\", \"lba\", \"lsg\", \"mhh\", \"mja\", \"mld\", \"mwx\",\n+            \"mwy\", \"myi\", \"myq\", \"ome\", \"pbz\", \"pgy\", \"pod\", \"prb\", \"puk\", \"rie\", \"rna\", \"rsi\", \"sgo\", \"snh\", \"svr\", \"toe\", \"xbx\", \"xip\", \"yds\", \"ynh\", \"yri\"\n+            );\n \n-//            if (!rule.regular) {\n-//                System.out.println(\n-//                    rule.lstrType + \"\\t\u2795\\t\" + rule.typeParts + \"\\t\u21d2\\t\"+rule.replacementParts + \"\\t\u2795\\t\" + rule.reason + \"\\t\" + diff(rule.typeParts, rule.replacementParts));\n-//            }\n-//        }\n-//    }\n+//        Error: (TestLsrvCanonicalizer.java:110) : drh: expected \"khk\", got \"mn\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : drw: expected \"prs\", got \"fa_af\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : tnf: expected \"prs\", got \"fa_af\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : AN: expected null, got \"CW SX BQ\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : CS: expected null, got \"RS ME\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : NT: expected null, got \"SA IQ\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : SU: expected null, got \"RU AM AZ BY EE GE KZ KG LV LT MD TJ TM UA UZ\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : YU: expected null, got \"RS ME\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : cel_gaulish: expected null, got \"xtg\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : i_enochian: expected null, got \"und_x_i_enochian\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : zh_guoyu: expected \"cmn\", got \"zh\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : zh_min: expected null, got \"nan_x_zh_min\"\n+//        Error: (TestLsrvCanonicalizer.java:110) : sgn_NO: expected \"nsl\", got \"nsi\"\n+//        Error: (TestLsrvCanonicalizer.java:119) Can't access aliasInfo for the following. Suggested additions are:\n \n+        SupplementalDataInfo SDI = SupplementalDataInfo.getInstance();\n+        Map<String, Map<String, R2<List<String>, String>>> aliasInfo = SDI.getLocaleAliasInfo();\n+        Set<String> shouldHave = new LinkedHashSet<>();\n+        Set<String> shouldSkip = new LinkedHashSet<>();\n+        Set<String> addExceptions = new LinkedHashSet<>();\n \n+        for ( Entry<LstrType, Map<String, Map<LstrField, String>>> entry1 : StandardCodes.getEnumLstreg().entrySet()) {\n+            LstrType type = entry1.getKey();\n+            if (type == LstrType.extlang) {\n+                continue;\n+            }\n+            final String typeCompat = type.toCompatString();\n+            Map<String, R2<List<String>, String>> aliasInfo2 = aliasInfo.get(typeCompat);\n+            if (aliasInfo2 == null) {\n+                errln(\"Can't access aliasInfo for: \" + type);\n+                continue;\n+            }\n+\n+            for (Entry<String, Map<LstrField, String>> entry2 : entry1.getValue().entrySet()) {\n+                String subtag = entry2.getKey();\n+                final Map<LstrField, String> subtagInfo = entry2.getValue();\n+                String deprecated = subtagInfo.get(LstrField.Deprecated);\n+                if (deprecated == null) {\n+                    continue;\n+                }\n+                String preferredValue = subtagInfo.get(LstrField.Preferred_Value);\n+                final String preferredValueCompat = preferredValue == null ? null : preferredValue.replace('-', '_');\n+                final String subtagCompat = subtag.replace('-', '_');\n+                R2<List<String>, String> aliasInfo3 = aliasInfo2.get(subtagCompat);\n+                if (aliasInfo3 == null) {\n+                    if (SKIP.contains(subtag)) {\n+                        continue;\n+                    }\n+                    String possibleReplacement = preferredValueCompat != null ? preferredValueCompat : subtagInfo.get(LstrField.Comments);\n+                    // <languageAlias type=\"sgn_BR\" replacement=\"bzs\" reason=\"deprecated\"/>\n+                    if (possibleReplacement != null) {\n+                        shouldHave.add(\"<\" + typeCompat + \"Alias\"\n+                            + \" type=\\\"\" + subtagCompat + \"\\\"\"\n+                            + (possibleReplacement == null || possibleReplacement.isEmpty() ? \"\" : \" replacement=\\\"\" + possibleReplacement + \"\\\"\")\n+                            + \" reason=\\\"\" + (type == LstrType.grandfathered || type == LstrType.redundant ? type.toString() : \"deprecated\") + \"\\\"\"\n+                            + \"/>  <!-- \" + subtagInfo.get(LstrField.Description) + \" -->\");\n+                    } else {\n+                        shouldSkip.add(subtag);\n+                    }\n+                    continue;\n+                }\n+                List<String> replacement = aliasInfo3.get0();\n+                String reason = aliasInfo3.get1();\n+                final String replacementString = Joiner.on(' ').join(replacement);\n+                if (!Objects.equal(preferredValueCompat, replacementString)) {\n+                    String exception = exceptions.get(subtag);\n+                    if (Objects.equal(exception, replacementString)) {\n+                        continue;\n+                    }\n+                    CLDRFile english = CLDRConfig.getInstance().getEnglish();\n+                    String typeName = english.getName(typeCompat, subtag);\n+                    String replacementName = preferredValueCompat == null ? \"???\" : english.getName(typeCompat, replacementString);\n+                    addExceptions.add(\".put(\\\"\" + subtag + \"\\\", \\\"\" + replacementString + \"\\\")\" + \" // \" + typeName + \" => \" + replacementName);\n+                }\n \n-//    private static String diff(XLanguageTag tagParts, XLanguageTag replacementParts) {\n-//        StringBuilder result = new StringBuilder();\n-//        for (LstrType type : LocaleCanonicalizer.LSTR) {\n-//            Collection<String> t = tagParts.get(type);\n-//            Collection<String> r = replacementParts.get(type);\n-//            if (t.isEmpty() && r.isEmpty()) {\n-//                //\n-//            } else {\n-//                String first = t.isEmpty() ? \"\u2205\" : Joiner.on(\"|\").join(t);\n-//                String second = r.isEmpty() ? \"\u2205\" : Joiner.on(\"|\").join(r);\n-//                result.append(first).append(\" \u2192 \").append(second);\n-//            }\n-//            result.append(\"\\t\");\n-//        }\n-//        return result.toString();\n-//    }\n+//                for (Entry<LstrField, String> entry3 : entry2.getValue().entrySet()) {\n+//                    LstrField field = entry3.getKey();\n+//                    String data = entry3.getValue();\n+//                }\n+            }\n+        }\n+        if (!addExceptions.isEmpty()) {\n+            errln(\"The following have different replacements.\\n\"\n+                + \"    Here are suggested exception values to add to the test code, but research each one:\");\n+            System.out.println(Joiner.on('\\n').join(addExceptions));\n+            System.out.println();\n+        }\n \n+        if (!shouldHave.isEmpty()) {\n+            errln(\"Can't access aliasInfo for the following.\\n\"\n+                + \"    Here are suggested additions to supplementalMetadata , but check them:\");\n+            System.out.println(Joiner.on('\\n').join(shouldHave));\n+            System.out.println();\n+        }\n+        if (!shouldSkip.isEmpty()) {\n+            errln(\"No replacement.\\n\"\n+                + \"    Here are suggested additions to SKIP in the test code, but check them:\");\n+            System.out.println(\"\\\"\" + Joiner.on(\"\\\", \\\"\").join(shouldSkip) + \"\\\"\");\n+            System.out.println();\n+        }\n+    }\n+}\n\\ No newline at end of file\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTMyMw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476409323", "body": "\"oo\" doesn't seem like a particularly clear variable name to me. Maybe \"outputOpts\" ?", "bodyText": "\"oo\" doesn't seem like a particularly clear variable name to me. Maybe \"outputOpts\" ?", "bodyHTML": "<p dir=\"auto\">\"oo\" doesn't seem like a particularly clear variable name to me. Maybe \"outputOpts\" ?</p>", "author": "hagbard", "createdAt": "2020-08-25T12:28:37Z", "path": "tools/java/org/unicode/cldr/util/LanguageTagCanonicalizer.java", "diffHunk": "@@ -52,6 +52,9 @@ public LanguageTagCanonicalizer(LstrType lstrType) {\n     // TODO, handle variants\n     @Override\n     public synchronized String transform(String locale) {\n+        return transform (locale, OutputOption.ICU_LCVARIANT);\n+    }\n+    public synchronized String transform(String locale, OutputOption oo) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MTk3MQ==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476851971", "bodyText": "I'd like to clean this up later. To much to do right now, and I don't want another cycle.", "author": "macchiati", "createdAt": "2020-08-25T23:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwOTMyMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMTY1Mg==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476411652", "body": "Do the if check first and just don't have a try-catch block.\r\nvalueOf() is defined to only throw IllegalArgumentException or NullPointerException and I think you want to complain if you're given null anyway (it's a very different type of failure mode).", "bodyText": "Do the if check first and just don't have a try-catch block.\nvalueOf() is defined to only throw IllegalArgumentException or NullPointerException and I think you want to complain if you're given null anyway (it's a very different type of failure mode).", "bodyHTML": "<p dir=\"auto\">Do the if check first and just don't have a try-catch block.<br>\nvalueOf() is defined to only throw IllegalArgumentException or NullPointerException and I think you want to complain if you're given null anyway (it's a very different type of failure mode).</p>", "author": "hagbard", "createdAt": "2020-08-25T12:32:39Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();\n         }\n+\n+        public static LstrType fromString(String rawType) {\n+            try {\n+                return valueOf(rawType);\n+            } catch (Exception e) {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "changed_code": [{"header": "diff --git a/tools/java/org/unicode/cldr/util/StandardCodes.java b/tools/java/org/unicode/cldr/util/StandardCodes.java\nindex 9726b5691c..b8245c82fc 100644\n--- a/tools/java/org/unicode/cldr/util/StandardCodes.java\n+++ b/tools/java/org/unicode/cldr/util/StandardCodes.java\n", "chunk": "@@ -1072,14 +1072,25 @@ public class StandardCodes {\n             }\n         }\n \n+        /**\n+         * Generate compatibility string, returning 'territory' instead of 'region', etc.\n+         */\n         public String toCompatString() {\n-            return this == region ? \"territory\" : toString();\n+            switch (this) {\n+            case region: return \"territory\";\n+            case grandfathered: return \"language\";\n+            case redundant: return \"language\";\n+            default: return toString();\n+            }\n         }\n \n+        /**\n+         * Create LstrType from string, allowing the compat string 'territory'.\n+         */\n         public static LstrType fromString(String rawType) {\n             try {\n                 return valueOf(rawType);\n-            } catch (Exception e) {\n+            } catch (IllegalArgumentException e) {\n                 if (\"territory\".equals(rawType)) {\n                     return region;\n                 }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjc1Nw==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476412757", "body": "Another way to do this is to store the compat string as a field, but either way it would be nice to see a comment on this public method explaining its *not* the enum name.", "bodyText": "Another way to do this is to store the compat string as a field, but either way it would be nice to see a comment on this public method explaining its not the enum name.", "bodyHTML": "<p dir=\"auto\">Another way to do this is to store the compat string as a field, but either way it would be nice to see a comment on this public method explaining its <em>not</em> the enum name.</p>", "author": "hagbard", "createdAt": "2020-08-25T12:34:36Z", "path": "tools/java/org/unicode/cldr/util/StandardCodes.java", "diffHunk": "@@ -1073,6 +1075,17 @@ boolean isWellFormed(String candidate) {\n         public String toCompatString() {\n             return this == region ? \"territory\" : toString();", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MjU1OA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476852558", "bodyText": "done (the doc, and some other changes)", "author": "macchiati", "createdAt": "2020-08-25T23:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxMjc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9191edd4650528b9c03f63719ae27a61326046a2", "changed_code": [{"header": "diff --git a/tools/java/org/unicode/cldr/util/StandardCodes.java b/tools/java/org/unicode/cldr/util/StandardCodes.java\nindex 9726b5691c..b8245c82fc 100644\n--- a/tools/java/org/unicode/cldr/util/StandardCodes.java\n+++ b/tools/java/org/unicode/cldr/util/StandardCodes.java\n", "chunk": "@@ -1072,14 +1072,25 @@ public class StandardCodes {\n             }\n         }\n \n+        /**\n+         * Generate compatibility string, returning 'territory' instead of 'region', etc.\n+         */\n         public String toCompatString() {\n-            return this == region ? \"territory\" : toString();\n+            switch (this) {\n+            case region: return \"territory\";\n+            case grandfathered: return \"language\";\n+            case redundant: return \"language\";\n+            default: return toString();\n+            }\n         }\n \n+        /**\n+         * Create LstrType from string, allowing the compat string 'territory'.\n+         */\n         public static LstrType fromString(String rawType) {\n             try {\n                 return valueOf(rawType);\n-            } catch (Exception e) {\n+            } catch (IllegalArgumentException e) {\n                 if (\"territory\".equals(rawType)) {\n                     return region;\n                 }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDI5NA==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476414294", "body": "JavaDoc?", "bodyText": "JavaDoc?", "bodyHTML": "<p dir=\"auto\">JavaDoc?</p>", "author": "hagbard", "createdAt": "2020-08-25T12:37:10Z", "path": "tools/java/org/unicode/cldr/tool/GenerateLocaleIDTestData.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.unicode.cldr.tool;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.unicode.cldr.util.CLDRPaths;\n+import org.unicode.cldr.util.CldrUtility;\n+import org.unicode.cldr.util.LsrvCanonicalizer;\n+import org.unicode.cldr.util.LsrvCanonicalizer.TestDataTypes;\n+import org.unicode.cldr.util.StandardCodes.LstrType;\n+import org.unicode.cldr.util.TempPrintWriter;\n+\n+public class GenerateLocaleIDTestData {", "originalCommit": "d3c89c38d85fea2f76b4685371dba74230a9c0f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg1MTI5MQ==", "url": "https://github.com/unicode-org/cldr/pull/594#discussion_r476851291", "bodyText": "done", "author": "macchiati", "createdAt": "2020-08-25T23:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNDI5NA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "9191edd4650528b9c03f63719ae27a61326046a2", "url": "https://github.com/unicode-org/cldr/commit/9191edd4650528b9c03f63719ae27a61326046a2", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-26T00:14:20Z", "type": "commit"}, {"oid": "9191edd4650528b9c03f63719ae27a61326046a2", "url": "https://github.com/unicode-org/cldr/commit/9191edd4650528b9c03f63719ae27a61326046a2", "message": "CLDR-14016 fix alias rules\n\nSee #594", "committedDate": "2020-08-26T00:14:20Z", "type": "forcePushed"}]}